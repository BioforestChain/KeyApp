# 订阅系统

## 概述

订阅系统允许用户添加多个“小程序可信源”，将不同来源的小程序聚合展示在“生态”页面。

本系统的设计参考 **SSR 的订阅原理**：
- **配置在本地**：用户在设置页维护可信源列表（可启用/禁用多个 URL）。
- **数据可缓存**：客户端会在本地缓存订阅源数据（用于离线与快速启动）。
- **可增量刷新**：优先使用 ETag/Last-Modified 等机制减少流量；必要时强制刷新。

> 当前版本先实现“可信源 + 本地缓存 + 基础聚合”，后续逐步增强评分、精选、搜索等能力。

## 订阅源格式

```typescript
interface EcosystemSource {
  name: string           // 源名称
  version: string        // 版本
  updated: string        // 更新时间 (ISO 8601)
  icon?: string          // 源图标（可选）
  search?: {             // 可选：远程搜索能力（用于搜索订阅列表以外的应用）
    urlTemplate: string  // 搜索 URL 模板（固定 GET），使用 %s 替换 query
  }
  apps: MiniappManifest[]
}

interface MiniappManifest {
  id: string             // 唯一标识
  name: string           // 显示名称
  description: string    // 描述
  icon: string           // 图标 URL
  url: string            // 入口 URL
  version: string        // 版本
  author?: string        // 作者
  permissions?: string[] // 需要的权限
  chains?: string[]      // 支持的链
  officialScore?: number // 推荐分（官方评分，0-100，可选）
  communityScore?: number// 热门分（社区评分，0-100，可选）
}

interface EcosystemSearchResponse {
  version: string
  data: MiniappManifest[]
}
```

## 示例

```json
{
  "name": "Bio 官方生态",
  "version": "1.0.0",
  "updated": "2024-12-27",
  "icon": "/logo.svg",
  "search": {
    "urlTemplate": "https://example.com/ecosystem/search?q=%s"
  },
  "apps": [
    {
      "id": "teleport",
      "name": "一键传送",
      "description": "跨钱包资产转移",
      "icon": "/miniapps/teleport/icon.svg",
      "url": "/miniapps/teleport/",
      "version": "0.1.0",
      "permissions": ["bio_requestAccounts", "bio_signMessage"],
      "chains": ["bfmeta", "bfchainv2"],
      "officialScore": 90,
      "communityScore": 80
    }
  ]
}
```

## 可信源管理

### 添加订阅

1. 打开设置 → 小程序可信源
2. 输入订阅 URL
3. 确认添加

### 订阅验证

- 检查 HTTPS
- 验证 JSON 格式
- 检查必要字段

### 安全考虑

- 只允许 HTTPS 源（本地开发除外）
- 显示源来源标识
- 用户需确认权限

## 本地缓存（SSR 订阅原理）

为了让“生态”页具备良好的启动性能与离线可用性，订阅源数据需要缓存到本地：

- **缓存介质**：优先使用 IndexedDB（容量更大，结构化更友好）。
- **缓存粒度**：按 source URL 缓存整份 `EcosystemSource`（包含 apps 列表）。
- **刷新策略**：
  - 默认刷新：携带 `If-None-Match`（ETag）请求；`304` 时复用缓存。
  - 强制刷新：忽略 ETag，重新拉取并覆盖缓存。

> 关键原则：**设置页只管理“可信源配置”**；“订阅内容/评分/精选/搜索”由订阅服务层统一计算并缓存（避免 UI 各处自己拼逻辑，DRY）。

## 展示策略：部分列出 + 评分精选

当前“订阅源”聚合不应直接“全量列出”。推荐采用**部分列出**：

- **推荐分（官方评分）**：`officialScore`（0-100）
- **热门分（社区评分）**：`communityScore`（0-100）
- **综合分（精选）**：按“日期动态权重”计算（见下）

“精选”列表按 `featuredScore` 降序取 Top N；“推荐/热门”按各自评分取 Top N。

### 日期动态权重（官方/社区）

为避免长期固定权重导致的“推荐固化”，综合分可按日期进行动态加权：

- Day 1：`15 / 85`
- Day 2：`30 / 70`
- 每天在“官方权重”基础上 `+15` 并对 `100` 取模循环：
  - `15, 30, 45, 60, 75, 90, 5, 20, 35, ...`

定义：

- `officialWeightPct = (officialWeightPct + 15) % 100`（初始值可为 `0`）
- `communityWeightPct = 100 - officialWeightPct`
- `featuredScore = (officialScore * officialWeightPct + communityScore * communityWeightPct) / 100`

## 搜索：订阅列表以外的应用

除了在本地缓存的 apps 内搜索（快速、离线可用），还需要支持**远程搜索**：

- 每个订阅源可以提供 `search.urlTemplate`（固定 GET），用于查询“订阅列表以外”的应用（例如官方全站搜索）。
  - 配置方式类似浏览器搜索引擎：`https://example.com/search?q=%s`
  - Host 侧需要对 query 做 URL 编码后替换 `%s`
- Host 侧提供统一的搜索函数：
  - 先本地搜索（cached apps）
  - 再并行调用启用源的 `search.urlTemplate`（如果存在）
  - 合并去重后返回（按相关性/评分排序）

远程搜索响应建议使用带版本的结构，保证协议升级时的兼容性：

```typescript
type EcosystemSearchResponse = {
  version: string
  data: MiniappManifest[]
}
```

> 远程搜索属于“增强能力”，但接口定义应尽早固定，避免后续破坏性变更（OCP）。

## 存储结构

```typescript
interface EcosystemStore {
  sources: {
    url: string          // 订阅 URL
    name: string         // 源名称
    lastUpdated: string  // 最后更新时间
    enabled: boolean     // 是否启用
  }[]
  permissions: {
    appId: string        // 小程序 ID
    granted: string[]    // 已授权的权限
  }[]
}
```

## API

```typescript
// 加载订阅源
async function loadSource(url: string): Promise<EcosystemSource>

// 刷新所有源
async function refreshSources(): Promise<void>

// 获取所有小程序
async function getAllApps(): Promise<MiniappManifest[]>

// 获取精选应用（综合分 Top N）
async function getFeaturedApps(limit: number): Promise<MiniappManifest[]>

// 本地搜索（订阅缓存内）
async function searchCachedApps(query: string): Promise<MiniappManifest[]>

// 远程搜索（订阅列表以外）
async function searchRemoteApps(query: string): Promise<MiniappManifest[]>

// 检查权限
function hasPermission(appId: string, permission: string): boolean

// 授予权限
function grantPermissions(appId: string, permissions: string[]): void
```
