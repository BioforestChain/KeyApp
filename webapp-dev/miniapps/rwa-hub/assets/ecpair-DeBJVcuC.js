import{a as b,B as o}from"./bioforestChainBundle-C9za-Hm3.js";import{d as k,e as g}from"./index-BK2FfW2b.js";import{t as i}from"./typeforce-BBtR0LCj.js";import"./page-C3-Jo2og.js";import"./index-CQoRotV0.js";import"./index-Dfl4ZgPg.js";import"./sha256-DIi67vjr.js";import"./WASMInterface-u96uWOK2.js";const d={messagePrefix:`Bitcoin Signed Message:
`,bech32:"bc",bip32:{public:76067358,private:76066276},pubKeyHash:0,scriptHash:5,wif:128},K=i.compile({messagePrefix:i.anyOf(i.Buffer,i.String),bip32:{public:i.UInt32,private:i.UInt32},pubKeyHash:i.UInt8,scriptHash:i.UInt8,wif:i.UInt8}),c=i.BufferN(32),_=i.Array,P=i.Boolean,m=i.maybe,h=i.maybe(i.compile({compressed:m(P),network:m(K)})),x=t=>t.length===32?t:t.slice(1,33);function A(t){function w(s){return t.isPoint(s)}function f(s,r){if(i(c,s),!t.isPrivate(s))throw new TypeError("Private key not in range [1, n)");return i(h,r),new p(s,void 0,r)}function y(s,r){return i(t.isPoint,s),i(h,r),new p(void 0,s,r)}function l(s,r){const e=k(s),n=e.version;if(_(r)){if(r=r.filter(a=>n===a.wif).pop(),!r)throw new Error("Unknown network version")}else if(r=r||d,n!==r.wif)throw new Error("Invalid network version");return f(e.privateKey,{compressed:e.compressed,network:r})}function v(s){i(h,s),s===void 0&&(s={});const r=s.rng||b;let e;do e=o.from(r(32)),i(c,e);while(!t.isPrivate(e));return f(e,s)}class p{constructor(r,e,n){this.__D=r,this.__Q=e,this.lowR=!1,n===void 0&&(n={}),this.compressed=n.compressed===void 0?!0:n.compressed,this.network=n.network||d,e!==void 0&&(this.__Q=o.from(t.pointCompress(e,this.compressed)))}get privateKey(){return this.__D}get publicKey(){if(!this.__Q){const r=t.pointFromScalar(this.__D,this.compressed);this.__Q=o.from(r)}return this.__Q}toWIF(){if(!this.__D)throw new Error("Missing private key");return g(this.network.wif,this.__D,this.compressed)}tweak(r){return this.privateKey?this.tweakFromPrivateKey(r):this.tweakFromPublicKey(r)}sign(r,e){if(!this.__D)throw new Error("Missing private key");if(e===void 0&&(e=this.lowR),e===!1)return o.from(t.sign(r,this.__D));{let n=t.sign(r,this.__D);const a=o.alloc(32,0);let u=0;for(;n[0]>127;)u++,a.writeUIntLE(u,0,6),n=t.sign(r,this.__D,a);return o.from(n)}}signSchnorr(r){if(!this.privateKey)throw new Error("Missing private key");if(!t.signSchnorr)throw new Error("signSchnorr not supported by ecc library");return o.from(t.signSchnorr(r,this.privateKey))}verify(r,e){return t.verify(r,this.publicKey,e)}verifySchnorr(r,e){if(!t.verifySchnorr)throw new Error("verifySchnorr not supported by ecc library");return t.verifySchnorr(r,this.publicKey.subarray(1,33),e)}tweakFromPublicKey(r){const e=x(this.publicKey),n=t.xOnlyPointAddTweak(e,r);if(!n||n.xOnlyPubkey===null)throw new Error("Cannot tweak public key!");const a=o.from([n.parity===0?2:3]);return y(o.concat([a,n.xOnlyPubkey]),{network:this.network,compressed:this.compressed})}tweakFromPrivateKey(r){const n=this.publicKey[0]===3||this.publicKey[0]===4&&(this.publicKey[64]&1)===1?t.privateNegate(this.privateKey):this.privateKey,a=t.privateAdd(n,r);if(!a)throw new Error("Invalid tweaked private key!");return f(o.from(a),{network:this.network,compressed:this.compressed})}}return{isPoint:w,fromPrivateKey:f,fromPublicKey:y,fromWIF:l,makeRandom:v}}export{A as ECPairFactory};
