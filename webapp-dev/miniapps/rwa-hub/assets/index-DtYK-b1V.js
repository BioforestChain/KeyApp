import{b as s}from"./networks-ZN7vFv_C.js";import{d as i,c as m}from"./script-FDeERxxs.js";import{p as u}from"./address-ZI_KEK0H.js";import{a as N,b as S,c as q,f as U,d as _,e as D}from"./address-ZI_KEK0H.js";import{t as r}from"./typeforce-Dwy2dsyn.js";import{OPS as f}from"./ops-CO93g0rg.js";import{p as z}from"./p2pk-ke5zHFR5.js";import"./bioforestChainBundle-D4MYt0oV.js";import"./page-BOxexyJV.js";import"./index-Dk9SKzm0.js";import"./index-BB9FVBrc.js";import"./sha256-DkPRHwlh.js";import"./WASMInterface-BB6uMQo8.js";import"./crypto-D1spmEbK.js";import"./ripemd160-BKeyKI6w.js";import"./sha1-DE6TSCkr.js";const n=f;function c(t,e){return t.length!==e.length?!1:t.every((p,o)=>p.equals(e[o]))}function j(t,e){if(!t.data&&!t.output)throw new TypeError("Not enough data");e=Object.assign({validate:!0},e||{}),r({network:r.maybe(r.Object),output:r.maybe(r.Buffer),data:r.maybe(r.arrayOf(r.Buffer))},t);const o={name:"embed",network:t.network||s};if(u(o,"output",()=>{if(t.data)return m([n.OP_RETURN].concat(t.data))}),u(o,"data",()=>{if(t.output)return i(t.output).slice(1)}),e.validate&&t.output){const a=i(t.output);if(a[0]!==n.OP_RETURN)throw new TypeError("Output is invalid");if(!a.slice(1).every(r.Buffer))throw new TypeError("Output is invalid");if(t.data&&!c(t.data,o.data))throw new TypeError("Data mismatch")}return Object.assign(o,t)}export{j as embed,N as p2ms,z as p2pk,S as p2pkh,q as p2sh,U as p2tr,_ as p2wpkh,D as p2wsh};
