import{c as u,v as I,g as l,b as ne,w as we,a as k,d as be,e as Se,f as Y,i as ve,h as b,j as se}from"./WASMInterface-u96uWOK2.js";import{a as Ot,c as qt}from"./hmac-CXcE4fap.js";import{a as Zt,c as Yt,k as _t}from"./keccak-BYlUylCf.js";import{p as _}from"./pbkdf2-CXD5CYaq.js";import{a as Jt}from"./pbkdf2-CXD5CYaq.js";import{a as er,c as tr,p as rr,r as ar}from"./ripemd160-BgXcNe3H.js";import{a as Ae,c as me}from"./sha256-DIi67vjr.js";import{p as sr,s as ir}from"./sha256-DIi67vjr.js";import{a as or,c as ur,p as dr,s as lr}from"./sha1-Z2WxFj6d.js";import{c as hr,a as pr,g as fr,s as gr}from"./sha3-e1ZEM-y8.js";import{a as br,c as Sr,p as vr,s as Ar}from"./sha512-36K92cF_.js";import"./page-C3-Jo2og.js";import"./index-CQoRotV0.js";import"./bioforestChainBundle-C9za-Hm3.js";const $=u("adler32",4),nt=async e=>(await $()).calculate(e),st=async()=>xe(await $()),xe=(e=$.wasm)=>{e.init();const r={init:()=>(e.init(),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:4,digestSize:4};return r},G=new Map,H=e=>{I(e,512);const r=e/8;let t=G.get(r);return t===void 0&&(t=u("blake2b",r),G.set(r,t)),t},ie=(e,r)=>{let t,a=e;if(r!==void 0){if(t=l(r),t.length>64)throw new Error("Max key length is 64 bytes");a=ne(e,t.length)}return{keyBuffer:t,initParam:a}},it=async(e,r=512,t)=>{const a=await H(r)(),{keyBuffer:n,initParam:s}=ie(r,t);return s>512&&a.writeMemory(n),a.calculate(e,s)},z=async(e=512,r)=>Ee(e,r,await H(e)()),Ee=(e=512,r,t=H(e).wasm)=>{const{keyBuffer:a,initParam:n}=ie(e,r),s=e/8;n>512&&t.writeMemory(a),t.init(n);const c={init:n>512?()=>(t.writeMemory(a),t.init(n),c):()=>(t.init(n),c),update:i=>(t.update(i),c),digest:i=>t.digest(i),save:()=>t.save(),load:i=>(t.load(i),c),blockSize:128,digestSize:s};return c},Me=u("argon2",1024);function ze(e,r,t){const a=[`m=${r.memorySize}`,`t=${r.iterations}`,`p=${r.parallelism}`].join(",");return`$argon2${r.hashType}$v=19$${a}$${Y(e,!1)}$${Y(t,!1)}`}const J=new DataView(new ArrayBuffer(4));function p(e){return J.setInt32(0,e,!0),new Uint8Array(J.buffer)}async function M(e,r,t){if(t<=64){const o=await z(t*8);return o.update(p(t)),o.update(r),o.digest("binary")}const a=Math.ceil(t/32)-2,n=new Uint8Array(t);e.init(),e.update(p(t)),e.update(r);let s=e.digest("binary");n.set(s.subarray(0,32),0);for(let o=1;o<a;o++)e.init(),e.update(s),s=e.digest("binary"),n.set(s.subarray(0,32),o*32);const c=t-32*a;let i;return c===64?(i=e,i.init()):i=await z(c*8),i.update(s),s=i.digest("binary"),n.set(s.subarray(0,c),a*32),n}function Ie(e){switch(e){case"d":return 0;case"i":return 1;default:return 2}}async function v(e){const{parallelism:r,iterations:t,hashLength:a}=e,n=l(e.password),s=l(e.salt),c=19,i=Ie(e.hashType),{memorySize:o}=e,[y,d]=await Promise.all([await Me(),z(512)]);y.setMemorySize(o*1024+1024);const f=new Uint8Array(24),h=new DataView(f.buffer);h.setInt32(0,r,!0),h.setInt32(4,a,!0),h.setInt32(8,o,!0),h.setInt32(12,t,!0),h.setInt32(16,c,!0),h.setInt32(20,i,!0),y.writeMemory(f,o*1024),d.init(),d.update(f),d.update(p(n.length)),d.update(n),d.update(p(s.length)),d.update(s),d.update(p(0)),d.update(p(0));const fe=Math.floor(o/(r*4))*4,g=new Uint8Array(72),ge=d.digest("binary");g.set(ge);for(let w=0;w<r;w++){g.set(p(0),64),g.set(p(w),68);let x=w*fe,E=await M(d,g,1024);y.writeMemory(E,x*1024),x+=1,g.set(p(1),64),E=await M(d,g,1024),y.writeMemory(E,x*1024)}const Z=new Uint8Array(1024);we(Z,y.calculate(new Uint8Array([]),o));const m=await M(d,Z,a);if(e.outputType==="hex"){const w=new Uint8Array(a*2);return k(w,m,a)}return e.outputType==="encoded"?ze(s,e,m):m}const A=e=>{if(!e||typeof e!="object")throw new Error("Invalid options parameter. It requires an object.");if(!e.password)throw new Error("Password must be specified");if(e.password=l(e.password),e.password.length<1)throw new Error("Password must be specified");if(!e.salt)throw new Error("Salt must be specified");if(e.salt=l(e.salt),e.salt.length<8)throw new Error("Salt should be at least 8 bytes long");if(!Number.isInteger(e.iterations)||e.iterations<1)throw new Error("Iterations should be a positive number");if(!Number.isInteger(e.parallelism)||e.parallelism<1)throw new Error("Parallelism should be a positive number");if(!Number.isInteger(e.hashLength)||e.hashLength<4)throw new Error("Hash length should be at least 4 bytes.");if(!Number.isInteger(e.memorySize))throw new Error("Memory size should be specified.");if(e.memorySize<8*e.parallelism)throw new Error("Memory size should be at least 8 * parallelism.");if(e.outputType===void 0&&(e.outputType="hex"),!["hex","binary","encoded"].includes(e.outputType))throw new Error(`Insupported output type ${e.outputType}. Valid values: ['hex', 'binary', 'encoded']`)};async function ct(e){return A(e),v({...e,hashType:"i"})}async function ot(e){return A(e),v({...e,hashType:"id"})}async function ut(e){return A(e),v({...e,hashType:"d"})}const ke=(e,r)=>{const t=/^\$argon2(id|i|d)\$v=([0-9]+)\$((?:[mtp]=[0-9]+,){2}[mtp]=[0-9]+)\$([A-Za-z0-9+/]+)\$([A-Za-z0-9+/]+)$/,a=r.match(t);if(!a)throw new Error("Invalid hash");const[,n,s,c,i,o]=a;if(s!=="19")throw new Error(`Unsupported version: ${s}`);const y={},d={m:"memorySize",p:"parallelism",t:"iterations"};return c.split(",").forEach(f=>{const[h,W]=f.split("=");y[d[h]]=parseInt(W,10)}),{...y,password:e,hashType:n,salt:Se(i),hashLength:be(o),outputType:"encoded"}},$e=e=>{if(!e||typeof e!="object")throw new Error("Invalid options parameter. It requires an object.");if(e.hash===void 0||typeof e.hash!="string")throw new Error("Hash should be specified")};async function dt(e){$e(e);const r=ke(e.password,e.hash);A(r);const t=e.hash.lastIndexOf("$")+1;return(await v(r)).substring(t)===e.hash.substring(t)}const ce=u("bcrypt",0);async function He(e){const{costFactor:r,password:t,salt:a}=e,n=await ce();n.writeMemory(l(a),0);const s=l(t);n.writeMemory(s,16);const c=e.outputType==="encoded"?1:0;n.getExports().bcrypt(s.length,r,c);const i=n.getMemory();if(e.outputType==="encoded")return ve(i,60);if(e.outputType==="hex"){const o=new Uint8Array(48);return k(o,i,24)}return i.slice(0,24)}const Be=e=>{if(!e||typeof e!="object")throw new Error("Invalid options parameter. It requires an object.");if(!Number.isInteger(e.costFactor)||e.costFactor<4||e.costFactor>31)throw new Error("Cost factor should be a number between 4 and 31");if(e.password=l(e.password),e.password.length<1)throw new Error("Password should be at least 1 byte long");if(e.password.length>72)throw new Error("Password should be at most 72 bytes long");if(e.salt=l(e.salt),e.salt.length!==16)throw new Error("Salt should be 16 bytes long");if(e.outputType===void 0&&(e.outputType="encoded"),!["hex","binary","encoded"].includes(e.outputType))throw new Error(`Insupported output type ${e.outputType}. Valid values: ['hex', 'binary', 'encoded']`)};async function lt(e){return Be(e),He(e)}const Pe=e=>!(!/^\$2[axyb]\$[0-3][0-9]\$[./A-Za-z0-9]{53}$/.test(e)||e[4]==="0"&&parseInt(e[5],10)<4||e[4]==="3"&&parseInt(e[5],10)>1),Te=e=>{if(!e||typeof e!="object")throw new Error("Invalid options parameter. It requires an object.");if(e.hash===void 0||typeof e.hash!="string")throw new Error("Hash should be specified");if(e.hash.length!==60)throw new Error("Hash should be 60 bytes long");if(!Pe(e.hash))throw new Error("Invalid hash");if(e.password=l(e.password),e.password.length<1)throw new Error("Password should be at least 1 byte long");if(e.password.length>72)throw new Error("Password should be at most 72 bytes long")};async function yt(e){Te(e);const{hash:r,password:t}=e,a=await ce();a.writeMemory(l(r),0);const n=l(t);return a.writeMemory(n,60),!!a.getExports().bcrypt_verify(n.length)}const Q=new Map,B=e=>{I(e,256);const r=e/8;let t=Q.get(r);return t===void 0&&(t=u("blake2s",r),Q.set(r,t)),t},oe=(e,r)=>{let t,a=e;if(r!==void 0){if(t=l(r),t.length>32)throw new Error("Max key length is 32 bytes");a=ne(e,t.length)}return{keyBuffer:t,initParam:a}},ht=async(e,r=256,t)=>{const a=await B(r)(),{keyBuffer:n,initParam:s}=oe(r,t);return s>512&&a.writeMemory(n),a.calculate(e,s)},pt=async(e=256,r)=>je(e,r,await B(e)()),je=(e=256,r,t=B(e).wasm)=>{const{keyBuffer:a,initParam:n}=oe(e,r),s=e/8;n>512&&t.writeMemory(a),t.init(n);const c={init:n>512?()=>(t.writeMemory(a),t.init(n),c):()=>(t.init(n),c),update:i=>(t.update(i),c),digest:i=>t.digest(i),save:()=>t.save(),load:i=>(t.load(i),c),blockSize:64,digestSize:s};return c},ee=new Map,P=e=>{I(e,1/0);const r=e/8;let t=ee.get(r);return t===void 0&&(t=u("blake3",r),ee.set(r,t)),t},ue=e=>{let r,t=0;if(e!==void 0){if(r=l(e),r.length!==32)throw new Error("Key length must be exactly 32 bytes");t=32}return{keyBuffer:r,initParam:t}},ft=async(e,r=256,t)=>{const a=await P(r)(),{keyBuffer:n,initParam:s}=ue(t);return s===32&&a.writeMemory(n),a.calculate(e,s,r/8)},gt=async(e=256,r)=>Xe(e,r,await P(e)()),Xe=(e=256,r,t=P(e).wasm)=>{const{keyBuffer:a,initParam:n}=ue(r),s=e/8;n===32&&t.writeMemory(a),t.init(n);const c={init:n===32?()=>(t.writeMemory(a),t.init(n),c):()=>(t.init(n),c),update:i=>(t.update(i),c),digest:i=>t.digest(i,s),save:()=>t.save(),load:i=>(t.load(i),c),blockSize:64,digestSize:s};return c},S=u("crc32",4),wt=async e=>(await S()).calculate(e,3988292384),bt=async()=>Ce(await S()),Ce=(e=S.wasm)=>{e.init(3988292384);const r={init:()=>(e.init(3988292384),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:4,digestSize:4};return r},St=async e=>(await S()).calculate(e,2197175160),vt=async()=>Ue(await S()),Ue=(e=S.wasm)=>{e.init(2197175160);const r={init:()=>(e.init(2197175160),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:4,digestSize:4};return r},T=u("md4",16),At=async e=>(await T()).calculate(e),mt=async()=>Ve(await T()),Ve=(e=T.wasm)=>{e.init();const r={init:()=>(e.init(),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:64,digestSize:16};return r},j=u("md5",16),xt=async e=>(await j()).calculate(e),Et=async()=>De(await j()),De=(e=j.wasm)=>{e.init();const r={init:()=>(e.init(),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:64,digestSize:16};return r},X=u("scrypt",0),de=(e,r,t=X.wasm)=>{const{costFactor:a,blockSize:n,parallelism:s,hashLength:c}=e,i=_({password:e.password,salt:e.salt,iterations:1,hashLength:128*n*s,hashFunction:r,outputType:"binary"}),o=128*n*a,y=256*n;t.setMemorySize(i.length+o+y),t.writeMemory(i,0),t.getExports().scrypt(n,a,s);const d=t.getMemory().subarray(0,128*n*s),f=_({password:e.password,salt:d,iterations:1,hashLength:c,hashFunction:r,outputType:"binary"});if(e.outputType==="hex"){const h=new Uint8Array(c*2);return k(h,f,c)}return f},Le=e=>!!(e&&!(e&e-1)),le=e=>{if(!e||typeof e!="object")throw new Error("Invalid options parameter. It requires an object.");if(!Number.isInteger(e.blockSize)||e.blockSize<1)throw new Error("Block size should be a positive number");if(!Number.isInteger(e.costFactor)||e.costFactor<2||!Le(e.costFactor))throw new Error("Cost factor should be a power of 2, greater than 1");if(!Number.isInteger(e.parallelism)||e.parallelism<1)throw new Error("Parallelism should be a positive number");if(!Number.isInteger(e.hashLength)||e.hashLength<1)throw new Error("Hash length should be a positive number.");if(e.outputType===void 0&&(e.outputType="hex"),!["hex","binary"].includes(e.outputType))throw new Error(`Insupported output type ${e.outputType}. Valid values: ['hex', 'binary']`)},Mt=async e=>(le(e),de(e,await Ae(),await X())),zt=e=>(le(e),de(e,me(),X.wasm)),C=u("sha256",28),It=async e=>(await C()).calculate(e,224),kt=async()=>Ke(await C()),Ke=(e=C.wasm)=>{e.init(224);const r={init:()=>(e.init(224),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:64,digestSize:28};return r},U=u("sha512",48),$t=async e=>(await U()).calculate(e,384),Ht=async()=>Fe(await U()),Fe=(e=U.wasm)=>{e.init(384);const r={init:()=>(e.init(384),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:128,digestSize:48};return r},V=u("sm3",32),Bt=async e=>(await V()).calculate(e),Pt=async()=>Ne(await V()),Ne=(e=V.wasm)=>{e.init();const r={init:()=>(e.init(),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:64,digestSize:32};return r},D=u("whirlpool",64),Tt=async e=>(await D()).calculate(e),jt=async()=>Re(await D()),Re=(e=D.wasm)=>{e.init();const r={init:()=>(e.init(),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:64,digestSize:64};return r},L=u("xxhash128",4),K=new ArrayBuffer(8),Oe=new Uint8Array(K),te=new DataView(K);function ye(e,r){te.setUint32(0,e,!0),te.setUint32(4,r,!0)}const Xt=async(e,r=0,t=0)=>{b(r,t),ye(r,t);const a=await L();return a.writeMemory(Oe),a.calculate(e)},Ct=async(e=0,r=0)=>qe(e,r,await L()),qe=(e=0,r=0,t=L.wasm)=>{b(e,r),ye(e,r);const a=new Uint8Array(K);t.writeMemory(a),t.init();const n={init:()=>(t.writeMemory(a),t.init(),n),update:s=>(t.update(s),n),digest:s=>t.digest(s),save:()=>t.save(),load:s=>(t.load(s),n),blockSize:512,digestSize:16};return n},F=u("xxhash3",8),N=new ArrayBuffer(8),We=new Uint8Array(N),re=new DataView(N);function he(e,r){re.setUint32(0,e,!0),re.setUint32(4,r,!0)}const Ut=async(e,r=0,t=0)=>{b(r,t),he(r,t);const a=await F();return a.writeMemory(We),a.calculate(e)},Vt=async(e=0,r=0)=>Ze(e,r,await F()),Ze=(e=0,r=0,t=F.wasm)=>{b(e,r),he(e,r);const a=new Uint8Array(N);t.writeMemory(a),t.init();const n={init:()=>(t.writeMemory(a),t.init(),n),update:s=>(t.update(s),n),digest:s=>t.digest(s),save:()=>t.save(),load:s=>(t.load(s),n),blockSize:512,digestSize:8};return n},R=u("xxhash32",4),Dt=async(e,r=0)=>(se(r),(await R()).calculate(e,r)),Lt=async(e=0)=>Ye(e,await R()),Ye=(e=0,r=R.wasm)=>{se(e),r.init(e);const t={init:()=>(r.init(e),t),update:a=>(r.update(a),t),digest:a=>r.digest(a),save:()=>r.save(),load:a=>(r.load(a),t),blockSize:16,digestSize:4};return t},O=u("xxhash64",4),q=new ArrayBuffer(8),_e=new Uint8Array(q),ae=new DataView(q);function pe(e,r){ae.setUint32(0,e,!0),ae.setUint32(4,r,!0)}const Kt=async(e,r=0,t=0)=>{b(r,t),pe(r,t);const a=await O();return a.writeMemory(_e),a.calculate(e)},Ft=async(e=0,r=0)=>Ge(e,r,await O()),Ge=(e=0,r=0,t=O.wasm)=>{b(e,r),pe(e,r);const a=new Uint8Array(q);t.writeMemory(a),t.init();const n={init:()=>(t.writeMemory(a),t.init(),n),update:s=>(t.update(s),n),digest:s=>t.digest(s),save:()=>t.save(),load:s=>(t.load(s),n),blockSize:32,digestSize:8};return n};export{nt as adler32,dt as argon2Verify,ut as argon2d,ct as argon2i,ot as argon2id,lt as bcrypt,yt as bcryptVerify,it as blake2b,ht as blake2s,ft as blake3,wt as crc32,St as crc32c,st as createAdler32,xe as createAdler32Sync,z as createBLAKE2b,Ee as createBLAKE2bSync,pt as createBLAKE2s,je as createBLAKE2sSync,gt as createBLAKE3,Xe as createBLAKE3Sync,bt as createCRC32,vt as createCRC32C,Ue as createCRC32CSync,Ce as createCRC32Sync,Ot as createHMAC,qt as createHMACSync,Zt as createKeccak,Yt as createKeccakSync,mt as createMD4,Ve as createMD4Sync,Et as createMD5,De as createMD5Sync,er as createRIPEMD160,tr as createRIPEMD160Sync,or as createSHA1,ur as createSHA1Sync,kt as createSHA224,Ke as createSHA224Sync,Ae as createSHA256,me as createSHA256Sync,hr as createSHA3,Ht as createSHA384,Fe as createSHA384Sync,pr as createSHA3Sync,br as createSHA512,Sr as createSHA512Sync,Pt as createSM3,Ne as createSM3Sync,jt as createWhirlpool,Re as createWhirlpoolSync,Ct as createXXHash128,qe as createXXHash128Sync,Vt as createXXHash3,Lt as createXXHash32,Ye as createXXHash32Sync,Ze as createXXHash3Sync,Ft as createXXHash64,Ge as createXXHash64Sync,H as getBLAKE2bPreparer,B as getBLAKE2sPreparer,P as getBLAKE3Preparer,fr as getSha3Preparer,_t as keccak,At as md4,xt as md5,Jt as pbkdf2,_ as pbkdf2Sync,$ as prepareAdler32,Me as prepareArgon2,ce as prepareBcrypt,S as prepareCRC32,T as prepareMD4,j as prepareMD5,rr as prepareRIPEMD160,dr as prepareSHA1,C as prepareSHA224,sr as prepareSHA256,U as prepareSHA384,vr as prepareSHA512,V as prepareSM3,X as prepareScrypt,D as prepareWhirlpool,L as prepareXXHash128,F as prepareXXHash3,R as prepareXXHash32,O as prepareXXHash64,ar as ripemd160,Mt as scrypt,zt as scryptSync,lr as sha1,It as sha224,ir as sha256,gr as sha3,$t as sha384,Ar as sha512,Bt as sm3,Tt as whirlpool,Xt as xxhash128,Ut as xxhash3,Dt as xxhash32,Kt as xxhash64};
