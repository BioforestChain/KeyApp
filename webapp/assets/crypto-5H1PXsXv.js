function ho(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var ct={},G={},tt={},ye={},Ut={},Ge;function Er(){return Ge||(Ge=1,Object.defineProperty(Ut,"__esModule",{value:!0}),Ut.crypto=void 0,Ut.crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0),Ut}var Xe;function ue(){return Xe||(Xe=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.wrapXOFConstructorWithOpts=e.wrapConstructorWithOpts=e.wrapConstructor=e.Hash=e.nextTick=e.swap32IfBE=e.byteSwapIfBE=e.swap8IfBE=e.isLE=void 0,e.isBytes=n,e.anumber=r,e.abytes=o,e.ahash=s,e.aexists=i,e.aoutput=c,e.u8=f,e.u32=u,e.clean=l,e.createView=h,e.rotr=p,e.rotl=g,e.byteSwap=w,e.byteSwap32=I,e.bytesToHex=O,e.hexToBytes=R,e.asyncLoop=K,e.utf8ToBytes=S,e.bytesToUtf8=d,e.toBytes=A,e.kdfInputToBytes=H,e.concatBytes=U,e.checkOpts=b,e.createHasher=x,e.createOptHasher=L,e.createXOFer=V,e.randomBytes=D;const t=Er();function n(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&a.constructor.name==="Uint8Array"}function r(a){if(!Number.isSafeInteger(a)||a<0)throw new Error("positive integer expected, got "+a)}function o(a,...E){if(!n(a))throw new Error("Uint8Array expected");if(E.length>0&&!E.includes(a.length))throw new Error("Uint8Array expected of length "+E+", got length="+a.length)}function s(a){if(typeof a!="function"||typeof a.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");r(a.outputLen),r(a.blockLen)}function i(a,E=!0){if(a.destroyed)throw new Error("Hash instance has been destroyed");if(E&&a.finished)throw new Error("Hash#digest() has already been called")}function c(a,E){o(a);const v=E.outputLen;if(a.length<v)throw new Error("digestInto() expects output buffer of length at least "+v)}function f(a){return new Uint8Array(a.buffer,a.byteOffset,a.byteLength)}function u(a){return new Uint32Array(a.buffer,a.byteOffset,Math.floor(a.byteLength/4))}function l(...a){for(let E=0;E<a.length;E++)a[E].fill(0)}function h(a){return new DataView(a.buffer,a.byteOffset,a.byteLength)}function p(a,E){return a<<32-E|a>>>E}function g(a,E){return a<<E|a>>>32-E>>>0}e.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function w(a){return a<<24&4278190080|a<<8&16711680|a>>>8&65280|a>>>24&255}e.swap8IfBE=e.isLE?a=>a:a=>w(a),e.byteSwapIfBE=e.swap8IfBE;function I(a){for(let E=0;E<a.length;E++)a[E]=w(a[E]);return a}e.swap32IfBE=e.isLE?a=>a:I;const _=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",B=Array.from({length:256},(a,E)=>E.toString(16).padStart(2,"0"));function O(a){if(o(a),_)return a.toHex();let E="";for(let v=0;v<a.length;v++)E+=B[a[v]];return E}const m={_0:48,_9:57,A:65,F:70,a:97,f:102};function k(a){if(a>=m._0&&a<=m._9)return a-m._0;if(a>=m.A&&a<=m.F)return a-(m.A-10);if(a>=m.a&&a<=m.f)return a-(m.a-10)}function R(a){if(typeof a!="string")throw new Error("hex string expected, got "+typeof a);if(_)return Uint8Array.fromHex(a);const E=a.length,v=E/2;if(E%2)throw new Error("hex string expected, got unpadded hex of length "+E);const T=new Uint8Array(v);for(let N=0,M=0;N<v;N++,M+=2){const F=k(a.charCodeAt(M)),j=k(a.charCodeAt(M+1));if(F===void 0||j===void 0){const Y=a[M]+a[M+1];throw new Error('hex string expected, got non-hex character "'+Y+'" at index '+M)}T[N]=F*16+j}return T}const C=async()=>{};e.nextTick=C;async function K(a,E,v){let T=Date.now();for(let N=0;N<a;N++){v(N);const M=Date.now()-T;M>=0&&M<E||(await(0,e.nextTick)(),T+=M)}}function S(a){if(typeof a!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(a))}function d(a){return new TextDecoder().decode(a)}function A(a){return typeof a=="string"&&(a=S(a)),o(a),a}function H(a){return typeof a=="string"&&(a=S(a)),o(a),a}function U(...a){let E=0;for(let T=0;T<a.length;T++){const N=a[T];o(N),E+=N.length}const v=new Uint8Array(E);for(let T=0,N=0;T<a.length;T++){const M=a[T];v.set(M,N),N+=M.length}return v}function b(a,E){if(E!==void 0&&{}.toString.call(E)!=="[object Object]")throw new Error("options should be object or undefined");return Object.assign(a,E)}class y{}e.Hash=y;function x(a){const E=T=>a().update(A(T)).digest(),v=a();return E.outputLen=v.outputLen,E.blockLen=v.blockLen,E.create=()=>a(),E}function L(a){const E=(T,N)=>a(N).update(A(T)).digest(),v=a({});return E.outputLen=v.outputLen,E.blockLen=v.blockLen,E.create=T=>a(T),E}function V(a){const E=(T,N)=>a(N).update(A(T)).digest(),v=a({});return E.outputLen=v.outputLen,E.blockLen=v.blockLen,E.create=T=>a(T),E}e.wrapConstructor=x,e.wrapConstructorWithOpts=L,e.wrapXOFConstructorWithOpts=V;function D(a=32){if(t.crypto&&typeof t.crypto.getRandomValues=="function")return t.crypto.getRandomValues(new Uint8Array(a));if(t.crypto&&typeof t.crypto.randomBytes=="function")return Uint8Array.from(t.crypto.randomBytes(a));throw new Error("crypto.getRandomValues must be defined")}})(ye)),ye}var $e;function Ar(){if($e)return tt;$e=1,Object.defineProperty(tt,"__esModule",{value:!0}),tt.SHA512_IV=tt.SHA384_IV=tt.SHA224_IV=tt.SHA256_IV=tt.HashMD=void 0,tt.setBigUint64=t,tt.Chi=n,tt.Maj=r;const e=ue();function t(s,i,c,f){if(typeof s.setBigUint64=="function")return s.setBigUint64(i,c,f);const u=BigInt(32),l=BigInt(4294967295),h=Number(c>>u&l),p=Number(c&l),g=f?4:0,w=f?0:4;s.setUint32(i+g,h,f),s.setUint32(i+w,p,f)}function n(s,i,c){return s&i^~s&c}function r(s,i,c){return s&i^s&c^i&c}class o extends e.Hash{constructor(i,c,f,u){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=i,this.outputLen=c,this.padOffset=f,this.isLE=u,this.buffer=new Uint8Array(i),this.view=(0,e.createView)(this.buffer)}update(i){(0,e.aexists)(this),i=(0,e.toBytes)(i),(0,e.abytes)(i);const{view:c,buffer:f,blockLen:u}=this,l=i.length;for(let h=0;h<l;){const p=Math.min(u-this.pos,l-h);if(p===u){const g=(0,e.createView)(i);for(;u<=l-h;h+=u)this.process(g,h);continue}f.set(i.subarray(h,h+p),this.pos),this.pos+=p,h+=p,this.pos===u&&(this.process(c,0),this.pos=0)}return this.length+=i.length,this.roundClean(),this}digestInto(i){(0,e.aexists)(this),(0,e.aoutput)(i,this),this.finished=!0;const{buffer:c,view:f,blockLen:u,isLE:l}=this;let{pos:h}=this;c[h++]=128,(0,e.clean)(this.buffer.subarray(h)),this.padOffset>u-h&&(this.process(f,0),h=0);for(let _=h;_<u;_++)c[_]=0;t(f,u-8,BigInt(this.length*8),l),this.process(f,0);const p=(0,e.createView)(i),g=this.outputLen;if(g%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const w=g/4,I=this.get();if(w>I.length)throw new Error("_sha2: outputLen bigger than state");for(let _=0;_<w;_++)p.setUint32(4*_,I[_],l)}digest(){const{buffer:i,outputLen:c}=this;this.digestInto(i);const f=i.slice(0,c);return this.destroy(),f}_cloneInto(i){i||(i=new this.constructor),i.set(...this.get());const{blockLen:c,buffer:f,length:u,finished:l,destroyed:h,pos:p}=this;return i.destroyed=h,i.finished=l,i.length=u,i.pos=p,u%c&&i.buffer.set(f),i}clone(){return this._cloneInto()}}return tt.HashMD=o,tt.SHA256_IV=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),tt.SHA224_IV=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),tt.SHA384_IV=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),tt.SHA512_IV=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),tt}var q={},We;function Br(){if(We)return q;We=1,Object.defineProperty(q,"__esModule",{value:!0}),q.toBig=q.shrSL=q.shrSH=q.rotrSL=q.rotrSH=q.rotrBL=q.rotrBH=q.rotr32L=q.rotr32H=q.rotlSL=q.rotlSH=q.rotlBL=q.rotlBH=q.add5L=q.add5H=q.add4L=q.add4H=q.add3L=q.add3H=void 0,q.add=B,q.fromBig=n,q.split=r;const e=BigInt(2**32-1),t=BigInt(32);function n(d,A=!1){return A?{h:Number(d&e),l:Number(d>>t&e)}:{h:Number(d>>t&e)|0,l:Number(d&e)|0}}function r(d,A=!1){const H=d.length;let U=new Uint32Array(H),b=new Uint32Array(H);for(let y=0;y<H;y++){const{h:x,l:L}=n(d[y],A);[U[y],b[y]]=[x,L]}return[U,b]}const o=(d,A)=>BigInt(d>>>0)<<t|BigInt(A>>>0);q.toBig=o;const s=(d,A,H)=>d>>>H;q.shrSH=s;const i=(d,A,H)=>d<<32-H|A>>>H;q.shrSL=i;const c=(d,A,H)=>d>>>H|A<<32-H;q.rotrSH=c;const f=(d,A,H)=>d<<32-H|A>>>H;q.rotrSL=f;const u=(d,A,H)=>d<<64-H|A>>>H-32;q.rotrBH=u;const l=(d,A,H)=>d>>>H-32|A<<64-H;q.rotrBL=l;const h=(d,A)=>A;q.rotr32H=h;const p=(d,A)=>d;q.rotr32L=p;const g=(d,A,H)=>d<<H|A>>>32-H;q.rotlSH=g;const w=(d,A,H)=>A<<H|d>>>32-H;q.rotlSL=w;const I=(d,A,H)=>A<<H-32|d>>>64-H;q.rotlBH=I;const _=(d,A,H)=>d<<H-32|A>>>64-H;q.rotlBL=_;function B(d,A,H,U){const b=(A>>>0)+(U>>>0);return{h:d+H+(b/2**32|0)|0,l:b|0}}const O=(d,A,H)=>(d>>>0)+(A>>>0)+(H>>>0);q.add3L=O;const m=(d,A,H,U)=>A+H+U+(d/2**32|0)|0;q.add3H=m;const k=(d,A,H,U)=>(d>>>0)+(A>>>0)+(H>>>0)+(U>>>0);q.add4L=k;const R=(d,A,H,U,b)=>A+H+U+b+(d/2**32|0)|0;q.add4H=R;const C=(d,A,H,U,b)=>(d>>>0)+(A>>>0)+(H>>>0)+(U>>>0)+(b>>>0);q.add5L=C;const K=(d,A,H,U,b,y)=>A+H+U+b+y+(d/2**32|0)|0;q.add5H=K;const S={fromBig:n,split:r,toBig:o,shrSH:s,shrSL:i,rotrSH:c,rotrSL:f,rotrBH:u,rotrBL:l,rotr32H:h,rotr32L:p,rotlSH:g,rotlSL:w,rotlBH:I,rotlBL:_,add:B,add3L:O,add3H:m,add4L:k,add4H:R,add5H:K,add5L:C};return q.default=S,q}var ze;function Hn(){if(ze)return G;ze=1,Object.defineProperty(G,"__esModule",{value:!0}),G.sha512_224=G.sha512_256=G.sha384=G.sha512=G.sha224=G.sha256=G.SHA512_256=G.SHA512_224=G.SHA384=G.SHA512=G.SHA224=G.SHA256=void 0;const e=Ar(),t=Br(),n=ue(),r=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),o=new Uint32Array(64);class s extends e.HashMD{constructor(m=32){super(64,m,8,!1),this.A=e.SHA256_IV[0]|0,this.B=e.SHA256_IV[1]|0,this.C=e.SHA256_IV[2]|0,this.D=e.SHA256_IV[3]|0,this.E=e.SHA256_IV[4]|0,this.F=e.SHA256_IV[5]|0,this.G=e.SHA256_IV[6]|0,this.H=e.SHA256_IV[7]|0}get(){const{A:m,B:k,C:R,D:C,E:K,F:S,G:d,H:A}=this;return[m,k,R,C,K,S,d,A]}set(m,k,R,C,K,S,d,A){this.A=m|0,this.B=k|0,this.C=R|0,this.D=C|0,this.E=K|0,this.F=S|0,this.G=d|0,this.H=A|0}process(m,k){for(let b=0;b<16;b++,k+=4)o[b]=m.getUint32(k,!1);for(let b=16;b<64;b++){const y=o[b-15],x=o[b-2],L=(0,n.rotr)(y,7)^(0,n.rotr)(y,18)^y>>>3,V=(0,n.rotr)(x,17)^(0,n.rotr)(x,19)^x>>>10;o[b]=V+o[b-7]+L+o[b-16]|0}let{A:R,B:C,C:K,D:S,E:d,F:A,G:H,H:U}=this;for(let b=0;b<64;b++){const y=(0,n.rotr)(d,6)^(0,n.rotr)(d,11)^(0,n.rotr)(d,25),x=U+y+(0,e.Chi)(d,A,H)+r[b]+o[b]|0,V=((0,n.rotr)(R,2)^(0,n.rotr)(R,13)^(0,n.rotr)(R,22))+(0,e.Maj)(R,C,K)|0;U=H,H=A,A=d,d=S+x|0,S=K,K=C,C=R,R=x+V|0}R=R+this.A|0,C=C+this.B|0,K=K+this.C|0,S=S+this.D|0,d=d+this.E|0,A=A+this.F|0,H=H+this.G|0,U=U+this.H|0,this.set(R,C,K,S,d,A,H,U)}roundClean(){(0,n.clean)(o)}destroy(){this.set(0,0,0,0,0,0,0,0),(0,n.clean)(this.buffer)}}G.SHA256=s;class i extends s{constructor(){super(28),this.A=e.SHA224_IV[0]|0,this.B=e.SHA224_IV[1]|0,this.C=e.SHA224_IV[2]|0,this.D=e.SHA224_IV[3]|0,this.E=e.SHA224_IV[4]|0,this.F=e.SHA224_IV[5]|0,this.G=e.SHA224_IV[6]|0,this.H=e.SHA224_IV[7]|0}}G.SHA224=i;const c=t.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(O=>BigInt(O))),f=c[0],u=c[1],l=new Uint32Array(80),h=new Uint32Array(80);class p extends e.HashMD{constructor(m=64){super(128,m,16,!1),this.Ah=e.SHA512_IV[0]|0,this.Al=e.SHA512_IV[1]|0,this.Bh=e.SHA512_IV[2]|0,this.Bl=e.SHA512_IV[3]|0,this.Ch=e.SHA512_IV[4]|0,this.Cl=e.SHA512_IV[5]|0,this.Dh=e.SHA512_IV[6]|0,this.Dl=e.SHA512_IV[7]|0,this.Eh=e.SHA512_IV[8]|0,this.El=e.SHA512_IV[9]|0,this.Fh=e.SHA512_IV[10]|0,this.Fl=e.SHA512_IV[11]|0,this.Gh=e.SHA512_IV[12]|0,this.Gl=e.SHA512_IV[13]|0,this.Hh=e.SHA512_IV[14]|0,this.Hl=e.SHA512_IV[15]|0}get(){const{Ah:m,Al:k,Bh:R,Bl:C,Ch:K,Cl:S,Dh:d,Dl:A,Eh:H,El:U,Fh:b,Fl:y,Gh:x,Gl:L,Hh:V,Hl:D}=this;return[m,k,R,C,K,S,d,A,H,U,b,y,x,L,V,D]}set(m,k,R,C,K,S,d,A,H,U,b,y,x,L,V,D){this.Ah=m|0,this.Al=k|0,this.Bh=R|0,this.Bl=C|0,this.Ch=K|0,this.Cl=S|0,this.Dh=d|0,this.Dl=A|0,this.Eh=H|0,this.El=U|0,this.Fh=b|0,this.Fl=y|0,this.Gh=x|0,this.Gl=L|0,this.Hh=V|0,this.Hl=D|0}process(m,k){for(let v=0;v<16;v++,k+=4)l[v]=m.getUint32(k),h[v]=m.getUint32(k+=4);for(let v=16;v<80;v++){const T=l[v-15]|0,N=h[v-15]|0,M=t.rotrSH(T,N,1)^t.rotrSH(T,N,8)^t.shrSH(T,N,7),F=t.rotrSL(T,N,1)^t.rotrSL(T,N,8)^t.shrSL(T,N,7),j=l[v-2]|0,Y=h[v-2]|0,nt=t.rotrSH(j,Y,19)^t.rotrBH(j,Y,61)^t.shrSH(j,Y,6),X=t.rotrSL(j,Y,19)^t.rotrBL(j,Y,61)^t.shrSL(j,Y,6),W=t.add4L(F,X,h[v-7],h[v-16]),dt=t.add4H(W,M,nt,l[v-7],l[v-16]);l[v]=dt|0,h[v]=W|0}let{Ah:R,Al:C,Bh:K,Bl:S,Ch:d,Cl:A,Dh:H,Dl:U,Eh:b,El:y,Fh:x,Fl:L,Gh:V,Gl:D,Hh:a,Hl:E}=this;for(let v=0;v<80;v++){const T=t.rotrSH(b,y,14)^t.rotrSH(b,y,18)^t.rotrBH(b,y,41),N=t.rotrSL(b,y,14)^t.rotrSL(b,y,18)^t.rotrBL(b,y,41),M=b&x^~b&V,F=y&L^~y&D,j=t.add5L(E,N,F,u[v],h[v]),Y=t.add5H(j,a,T,M,f[v],l[v]),nt=j|0,X=t.rotrSH(R,C,28)^t.rotrBH(R,C,34)^t.rotrBH(R,C,39),W=t.rotrSL(R,C,28)^t.rotrBL(R,C,34)^t.rotrBL(R,C,39),dt=R&K^R&d^K&d,Wt=C&S^C&A^S&A;a=V|0,E=D|0,V=x|0,D=L|0,x=b|0,L=y|0,{h:b,l:y}=t.add(H|0,U|0,Y|0,nt|0),H=d|0,U=A|0,d=K|0,A=S|0,K=R|0,S=C|0;const Rt=t.add3L(nt,W,Wt);R=t.add3H(Rt,Y,X,dt),C=Rt|0}({h:R,l:C}=t.add(this.Ah|0,this.Al|0,R|0,C|0)),{h:K,l:S}=t.add(this.Bh|0,this.Bl|0,K|0,S|0),{h:d,l:A}=t.add(this.Ch|0,this.Cl|0,d|0,A|0),{h:H,l:U}=t.add(this.Dh|0,this.Dl|0,H|0,U|0),{h:b,l:y}=t.add(this.Eh|0,this.El|0,b|0,y|0),{h:x,l:L}=t.add(this.Fh|0,this.Fl|0,x|0,L|0),{h:V,l:D}=t.add(this.Gh|0,this.Gl|0,V|0,D|0),{h:a,l:E}=t.add(this.Hh|0,this.Hl|0,a|0,E|0),this.set(R,C,K,S,d,A,H,U,b,y,x,L,V,D,a,E)}roundClean(){(0,n.clean)(l,h)}destroy(){(0,n.clean)(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}G.SHA512=p;class g extends p{constructor(){super(48),this.Ah=e.SHA384_IV[0]|0,this.Al=e.SHA384_IV[1]|0,this.Bh=e.SHA384_IV[2]|0,this.Bl=e.SHA384_IV[3]|0,this.Ch=e.SHA384_IV[4]|0,this.Cl=e.SHA384_IV[5]|0,this.Dh=e.SHA384_IV[6]|0,this.Dl=e.SHA384_IV[7]|0,this.Eh=e.SHA384_IV[8]|0,this.El=e.SHA384_IV[9]|0,this.Fh=e.SHA384_IV[10]|0,this.Fl=e.SHA384_IV[11]|0,this.Gh=e.SHA384_IV[12]|0,this.Gl=e.SHA384_IV[13]|0,this.Hh=e.SHA384_IV[14]|0,this.Hl=e.SHA384_IV[15]|0}}G.SHA384=g;const w=Uint32Array.from([2352822216,424955298,1944164710,2312950998,502970286,855612546,1738396948,1479516111,258812777,2077511080,2011393907,79989058,1067287976,1780299464,286451373,2446758561]),I=Uint32Array.from([573645204,4230739756,2673172387,3360449730,596883563,1867755857,2520282905,1497426621,2519219938,2827943907,3193839141,1401305490,721525244,746961066,246885852,2177182882]);class _ extends p{constructor(){super(28),this.Ah=w[0]|0,this.Al=w[1]|0,this.Bh=w[2]|0,this.Bl=w[3]|0,this.Ch=w[4]|0,this.Cl=w[5]|0,this.Dh=w[6]|0,this.Dl=w[7]|0,this.Eh=w[8]|0,this.El=w[9]|0,this.Fh=w[10]|0,this.Fl=w[11]|0,this.Gh=w[12]|0,this.Gl=w[13]|0,this.Hh=w[14]|0,this.Hl=w[15]|0}}G.SHA512_224=_;class B extends p{constructor(){super(32),this.Ah=I[0]|0,this.Al=I[1]|0,this.Bh=I[2]|0,this.Bl=I[3]|0,this.Ch=I[4]|0,this.Cl=I[5]|0,this.Dh=I[6]|0,this.Dl=I[7]|0,this.Eh=I[8]|0,this.El=I[9]|0,this.Fh=I[10]|0,this.Fl=I[11]|0,this.Gh=I[12]|0,this.Gl=I[13]|0,this.Hh=I[14]|0,this.Hl=I[15]|0}}return G.SHA512_256=B,G.sha256=(0,n.createHasher)(()=>new s),G.sha224=(0,n.createHasher)(()=>new i),G.sha512=(0,n.createHasher)(()=>new p),G.sha384=(0,n.createHasher)(()=>new g),G.sha512_256=(0,n.createHasher)(()=>new B),G.sha512_224=(0,n.createHasher)(()=>new _),G}var Pe;function lo(){if(Pe)return ct;Pe=1,Object.defineProperty(ct,"__esModule",{value:!0}),ct.sha224=ct.SHA224=ct.sha256=ct.SHA256=void 0;const e=Hn();return ct.SHA256=e.SHA256,ct.sha256=e.sha256,ct.SHA224=e.SHA224,ct.sha224=e.sha224,ct}var P={},Je;function bo(){if(Je)return P;Je=1,Object.defineProperty(P,"__esModule",{value:!0}),P.sha512_256=P.SHA512_256=P.sha512_224=P.SHA512_224=P.sha384=P.SHA384=P.sha512=P.SHA512=void 0;const e=Hn();return P.SHA512=e.SHA512,P.sha512=e.sha512,P.SHA384=e.SHA384,P.sha384=e.sha384,P.SHA512_224=e.SHA512_224,P.sha512_224=e.sha512_224,P.SHA512_256=e.SHA512_256,P.sha512_256=e.sha512_256,P}var Ot={},xe={},Qe;function Hr(){return Qe||(Qe=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.hmac=e.HMAC=void 0;const t=ue();class n extends t.Hash{constructor(s,i){super(),this.finished=!1,this.destroyed=!1,(0,t.ahash)(s);const c=(0,t.toBytes)(i);if(this.iHash=s.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const f=this.blockLen,u=new Uint8Array(f);u.set(c.length>f?s.create().update(c).digest():c);for(let l=0;l<u.length;l++)u[l]^=54;this.iHash.update(u),this.oHash=s.create();for(let l=0;l<u.length;l++)u[l]^=106;this.oHash.update(u),(0,t.clean)(u)}update(s){return(0,t.aexists)(this),this.iHash.update(s),this}digestInto(s){(0,t.aexists)(this),(0,t.abytes)(s,this.outputLen),this.finished=!0,this.iHash.digestInto(s),this.oHash.update(s),this.oHash.digestInto(s),this.destroy()}digest(){const s=new Uint8Array(this.oHash.outputLen);return this.digestInto(s),s}_cloneInto(s){s||(s=Object.create(Object.getPrototypeOf(this),{}));const{oHash:i,iHash:c,finished:f,destroyed:u,blockLen:l,outputLen:h}=this;return s=s,s.finished=f,s.destroyed=u,s.blockLen=l,s.outputLen=h,s.oHash=i._cloneInto(s.oHash),s.iHash=c._cloneInto(s.iHash),s}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}e.HMAC=n;const r=(o,s,i)=>new n(o,s).update(i).digest();e.hmac=r,e.hmac.create=(o,s)=>new n(o,s)})(xe)),xe}var tn;function wo(){if(tn)return Ot;tn=1,Object.defineProperty(Ot,"__esModule",{value:!0}),Ot.pbkdf2=o,Ot.pbkdf2Async=s;const e=Hr(),t=ue();function n(i,c,f,u){(0,t.ahash)(i);const l=(0,t.checkOpts)({dkLen:32,asyncTick:10},u),{c:h,dkLen:p,asyncTick:g}=l;if((0,t.anumber)(h),(0,t.anumber)(p),(0,t.anumber)(g),h<1)throw new Error("iterations (c) should be >= 1");const w=(0,t.kdfInputToBytes)(c),I=(0,t.kdfInputToBytes)(f),_=new Uint8Array(p),B=e.hmac.create(i,w),O=B._cloneInto().update(I);return{c:h,dkLen:p,asyncTick:g,DK:_,PRF:B,PRFSalt:O}}function r(i,c,f,u,l){return i.destroy(),c.destroy(),u&&u.destroy(),(0,t.clean)(l),f}function o(i,c,f,u){const{c:l,dkLen:h,DK:p,PRF:g,PRFSalt:w}=n(i,c,f,u);let I;const _=new Uint8Array(4),B=(0,t.createView)(_),O=new Uint8Array(g.outputLen);for(let m=1,k=0;k<h;m++,k+=g.outputLen){const R=p.subarray(k,k+g.outputLen);B.setInt32(0,m,!1),(I=w._cloneInto(I)).update(_).digestInto(O),R.set(O.subarray(0,R.length));for(let C=1;C<l;C++){g._cloneInto(I).update(O).digestInto(O);for(let K=0;K<R.length;K++)R[K]^=O[K]}}return r(g,w,p,I,O)}async function s(i,c,f,u){const{c:l,dkLen:h,asyncTick:p,DK:g,PRF:w,PRFSalt:I}=n(i,c,f,u);let _;const B=new Uint8Array(4),O=(0,t.createView)(B),m=new Uint8Array(w.outputLen);for(let k=1,R=0;R<h;k++,R+=w.outputLen){const C=g.subarray(R,R+w.outputLen);O.setInt32(0,k,!1),(_=I._cloneInto(_)).update(B).digestInto(m),C.set(m.subarray(0,C.length)),await(0,t.asyncLoop)(l-1,p,()=>{w._cloneInto(_).update(m).digestInto(m);for(let K=0;K<C.length;K++)C[K]^=m[K]})}return r(w,I,g,_,m)}return Ot}function he(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function it(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function Z(e,t,n=""){const r=he(e),o=e?.length,s=t!==void 0;if(!r||s&&o!==t){const i=n&&`"${n}" `,c=s?` of length ${t}`:"",f=r?`length=${o}`:`type=${typeof e}`;throw new Error(i+"expected Uint8Array"+c+", got "+f)}return e}function Ce(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");it(e.outputLen),it(e.blockLen)}function It(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function _n(e,t){Z(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function _r(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function ot(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function Et(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function ft(e,t){return e<<32-t|e>>>t}function Tt(e,t){return e<<t|e>>>32-t>>>0}const Sr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function vr(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function Ir(e){for(let t=0;t<e.length;t++)e[t]=vr(e[t]);return e}const en=Sr?e=>e:Ir,Sn=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Lr=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Yt(e){if(Z(e),Sn)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=Lr[e[n]];return t}const at={_0:48,_9:57,A:65,F:70,a:97,f:102};function nn(e){if(e>=at._0&&e<=at._9)return e-at._0;if(e>=at.A&&e<=at.F)return e-(at.A-10);if(e>=at.a&&e<=at.f)return e-(at.a-10)}function Nt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(Sn)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const i=nn(e.charCodeAt(s)),c=nn(e.charCodeAt(s+1));if(i===void 0||c===void 0){const f=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+f+'" at index '+s)}r[o]=i*16+c}return r}function Rr(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function rn(e,t=""){return typeof e=="string"?Rr(e):Z(e,void 0,t)}function rt(...e){let t=0;for(let r=0;r<e.length;r++){const o=e[r];Z(o),t+=o.length}const n=new Uint8Array(t);for(let r=0,o=0;r<e.length;r++){const s=e[r];n.set(s,o),o+=s.length}return n}function Ur(e,t){if(t!==void 0&&{}.toString.call(t)!=="[object Object]")throw new Error("options must be object or undefined");return Object.assign(e,t)}function Gt(e,t={}){const n=(o,s)=>e(s).update(o).digest(),r=e(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=o=>e(o),Object.assign(n,t),Object.freeze(n)}function Te(e=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}const vn=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function ve(e,t,n){return e&t^~e&n}function Or(e,t,n){return e&t^e&n^t&n}class de{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(t,n,r,o){this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.buffer=new Uint8Array(t),this.view=Et(this.buffer)}update(t){It(this),Z(t);const{view:n,buffer:r,blockLen:o}=this,s=t.length;for(let i=0;i<s;){const c=Math.min(o-this.pos,s-i);if(c===o){const f=Et(t);for(;o<=s-i;i+=o)this.process(f,i);continue}r.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){It(this),_n(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:i}=this;n[i++]=128,ot(this.buffer.subarray(i)),this.padOffset>o-i&&(this.process(r,0),i=0);for(let h=i;h<o;h++)n[h]=0;r.setBigUint64(o-8,BigInt(this.length*8),s),this.process(r,0);const c=Et(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=f/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)c.setUint32(4*h,l[h],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||=new this.constructor,t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:i,pos:c}=this;return t.destroyed=i,t.finished=s,t.length=o,t.pos=c,o%n&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const lt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),et=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),zt=BigInt(2**32-1),sn=BigInt(32);function kr(e,t=!1){return t?{h:Number(e&zt),l:Number(e>>sn&zt)}:{h:Number(e>>sn&zt)|0,l:Number(e&zt)|0}}function In(e,t=!1){const n=e.length;let r=new Uint32Array(n),o=new Uint32Array(n);for(let s=0;s<n;s++){const{h:i,l:c}=kr(e[s],t);[r[s],o[s]]=[i,c]}return[r,o]}const on=(e,t,n)=>e>>>n,cn=(e,t,n)=>e<<32-n|t>>>n,Bt=(e,t,n)=>e>>>n|t<<32-n,Ht=(e,t,n)=>e<<32-n|t>>>n,Pt=(e,t,n)=>e<<64-n|t>>>n-32,Jt=(e,t,n)=>e>>>n-32|t<<64-n,Vr=(e,t,n)=>e<<n|t>>>32-n,Cr=(e,t,n)=>t<<n|e>>>32-n,Tr=(e,t,n)=>t<<n-32|e>>>64-n,Dr=(e,t,n)=>e<<n-32|t>>>64-n;function ut(e,t,n,r){const o=(t>>>0)+(r>>>0);return{h:e+n+(o/2**32|0)|0,l:o|0}}const Kr=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),Nr=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,qr=(e,t,n,r)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0),Mr=(e,t,n,r,o)=>t+n+r+o+(e/2**32|0)|0,Zr=(e,t,n,r,o)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0)+(o>>>0),Fr=(e,t,n,r,o,s)=>t+n+r+o+s+(e/2**32|0)|0,jr=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),bt=new Uint32Array(64);class Yr extends de{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:n,C:r,D:o,E:s,F:i,G:c,H:f}=this;return[t,n,r,o,s,i,c,f]}set(t,n,r,o,s,i,c,f){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=f|0}process(t,n){for(let h=0;h<16;h++,n+=4)bt[h]=t.getUint32(n,!1);for(let h=16;h<64;h++){const p=bt[h-15],g=bt[h-2],w=ft(p,7)^ft(p,18)^p>>>3,I=ft(g,17)^ft(g,19)^g>>>10;bt[h]=I+bt[h-7]+w+bt[h-16]|0}let{A:r,B:o,C:s,D:i,E:c,F:f,G:u,H:l}=this;for(let h=0;h<64;h++){const p=ft(c,6)^ft(c,11)^ft(c,25),g=l+p+ve(c,f,u)+jr[h]+bt[h]|0,I=(ft(r,2)^ft(r,13)^ft(r,22))+Or(r,o,s)|0;l=u,u=f,f=c,c=i+g|0,i=s,s=o,o=r,r=g+I|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,f=f+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(r,o,s,i,c,f,u,l)}roundClean(){ot(bt)}destroy(){this.set(0,0,0,0,0,0,0,0),ot(this.buffer)}}class Ln extends Yr{A=lt[0]|0;B=lt[1]|0;C=lt[2]|0;D=lt[3]|0;E=lt[4]|0;F=lt[5]|0;G=lt[6]|0;H=lt[7]|0;constructor(){super(32)}}const Rn=In(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),Gr=Rn[0],Xr=Rn[1],wt=new Uint32Array(80),yt=new Uint32Array(80);class $r extends de{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:n,Bh:r,Bl:o,Ch:s,Cl:i,Dh:c,Dl:f,Eh:u,El:l,Fh:h,Fl:p,Gh:g,Gl:w,Hh:I,Hl:_}=this;return[t,n,r,o,s,i,c,f,u,l,h,p,g,w,I,_]}set(t,n,r,o,s,i,c,f,u,l,h,p,g,w,I,_){this.Ah=t|0,this.Al=n|0,this.Bh=r|0,this.Bl=o|0,this.Ch=s|0,this.Cl=i|0,this.Dh=c|0,this.Dl=f|0,this.Eh=u|0,this.El=l|0,this.Fh=h|0,this.Fl=p|0,this.Gh=g|0,this.Gl=w|0,this.Hh=I|0,this.Hl=_|0}process(t,n){for(let m=0;m<16;m++,n+=4)wt[m]=t.getUint32(n),yt[m]=t.getUint32(n+=4);for(let m=16;m<80;m++){const k=wt[m-15]|0,R=yt[m-15]|0,C=Bt(k,R,1)^Bt(k,R,8)^on(k,R,7),K=Ht(k,R,1)^Ht(k,R,8)^cn(k,R,7),S=wt[m-2]|0,d=yt[m-2]|0,A=Bt(S,d,19)^Pt(S,d,61)^on(S,d,6),H=Ht(S,d,19)^Jt(S,d,61)^cn(S,d,6),U=qr(K,H,yt[m-7],yt[m-16]),b=Mr(U,C,A,wt[m-7],wt[m-16]);wt[m]=b|0,yt[m]=U|0}let{Ah:r,Al:o,Bh:s,Bl:i,Ch:c,Cl:f,Dh:u,Dl:l,Eh:h,El:p,Fh:g,Fl:w,Gh:I,Gl:_,Hh:B,Hl:O}=this;for(let m=0;m<80;m++){const k=Bt(h,p,14)^Bt(h,p,18)^Pt(h,p,41),R=Ht(h,p,14)^Ht(h,p,18)^Jt(h,p,41),C=h&g^~h&I,K=p&w^~p&_,S=Zr(O,R,K,Xr[m],yt[m]),d=Fr(S,B,k,C,Gr[m],wt[m]),A=S|0,H=Bt(r,o,28)^Pt(r,o,34)^Pt(r,o,39),U=Ht(r,o,28)^Jt(r,o,34)^Jt(r,o,39),b=r&s^r&c^s&c,y=o&i^o&f^i&f;B=I|0,O=_|0,I=g|0,_=w|0,g=h|0,w=p|0,{h,l:p}=ut(u|0,l|0,d|0,A|0),u=c|0,l=f|0,c=s|0,f=i|0,s=r|0,i=o|0;const x=Kr(A,U,y);r=Nr(x,d,H,b),o=x|0}({h:r,l:o}=ut(this.Ah|0,this.Al|0,r|0,o|0)),{h:s,l:i}=ut(this.Bh|0,this.Bl|0,s|0,i|0),{h:c,l:f}=ut(this.Ch|0,this.Cl|0,c|0,f|0),{h:u,l}=ut(this.Dh|0,this.Dl|0,u|0,l|0),{h,l:p}=ut(this.Eh|0,this.El|0,h|0,p|0),{h:g,l:w}=ut(this.Fh|0,this.Fl|0,g|0,w|0),{h:I,l:_}=ut(this.Gh|0,this.Gl|0,I|0,_|0),{h:B,l:O}=ut(this.Hh|0,this.Hl|0,B|0,O|0),this.set(r,o,s,i,c,f,u,l,h,p,g,w,I,_,B,O)}roundClean(){ot(wt,yt)}destroy(){ot(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Un extends $r{Ah=et[0]|0;Al=et[1]|0;Bh=et[2]|0;Bl=et[3]|0;Ch=et[4]|0;Cl=et[5]|0;Dh=et[6]|0;Dl=et[7]|0;Eh=et[8]|0;El=et[9]|0;Fh=et[10]|0;Fl=et[11]|0;Gh=et[12]|0;Gl=et[13]|0;Hh=et[14]|0;Hl=et[15]|0;constructor(){super(64)}}const le=Gt(()=>new Ln,vn(1)),qt=Gt(()=>new Un,vn(3)),yo=Object.freeze(Object.defineProperty({__proto__:null,_SHA256:Ln,_SHA512:Un,sha256:le,sha512:qt},Symbol.toStringTag,{value:"Module"}));const De=BigInt(0),Ie=BigInt(1);function At(e,t=""){if(typeof e!="boolean"){const n=t&&`"${t}" `;throw new Error(n+"expected boolean, got type="+typeof e)}return e}function On(e){if(typeof e=="bigint"){if(!se(e))throw new Error("positive bigint expected, got "+e)}else it(e);return e}function Qt(e){const t=On(e).toString(16);return t.length&1?"0"+t:t}function kn(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?De:BigInt("0x"+e)}function be(e){return kn(Yt(e))}function Mt(e){return kn(Yt(Le(Z(e)).reverse()))}function Ke(e,t){it(t),e=On(e);const n=Nt(e.toString(16).padStart(t*2,"0"));if(n.length!==t)throw new Error("number too large");return n}function Vn(e,t){return Ke(e,t).reverse()}function Le(e){return Uint8Array.from(e)}const se=e=>typeof e=="bigint"&&De<=e;function Wr(e,t,n){return se(e)&&se(t)&&se(n)&&t<=e&&e<n}function Re(e,t,n,r){if(!Wr(t,n,r))throw new Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}function zr(e){let t;for(t=0;e>De;e>>=Ie,t+=1);return t}const Ne=e=>(Ie<<BigInt(e))-Ie;function Pr(e,t,n){if(it(e,"hashLen"),it(t,"qByteLen"),typeof n!="function")throw new Error("hmacFn must be a function");const r=_=>new Uint8Array(_),o=Uint8Array.of(),s=Uint8Array.of(0),i=Uint8Array.of(1),c=1e3;let f=r(e),u=r(e),l=0;const h=()=>{f.fill(1),u.fill(0),l=0},p=(..._)=>n(u,rt(f,..._)),g=(_=o)=>{u=p(s,_),f=p(),_.length!==0&&(u=p(i,_),f=p())},w=()=>{if(l++>=c)throw new Error("drbg: tried max amount of iterations");let _=0;const B=[];for(;_<t;){f=p();const O=f.slice();B.push(O),_+=f.length}return rt(...B)};return(_,B)=>{h(),g(_);let O;for(;!(O=B(w()));)g();return h(),O}}function Xt(e,t={},n={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(s,i,c){const f=e[s];if(c&&f===void 0)return;const u=typeof f;if(u!==i||f===null)throw new Error(`param "${s}" is invalid: expected ${i}, got ${u}`)}const o=(s,i)=>Object.entries(s).forEach(([c,f])=>r(c,f,i));o(t,!1),o(n,!0)}function ie(e){const t=new WeakMap;return(n,...r)=>{const o=t.get(n);if(o!==void 0)return o;const s=e(n,...r);return t.set(n,s),s}}const st=BigInt(0),Q=BigInt(1),gt=BigInt(2),Cn=BigInt(3),Tn=BigInt(4),Dn=BigInt(5),Jr=BigInt(7),Kn=BigInt(8),Qr=BigInt(9),Nn=BigInt(16);function z(e,t){const n=e%t;return n>=st?n:t+n}function $(e,t,n){let r=e;for(;t-- >st;)r*=r,r%=n;return r}function fn(e,t){if(e===st)throw new Error("invert: expected non-zero number");if(t<=st)throw new Error("invert: expected positive modulus, got "+t);let n=z(e,t),r=t,o=st,s=Q;for(;n!==st;){const c=r/n,f=r%n,u=o-s*c;r=n,n=f,o=s,s=u}if(r!==Q)throw new Error("invert: does not exist");return z(o,t)}function qe(e,t,n){if(!e.eql(e.sqr(t),n))throw new Error("Cannot find square root")}function qn(e,t){const n=(e.ORDER+Q)/Tn,r=e.pow(t,n);return qe(e,r,t),r}function ts(e,t){const n=(e.ORDER-Dn)/Kn,r=e.mul(t,gt),o=e.pow(r,n),s=e.mul(t,o),i=e.mul(e.mul(s,gt),o),c=e.mul(s,e.sub(i,e.ONE));return qe(e,c,t),c}function es(e){const t=we(e),n=Mn(e),r=n(t,t.neg(t.ONE)),o=n(t,r),s=n(t,t.neg(r)),i=(e+Jr)/Nn;return(c,f)=>{let u=c.pow(f,i),l=c.mul(u,r);const h=c.mul(u,o),p=c.mul(u,s),g=c.eql(c.sqr(l),f),w=c.eql(c.sqr(h),f);u=c.cmov(u,l,g),l=c.cmov(p,h,w);const I=c.eql(c.sqr(l),f),_=c.cmov(u,l,I);return qe(c,_,f),_}}function Mn(e){if(e<Cn)throw new Error("sqrt is not defined for small field");let t=e-Q,n=0;for(;t%gt===st;)t/=gt,n++;let r=gt;const o=we(e);for(;an(o,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return qn;let s=o.pow(r,t);const i=(t+Q)/gt;return function(f,u){if(f.is0(u))return u;if(an(f,u)!==1)throw new Error("Cannot find square root");let l=n,h=f.mul(f.ONE,s),p=f.pow(u,t),g=f.pow(u,i);for(;!f.eql(p,f.ONE);){if(f.is0(p))return f.ZERO;let w=1,I=f.sqr(p);for(;!f.eql(I,f.ONE);)if(w++,I=f.sqr(I),w===l)throw new Error("Cannot find square root");const _=Q<<BigInt(l-w-1),B=f.pow(h,_);l=w,h=f.sqr(B),p=f.mul(p,h),g=f.mul(g,B)}return g}}function ns(e){return e%Tn===Cn?qn:e%Kn===Dn?ts:e%Nn===Qr?es(e):Mn(e)}const rs=(e,t)=>(z(e,t)&Q)===Q,ss=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function os(e){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},n=ss.reduce((r,o)=>(r[o]="function",r),t);return Xt(e,n),e}function is(e,t,n){if(n<st)throw new Error("invalid exponent, negatives unsupported");if(n===st)return e.ONE;if(n===Q)return t;let r=e.ONE,o=t;for(;n>st;)n&Q&&(r=e.mul(r,o)),o=e.sqr(o),n>>=Q;return r}function Zn(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),o=t.reduce((i,c,f)=>e.is0(c)?i:(r[f]=i,e.mul(i,c)),e.ONE),s=e.inv(o);return t.reduceRight((i,c,f)=>e.is0(c)?i:(r[f]=e.mul(i,r[f]),e.mul(i,c)),s),r}function an(e,t){const n=(e.ORDER-Q)/gt,r=e.pow(t,n),o=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),i=e.eql(r,e.neg(e.ONE));if(!o&&!s&&!i)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function cs(e,t){t!==void 0&&it(t);const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}class fs{ORDER;BITS;BYTES;isLE;ZERO=st;ONE=Q;_lengths;_sqrt;_mod;constructor(t,n={}){if(t<=st)throw new Error("invalid field: expected ORDER > 0, got "+t);let r;this.isLE=!1,n!=null&&typeof n=="object"&&(typeof n.BITS=="number"&&(r=n.BITS),typeof n.sqrt=="function"&&(this.sqrt=n.sqrt),typeof n.isLE=="boolean"&&(this.isLE=n.isLE),n.allowedLengths&&(this._lengths=n.allowedLengths?.slice()),typeof n.modFromBytes=="boolean"&&(this._mod=n.modFromBytes));const{nBitLength:o,nByteLength:s}=cs(t,r);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=o,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return z(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return st<=t&&t<this.ORDER}is0(t){return t===st}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&Q)===Q}neg(t){return z(-t,this.ORDER)}eql(t,n){return t===n}sqr(t){return z(t*t,this.ORDER)}add(t,n){return z(t+n,this.ORDER)}sub(t,n){return z(t-n,this.ORDER)}mul(t,n){return z(t*n,this.ORDER)}pow(t,n){return is(this,t,n)}div(t,n){return z(t*fn(n,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,n){return t+n}subN(t,n){return t-n}mulN(t,n){return t*n}inv(t){return fn(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=ns(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Vn(t,this.BYTES):Ke(t,this.BYTES)}fromBytes(t,n=!1){Z(t);const{_lengths:r,BYTES:o,isLE:s,ORDER:i,_mod:c}=this;if(r){if(!r.includes(t.length)||t.length>o)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+t.length);const u=new Uint8Array(o);u.set(t,s?0:u.length-t.length),t=u}if(t.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+t.length);let f=s?Mt(t):be(t);if(c&&(f=z(f,i)),!n&&!this.isValid(f))throw new Error("invalid field element: outside of range 0..ORDER");return f}invertBatch(t){return Zn(this,t)}cmov(t,n,r){return r?n:t}}function we(e,t={}){return new fs(e,t)}function Fn(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function jn(e){const t=Fn(e);return t+Math.ceil(t/2)}function as(e,t,n=!1){Z(e);const r=e.length,o=Fn(t),s=jn(t);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const i=n?Mt(e):be(e),c=z(i,t-Q)+Q;return n?Vn(c,o):Ke(c,o)}const Lt=BigInt(0),mt=BigInt(1);function ce(e,t){const n=t.negate();return e?n:t}function Kt(e,t){const n=Zn(e.Fp,t.map(r=>r.Z));return t.map((r,o)=>e.fromAffine(r.toAffine(n[o])))}function Yn(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function pe(e,t){Yn(e,t);const n=Math.ceil(t/e)+1,r=2**(e-1),o=2**e,s=Ne(e),i=BigInt(e);return{windows:n,windowSize:r,mask:s,maxNumber:o,shiftBy:i}}function un(e,t,n){const{windowSize:r,mask:o,maxNumber:s,shiftBy:i}=n;let c=Number(e&o),f=e>>i;c>r&&(c-=s,f+=mt);const u=t*r,l=u+Math.abs(c)-1,h=c===0,p=c<0,g=t%2!==0;return{nextN:f,offset:l,isZero:h,isNeg:p,isNegF:g,offsetF:u}}const ge=new WeakMap,Gn=new WeakMap;function me(e){return Gn.get(e)||1}function hn(e){if(e!==Lt)throw new Error("invalid wNAF")}class Xn{BASE;ZERO;Fn;bits;constructor(t,n){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=n}_unsafeLadder(t,n,r=this.ZERO){let o=t;for(;n>Lt;)n&mt&&(r=r.add(o)),o=o.double(),n>>=mt;return r}precomputeWindow(t,n){const{windows:r,windowSize:o}=pe(n,this.bits),s=[];let i=t,c=i;for(let f=0;f<r;f++){c=i,s.push(c);for(let u=1;u<o;u++)c=c.add(i),s.push(c);i=c.double()}return s}wNAF(t,n,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE;const i=pe(t,this.bits);for(let c=0;c<i.windows;c++){const{nextN:f,offset:u,isZero:l,isNeg:h,isNegF:p,offsetF:g}=un(r,c,i);r=f,l?s=s.add(ce(p,n[g])):o=o.add(ce(h,n[u]))}return hn(r),{p:o,f:s}}wNAFUnsafe(t,n,r,o=this.ZERO){const s=pe(t,this.bits);for(let i=0;i<s.windows&&r!==Lt;i++){const{nextN:c,offset:f,isZero:u,isNeg:l}=un(r,i,s);if(r=c,!u){const h=n[f];o=o.add(l?h.negate():h)}}return hn(r),o}getPrecomputes(t,n,r){let o=ge.get(n);return o||(o=this.precomputeWindow(n,t),t!==1&&(typeof r=="function"&&(o=r(o)),ge.set(n,o))),o}cached(t,n,r){const o=me(t);return this.wNAF(o,this.getPrecomputes(o,t,r),n)}unsafe(t,n,r,o){const s=me(t);return s===1?this._unsafeLadder(t,n,o):this.wNAFUnsafe(s,this.getPrecomputes(s,t,r),n,o)}createCache(t,n){Yn(n,this.bits),Gn.set(t,n),ge.delete(t)}hasCache(t){return me(t)!==1}}function us(e,t,n,r){let o=t,s=e.ZERO,i=e.ZERO;for(;n>Lt||r>Lt;)n&mt&&(s=s.add(o)),r&mt&&(i=i.add(o)),o=o.double(),n>>=mt,r>>=mt;return{p1:s,p2:i}}function dn(e,t,n){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return os(t),t}else return we(e,{isLE:n})}function $n(e,t,n={},r){if(r===void 0&&(r=e==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${e} CURVE object`);for(const f of["p","n","h"]){const u=t[f];if(!(typeof u=="bigint"&&u>Lt))throw new Error(`CURVE.${f} must be positive bigint`)}const o=dn(t.p,n.Fp,r),s=dn(t.n,n.Fn,r),c=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const f of c)if(!o.isValid(t[f]))throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:o,Fn:s}}function Wn(e,t){return function(r){const o=e(r);return{secretKey:o,publicKey:t(o)}}}class zn{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(t,n){if(Ce(t),Z(n,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,o=new Uint8Array(r);o.set(n.length>r?t.create().update(n).digest():n);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=t.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),ot(o)}update(t){return It(this),this.iHash.update(t),this}digestInto(t){It(this),Z(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||=Object.create(Object.getPrototypeOf(this),{});const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=i,t.outputLen=c,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Zt=(e,t,n)=>new zn(e,t).update(n).digest();Zt.create=(e,t)=>new zn(e,t);const ln=(e,t)=>(e+(e>=0?t:-t)/Pn)/t;function hs(e,t,n){const[[r,o],[s,i]]=t,c=ln(i*e,n),f=ln(-o*e,n);let u=e-c*r-f*s,l=-c*o-f*i;const h=u<ht,p=l<ht;h&&(u=-u),p&&(l=-l);const g=Ne(Math.ceil(zr(n)/2))+vt;if(u<ht||u>=g||l<ht||l>=g)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:h,k1:u,k2neg:p,k2:l}}function Ue(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function Ee(e,t){const n={};for(let r of Object.keys(t))n[r]=e[r]===void 0?t[r]:e[r];return At(n.lowS,"lowS"),At(n.prehash,"prehash"),n.format!==void 0&&Ue(n.format),n}class ds extends Error{constructor(t=""){super(t)}}const pt={Err:ds,_tlv:{encode:(e,t)=>{const{Err:n}=pt;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length&1)throw new n("tlv.encode: unpadded data");const r=t.length/2,o=Qt(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const s=r>127?Qt(o.length/2|128):"";return Qt(e)+s+o+t},decode(e,t){const{Err:n}=pt;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const o=t[r++],s=!!(o&128);let i=0;if(!s)i=o;else{const f=o&127;if(!f)throw new n("tlv.decode(long): indefinite length not supported");if(f>4)throw new n("tlv.decode(long): byte length is too big");const u=t.subarray(r,r+f);if(u.length!==f)throw new n("tlv.decode: length bytes not complete");if(u[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const l of u)i=i<<8|l;if(r+=f,i<128)throw new n("tlv.decode(long): not minimal encoding")}const c=t.subarray(r,r+i);if(c.length!==i)throw new n("tlv.decode: wrong value length");return{v:c,l:t.subarray(r+i)}}},_int:{encode(e){const{Err:t}=pt;if(e<ht)throw new t("integer: negative integers are not allowed");let n=Qt(e);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=pt;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return be(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=pt,o=Z(e,void 0,"signature"),{v:s,l:i}=r.decode(48,o);if(i.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:f}=r.decode(2,s),{v:u,l}=r.decode(2,f);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(u)}},hexFromSig(e){const{_tlv:t,_int:n}=pt,r=t.encode(2,n.encode(e.r)),o=t.encode(2,n.encode(e.s)),s=r+o;return t.encode(48,s)}},ht=BigInt(0),vt=BigInt(1),Pn=BigInt(2),te=BigInt(3),ls=BigInt(4);function bs(e,t={}){const n=$n("weierstrass",e,t),{Fp:r,Fn:o}=n;let s=n.CURVE;const{h:i,n:c}=s;Xt(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:f}=t;if(f&&(!r.is0(s.a)||typeof f.beta!="bigint"||!Array.isArray(f.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=Qn(r,o);function l(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(U,b,y){const{x,y:L}=b.toAffine(),V=r.toBytes(x);if(At(y,"isCompressed"),y){l();const D=!r.isOdd(L);return rt(Jn(D),V)}else return rt(Uint8Array.of(4),V,r.toBytes(L))}function p(U){Z(U,void 0,"Point");const{publicKey:b,publicKeyUncompressed:y}=u,x=U.length,L=U[0],V=U.subarray(1);if(x===b&&(L===2||L===3)){const D=r.fromBytes(V);if(!r.isValid(D))throw new Error("bad point: is not on curve, wrong x");const a=I(D);let E;try{E=r.sqrt(a)}catch(N){const M=N instanceof Error?": "+N.message:"";throw new Error("bad point: is not on curve, sqrt error"+M)}l();const v=r.isOdd(E);return(L&1)===1!==v&&(E=r.neg(E)),{x:D,y:E}}else if(x===y&&L===4){const D=r.BYTES,a=r.fromBytes(V.subarray(0,D)),E=r.fromBytes(V.subarray(D,D*2));if(!_(a,E))throw new Error("bad point: is not on curve");return{x:a,y:E}}else throw new Error(`bad point: got length ${x}, expected compressed=${b} or uncompressed=${y}`)}const g=t.toBytes||h,w=t.fromBytes||p;function I(U){const b=r.sqr(U),y=r.mul(b,U);return r.add(r.add(y,r.mul(U,s.a)),s.b)}function _(U,b){const y=r.sqr(b),x=I(U);return r.eql(y,x)}if(!_(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const B=r.mul(r.pow(s.a,te),ls),O=r.mul(r.sqr(s.b),BigInt(27));if(r.is0(r.add(B,O)))throw new Error("bad curve params: a or b");function m(U,b,y=!1){if(!r.isValid(b)||y&&r.is0(b))throw new Error(`bad point coordinate ${U}`);return b}function k(U){if(!(U instanceof d))throw new Error("Weierstrass Point expected")}function R(U){if(!f||!f.basises)throw new Error("no endo");return hs(U,f.basises,o.ORDER)}const C=ie((U,b)=>{const{X:y,Y:x,Z:L}=U;if(r.eql(L,r.ONE))return{x:y,y:x};const V=U.is0();b==null&&(b=V?r.ONE:r.inv(L));const D=r.mul(y,b),a=r.mul(x,b),E=r.mul(L,b);if(V)return{x:r.ZERO,y:r.ZERO};if(!r.eql(E,r.ONE))throw new Error("invZ was invalid");return{x:D,y:a}}),K=ie(U=>{if(U.is0()){if(t.allowInfinityPoint&&!r.is0(U.Y))return;throw new Error("bad point: ZERO")}const{x:b,y}=U.toAffine();if(!r.isValid(b)||!r.isValid(y))throw new Error("bad point: x or y not field elements");if(!_(b,y))throw new Error("bad point: equation left != right");if(!U.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function S(U,b,y,x,L){return y=new d(r.mul(y.X,U),y.Y,y.Z),b=ce(x,b),y=ce(L,y),b.add(y)}class d{static BASE=new d(s.Gx,s.Gy,r.ONE);static ZERO=new d(r.ZERO,r.ONE,r.ZERO);static Fp=r;static Fn=o;X;Y;Z;constructor(b,y,x){this.X=m("x",b),this.Y=m("y",y,!0),this.Z=m("z",x),Object.freeze(this)}static CURVE(){return s}static fromAffine(b){const{x:y,y:x}=b||{};if(!b||!r.isValid(y)||!r.isValid(x))throw new Error("invalid affine point");if(b instanceof d)throw new Error("projective point not allowed");return r.is0(y)&&r.is0(x)?d.ZERO:new d(y,x,r.ONE)}static fromBytes(b){const y=d.fromAffine(w(Z(b,void 0,"point")));return y.assertValidity(),y}static fromHex(b){return d.fromBytes(Nt(b))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(b=8,y=!0){return H.createCache(this,b),y||this.multiply(te),this}assertValidity(){K(this)}hasEvenY(){const{y:b}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(b)}equals(b){k(b);const{X:y,Y:x,Z:L}=this,{X:V,Y:D,Z:a}=b,E=r.eql(r.mul(y,a),r.mul(V,L)),v=r.eql(r.mul(x,a),r.mul(D,L));return E&&v}negate(){return new d(this.X,r.neg(this.Y),this.Z)}double(){const{a:b,b:y}=s,x=r.mul(y,te),{X:L,Y:V,Z:D}=this;let a=r.ZERO,E=r.ZERO,v=r.ZERO,T=r.mul(L,L),N=r.mul(V,V),M=r.mul(D,D),F=r.mul(L,V);return F=r.add(F,F),v=r.mul(L,D),v=r.add(v,v),a=r.mul(b,v),E=r.mul(x,M),E=r.add(a,E),a=r.sub(N,E),E=r.add(N,E),E=r.mul(a,E),a=r.mul(F,a),v=r.mul(x,v),M=r.mul(b,M),F=r.sub(T,M),F=r.mul(b,F),F=r.add(F,v),v=r.add(T,T),T=r.add(v,T),T=r.add(T,M),T=r.mul(T,F),E=r.add(E,T),M=r.mul(V,D),M=r.add(M,M),T=r.mul(M,F),a=r.sub(a,T),v=r.mul(M,N),v=r.add(v,v),v=r.add(v,v),new d(a,E,v)}add(b){k(b);const{X:y,Y:x,Z:L}=this,{X:V,Y:D,Z:a}=b;let E=r.ZERO,v=r.ZERO,T=r.ZERO;const N=s.a,M=r.mul(s.b,te);let F=r.mul(y,V),j=r.mul(x,D),Y=r.mul(L,a),nt=r.add(y,x),X=r.add(V,D);nt=r.mul(nt,X),X=r.add(F,j),nt=r.sub(nt,X),X=r.add(y,L);let W=r.add(V,a);return X=r.mul(X,W),W=r.add(F,Y),X=r.sub(X,W),W=r.add(x,L),E=r.add(D,a),W=r.mul(W,E),E=r.add(j,Y),W=r.sub(W,E),T=r.mul(N,X),E=r.mul(M,Y),T=r.add(E,T),E=r.sub(j,T),T=r.add(j,T),v=r.mul(E,T),j=r.add(F,F),j=r.add(j,F),Y=r.mul(N,Y),X=r.mul(M,X),j=r.add(j,Y),Y=r.sub(F,Y),Y=r.mul(N,Y),X=r.add(X,Y),F=r.mul(j,X),v=r.add(v,F),F=r.mul(W,X),E=r.mul(nt,E),E=r.sub(E,F),F=r.mul(nt,j),T=r.mul(W,T),T=r.add(T,F),new d(E,v,T)}subtract(b){return this.add(b.negate())}is0(){return this.equals(d.ZERO)}multiply(b){const{endo:y}=t;if(!o.isValidNot0(b))throw new Error("invalid scalar: out of range");let x,L;const V=D=>H.cached(this,D,a=>Kt(d,a));if(y){const{k1neg:D,k1:a,k2neg:E,k2:v}=R(b),{p:T,f:N}=V(a),{p:M,f:F}=V(v);L=N.add(F),x=S(y.beta,T,M,D,E)}else{const{p:D,f:a}=V(b);x=D,L=a}return Kt(d,[x,L])[0]}multiplyUnsafe(b){const{endo:y}=t,x=this;if(!o.isValid(b))throw new Error("invalid scalar: out of range");if(b===ht||x.is0())return d.ZERO;if(b===vt)return x;if(H.hasCache(this))return this.multiply(b);if(y){const{k1neg:L,k1:V,k2neg:D,k2:a}=R(b),{p1:E,p2:v}=us(d,x,V,a);return S(y.beta,E,v,L,D)}else return H.unsafe(x,b)}toAffine(b){return C(this,b)}isTorsionFree(){const{isTorsionFree:b}=t;return i===vt?!0:b?b(d,this):H.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:b}=t;return i===vt?this:b?b(d,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(b=!0){return At(b,"isCompressed"),this.assertValidity(),g(d,this,b)}toHex(b=!0){return Yt(this.toBytes(b))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const A=o.BITS,H=new Xn(d,t.endo?Math.ceil(A/2):A);return d.BASE.precompute(8),d}function Jn(e){return Uint8Array.of(e?2:3)}function Qn(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function ws(e,t={}){const{Fn:n}=e,r=t.randomBytes||Te,o=Object.assign(Qn(e.Fp,n),{seed:jn(n.ORDER)});function s(g){try{const w=n.fromBytes(g);return n.isValidNot0(w)}catch{return!1}}function i(g,w){const{publicKey:I,publicKeyUncompressed:_}=o;try{const B=g.length;return w===!0&&B!==I||w===!1&&B!==_?!1:!!e.fromBytes(g)}catch{return!1}}function c(g=r(o.seed)){return as(Z(g,o.seed,"seed"),n.ORDER)}function f(g,w=!0){return e.BASE.multiply(n.fromBytes(g)).toBytes(w)}function u(g){const{secretKey:w,publicKey:I,publicKeyUncompressed:_}=o;if(!he(g)||"_lengths"in n&&n._lengths||w===I)return;const B=Z(g,void 0,"key").length;return B===I||B===_}function l(g,w,I=!0){if(u(g)===!0)throw new Error("first arg must be private key");if(u(w)===!1)throw new Error("second arg must be public key");const _=n.fromBytes(g);return e.fromBytes(w).multiply(_).toBytes(I)}const h={isValidSecretKey:s,isValidPublicKey:i,randomSecretKey:c},p=Wn(c,f);return Object.freeze({getPublicKey:f,getSharedSecret:l,keygen:p,Point:e,utils:h,lengths:o})}function ys(e,t,n={}){Ce(t),Xt(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),n=Object.assign({},n);const r=n.randomBytes||Te,o=n.hmac||((y,x)=>Zt(t,y,x)),{Fp:s,Fn:i}=e,{ORDER:c,BITS:f}=i,{keygen:u,getPublicKey:l,getSharedSecret:h,utils:p,lengths:g}=ws(e,n),w={prehash:!0,lowS:typeof n.lowS=="boolean"?n.lowS:!0,format:"compact",extraEntropy:!1},I=c*Pn<s.ORDER;function _(y){const x=c>>vt;return y>x}function B(y,x){if(!i.isValidNot0(x))throw new Error(`invalid signature ${y}: out of range 1..Point.Fn.ORDER`);return x}function O(){if(I)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function m(y,x){Ue(x);const L=g.signature,V=x==="compact"?L:x==="recovered"?L+1:void 0;return Z(y,V)}class k{r;s;recovery;constructor(x,L,V){if(this.r=B("r",x),this.s=B("s",L),V!=null){if(O(),![0,1,2,3].includes(V))throw new Error("invalid recovery id");this.recovery=V}Object.freeze(this)}static fromBytes(x,L=w.format){m(x,L);let V;if(L==="der"){const{r:v,s:T}=pt.toSig(Z(x));return new k(v,T)}L==="recovered"&&(V=x[0],L="compact",x=x.subarray(1));const D=g.signature/2,a=x.subarray(0,D),E=x.subarray(D,D*2);return new k(i.fromBytes(a),i.fromBytes(E),V)}static fromHex(x,L){return this.fromBytes(Nt(x),L)}assertRecovery(){const{recovery:x}=this;if(x==null)throw new Error("invalid recovery id: must be present");return x}addRecoveryBit(x){return new k(this.r,this.s,x)}recoverPublicKey(x){const{r:L,s:V}=this,D=this.assertRecovery(),a=D===2||D===3?L+c:L;if(!s.isValid(a))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const E=s.toBytes(a),v=e.fromBytes(rt(Jn((D&1)===0),E)),T=i.inv(a),N=C(Z(x,void 0,"msgHash")),M=i.create(-N*T),F=i.create(V*T),j=e.BASE.multiplyUnsafe(M).add(v.multiplyUnsafe(F));if(j.is0())throw new Error("invalid recovery: point at infinify");return j.assertValidity(),j}hasHighS(){return _(this.s)}toBytes(x=w.format){if(Ue(x),x==="der")return Nt(pt.hexFromSig(this));const{r:L,s:V}=this,D=i.toBytes(L),a=i.toBytes(V);return x==="recovered"?(O(),rt(Uint8Array.of(this.assertRecovery()),D,a)):rt(D,a)}toHex(x){return Yt(this.toBytes(x))}}const R=n.bits2int||function(x){if(x.length>8192)throw new Error("input is too large");const L=be(x),V=x.length*8-f;return V>0?L>>BigInt(V):L},C=n.bits2int_modN||function(x){return i.create(R(x))},K=Ne(f);function S(y){return Re("num < 2^"+f,y,ht,K),i.toBytes(y)}function d(y,x){return Z(y,void 0,"message"),x?Z(t(y),void 0,"prehashed message"):y}function A(y,x,L){const{lowS:V,prehash:D,extraEntropy:a}=Ee(L,w);y=d(y,D);const E=C(y),v=i.fromBytes(x);if(!i.isValidNot0(v))throw new Error("invalid private key");const T=[S(v),S(E)];if(a!=null&&a!==!1){const j=a===!0?r(g.secretKey):a;T.push(Z(j,void 0,"extraEntropy"))}const N=rt(...T),M=E;function F(j){const Y=R(j);if(!i.isValidNot0(Y))return;const nt=i.inv(Y),X=e.BASE.multiply(Y).toAffine(),W=i.create(X.x);if(W===ht)return;const dt=i.create(nt*i.create(M+W*v));if(dt===ht)return;let Wt=(X.x===W?0:2)|Number(X.y&vt),Rt=dt;return V&&_(dt)&&(Rt=i.neg(dt),Wt^=1),new k(W,Rt,I?void 0:Wt)}return{seed:N,k2sig:F}}function H(y,x,L={}){const{seed:V,k2sig:D}=A(y,x,L);return Pr(t.outputLen,i.BYTES,o)(V,D).toBytes(L.format)}function U(y,x,L,V={}){const{lowS:D,prehash:a,format:E}=Ee(V,w);if(L=Z(L,void 0,"publicKey"),x=d(x,a),!he(y)){const v=y instanceof k?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+v)}m(y,E);try{const v=k.fromBytes(y,E),T=e.fromBytes(L);if(D&&v.hasHighS())return!1;const{r:N,s:M}=v,F=C(x),j=i.inv(M),Y=i.create(F*j),nt=i.create(N*j),X=e.BASE.multiplyUnsafe(Y).add(T.multiplyUnsafe(nt));return X.is0()?!1:i.create(X.x)===N}catch{return!1}}function b(y,x,L={}){const{prehash:V}=Ee(L,w);return x=d(x,V),k.fromBytes(y,"recovered").recoverPublicKey(x).toBytes()}return Object.freeze({keygen:u,getPublicKey:l,getSharedSecret:h,utils:p,lengths:g,Point:e,sign:H,verify:U,recoverPublicKey:b,Signature:k,hash:t})}const Me={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},xs={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},bn=BigInt(2);function ps(e){const t=Me.p,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),c=BigInt(44),f=BigInt(88),u=e*e*e%t,l=u*u*e%t,h=$(l,n,t)*l%t,p=$(h,n,t)*l%t,g=$(p,bn,t)*u%t,w=$(g,o,t)*g%t,I=$(w,s,t)*w%t,_=$(I,c,t)*I%t,B=$(_,f,t)*_%t,O=$(B,c,t)*I%t,m=$(O,n,t)*l%t,k=$(m,i,t)*w%t,R=$(k,r,t)*u%t,C=$(R,bn,t);if(!Oe.eql(Oe.sqr(C),e))throw new Error("Cannot find square root");return C}const Oe=we(Me.p,{sqrt:ps}),gs=bs(Me,{Fp:Oe,endo:xs}),_t=ys(gs,le),ms=Uint32Array.from([1732584193,4023233417,2562383102,271733878,3285377520]),Es=Math.pow(2,32),As=Array.from({length:64},(e,t)=>Math.floor(Es*Math.abs(Math.sin(t+1)))),ee=ms.slice(0,4),Ae=new Uint32Array(16);class tr extends de{A=ee[0]|0;B=ee[1]|0;C=ee[2]|0;D=ee[3]|0;constructor(){super(64,16,8,!0)}get(){const{A:t,B:n,C:r,D:o}=this;return[t,n,r,o]}set(t,n,r,o){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0}process(t,n){for(let c=0;c<16;c++,n+=4)Ae[c]=t.getUint32(n,!0);let{A:r,B:o,C:s,D:i}=this;for(let c=0;c<64;c++){let f,u,l;c<16?(f=ve(o,s,i),u=c,l=[7,12,17,22]):c<32?(f=ve(i,o,s),u=(5*c+1)%16,l=[5,9,14,20]):c<48?(f=o^s^i,u=(3*c+5)%16,l=[4,11,16,23]):(f=s^(o|~i),u=7*c%16,l=[6,10,15,21]),f=f+r+As[c]+Ae[u],r=i,i=s,s=o,o=o+Tt(f,l[c%4])}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,this.set(r,o,s,i)}roundClean(){ot(Ae)}destroy(){this.set(0,0,0,0),ot(this.buffer)}}const Bs=Gt(()=>new tr),Hs=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),er=Uint8Array.from(new Array(16).fill(0).map((e,t)=>t)),_s=er.map(e=>(9*e+5)%16),nr=(()=>{const n=[[er],[_s]];for(let r=0;r<4;r++)for(let o of n)o.push(o[r].map(s=>Hs[s]));return n})(),rr=nr[0],sr=nr[1],or=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(e=>Uint8Array.from(e)),Ss=rr.map((e,t)=>e.map(n=>or[t][n])),vs=sr.map((e,t)=>e.map(n=>or[t][n])),Is=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),Ls=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function wn(e,t,n,r){return e===0?t^n^r:e===1?t&n|~t&r:e===2?(t|~n)^r:e===3?t&r|n&~r:t^(n|~r)}const ne=new Uint32Array(16);class ir extends de{h0=1732584193;h1=-271733879;h2=-1732584194;h3=271733878;h4=-1009589776;constructor(){super(64,20,8,!0)}get(){const{h0:t,h1:n,h2:r,h3:o,h4:s}=this;return[t,n,r,o,s]}set(t,n,r,o,s){this.h0=t|0,this.h1=n|0,this.h2=r|0,this.h3=o|0,this.h4=s|0}process(t,n){for(let g=0;g<16;g++,n+=4)ne[g]=t.getUint32(n,!0);let r=this.h0|0,o=r,s=this.h1|0,i=s,c=this.h2|0,f=c,u=this.h3|0,l=u,h=this.h4|0,p=h;for(let g=0;g<5;g++){const w=4-g,I=Is[g],_=Ls[g],B=rr[g],O=sr[g],m=Ss[g],k=vs[g];for(let R=0;R<16;R++){const C=Tt(r+wn(g,s,c,u)+ne[B[R]]+I,m[R])+h|0;r=h,h=u,u=Tt(c,10)|0,c=s,s=C}for(let R=0;R<16;R++){const C=Tt(o+wn(w,i,f,l)+ne[O[R]]+_,k[R])+p|0;o=p,p=l,l=Tt(f,10)|0,f=i,i=C}}this.set(this.h1+c+l|0,this.h2+u+p|0,this.h3+h+o|0,this.h4+r+i|0,this.h0+s+f|0)}roundClean(){ot(ne)}destroy(){this.destroyed=!0,ot(this.buffer),this.set(0,0,0,0,0)}}const cr=Gt(()=>new ir),xo=Object.freeze(Object.defineProperty({__proto__:null,_MD5:tr,_RIPEMD160:ir,md5:Bs,ripemd160:cr},Symbol.toStringTag,{value:"Module"}));function Ft(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function fr(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(n=>typeof n=="string"):t.every(n=>Number.isSafeInteger(n)):!1}function ar(e){if(typeof e!="function")throw new Error("function expected");return!0}function jt(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function $t(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function fe(e){if(!Array.isArray(e))throw new Error("array expected")}function ur(e,t){if(!fr(!0,t))throw new Error(`${e}: array of strings expected`)}function Ze(e,t){if(!fr(!1,t))throw new Error(`${e}: array of numbers expected`)}function Fe(...e){const t=s=>s,n=(s,i)=>c=>s(i(c)),r=e.map(s=>s.encode).reduceRight(n,t),o=e.map(s=>s.decode).reduce(n,t);return{encode:r,decode:o}}function hr(e){const t=typeof e=="string"?e.split(""):e,n=t.length;ur("alphabet",t);const r=new Map(t.map((o,s)=>[o,s]));return{encode:o=>(fe(o),o.map(s=>{if(!Number.isSafeInteger(s)||s<0||s>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${e}`);return t[s]})),decode:o=>(fe(o),o.map(s=>{jt("alphabet.decode",s);const i=r.get(s);if(i===void 0)throw new Error(`Unknown letter: "${s}". Allowed: ${e}`);return i}))}}function dr(e=""){return jt("join",e),{encode:t=>(ur("join.decode",t),t.join(e)),decode:t=>(jt("join.decode",t),t.split(e))}}function yn(e,t,n){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(fe(e),!e.length)return[];let r=0;const o=[],s=Array.from(e,c=>{if($t(c),c<0||c>=t)throw new Error(`invalid integer: ${c}`);return c}),i=s.length;for(;;){let c=0,f=!0;for(let u=r;u<i;u++){const l=s[u],h=t*c,p=h+l;if(!Number.isSafeInteger(p)||h/t!==c||p-l!==h)throw new Error("convertRadix: carry overflow");const g=p/n;c=p%n;const w=Math.floor(g);if(s[u]=w,!Number.isSafeInteger(w)||w*n+c!==p)throw new Error("convertRadix: carry overflow");if(f)w?f=!1:r=u;else continue}if(o.push(c),f)break}for(let c=0;c<e.length-1&&e[c]===0;c++)o.push(0);return o.reverse()}const lr=(e,t)=>t===0?e:lr(t,e%t),ae=(e,t)=>e+(t-lr(e,t)),oe=(()=>{let e=[];for(let t=0;t<40;t++)e.push(2**t);return e})();function ke(e,t,n,r){if(fe(e),t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(ae(t,n)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${ae(t,n)}`);let o=0,s=0;const i=oe[t],c=oe[n]-1,f=[];for(const u of e){if($t(u),u>=i)throw new Error(`convertRadix2: invalid data word=${u} from=${t}`);if(o=o<<t|u,s+t>32)throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);for(s+=t;s>=n;s-=n)f.push((o>>s-n&c)>>>0);const l=oe[s];if(l===void 0)throw new Error("invalid carry");o&=l-1}if(o=o<<n-s&c,!r&&s>=t)throw new Error("Excess padding");if(!r&&o>0)throw new Error(`Non-zero padding: ${o}`);return r&&s>0&&f.push(o>>>0),f}function Rs(e){$t(e);const t=2**8;return{encode:n=>{if(!Ft(n))throw new Error("radix.encode input should be Uint8Array");return yn(Array.from(n),t,e)},decode:n=>(Ze("radix.decode",n),Uint8Array.from(yn(n,e,t)))}}function Us(e,t=!1){if($t(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(ae(8,e)>32||ae(e,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!Ft(n))throw new Error("radix2.encode input should be Uint8Array");return ke(Array.from(n),8,e,!t)},decode:n=>(Ze("radix2.decode",n),Uint8Array.from(ke(n,e,8,t)))}}function xn(e){return ar(e),function(...t){try{return e.apply(null,t)}catch{}}}function Os(e,t){return $t(e),ar(t),{encode(n){if(!Ft(n))throw new Error("checksum.encode: input should be Uint8Array");const r=t(n).slice(0,e),o=new Uint8Array(n.length+e);return o.set(n),o.set(r,n.length),o},decode(n){if(!Ft(n))throw new Error("checksum.decode: input should be Uint8Array");const r=n.slice(0,-e),o=n.slice(-e),s=t(r).slice(0,e);for(let i=0;i<e;i++)if(s[i]!==o[i])throw new Error("Invalid checksum");return r}}}const ks=e=>Fe(Rs(58),hr(e),dr("")),Vs=ks("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),br=e=>Fe(Os(4,t=>e(e(t))),Vs),po=br,Ve=Fe(hr("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),dr("")),pn=[996825010,642813549,513874426,1027748829,705979059];function kt(e){const t=e>>25;let n=(e&33554431)<<5;for(let r=0;r<pn.length;r++)(t>>r&1)===1&&(n^=pn[r]);return n}function gn(e,t,n=1){const r=e.length;let o=1;for(let s=0;s<r;s++){const i=e.charCodeAt(s);if(i<33||i>126)throw new Error(`Invalid prefix (${e})`);o=kt(o)^i>>5}o=kt(o);for(let s=0;s<r;s++)o=kt(o)^e.charCodeAt(s)&31;for(let s of t)o=kt(o)^s;for(let s=0;s<6;s++)o=kt(o);return o^=n,Ve.encode(ke([o%oe[30]],30,5,!1))}function wr(e){const t=e==="bech32"?1:734539939,n=Us(5),r=n.decode,o=n.encode,s=xn(r);function i(h,p,g=90){jt("bech32.encode prefix",h),Ft(p)&&(p=Array.from(p)),Ze("bech32.encode",p);const w=h.length;if(w===0)throw new TypeError(`Invalid prefix length ${w}`);const I=w+7+p.length;if(g!==!1&&I>g)throw new TypeError(`Length ${I} exceeds limit ${g}`);const _=h.toLowerCase(),B=gn(_,p,t);return`${_}1${Ve.encode(p)}${B}`}function c(h,p=90){jt("bech32.decode input",h);const g=h.length;if(g<8||p!==!1&&g>p)throw new TypeError(`invalid string length: ${g} (${h}). Expected (8..${p})`);const w=h.toLowerCase();if(h!==w&&h!==h.toUpperCase())throw new Error("String must be lowercase or uppercase");const I=w.lastIndexOf("1");if(I===0||I===-1)throw new Error('Letter "1" must be present between prefix and data only');const _=w.slice(0,I),B=w.slice(I+1);if(B.length<6)throw new Error("Data must be at least 6 characters long");const O=Ve.decode(B).slice(0,-6),m=gn(_,O,t);if(!B.endsWith(m))throw new Error(`Invalid checksum in ${h}: expected "${m}"`);return{prefix:_,words:O}}const f=xn(c);function u(h){const{prefix:p,words:g}=c(h,!1);return{prefix:p,words:g,bytes:r(g)}}function l(h,p){return i(h,o(p))}return{encode:i,decode:c,encodeFromBytes:l,decodeToBytes:u,decodeUnsafe:f,fromWords:r,fromWordsUnsafe:s,toWords:o}}const go=wr("bech32"),mo=wr("bech32m");const Dt=_t.Point,{Fn:Vt}=Dt,Be=br(le),Cs=Uint8Array.from("Bitcoin seed".split(""),e=>e.charCodeAt(0)),He={private:76066276,public:76067358},_e=2147483648,Ts=e=>cr(le(e)),Ds=e=>Et(e).getUint32(0,!1),re=e=>{if(!Number.isSafeInteger(e)||e<0||e>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+e);const t=new Uint8Array(4);return Et(t).setUint32(0,e,!1),t};class St{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Ds(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const t=this._privateKey;if(!t)throw new Error("No private key");return Be.encode(this.serialize(this.versions.private,rt(Uint8Array.of(0),t)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return Be.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(t,n=He){if(Z(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const r=Zt(qt,Cs,t),o=r.slice(0,32),s=r.slice(32);return new St({versions:n,chainCode:s,privateKey:o})}static fromExtendedKey(t,n=He){const r=Be.decode(t),o=Et(r),s=o.getUint32(0,!1),i={versions:n,depth:r[4],parentFingerprint:o.getUint32(5,!1),index:o.getUint32(9,!1),chainCode:r.slice(13,45)},c=r.slice(45),f=c[0]===0;if(s!==n[f?"private":"public"])throw new Error("Version mismatch");return f?new St({...i,privateKey:c.slice(1)}):new St({...i,publicKey:c})}static fromJSON(t){return St.fromExtendedKey(t.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(t){if(!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||He,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!_t.utils.isValidSecretKey(t.privateKey))throw new Error("Invalid private key");this._privateKey=t.privateKey,this._publicKey=_t.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this._publicKey=Dt.fromBytes(t.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=Ts(this._publicKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const n=t.replace(/^[mM]'?\//,"").split("/");let r=this;for(const o of n){const s=/^(\d+)('?)$/.exec(o),i=s&&s[1];if(!s||s.length!==3||typeof i!="string")throw new Error("invalid child index: "+o);let c=+i;if(!Number.isSafeInteger(c)||c>=_e)throw new Error("Invalid index");s[2]==="'"&&(c+=_e),r=r.deriveChild(c)}return r}deriveChild(t){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let n=re(t);if(t>=_e){const f=this._privateKey;if(!f)throw new Error("Could not derive hardened child key");n=rt(Uint8Array.of(0),f,n)}else n=rt(this._publicKey,n);const r=Zt(qt,this.chainCode,n),o=r.slice(0,32),s=r.slice(32);if(!_t.utils.isValidSecretKey(o))throw new Error("Tweak bigger than curve order");const i={versions:this.versions,chainCode:s,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t},c=Vt.fromBytes(o);try{if(this._privateKey){const f=Vt.create(Vt.fromBytes(this._privateKey)+c);if(!Vt.isValidNot0(f))throw new Error("The tweak was out of range or the resulted private key is invalid");i.privateKey=Vt.toBytes(f)}else{const f=Dt.fromBytes(this._publicKey).add(Dt.BASE.multiply(c));if(f.equals(Dt.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");i.publicKey=f.toBytes(!0)}return new St(i)}catch{return this.deriveChild(t+1)}}sign(t){if(!this._privateKey)throw new Error("No privateKey set!");return Z(t,32),_t.sign(t,this._privateKey,{prehash:!1})}verify(t,n){if(Z(t,32),Z(n,64),!this._publicKey)throw new Error("No publicKey set!");return _t.verify(n,t,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,n){if(!this.chainCode)throw new Error("No chainCode set");return Z(n,33),rt(re(t),new Uint8Array([this.depth]),re(this.parentFingerprint),re(this.index),this.chainCode,n)}}function Ks(e,t,n,r){Ce(e);const o=Ur({dkLen:32,asyncTick:10},r),{c:s,dkLen:i,asyncTick:c}=o;if(it(s,"c"),it(i,"dkLen"),it(c,"asyncTick"),s<1)throw new Error("iterations (c) must be >= 1");const f=rn(t,"password"),u=rn(n,"salt"),l=new Uint8Array(i),h=Zt.create(e,f),p=h._cloneInto().update(u);return{c:s,dkLen:i,asyncTick:c,DK:l,PRF:h,PRFSalt:p}}function Ns(e,t,n,r,o){return e.destroy(),t.destroy(),r&&r.destroy(),ot(o),n}function qs(e,t,n,r){const{c:o,dkLen:s,DK:i,PRF:c,PRFSalt:f}=Ks(e,t,n,r);let u;const l=new Uint8Array(4),h=Et(l),p=new Uint8Array(c.outputLen);for(let g=1,w=0;w<s;g++,w+=c.outputLen){const I=i.subarray(w,w+c.outputLen);h.setInt32(0,g,!1),(u=f._cloneInto(u)).update(l).digestInto(p),I.set(p.subarray(0,I.length));for(let _=1;_<o;_++){c._cloneInto(u).update(p).digestInto(p);for(let B=0;B<I.length;B++)I[B]^=p[B]}}return Ns(c,f,i,u,p)}function yr(e){if(typeof e!="string")throw new TypeError("invalid mnemonic type: "+typeof e);return e.normalize("NFKD")}function Ms(e){const t=yr(e),n=t.split(" ");if(![12,15,18,21,24].includes(n.length))throw new Error("Invalid mnemonic");return{nfkd:t,words:n}}const Zs=e=>yr("mnemonic"+e);function Eo(e,t=""){return qs(qt,Ms(e).nfkd,Zs(t),{c:2048,dkLen:64})}const Fs=BigInt(0),Ct=BigInt(1),js=BigInt(2),Ys=BigInt(7),Gs=BigInt(256),Xs=BigInt(113),xr=[],pr=[],gr=[];for(let e=0,t=Ct,n=1,r=0;e<24;e++){[n,r]=[r,(2*n+3*r)%5],xr.push(2*(5*r+n)),pr.push((e+1)*(e+2)/2%64);let o=Fs;for(let s=0;s<7;s++)t=(t<<Ct^(t>>Ys)*Xs)%Gs,t&js&&(o^=Ct<<(Ct<<BigInt(s))-Ct);gr.push(o)}const mr=In(gr,!0),$s=mr[0],Ws=mr[1],mn=(e,t,n)=>n>32?Tr(e,t,n):Vr(e,t,n),En=(e,t,n)=>n>32?Dr(e,t,n):Cr(e,t,n);function zs(e,t=24){const n=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let i=0;i<10;i++)n[i]=e[i]^e[i+10]^e[i+20]^e[i+30]^e[i+40];for(let i=0;i<10;i+=2){const c=(i+8)%10,f=(i+2)%10,u=n[f],l=n[f+1],h=mn(u,l,1)^n[c],p=En(u,l,1)^n[c+1];for(let g=0;g<50;g+=10)e[i+g]^=h,e[i+g+1]^=p}let o=e[2],s=e[3];for(let i=0;i<24;i++){const c=pr[i],f=mn(o,s,c),u=En(o,s,c),l=xr[i];o=e[l],s=e[l+1],e[l]=f,e[l+1]=u}for(let i=0;i<50;i+=10){for(let c=0;c<10;c++)n[c]=e[i+c];for(let c=0;c<10;c++)e[i+c]^=~n[(c+2)%10]&n[(c+4)%10]}e[0]^=$s[r],e[1]^=Ws[r]}ot(n)}class je{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(t,n,r,o=!1,s=24){if(this.blockLen=t,this.suffix=n,this.outputLen=r,this.enableXOF=o,this.rounds=s,it(r,"outputLen"),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=_r(this.state)}clone(){return this._cloneInto()}keccak(){en(this.state32),zs(this.state32,this.rounds),en(this.state32),this.posOut=0,this.pos=0}update(t){It(this),Z(t);const{blockLen:n,state:r}=this,o=t.length;for(let s=0;s<o;){const i=Math.min(n-this.pos,o-s);for(let c=0;c<i;c++)r[this.pos++]^=t[s++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:r,blockLen:o}=this;t[r]^=n,(n&128)!==0&&r===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){It(this,!1),Z(t),this.finish();const n=this.state,{blockLen:r}=this;for(let o=0,s=t.length;o<s;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,s-o);t.set(n.subarray(this.posOut,this.posOut+i),o),this.posOut+=i,o+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return it(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(_n(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,ot(this.state)}_cloneInto(t){const{blockLen:n,suffix:r,outputLen:o,rounds:s,enableXOF:i}=this;return t||=new je(n,r,o,i,s),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=r,t.outputLen=o,t.enableXOF=i,t.destroyed=this.destroyed,t}}const Ps=(e,t,n,r={})=>Gt(()=>new je(t,e,n),r),Ao=Ps(1,136,32);const xt=BigInt(0),J=BigInt(1),Se=BigInt(2),Js=BigInt(8);function Qs(e,t,n,r){const o=e.sqr(n),s=e.sqr(r),i=e.add(e.mul(t.a,o),s),c=e.add(e.ONE,e.mul(t.d,e.mul(o,s)));return e.eql(i,c)}function to(e,t={}){const n=$n("edwards",e,t,t.FpFnLE),{Fp:r,Fn:o}=n;let s=n.CURVE;const{h:i}=s;Xt(t,{},{uvRatio:"function"});const c=Se<<BigInt(o.BYTES*8)-J,f=_=>r.create(_),u=t.uvRatio||((_,B)=>{try{return{isValid:!0,value:r.sqrt(r.div(_,B))}}catch{return{isValid:!1,value:xt}}});if(!Qs(r,s,s.Gx,s.Gy))throw new Error("bad curve params: generator point");function l(_,B,O=!1){const m=O?J:xt;return Re("coordinate "+_,B,m,c),B}function h(_){if(!(_ instanceof w))throw new Error("EdwardsPoint expected")}const p=ie((_,B)=>{const{X:O,Y:m,Z:k}=_,R=_.is0();B==null&&(B=R?Js:r.inv(k));const C=f(O*B),K=f(m*B),S=r.mul(k,B);if(R)return{x:xt,y:J};if(S!==J)throw new Error("invZ was invalid");return{x:C,y:K}}),g=ie(_=>{const{a:B,d:O}=s;if(_.is0())throw new Error("bad point: ZERO");const{X:m,Y:k,Z:R,T:C}=_,K=f(m*m),S=f(k*k),d=f(R*R),A=f(d*d),H=f(K*B),U=f(d*f(H+S)),b=f(A+f(O*f(K*S)));if(U!==b)throw new Error("bad point: equation left != right (1)");const y=f(m*k),x=f(R*C);if(y!==x)throw new Error("bad point: equation left != right (2)");return!0});class w{static BASE=new w(s.Gx,s.Gy,J,f(s.Gx*s.Gy));static ZERO=new w(xt,J,J,xt);static Fp=r;static Fn=o;X;Y;Z;T;constructor(B,O,m,k){this.X=l("x",B),this.Y=l("y",O),this.Z=l("z",m,!0),this.T=l("t",k),Object.freeze(this)}static CURVE(){return s}static fromAffine(B){if(B instanceof w)throw new Error("extended point not allowed");const{x:O,y:m}=B||{};return l("x",O),l("y",m),new w(O,m,J,f(O*m))}static fromBytes(B,O=!1){const m=r.BYTES,{a:k,d:R}=s;B=Le(Z(B,m,"point")),At(O,"zip215");const C=Le(B),K=B[m-1];C[m-1]=K&-129;const S=Mt(C),d=O?c:r.ORDER;Re("point.y",S,xt,d);const A=f(S*S),H=f(A-J),U=f(R*A-k);let{isValid:b,value:y}=u(H,U);if(!b)throw new Error("bad point: invalid y coordinate");const x=(y&J)===J,L=(K&128)!==0;if(!O&&y===xt&&L)throw new Error("bad point: x=0 and x_0=1");return L!==x&&(y=f(-y)),w.fromAffine({x:y,y:S})}static fromHex(B,O=!1){return w.fromBytes(Nt(B),O)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(B=8,O=!0){return I.createCache(this,B),O||this.multiply(Se),this}assertValidity(){g(this)}equals(B){h(B);const{X:O,Y:m,Z:k}=this,{X:R,Y:C,Z:K}=B,S=f(O*K),d=f(R*k),A=f(m*K),H=f(C*k);return S===d&&A===H}is0(){return this.equals(w.ZERO)}negate(){return new w(f(-this.X),this.Y,this.Z,f(-this.T))}double(){const{a:B}=s,{X:O,Y:m,Z:k}=this,R=f(O*O),C=f(m*m),K=f(Se*f(k*k)),S=f(B*R),d=O+m,A=f(f(d*d)-R-C),H=S+C,U=H-K,b=S-C,y=f(A*U),x=f(H*b),L=f(A*b),V=f(U*H);return new w(y,x,V,L)}add(B){h(B);const{a:O,d:m}=s,{X:k,Y:R,Z:C,T:K}=this,{X:S,Y:d,Z:A,T:H}=B,U=f(k*S),b=f(R*d),y=f(K*m*H),x=f(C*A),L=f((k+R)*(S+d)-U-b),V=x-y,D=x+y,a=f(b-O*U),E=f(L*V),v=f(D*a),T=f(L*a),N=f(V*D);return new w(E,v,N,T)}subtract(B){return this.add(B.negate())}multiply(B){if(!o.isValidNot0(B))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:O,f:m}=I.cached(this,B,k=>Kt(w,k));return Kt(w,[O,m])[0]}multiplyUnsafe(B,O=w.ZERO){if(!o.isValid(B))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return B===xt?w.ZERO:this.is0()||B===J?this:I.unsafe(this,B,m=>Kt(w,m),O)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return I.unsafe(this,s.n).is0()}toAffine(B){return p(this,B)}clearCofactor(){return i===J?this:this.multiplyUnsafe(i)}toBytes(){const{x:B,y:O}=this.toAffine(),m=r.toBytes(O);return m[m.length-1]|=B&J?128:0,m}toHex(){return Yt(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const I=new Xn(w,o.BITS);return w.BASE.precompute(8),w}function eo(e,t,n={}){if(typeof t!="function")throw new Error('"hash" function param is required');Xt(n,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=n,{BASE:o,Fp:s,Fn:i}=e,c=n.randomBytes||Te,f=n.adjustScalarBytes||(S=>S),u=n.domain||((S,d,A)=>{if(At(A,"phflag"),d.length||A)throw new Error("Contexts/pre-hash are not supported");return S});function l(S){return i.create(Mt(S))}function h(S){const d=m.secretKey;Z(S,m.secretKey,"secretKey");const A=Z(t(S),2*d,"hashedSecretKey"),H=f(A.slice(0,d)),U=A.slice(d,2*d),b=l(H);return{head:H,prefix:U,scalar:b}}function p(S){const{head:d,prefix:A,scalar:H}=h(S),U=o.multiply(H),b=U.toBytes();return{head:d,prefix:A,scalar:H,point:U,pointBytes:b}}function g(S){return p(S).pointBytes}function w(S=Uint8Array.of(),...d){const A=rt(...d);return l(t(u(A,Z(S,void 0,"context"),!!r)))}function I(S,d,A={}){S=Z(S,void 0,"message"),r&&(S=r(S));const{prefix:H,scalar:U,pointBytes:b}=p(d),y=w(A.context,H,S),x=o.multiply(y).toBytes(),L=w(A.context,x,b,S),V=i.create(y+L*U);if(!i.isValid(V))throw new Error("sign failed: invalid s");const D=rt(x,i.toBytes(V));return Z(D,m.signature,"result")}const _={zip215:!0};function B(S,d,A,H=_){const{context:U,zip215:b}=H,y=m.signature;S=Z(S,y,"signature"),d=Z(d,void 0,"message"),A=Z(A,m.publicKey,"publicKey"),b!==void 0&&At(b,"zip215"),r&&(d=r(d));const x=y/2,L=S.subarray(0,x),V=Mt(S.subarray(x,y));let D,a,E;try{D=e.fromBytes(A,b),a=e.fromBytes(L,b),E=o.multiplyUnsafe(V)}catch{return!1}if(!b&&D.isSmallOrder())return!1;const v=w(U,a.toBytes(),D.toBytes(),d);return a.add(D.multiplyUnsafe(v)).subtract(E).clearCofactor().is0()}const O=s.BYTES,m={secretKey:O,publicKey:O,signature:2*O,seed:O};function k(S=c(m.seed)){return Z(S,m.seed,"seed")}function R(S){return he(S)&&S.length===i.BYTES}function C(S,d){try{return!!e.fromBytes(S,d)}catch{return!1}}const K={getExtendedPublicKey:p,randomSecretKey:k,isValidSecretKey:R,isValidPublicKey:C,toMontgomery(S){const{y:d}=e.fromBytes(S),A=m.publicKey,H=A===32;if(!H&&A!==57)throw new Error("only defined for 25519 and 448");const U=H?s.div(J+d,J-d):s.div(d-J,d+J);return s.toBytes(U)},toMontgomerySecret(S){const d=m.secretKey;Z(S,d);const A=t(S.subarray(0,d));return f(A).subarray(0,d)}};return Object.freeze({keygen:Wn(k,g),getPublicKey:g,sign:I,verify:B,utils:K,Point:e,lengths:m})}const no=BigInt(1),An=BigInt(2),ro=BigInt(5),so=BigInt(8),Ye=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),oo={p:Ye,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:so,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function io(e){const t=BigInt(10),n=BigInt(20),r=BigInt(40),o=BigInt(80),s=Ye,c=e*e%s*e%s,f=$(c,An,s)*c%s,u=$(f,no,s)*e%s,l=$(u,ro,s)*u%s,h=$(l,t,s)*l%s,p=$(h,n,s)*h%s,g=$(p,r,s)*p%s,w=$(g,o,s)*g%s,I=$(w,o,s)*g%s,_=$(I,t,s)*l%s;return{pow_p_5_8:$(_,An,s)*e%s,b2:c}}function co(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const Bn=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function fo(e,t){const n=Ye,r=z(t*t*t,n),o=z(r*r*t,n),s=io(e*o).pow_p_5_8;let i=z(e*r*s,n);const c=z(t*i*i,n),f=i,u=z(i*Bn,n),l=c===e,h=c===z(-e,n),p=c===z(-e*Bn,n);return l&&(i=f),(h||p)&&(i=u),rs(i,n)&&(i=z(-i,n)),{isValid:l||h,value:i}}const ao=to(oo,{uvRatio:fo});function uo(e){return eo(ao,qt,Object.assign({adjustScalarBytes:co},e))}const Bo=uo({});export{St as H,bo as a,lo as b,ue as c,Yt as d,cr as e,_t as f,ho as g,Bo as h,Nt as i,po as j,Ao as k,go as l,Eo as m,mo as n,yo as o,xo as p,wo as r,le as s};
