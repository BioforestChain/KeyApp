import{g as L}from"./address-CwlnRuVT.js";import{a as v,$ as B,g as N}from"./signature-MTDex1F4.js";import{B as f}from"./polyfills-BATEtbik.js";import{b as d}from"./bridge-DyWekW1m.js";import{b as H,c as K,d as P,f as U,g as $,a as q}from"./noop-ChEnm3CV.js";async function b(e,t,n,o){return d("bio_requestCryptoToken",{actions:e,duration:t,address:n,chainId:o})}async function g(e,t){return d("bio_getCryptoTokenInfo",{tokenId:e,sessionSecret:t})}async function A(e,t,n,o){return d("bio_cryptoExecute",{tokenId:e,sessionSecret:t,action:"asymmetricEncrypt",params:{data:n,recipientPublicKey:o}})}const u="bio_crypto_token_cache";function w(){try{const e=localStorage.getItem(u);return e?JSON.parse(e):null}catch{return null}}function x(e){localStorage.setItem(u,JSON.stringify(e))}function E(){localStorage.removeItem(u)}function T(e){if(typeof e=="string")return e;if(e&&typeof e=="object"&&"type"in e&&"data"in e){const t=e;if(t.type==="Buffer"&&Array.isArray(t.data))return f.from(t.data).toString("hex")}if(Array.isArray(e)||e instanceof Uint8Array)return f.from(e).toString("hex");if(f.isBuffer(e))return e.toString("hex");throw new Error(`Invalid input format: ${typeof e}`)}async function k(e){const t=T(e),n=["bfmeta","bfchainv2","bioforest","bfmchain","bfchain"],o=await d("bio_requestAccounts",{chain:"bfmeta"});if(!o||o.length===0)throw new Error("No accounts available");const s=o.find(r=>{const y=r.chain.toLowerCase();return n.includes(y)});if(!s){const r=o.map(y=>y.chain).join(", ");throw new Error(`BFMeta account not found. Available chains: ${r}`)}let c,i;const a=w();if(a&&a.address===s.address&&a.expiresAt>Date.now())try{const r=await g(a.tokenId,a.sessionSecret);r.valid&&r.address===s.address&&(c=a.tokenId,i=a.sessionSecret)}catch{}if(!c||!i){E();const r=await b(["asymmetricEncrypt"],"1day",s.address,s.chain);c=r.tokenId,i=r.sessionSecret,x({tokenId:c,sessionSecret:i,address:r.address,expiresAt:r.expiresAt})}const m=Date.now().toString(),{result:p,publicKey:l,address:h}=await A(c,i,m,t);return{address:h,publicKey:f.from(l,"hex"),signcode:f.from(p,"hex")}}export{v as $WALLET_PLAOC_PATH,B as $WALLET_SIGNATURE_TYPE,H as appVersionUpdate,A as asymmetricEncrypt,K as canOpenUrl,P as dwebAppConfig,U as focusWindow,$ as getDwebAppDownUrl,N as getExternalAppData,L as getWalleterAddresss,q as gotoDwebAppMarketDownLoad,b as requestCryptoToken,k as rwaLogin};
