import{c as u,v as I,g as l,b as ne,w as we,a as k,d as be,e as Se,f as Y,i as ve,h as b,j as se}from"./WASMInterface-CIe9o4E6.js";import{a as qt,c as Wt}from"./hmac-CMC3_Bam.js";import{a as Yt,c as _t,k as Gt}from"./keccak-btzTVROz.js";import{p as _}from"./pbkdf2-CsemIPQR.js";import{a as Qt}from"./pbkdf2-CsemIPQR.js";import{a as tr,c as rr,p as ar,r as nr}from"./ripemd160-DL6wvOUv.js";import{a as me,c as Ae}from"./sha256-ee5_68YR.js";import{p as ir,s as cr}from"./sha256-ee5_68YR.js";import{a as ur,c as dr,p as lr,s as yr}from"./sha1-DJ3V1sdw.js";import{c as pr,a as fr,g as gr,s as wr}from"./sha3-DdZOXJgg.js";import{a as Sr,c as vr,p as mr,s as Ar}from"./sha512-DZTP63bZ.js";import"./page-BL_iZuG4.js";import"./index-15D1tlVU.js";import"./polyfills-BATEtbik.js";import"./bioforestChainBundle-CAVzb9HK.js";const $=u("adler32",4),st=async e=>(await $()).calculate(e),it=async()=>xe(await $()),xe=(e=$.wasm)=>{e.init();const r={init:()=>(e.init(),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:4,digestSize:4};return r},G=new Map,H=e=>{I(e,512);const r=e/8;let t=G.get(r);return t===void 0&&(t=u("blake2b",r),G.set(r,t)),t},ie=(e,r)=>{let t,a=e;if(r!==void 0){if(t=l(r),t.length>64)throw new Error("Max key length is 64 bytes");a=ne(e,t.length)}return{keyBuffer:t,initParam:a}},ct=async(e,r=512,t)=>{const a=await H(r)(),{keyBuffer:n,initParam:s}=ie(r,t);return s>512&&a.writeMemory(n),a.calculate(e,s)},z=async(e=512,r)=>Ee(e,r,await H(e)()),Ee=(e=512,r,t=H(e).wasm)=>{const{keyBuffer:a,initParam:n}=ie(e,r),s=e/8;n>512&&t.writeMemory(a),t.init(n);const c={init:n>512?()=>(t.writeMemory(a),t.init(n),c):()=>(t.init(n),c),update:i=>(t.update(i),c),digest:i=>t.digest(i),save:()=>t.save(),load:i=>(t.load(i),c),blockSize:128,digestSize:s};return c},Me=u("argon2",1024);function ze(e,r,t){const a=[`m=${r.memorySize}`,`t=${r.iterations}`,`p=${r.parallelism}`].join(",");return`$argon2${r.hashType}$v=19$${a}$${Y(e,!1)}$${Y(t,!1)}`}const J=new DataView(new ArrayBuffer(4));function p(e){return J.setInt32(0,e,!0),new Uint8Array(J.buffer)}async function M(e,r,t){if(t<=64){const o=await z(t*8);return o.update(p(t)),o.update(r),o.digest("binary")}const a=Math.ceil(t/32)-2,n=new Uint8Array(t);e.init(),e.update(p(t)),e.update(r);let s=e.digest("binary");n.set(s.subarray(0,32),0);for(let o=1;o<a;o++)e.init(),e.update(s),s=e.digest("binary"),n.set(s.subarray(0,32),o*32);const c=t-32*a;let i;return c===64?(i=e,i.init()):i=await z(c*8),i.update(s),s=i.digest("binary"),n.set(s.subarray(0,c),a*32),n}function Ie(e){switch(e){case"d":return 0;case"i":return 1;default:return 2}}async function v(e){const{parallelism:r,iterations:t,hashLength:a}=e,n=l(e.password),s=l(e.salt),c=19,i=Ie(e.hashType),{memorySize:o}=e,[y,d]=await Promise.all([await Me(),z(512)]);y.setMemorySize(o*1024+1024);const f=new Uint8Array(24),h=new DataView(f.buffer);h.setInt32(0,r,!0),h.setInt32(4,a,!0),h.setInt32(8,o,!0),h.setInt32(12,t,!0),h.setInt32(16,c,!0),h.setInt32(20,i,!0),y.writeMemory(f,o*1024),d.init(),d.update(f),d.update(p(n.length)),d.update(n),d.update(p(s.length)),d.update(s),d.update(p(0)),d.update(p(0));const fe=Math.floor(o/(r*4))*4,g=new Uint8Array(72),ge=d.digest("binary");g.set(ge);for(let w=0;w<r;w++){g.set(p(0),64),g.set(p(w),68);let x=w*fe,E=await M(d,g,1024);y.writeMemory(E,x*1024),x+=1,g.set(p(1),64),E=await M(d,g,1024),y.writeMemory(E,x*1024)}const Z=new Uint8Array(1024);we(Z,y.calculate(new Uint8Array([]),o));const A=await M(d,Z,a);if(e.outputType==="hex"){const w=new Uint8Array(a*2);return k(w,A,a)}return e.outputType==="encoded"?ze(s,e,A):A}const m=e=>{if(!e||typeof e!="object")throw new Error("Invalid options parameter. It requires an object.");if(!e.password)throw new Error("Password must be specified");if(e.password=l(e.password),e.password.length<1)throw new Error("Password must be specified");if(!e.salt)throw new Error("Salt must be specified");if(e.salt=l(e.salt),e.salt.length<8)throw new Error("Salt should be at least 8 bytes long");if(!Number.isInteger(e.iterations)||e.iterations<1)throw new Error("Iterations should be a positive number");if(!Number.isInteger(e.parallelism)||e.parallelism<1)throw new Error("Parallelism should be a positive number");if(!Number.isInteger(e.hashLength)||e.hashLength<4)throw new Error("Hash length should be at least 4 bytes.");if(!Number.isInteger(e.memorySize))throw new Error("Memory size should be specified.");if(e.memorySize<8*e.parallelism)throw new Error("Memory size should be at least 8 * parallelism.");if(e.outputType===void 0&&(e.outputType="hex"),!["hex","binary","encoded"].includes(e.outputType))throw new Error(`Insupported output type ${e.outputType}. Valid values: ['hex', 'binary', 'encoded']`)};async function ot(e){return m(e),v({...e,hashType:"i"})}async function ut(e){return m(e),v({...e,hashType:"id"})}async function dt(e){return m(e),v({...e,hashType:"d"})}const ke=(e,r)=>{const t=/^\$argon2(id|i|d)\$v=([0-9]+)\$((?:[mtp]=[0-9]+,){2}[mtp]=[0-9]+)\$([A-Za-z0-9+/]+)\$([A-Za-z0-9+/]+)$/,a=r.match(t);if(!a)throw new Error("Invalid hash");const[,n,s,c,i,o]=a;if(s!=="19")throw new Error(`Unsupported version: ${s}`);const y={},d={m:"memorySize",p:"parallelism",t:"iterations"};return c.split(",").forEach(f=>{const[h,W]=f.split("=");y[d[h]]=parseInt(W,10)}),{...y,password:e,hashType:n,salt:Se(i),hashLength:be(o),outputType:"encoded"}},$e=e=>{if(!e||typeof e!="object")throw new Error("Invalid options parameter. It requires an object.");if(e.hash===void 0||typeof e.hash!="string")throw new Error("Hash should be specified")};async function lt(e){$e(e);const r=ke(e.password,e.hash);m(r);const t=e.hash.lastIndexOf("$")+1;return(await v(r)).substring(t)===e.hash.substring(t)}const ce=u("bcrypt",0);async function He(e){const{costFactor:r,password:t,salt:a}=e,n=await ce();n.writeMemory(l(a),0);const s=l(t);n.writeMemory(s,16);const c=e.outputType==="encoded"?1:0;n.getExports().bcrypt(s.length,r,c);const i=n.getMemory();if(e.outputType==="encoded")return ve(i,60);if(e.outputType==="hex"){const o=new Uint8Array(48);return k(o,i,24)}return i.slice(0,24)}const Be=e=>{if(!e||typeof e!="object")throw new Error("Invalid options parameter. It requires an object.");if(!Number.isInteger(e.costFactor)||e.costFactor<4||e.costFactor>31)throw new Error("Cost factor should be a number between 4 and 31");if(e.password=l(e.password),e.password.length<1)throw new Error("Password should be at least 1 byte long");if(e.password.length>72)throw new Error("Password should be at most 72 bytes long");if(e.salt=l(e.salt),e.salt.length!==16)throw new Error("Salt should be 16 bytes long");if(e.outputType===void 0&&(e.outputType="encoded"),!["hex","binary","encoded"].includes(e.outputType))throw new Error(`Insupported output type ${e.outputType}. Valid values: ['hex', 'binary', 'encoded']`)};async function yt(e){return Be(e),He(e)}const Pe=e=>!(!/^\$2[axyb]\$[0-3][0-9]\$[./A-Za-z0-9]{53}$/.test(e)||e[4]==="0"&&parseInt(e[5],10)<4||e[4]==="3"&&parseInt(e[5],10)>1),Te=e=>{if(!e||typeof e!="object")throw new Error("Invalid options parameter. It requires an object.");if(e.hash===void 0||typeof e.hash!="string")throw new Error("Hash should be specified");if(e.hash.length!==60)throw new Error("Hash should be 60 bytes long");if(!Pe(e.hash))throw new Error("Invalid hash");if(e.password=l(e.password),e.password.length<1)throw new Error("Password should be at least 1 byte long");if(e.password.length>72)throw new Error("Password should be at most 72 bytes long")};async function ht(e){Te(e);const{hash:r,password:t}=e,a=await ce();a.writeMemory(l(r),0);const n=l(t);return a.writeMemory(n,60),!!a.getExports().bcrypt_verify(n.length)}const Q=new Map,B=e=>{I(e,256);const r=e/8;let t=Q.get(r);return t===void 0&&(t=u("blake2s",r),Q.set(r,t)),t},oe=(e,r)=>{let t,a=e;if(r!==void 0){if(t=l(r),t.length>32)throw new Error("Max key length is 32 bytes");a=ne(e,t.length)}return{keyBuffer:t,initParam:a}},pt=async(e,r=256,t)=>{const a=await B(r)(),{keyBuffer:n,initParam:s}=oe(r,t);return s>512&&a.writeMemory(n),a.calculate(e,s)},ft=async(e=256,r)=>je(e,r,await B(e)()),je=(e=256,r,t=B(e).wasm)=>{const{keyBuffer:a,initParam:n}=oe(e,r),s=e/8;n>512&&t.writeMemory(a),t.init(n);const c={init:n>512?()=>(t.writeMemory(a),t.init(n),c):()=>(t.init(n),c),update:i=>(t.update(i),c),digest:i=>t.digest(i),save:()=>t.save(),load:i=>(t.load(i),c),blockSize:64,digestSize:s};return c},ee=new Map,P=e=>{I(e,1/0);const r=e/8;let t=ee.get(r);return t===void 0&&(t=u("blake3",r),ee.set(r,t)),t},ue=e=>{let r,t=0;if(e!==void 0){if(r=l(e),r.length!==32)throw new Error("Key length must be exactly 32 bytes");t=32}return{keyBuffer:r,initParam:t}},gt=async(e,r=256,t)=>{const a=await P(r)(),{keyBuffer:n,initParam:s}=ue(t);return s===32&&a.writeMemory(n),a.calculate(e,s,r/8)},wt=async(e=256,r)=>Xe(e,r,await P(e)()),Xe=(e=256,r,t=P(e).wasm)=>{const{keyBuffer:a,initParam:n}=ue(r),s=e/8;n===32&&t.writeMemory(a),t.init(n);const c={init:n===32?()=>(t.writeMemory(a),t.init(n),c):()=>(t.init(n),c),update:i=>(t.update(i),c),digest:i=>t.digest(i,s),save:()=>t.save(),load:i=>(t.load(i),c),blockSize:64,digestSize:s};return c},S=u("crc32",4),bt=async e=>(await S()).calculate(e,3988292384),St=async()=>Ce(await S()),Ce=(e=S.wasm)=>{e.init(3988292384);const r={init:()=>(e.init(3988292384),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:4,digestSize:4};return r},vt=async e=>(await S()).calculate(e,2197175160),mt=async()=>Ue(await S()),Ue=(e=S.wasm)=>{e.init(2197175160);const r={init:()=>(e.init(2197175160),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:4,digestSize:4};return r},T=u("md4",16),At=async e=>(await T()).calculate(e),xt=async()=>Ve(await T()),Ve=(e=T.wasm)=>{e.init();const r={init:()=>(e.init(),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:64,digestSize:16};return r},j=u("md5",16),Et=async e=>(await j()).calculate(e),Mt=async()=>De(await j()),De=(e=j.wasm)=>{e.init();const r={init:()=>(e.init(),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:64,digestSize:16};return r},X=u("scrypt",0),de=(e,r,t=X.wasm)=>{const{costFactor:a,blockSize:n,parallelism:s,hashLength:c}=e,i=_({password:e.password,salt:e.salt,iterations:1,hashLength:128*n*s,hashFunction:r,outputType:"binary"}),o=128*n*a,y=256*n;t.setMemorySize(i.length+o+y),t.writeMemory(i,0),t.getExports().scrypt(n,a,s);const d=t.getMemory().subarray(0,128*n*s),f=_({password:e.password,salt:d,iterations:1,hashLength:c,hashFunction:r,outputType:"binary"});if(e.outputType==="hex"){const h=new Uint8Array(c*2);return k(h,f,c)}return f},Le=e=>!!(e&&!(e&e-1)),le=e=>{if(!e||typeof e!="object")throw new Error("Invalid options parameter. It requires an object.");if(!Number.isInteger(e.blockSize)||e.blockSize<1)throw new Error("Block size should be a positive number");if(!Number.isInteger(e.costFactor)||e.costFactor<2||!Le(e.costFactor))throw new Error("Cost factor should be a power of 2, greater than 1");if(!Number.isInteger(e.parallelism)||e.parallelism<1)throw new Error("Parallelism should be a positive number");if(!Number.isInteger(e.hashLength)||e.hashLength<1)throw new Error("Hash length should be a positive number.");if(e.outputType===void 0&&(e.outputType="hex"),!["hex","binary"].includes(e.outputType))throw new Error(`Insupported output type ${e.outputType}. Valid values: ['hex', 'binary']`)},zt=async e=>(le(e),de(e,await me(),await X())),It=e=>(le(e),de(e,Ae(),X.wasm)),C=u("sha256",28),kt=async e=>(await C()).calculate(e,224),$t=async()=>Ke(await C()),Ke=(e=C.wasm)=>{e.init(224);const r={init:()=>(e.init(224),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:64,digestSize:28};return r},U=u("sha512",48),Ht=async e=>(await U()).calculate(e,384),Bt=async()=>Fe(await U()),Fe=(e=U.wasm)=>{e.init(384);const r={init:()=>(e.init(384),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:128,digestSize:48};return r},V=u("sm3",32),Pt=async e=>(await V()).calculate(e),Tt=async()=>Ne(await V()),Ne=(e=V.wasm)=>{e.init();const r={init:()=>(e.init(),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:64,digestSize:32};return r},D=u("whirlpool",64),jt=async e=>(await D()).calculate(e),Xt=async()=>Re(await D()),Re=(e=D.wasm)=>{e.init();const r={init:()=>(e.init(),r),update:t=>(e.update(t),r),digest:t=>e.digest(t),save:()=>e.save(),load:t=>(e.load(t),r),blockSize:64,digestSize:64};return r},L=u("xxhash128",4),K=new ArrayBuffer(8),Oe=new Uint8Array(K),te=new DataView(K);function ye(e,r){te.setUint32(0,e,!0),te.setUint32(4,r,!0)}const Ct=async(e,r=0,t=0)=>{b(r,t),ye(r,t);const a=await L();return a.writeMemory(Oe),a.calculate(e)},Ut=async(e=0,r=0)=>qe(e,r,await L()),qe=(e=0,r=0,t=L.wasm)=>{b(e,r),ye(e,r);const a=new Uint8Array(K);t.writeMemory(a),t.init();const n={init:()=>(t.writeMemory(a),t.init(),n),update:s=>(t.update(s),n),digest:s=>t.digest(s),save:()=>t.save(),load:s=>(t.load(s),n),blockSize:512,digestSize:16};return n},F=u("xxhash3",8),N=new ArrayBuffer(8),We=new Uint8Array(N),re=new DataView(N);function he(e,r){re.setUint32(0,e,!0),re.setUint32(4,r,!0)}const Vt=async(e,r=0,t=0)=>{b(r,t),he(r,t);const a=await F();return a.writeMemory(We),a.calculate(e)},Dt=async(e=0,r=0)=>Ze(e,r,await F()),Ze=(e=0,r=0,t=F.wasm)=>{b(e,r),he(e,r);const a=new Uint8Array(N);t.writeMemory(a),t.init();const n={init:()=>(t.writeMemory(a),t.init(),n),update:s=>(t.update(s),n),digest:s=>t.digest(s),save:()=>t.save(),load:s=>(t.load(s),n),blockSize:512,digestSize:8};return n},R=u("xxhash32",4),Lt=async(e,r=0)=>(se(r),(await R()).calculate(e,r)),Kt=async(e=0)=>Ye(e,await R()),Ye=(e=0,r=R.wasm)=>{se(e),r.init(e);const t={init:()=>(r.init(e),t),update:a=>(r.update(a),t),digest:a=>r.digest(a),save:()=>r.save(),load:a=>(r.load(a),t),blockSize:16,digestSize:4};return t},O=u("xxhash64",4),q=new ArrayBuffer(8),_e=new Uint8Array(q),ae=new DataView(q);function pe(e,r){ae.setUint32(0,e,!0),ae.setUint32(4,r,!0)}const Ft=async(e,r=0,t=0)=>{b(r,t),pe(r,t);const a=await O();return a.writeMemory(_e),a.calculate(e)},Nt=async(e=0,r=0)=>Ge(e,r,await O()),Ge=(e=0,r=0,t=O.wasm)=>{b(e,r),pe(e,r);const a=new Uint8Array(q);t.writeMemory(a),t.init();const n={init:()=>(t.writeMemory(a),t.init(),n),update:s=>(t.update(s),n),digest:s=>t.digest(s),save:()=>t.save(),load:s=>(t.load(s),n),blockSize:32,digestSize:8};return n};export{st as adler32,lt as argon2Verify,dt as argon2d,ot as argon2i,ut as argon2id,yt as bcrypt,ht as bcryptVerify,ct as blake2b,pt as blake2s,gt as blake3,bt as crc32,vt as crc32c,it as createAdler32,xe as createAdler32Sync,z as createBLAKE2b,Ee as createBLAKE2bSync,ft as createBLAKE2s,je as createBLAKE2sSync,wt as createBLAKE3,Xe as createBLAKE3Sync,St as createCRC32,mt as createCRC32C,Ue as createCRC32CSync,Ce as createCRC32Sync,qt as createHMAC,Wt as createHMACSync,Yt as createKeccak,_t as createKeccakSync,xt as createMD4,Ve as createMD4Sync,Mt as createMD5,De as createMD5Sync,tr as createRIPEMD160,rr as createRIPEMD160Sync,ur as createSHA1,dr as createSHA1Sync,$t as createSHA224,Ke as createSHA224Sync,me as createSHA256,Ae as createSHA256Sync,pr as createSHA3,Bt as createSHA384,Fe as createSHA384Sync,fr as createSHA3Sync,Sr as createSHA512,vr as createSHA512Sync,Tt as createSM3,Ne as createSM3Sync,Xt as createWhirlpool,Re as createWhirlpoolSync,Ut as createXXHash128,qe as createXXHash128Sync,Dt as createXXHash3,Kt as createXXHash32,Ye as createXXHash32Sync,Ze as createXXHash3Sync,Nt as createXXHash64,Ge as createXXHash64Sync,H as getBLAKE2bPreparer,B as getBLAKE2sPreparer,P as getBLAKE3Preparer,gr as getSha3Preparer,Gt as keccak,At as md4,Et as md5,Qt as pbkdf2,_ as pbkdf2Sync,$ as prepareAdler32,Me as prepareArgon2,ce as prepareBcrypt,S as prepareCRC32,T as prepareMD4,j as prepareMD5,ar as prepareRIPEMD160,lr as prepareSHA1,C as prepareSHA224,ir as prepareSHA256,U as prepareSHA384,mr as prepareSHA512,V as prepareSM3,X as prepareScrypt,D as prepareWhirlpool,L as prepareXXHash128,F as prepareXXHash3,R as prepareXXHash32,O as prepareXXHash64,nr as ripemd160,zt as scrypt,It as scryptSync,yr as sha1,kt as sha224,cr as sha256,wr as sha3,Ht as sha384,Ar as sha512,Pt as sm3,jt as whirlpool,Ct as xxhash128,Vt as xxhash3,Lt as xxhash32,Ft as xxhash64};
