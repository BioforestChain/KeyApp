import{$ as D}from"./page-BL_iZuG4.js";import{c as _}from"./bioforestChainBundle-CAVzb9HK.js";class P{constructor(){this.mutex=Promise.resolve()}lock(){let t=()=>{};return this.mutex=this.mutex.then(()=>new Promise(t)),new Promise(n=>{t=n})}async dispatch(t){const n=await this.lock();try{return await t()}finally{n()}}}function F(){return typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:D}const C=F(),S=C.Buffer??null,q=C.TextEncoder?new C.TextEncoder:null;function te(e,t){return String.fromCharCode(...e.subarray(0,t))}function X(e,t){return(e&15)+(e>>6|e>>3&8)<<4|(t&15)+(t>>6|t>>3&8)}function ne(e,t){const n=t.length>>1;for(let i=0;i<n;i++){const o=i<<1;e[i]=X(t.charCodeAt(o),t.charCodeAt(o+1))}}function Z(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}const k=87,M=48;function T(e,t,n){let i=0;for(let o=0;o<n;o++){let r=t[o]>>>4;e[i++]=r>9?r+k:r+M,r=t[o]&15,e[i++]=r>9?r+k:r+M}return String.fromCharCode.apply(null,e)}const $=S!==null?e=>{if(typeof e=="string"){const t=S.from(e,"utf8");return new Uint8Array(t.buffer,t.byteOffset,t.length)}if(S.isBuffer(e))return new Uint8Array(e.buffer,e.byteOffset,e.length);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Invalid data type!")}:e=>{if(typeof e=="string")return q.encode(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Invalid data type!")},h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",p=new Uint8Array(256);for(let e=0;e<h.length;e++)p[h.charCodeAt(e)]=e;function re(e,t=!0){const n=e.length,i=n%3,o=[],r=n-i;for(let f=0;f<r;f+=3){const a=(e[f]<<16&16711680)+(e[f+1]<<8&65280)+(e[f+2]&255),l=h.charAt(a>>18&63)+h.charAt(a>>12&63)+h.charAt(a>>6&63)+h.charAt(a&63);o.push(l)}if(i===1){const f=e[n-1],a=h.charAt(f>>2),l=h.charAt(f<<4&63);o.push(`${a}${l}`),t&&o.push("==")}else if(i===2){const f=(e[n-2]<<8)+e[n-1],a=h.charAt(f>>10),l=h.charAt(f>>4&63),g=h.charAt(f<<2&63);o.push(`${a}${l}${g}`),t&&o.push("=")}return o.join("")}function J(e){let t=Math.floor(e.length*.75);const n=e.length;return e[n-1]==="="&&(t-=1,e[n-2]==="="&&(t-=1)),t}function se(e){const t=J(e),n=e.length,i=new Uint8Array(t);let o=0;for(let r=0;r<n;r+=4){const f=p[e.charCodeAt(r)],a=p[e.charCodeAt(r+1)],l=p[e.charCodeAt(r+2)],g=p[e.charCodeAt(r+3)];i[o]=f<<2|a>>4,o+=1,i[o]=(a&15)<<4|l>>2,o+=1,i[o]=(l&3)<<6|g&63,o+=1}return i}function oe(e,t){if(!Number.isInteger(e)||e<8||e>t||e%8!==0)throw`Invalid variant! Valid values: 8, 16, ..., ${t}`}function ie(e,t){return e|t<<16}const U=e=>!Number.isInteger(e)||e<0||e>4294967295,ce=e=>{if(U(e))throw new Error("Seed must be a valid 32-bit long unsigned integer.")},fe=(e,t)=>{if(U(e)||U(t))throw new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).")};async function K(e){const t=`${_.wasmBaseUrl}/hash-wasm/${e}.wasm`,n=await _.wasmLoader(t),i=await crypto.subtle.digest("SHA-1",n);return{data:n,sha1:i}}const m=16*1024,w=4,Q=new P,A=new Map,L=async e=>{let t=A.get(e);return t===void 0&&(t=Q.dispatch(()=>K(e).then(async n=>{const i=new Uint8Array(n.sha1.slice(0,w)),o=await WebAssembly.compile(n.data),r=await WebAssembly.instantiate(o,{}),f={hash:i,module:o,instance:r};return A.set(e,f),f})),A.set(e,t)),await t},O=(e,t,n)=>{const{instance:i,hash:o}=e,r=i.exports;let f=new Uint8Array(r.memory.buffer,r.Hash_GetBuffer(),m),a=!1;const l=()=>f,g=(s,c=0)=>{l().set(s,c)},W=s=>{r.Hash_SetMemorySize(s),f=new Uint8Array(r.memory.buffer,r.Hash_GetBuffer(),s)},v=()=>new DataView(r.memory.buffer).getUint32(r.STATE_SIZE,!0),E=s=>{a=!0,r.Hash_Init(s)},z=s=>{let c=0;for(;c<s.length;){const u=s.subarray(c,c+m);c+=u.length,l().set(u),r.Hash_Update(u.length)}},H=s=>{if(!a)throw new Error("update() called before init()");const c=$(s);z(c)},B=new Uint8Array(n*2),I=((s="binary",c)=>{if(!a)throw new Error("digest() called before init()");return a=!1,r.Hash_Final(c),s==="hex"?T(B,l(),n):l().slice(0,n)}),G=()=>{if(!a)throw new Error("save() can only be called after init() and before digest()");const s=r.Hash_GetState(),c=v(),u=r.memory.buffer,y=new Uint8Array(u,s,c),d=new Uint8Array(w+c);return d.set(o,0),d.set(y,w),d},V=s=>{if(!(s instanceof Uint8Array))throw new Error("load() expects an Uint8Array generated by save()");const c=r.Hash_GetState(),u=v(),y=w+u,d=r.memory.buffer;if(s.length!==y)throw new Error(`Bad state length (expected ${y} bytes, got ${s.length})`);if(!Z(o,s.subarray(0,w)))throw new Error("This state was written by an incompatible hash implementation");const j=s.subarray(w);new Uint8Array(d,c,u).set(j),a=!0},x=s=>typeof s=="string"?s.length<m/4:s.byteLength<m;let b=x;switch(t){case"argon2":case"scrypt":b=()=>!0;break;case"blake2b":case"blake2s":b=(s,c)=>typeof c=="number"&&c<=512&&x(s);break;case"blake3":b=(s,c)=>c===0&&x(s);break;case"xxhash64":case"xxhash3":case"xxhash128":b=()=>!1;break}return{getMemory:l,writeMemory:g,getExports:()=>r,setMemorySize:W,init:E,update:H,digest:I,save:G,load:V,calculate:(s,c,u)=>{if(!b(s,c))return E(c),H(s),I("hex",u);const y=$(s);return l().set(y),r.Hash_Calculate(y.length,c,u),T(B,l(),n)},hashLength:n}},R=async(e,t)=>O(await L(e),e,t),ae=(e,t)=>{const n=()=>R(e,t);return Object.defineProperties(n,{wasm:{get(){const i=A.get(e);if(i===void 0||i instanceof Promise)throw new Error(`wasm instance ${e} is not yet ready.`);return O(i,e,t)}},prepare:{value:async()=>{await L(e)}}}),n};export{T as a,ie as b,ae as c,J as d,se as e,re as f,$ as g,fe as h,te as i,ce as j,oe as v,ne as w};
