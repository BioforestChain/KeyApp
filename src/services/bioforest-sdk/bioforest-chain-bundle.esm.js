const __getOwnPropNames = Object.getOwnPropertyNames;
const __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/services/bioforest-sdk/bioforest-chain-bundle.cjs
const require_bioforest_chain_bundle = __commonJS({
  "src/services/bioforest-sdk/bioforest-chain-bundle.cjs"(exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function l(i, e, t, r) {
      let n = arguments.length, s = n < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, o;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") s = Reflect.decorate(i, e, t, r);
      else for (let a = i.length - 1; a >= 0; a--) (o = i[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
      return n > 3 && s && Object.defineProperty(e, t, s), s;
    }
    function be(i, e) {
      return function(t, r) {
        e(t, r, i);
      };
    }
    function u(i, e) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(i, e);
    }
    const Dy = /* @__PURE__ */ new WeakMap();
    function Vs(i, e, t) {
      if (!t || typeof t.value !== "function") throw new TypeError(`Only methods can be decorated with @cacheBytesGetter. <${e}> is not a method!`);
      const r = t.value, n = function(...s) {
        if (Object.isFrozen(this)) {
          const a = JSON.stringify(s);
          let p = Dy.get(this);
          p || (p = /* @__PURE__ */ new Map(), Dy.set(this, p));
          let h = p.get(a);
          return h || (h = r.apply(this, s), p.set(a, h)), h;
        }
        return r.apply(this, s);
      };
      return t.value = n, t;
    }
    const Fy = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function mo(i) {
      return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
    }
    const k_ = {};
    (function(i) {
      const e = i;
      e.length = function(a) {
        let p = a.length;
        if (!p) return 0;
        for (var h = 0; --p % 4 > 1 && a.charAt(p) === "="; ) ++h;
        return Math.ceil(a.length * 3) / 4 - h;
      };
      for (var t = new Array(64), r = new Array(123), n = 0; n < 64; ) r[t[n] = n < 26 ? n + 65 : n < 52 ? n + 71 : n < 62 ? n - 4 : n - 59 | 43] = n++;
      e.encode = function(a, p, h) {
        for (var f = null, g = [], d = 0, y = 0, _; p < h; ) {
          const I = a[p++];
          switch (y) {
            case 0:
              g[d++] = t[I >> 2], _ = (I & 3) << 4, y = 1;
              break;
            case 1:
              g[d++] = t[_ | I >> 4], _ = (I & 15) << 2, y = 2;
              break;
            case 2:
              g[d++] = t[_ | I >> 6], g[d++] = t[I & 63], y = 0;
              break;
          }
          d > 8191 && ((f || (f = [])).push(String.fromCharCode.apply(String, g)), d = 0);
        }
        return y && (g[d++] = t[_], g[d++] = 61, y === 1 && (g[d++] = 61)), f ? (d && f.push(String.fromCharCode.apply(String, g.slice(0, d))), f.join("")) : String.fromCharCode.apply(String, g.slice(0, d));
      };
      const s = "invalid encoding";
      e.decode = function(a, p, h) {
        for (var f = h, g = 0, d, y = 0; y < a.length; ) {
          let _ = a.charCodeAt(y++);
          if (_ === 61 && g > 1) break;
          if ((_ = r[_]) === void 0) throw Error(s);
          switch (g) {
            case 0:
              d = _, g = 1;
              break;
            case 1:
              p[h++] = d << 2 | (_ & 48) >> 4, d = _, g = 2;
              break;
            case 2:
              p[h++] = (d & 15) << 4 | (_ & 60) >> 2, d = _, g = 3;
              break;
            case 3:
              p[h++] = (d & 3) << 6 | _, g = 0;
              break;
          }
        }
        if (g === 1) throw Error(s);
        return h - f;
      }, e.test = function(a) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(a);
      };
    })(k_);
    const mf = mo(k_);
    let dn;
    try {
      if (typeof WebAssembly === "object") {
        const i = "AGFzbQEAAAABDQJgAAF/YAR/f39/AX8DBwYAAQEBAQEGBgF/AUEACwcyBgNtdWwAAQVkaXZfcwACBWRpdl91AAMFcmVtX3MABAVyZW1fdQAFCGdldF9oaWdoAAAKvwEGBAAjAAskAQF+IACtIAGtQiCGhCACrSADrUIghoR+IgRCIIenJAAgBKcLJAEBfiAArSABrUIghoQgAq0gA61CIIaEfyIEQiCHpyQAIASnCyQBAX4gAK0gAa1CIIaEIAKtIAOtQiCGhIAiBEIgh6ckACAEpwskAQF+IACtIAGtQiCGhCACrSADrUIghoSBIgRCIIenJAAgBKcLJAEBfiAArSABrUIghoQgAq0gA61CIIaEgiIEQiCHpyQAIASnCw==", e = new Uint8Array(mf.length(i));
        mf.decode(i, e, 0), dn = new WebAssembly.Instance(new WebAssembly.Module(e), {}).exports;
      }
    } catch {
    }
    const zt = class fe {
      constructor(e, t, r) {
        this.__isLong__ = true, this.low = e | 0, this.high = t | 0, this.unsigned = !!r;
      }
      static isLong(e) {
        return (e && e.__isLong__) === true;
      }
      static fromInt(e, t) {
        let r, n, s;
        return t ? (e >>>= 0, (s = 0 <= e && e < 256) && (n = this._UINT_CACHE[e], n) ? n : (r = this.fromBits(e, (e | 0) < 0 ? -1 : 0, true), s && (this._UINT_CACHE[e] = r), r)) : (e |= 0, (s = -128 <= e && e < 128) && (n = this._INT_CACHE[e], n) ? n : (r = this.fromBits(e, e < 0 ? -1 : 0, false), s && (this._INT_CACHE[e] = r), r));
      }
      static fromNumber(e, t) {
        if (isNaN(e)) return t ? fe.UZERO : fe.ZERO;
        if (t) {
          if (e < 0) return fe.UZERO;
          if (e >= D_) return fe.MAX_UNSIGNED_VALUE;
        } else {
          if (e <= -Uy) return fe.MIN_VALUE;
          if (e + 1 >= Uy) return fe.MAX_VALUE;
        }
        return e < 0 ? this.fromNumber(-e, t).neg() : this.fromBits(e % ea | 0, e / ea | 0, t);
      }
      static fromBits(e, t, r) {
        return new fe(e, t, r);
      }
      static fromString(e, t, r) {
        if (e.length === 0) throw Error("empty string");
        if (e === "NaN" || e === "Infinity" || e === "+Infinity" || e === "-Infinity") return fe.ZERO;
        if (typeof t === "number" ? (r = t, t = false) : t = !!t, r = r || 10, r < 2 || 36 < r) throw RangeError("radix");
        let n;
        if ((n = e.indexOf("-")) > 0) throw Error("interior hyphen");
        if (n === 0) return this.fromString(e.substring(1), t, r).neg();
        for (var s = this.fromNumber(vl(r, 8)), o = fe.ZERO, a = 0; a < e.length; a += 8) {
          const p = Math.min(8, e.length - a), h = parseInt(e.substring(a, a + p), r);
          if (p < 8) {
            const f = this.fromNumber(vl(r, p));
            o = o.mul(f).add(this.fromNumber(h));
          } else o = o.mul(s), o = o.add(this.fromNumber(h));
        }
        return o.unsigned = t, o;
      }
      static fromValue(e, t) {
        return typeof e === "number" ? this.fromNumber(e, t) : typeof e === "string" ? this.fromString(e, t) : this.fromBits(e.low, e.high, typeof t === "boolean" ? t : e.unsigned);
      }
      toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      }
      toNumber() {
        return this.unsigned ? (this.high >>> 0) * ea + (this.low >>> 0) : this.high * ea + (this.low >>> 0);
      }
      toString(e) {
        if (e = e || 10, e < 2 || 36 < e) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) if (this.eq(fe.MIN_VALUE)) {
          const t = fe.fromNumber(e), r = this.div(t), n = r.mul(t).sub(this);
          return r.toString(e) + n.toInt().toString(e);
        } else return "-" + this.neg().toString(e);
        for (let s = fe.fromNumber(vl(e, 6), this.unsigned), o = this, a = ""; ; ) {
          let p = o.div(s), h = o.sub(p.mul(s)).toInt() >>> 0, f = h.toString(e);
          if (o = p, o.isZero()) return f + a;
          for (; f.length < 6; ) f = "0" + f;
          a = "" + f + a;
        }
      }
      getHighBits() {
        return this.high;
      }
      getHighBitsUnsigned() {
        return this.high >>> 0;
      }
      getLowBits() {
        return this.low;
      }
      getLowBitsUnsigned() {
        return this.low >>> 0;
      }
      getNumBitsAbs() {
        if (this.isNegative()) return this.eq(fe.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        for (var e = this.high != 0 ? this.high : this.low, t = 31; t > 0 && !(e & 1 << t); t--) ;
        return this.high != 0 ? t + 33 : t + 1;
      }
      isZero() {
        return this.high === 0 && this.low === 0;
      }
      isNegative() {
        return !this.unsigned && this.high < 0;
      }
      isPositive() {
        return this.unsigned || this.high >= 0;
      }
      isOdd() {
        return (this.low & 1) === 1;
      }
      isEven() {
        return (this.low & 1) === 0;
      }
      equals(e) {
        return fe.isLong(e) || (e = fe.fromValue(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? false : this.high === e.high && this.low === e.low;
      }
      notEquals(e) {
        return !this.eq(e);
      }
      lessThan(e) {
        return this.comp(e) < 0;
      }
      lessThanOrEqual(e) {
        return this.comp(e) <= 0;
      }
      greaterThan(e) {
        return this.comp(e) > 0;
      }
      greaterThanOrEqual(e) {
        return this.comp(e) >= 0;
      }
      compare(e) {
        if (fe.isLong(e) || (e = fe.fromValue(e)), this.eq(e)) return 0;
        const t = this.isNegative(), r = e.isNegative();
        return t && !r ? -1 : !t && r ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
      }
      negate() {
        return !this.unsigned && this.eq(fe.MIN_VALUE) ? fe.MIN_VALUE : this.not().add(fe.ONE);
      }
      add(e) {
        fe.isLong(e) || (e = fe.fromValue(e));
        let t = this.high >>> 16, r = this.high & 65535, n = this.low >>> 16, s = this.low & 65535, o = e.high >>> 16, a = e.high & 65535, p = e.low >>> 16, h = e.low & 65535, f = 0, g = 0, d = 0, y = 0;
        return y += s + h, d += y >>> 16, y &= 65535, d += n + p, g += d >>> 16, d &= 65535, g += r + a, f += g >>> 16, g &= 65535, f += t + o, f &= 65535, fe.fromBits(d << 16 | y, f << 16 | g, this.unsigned);
      }
      subtract(e) {
        return fe.isLong(e) || (e = fe.fromValue(e)), this.add(e.neg());
      }
      multiply(e) {
        if (this.isZero()) return fe.ZERO;
        if (fe.isLong(e) || (e = fe.fromValue(e)), dn) {
          const t = dn.mul(this.low, this.high, e.low, e.high);
          return fe.fromBits(t, dn.get_high(), this.unsigned);
        }
        if (e.isZero()) return fe.ZERO;
        if (this.eq(fe.MIN_VALUE)) return e.isOdd() ? fe.MIN_VALUE : fe.ZERO;
        if (e.eq(fe.MIN_VALUE)) return this.isOdd() ? fe.MIN_VALUE : fe.ZERO;
        if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
        if (e.isNegative()) return this.mul(e.neg()).neg();
        if (this.lt(Vy) && e.lt(Vy)) return fe.fromNumber(this.toNumber() * e.toNumber(), this.unsigned);
        let r = this.high >>> 16, n = this.high & 65535, s = this.low >>> 16, o = this.low & 65535, a = e.high >>> 16, p = e.high & 65535, h = e.low >>> 16, f = e.low & 65535, g = 0, d = 0, y = 0, _ = 0;
        return _ += o * f, y += _ >>> 16, _ &= 65535, y += s * f, d += y >>> 16, y &= 65535, y += o * h, d += y >>> 16, y &= 65535, d += n * f, g += d >>> 16, d &= 65535, d += s * h, g += d >>> 16, d &= 65535, d += o * p, g += d >>> 16, d &= 65535, g += r * f + n * h + s * p + o * a, g &= 65535, fe.fromBits(y << 16 | _, g << 16 | d, this.unsigned);
      }
      divide(e) {
        if (fe.isLong(e) || (e = fe.fromValue(e)), e.isZero()) throw Error("division by zero");
        if (dn) {
          if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1) return this;
          const t = (this.unsigned ? dn.div_u : dn.div_s)(this.low, this.high, e.low, e.high);
          return fe.fromBits(t, dn.get_high(), this.unsigned);
        }
        if (this.isZero()) return this.unsigned ? fe.UZERO : fe.ZERO;
        let r, n, s;
        if (this.unsigned) {
          if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return fe.UZERO;
          if (e.gt(this.shru(1))) return fe.UONE;
          s = fe.UZERO;
        } else {
          if (this.eq(fe.MIN_VALUE)) {
            if (e.eq(fe.ONE) || e.eq(fe.NEG_ONE)) return fe.MIN_VALUE;
            if (e.eq(fe.MIN_VALUE)) return fe.ONE;
            const o = this.shr(1);
            return r = o.div(e).shl(1), r.eq(fe.ZERO) ? e.isNegative() ? fe.ONE : fe.NEG_ONE : (n = this.sub(e.mul(r)), s = r.add(n.div(e)), s);
          } else if (e.eq(fe.MIN_VALUE)) return this.unsigned ? fe.UZERO : fe.ZERO;
          if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
          if (e.isNegative()) return this.div(e.neg()).neg();
          s = fe.ZERO;
        }
        for (n = this; n.gte(e); ) {
          r = Math.max(1, Math.floor(n.toNumber() / e.toNumber()));
          for (var a = Math.ceil(Math.log(r) / Math.LN2), p = a <= 48 ? 1 : vl(2, a - 48), h = fe.fromNumber(r), f = h.mul(e); f.isNegative() || f.gt(n); ) r -= p, h = fe.fromNumber(r, this.unsigned), f = h.mul(e);
          h.isZero() && (h = fe.ONE), s = s.add(h), n = n.sub(f);
        }
        return s;
      }
      modulo(e) {
        if (fe.isLong(e) || (e = fe.fromValue(e)), dn) {
          const t = (this.unsigned ? dn.rem_u : dn.rem_s)(this.low, this.high, e.low, e.high);
          return fe.fromBits(t, dn.get_high(), this.unsigned);
        }
        return this.sub(this.div(e).mul(e));
      }
      not() {
        return fe.fromBits(~this.low, ~this.high, this.unsigned);
      }
      and(e) {
        return fe.isLong(e) || (e = fe.fromValue(e)), fe.fromBits(this.low & e.low, this.high & e.high, this.unsigned);
      }
      or(e) {
        return fe.isLong(e) || (e = fe.fromValue(e)), fe.fromBits(this.low | e.low, this.high | e.high, this.unsigned);
      }
      xor(e) {
        return fe.isLong(e) || (e = fe.fromValue(e)), fe.fromBits(this.low ^ e.low, this.high ^ e.high, this.unsigned);
      }
      shiftLeft(e) {
        return fe.isLong(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? fe.fromBits(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : fe.fromBits(0, this.low << e - 32, this.unsigned);
      }
      shiftRight(e) {
        return fe.isLong(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? fe.fromBits(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : fe.fromBits(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      }
      shiftRightUnsigned(e) {
        if (fe.isLong(e) && (e = e.toInt()), e &= 63, e === 0) return this;
        const t = this.high;
        if (e < 32) {
          const r = this.low;
          return fe.fromBits(r >>> e | t << 32 - e, t >>> e, this.unsigned);
        } else return e === 32 ? fe.fromBits(t, 0, this.unsigned) : fe.fromBits(t >>> e - 32, 0, this.unsigned);
      }
      toSigned() {
        return this.unsigned ? fe.fromBits(this.low, this.high, false) : this;
      }
      toUnsigned() {
        return this.unsigned ? this : fe.fromBits(this.low, this.high, true);
      }
      toBytes(e) {
        return e ? this.toBytesLE() : this.toBytesBE();
      }
      toBytesLE() {
        const e = this.high, t = this.low;
        return [t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, e & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
      }
      toBytesBE() {
        const e = this.high, t = this.low;
        return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, e & 255, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255];
      }
      static fromBytes(e, t, r) {
        return r ? fe.fromBytesLE(e, t) : this.fromBytesBE(e, t);
      }
      static fromBytesLE(e, t) {
        return new fe(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
      }
      static fromBytesBE(e, t) {
        return new fe(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
      }
    };
    zt._INT_CACHE = /* @__PURE__ */ Object.create(null);
    zt._UINT_CACHE = /* @__PURE__ */ Object.create(null);
    zt.ZERO = zt.fromInt(0);
    zt.UZERO = zt.fromInt(0, true);
    zt.ONE = zt.fromInt(1);
    zt.UONE = zt.fromInt(1, true);
    zt.NEG_ONE = zt.fromInt(-1);
    zt.MAX_VALUE = zt.fromBits(-1, 2147483647, false);
    zt.MAX_UNSIGNED_VALUE = zt.fromBits(-1, -1, true);
    zt.MIN_VALUE = zt.fromBits(0, -2147483648, false);
    const vl = Math.pow;
    const $y = 65536;
    const tE = 1 << 24;
    const ea = $y * $y;
    const D_ = ea * ea;
    const Uy = D_ / 2;
    const Vy = zt.fromInt(tE);
    const Ue = zt.prototype;
    Ue.eqz = Ue.isZero;
    Ue.eq = Ue.equals;
    Ue.neq = Ue.notEquals;
    Ue.ne = Ue.notEquals;
    Ue.lt = Ue.lessThan;
    Ue.lte = Ue.lessThanOrEqual;
    Ue.le = Ue.lessThanOrEqual;
    Ue.gt = Ue.greaterThan;
    Ue.gte = Ue.greaterThanOrEqual;
    Ue.ge = Ue.greaterThanOrEqual;
    Ue.comp = Ue.compare;
    Ue.neg = Ue.negate;
    Ue.sub = Ue.subtract;
    Ue.mul = Ue.multiply;
    Ue.div = Ue.divide;
    Ue.mod = Ue.modulo;
    Ue.rem = Ue.modulo;
    Ue.shl = Ue.shiftLeft;
    Ue.shr = Ue.shiftRight;
    Ue.shru = Ue.shiftRightUnsigned;
    Ue.shr_u = Ue.shiftRightUnsigned;
    const rs = {};
    const uu = {};
    uu.byteLength = sE;
    uu.toByteArray = oE;
    uu.fromByteArray = pE;
    const ns = [];
    const yn = [];
    const rE = typeof Uint8Array < "u" ? Uint8Array : Array;
    const Cu = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (Ho = 0, nE = Cu.length; Ho < nE; ++Ho) ns[Ho] = Cu[Ho], yn[Cu.charCodeAt(Ho)] = Ho;
    let Ho;
    let nE;
    yn["-".charCodeAt(0)] = 62;
    yn["_".charCodeAt(0)] = 63;
    function F_(i) {
      const e = i.length;
      if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
      let t = i.indexOf("=");
      t === -1 && (t = e);
      const r = t === e ? 0 : 4 - t % 4;
      return [t, r];
    }
    function sE(i) {
      const e = F_(i), t = e[0], r = e[1];
      return (t + r) * 3 / 4 - r;
    }
    function iE(i, e, t) {
      return (e + t) * 3 / 4 - t;
    }
    function oE(i) {
      let e, t = F_(i), r = t[0], n = t[1], s = new rE(iE(i, r, n)), o = 0, a = n > 0 ? r - 4 : r, p;
      for (p = 0; p < a; p += 4) e = yn[i.charCodeAt(p)] << 18 | yn[i.charCodeAt(p + 1)] << 12 | yn[i.charCodeAt(p + 2)] << 6 | yn[i.charCodeAt(p + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
      return n === 2 && (e = yn[i.charCodeAt(p)] << 2 | yn[i.charCodeAt(p + 1)] >> 4, s[o++] = e & 255), n === 1 && (e = yn[i.charCodeAt(p)] << 10 | yn[i.charCodeAt(p + 1)] << 4 | yn[i.charCodeAt(p + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s;
    }
    function aE(i) {
      return ns[i >> 18 & 63] + ns[i >> 12 & 63] + ns[i >> 6 & 63] + ns[i & 63];
    }
    function cE(i, e, t) {
      for (var r, n = [], s = e; s < t; s += 3) r = (i[s] << 16 & 16711680) + (i[s + 1] << 8 & 65280) + (i[s + 2] & 255), n.push(aE(r));
      return n.join("");
    }
    function pE(i) {
      for (var e, t = i.length, r = t % 3, n = [], s = 16383, o = 0, a = t - r; o < a; o += s) n.push(cE(i, o, o + s > a ? a : o + s));
      return r === 1 ? (e = i[t - 1], n.push(ns[e >> 2] + ns[e << 4 & 63] + "==")) : r === 2 && (e = (i[t - 2] << 8) + i[t - 1], n.push(ns[e >> 10] + ns[e >> 4 & 63] + ns[e << 2 & 63] + "=")), n.join("");
    }
    const pd = {};
    pd.read = function(i, e, t, r, n) {
      let s, o, a = n * 8 - r - 1, p = (1 << a) - 1, h = p >> 1, f = -7, g = t ? n - 1 : 0, d = t ? -1 : 1, y = i[e + g];
      for (g += d, s = y & (1 << -f) - 1, y >>= -f, f += a; f > 0; s = s * 256 + i[e + g], g += d, f -= 8) ;
      for (o = s & (1 << -f) - 1, s >>= -f, f += r; f > 0; o = o * 256 + i[e + g], g += d, f -= 8) ;
      if (s === 0) s = 1 - h;
      else {
        if (s === p) return o ? NaN : (y ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, r), s = s - h;
      }
      return (y ? -1 : 1) * o * Math.pow(2, s - r);
    };
    pd.write = function(i, e, t, r, n, s) {
      let o, a, p, h = s * 8 - n - 1, f = (1 << h) - 1, g = f >> 1, d = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = r ? 0 : s - 1, _ = r ? 1 : -1, I = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = f) : (o = Math.floor(Math.log(e) / Math.LN2), e * (p = Math.pow(2, -o)) < 1 && (o--, p *= 2), o + g >= 1 ? e += d / p : e += d * Math.pow(2, 1 - g), e * p >= 2 && (o++, p /= 2), o + g >= f ? (a = 0, o = f) : o + g >= 1 ? (a = (e * p - 1) * Math.pow(2, n), o = o + g) : (a = e * Math.pow(2, g - 1) * Math.pow(2, n), o = 0)); n >= 8; i[t + y] = a & 255, y += _, a /= 256, n -= 8) ;
      for (o = o << n | a, h += n; h > 0; i[t + y] = o & 255, y += _, o /= 256, h -= 8) ;
      i[t + y - _] |= I * 128;
    };
    (function(i) {
      const e = uu, t = pd, r = typeof Symbol === "function" && typeof Symbol.for === "function" ? /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom") : null;
      i.Buffer = a, i.SlowBuffer = N, i.INSPECT_MAX_BYTES = 50;
      const n = 2147483647;
      i.kMaxLength = n, a.TYPED_ARRAY_SUPPORT = s(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error === "function" && ;
      function s() {
        try {
          const T = new Uint8Array(1), m = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(m, Uint8Array.prototype), Object.setPrototypeOf(T, m), T.foo() === 42;
        } catch {
          return false;
        }
      }
      Object.defineProperty(a.prototype, "parent", { enumerable: true, get: function() {
        if (a.isBuffer(this)) return this.buffer;
      } }), Object.defineProperty(a.prototype, "offset", { enumerable: true, get: function() {
        if (a.isBuffer(this)) return this.byteOffset;
      } });
      function o(T) {
        if (T > n) throw new RangeError('The value "' + T + '" is invalid for option "size"');
        const m = new Uint8Array(T);
        return Object.setPrototypeOf(m, a.prototype), m;
      }
      function a(T, m, E) {
        if (typeof T === "number") {
          if (typeof m === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
          return g(T);
        }
        return p(T, m, E);
      }
      a.poolSize = 8192;
      function p(T, m, E) {
        if (typeof T === "string") return d(T, m);
        if (ArrayBuffer.isView(T)) return _(T);
        if (T == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof T);
        if (hn(T, ArrayBuffer) || T && hn(T.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (hn(T, SharedArrayBuffer) || T && hn(T.buffer, SharedArrayBuffer))) return I(T, m, E);
        if (typeof T === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const b = T.valueOf && T.valueOf();
        if (b != null && b !== T) return a.from(b, m, E);
        const M = S(T);
        if (M) return M;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof T[Symbol.toPrimitive] === "function") return a.from(T[Symbol.toPrimitive]("string"), m, E);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof T);
      }
      a.from = function(T, m, E) {
        return p(T, m, E);
      }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
      function h(T) {
        if (typeof T !== "number") throw new TypeError('"size" argument must be of type number');
        if (T < 0) throw new RangeError('The value "' + T + '" is invalid for option "size"');
      }
      function f(T, m, E) {
        return h(T), T <= 0 ? o(T) : m !== void 0 ? typeof E === "string" ? o(T).fill(m, E) : o(T).fill(m) : o(T);
      }
      a.alloc = function(T, m, E) {
        return f(T, m, E);
      };
      function g(T) {
        return h(T), o(T < 0 ? 0 : w(T) | 0);
      }
      a.allocUnsafe = function(T) {
        return g(T);
      }, a.allocUnsafeSlow = function(T) {
        return g(T);
      };
      function d(T, m) {
        if ((typeof m !== "string" || m === "") && (m = "utf8"), !a.isEncoding(m)) throw new TypeError("Unknown encoding: " + m);
        const E = B(T, m) | 0;
        let b = o(E);
        const M = b.write(T, m);
        return M !== E && (b = b.slice(0, M)), b;
      }
      function y(T) {
        const m = T.length < 0 ? 0 : w(T.length) | 0, E = o(m);
        for (let b = 0; b < m; b += 1) E[b] = T[b] & 255;
        return E;
      }
      function _(T) {
        if (hn(T, Uint8Array)) {
          const m = new Uint8Array(T);
          return I(m.buffer, m.byteOffset, m.byteLength);
        }
        return y(T);
      }
      function I(T, m, E) {
        if (m < 0 || T.byteLength < m) throw new RangeError('"offset" is outside of buffer bounds');
        if (T.byteLength < m + (E || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let b;
        return m === void 0 && E === void 0 ? b = new Uint8Array(T) : E === void 0 ? b = new Uint8Array(T, m) : b = new Uint8Array(T, m, E), Object.setPrototypeOf(b, a.prototype), b;
      }
      function S(T) {
        if (a.isBuffer(T)) {
          const m = w(T.length) | 0, E = o(m);
          return E.length === 0 || T.copy(E, 0, 0, m), E;
        }
        if (T.length !== void 0) return typeof T.length !== "number" || Mi(T.length) ? o(0) : y(T);
        if (T.type === "Buffer" && Array.isArray(T.data)) return y(T.data);
      }
      function w(T) {
        if (T >= n) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n.toString(16) + " bytes");
        return T | 0;
      }
      function N(T) {
        return +T != T && (T = 0), a.alloc(+T);
      }
      a.isBuffer = function(m) {
        return m != null && m._isBuffer === true && m !== a.prototype;
      }, a.compare = function(m, E) {
        if (hn(m, Uint8Array) && (m = a.from(m, m.offset, m.byteLength)), hn(E, Uint8Array) && (E = a.from(E, E.offset, E.byteLength)), !a.isBuffer(m) || !a.isBuffer(E)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (m === E) return 0;
        let b = m.length, M = E.length;
        for (let k = 0, X = Math.min(b, M); k < X; ++k) if (m[k] !== E[k]) {
          b = m[k], M = E[k];
          break;
        }
        return b < M ? -1 : M < b ? 1 : 0;
      }, a.isEncoding = function(m) {
        switch (String(m).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, a.concat = function(m, E) {
        if (!Array.isArray(m)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (m.length === 0) return a.alloc(0);
        let b;
        if (E === void 0) for (E = 0, b = 0; b < m.length; ++b) E += m[b].length;
        const M = a.allocUnsafe(E);
        let k = 0;
        for (b = 0; b < m.length; ++b) {
          let X = m[b];
          if (hn(X, Uint8Array)) k + X.length > M.length ? (a.isBuffer(X) || (X = a.from(X)), X.copy(M, k)) : Uint8Array.prototype.set.call(M, X, k);
          else if (a.isBuffer(X)) X.copy(M, k);
          else throw new TypeError('"list" argument must be an Array of Buffers');
          k += X.length;
        }
        return M;
      };
      function B(T, m) {
        if (a.isBuffer(T)) return T.length;
        if (ArrayBuffer.isView(T) || hn(T, ArrayBuffer)) return T.byteLength;
        if (typeof T !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof T);
        const E = T.length, b = arguments.length > 2 && arguments[2] === true;
        if (!b && E === 0) return 0;
        let M = false;
        for (; ; ) switch (m) {
          case "ascii":
          case "latin1":
          case "binary":
            return E;
          case "utf8":
          case "utf-8":
            return ic(T).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return E * 2;
          case "hex":
            return E >>> 1;
          case "base64":
            return Hl(T).length;
          default:
            if (M) return b ? -1 : ic(T).length;
            m = ("" + m).toLowerCase(), M = true;
        }
      }
      a.byteLength = B;
      function O(T, m, E) {
        let b = false;
        if ((m === void 0 || m < 0) && (m = 0), m > this.length || ((E === void 0 || E > this.length) && (E = this.length), E <= 0) || (E >>>= 0, m >>>= 0, E <= m)) return "";
        for (T || (T = "utf8"); ; ) switch (T) {
          case "hex":
            return he(this, m, E);
          case "utf8":
          case "utf-8":
            return $(this, m, E);
          case "ascii":
            return ge(this, m, E);
          case "latin1":
          case "binary":
            return Ae(this, m, E);
          case "base64":
            return z(this, m, E);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return x(this, m, E);
          default:
            if (b) throw new TypeError("Unknown encoding: " + T);
            T = (T + "").toLowerCase(), b = true;
        }
      }
      a.prototype._isBuffer = true;
      function P(T, m, E) {
        const b = T[m];
        T[m] = T[E], T[E] = b;
      }
      a.prototype.swap16 = function() {
        const m = this.length;
        if (m % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let E = 0; E < m; E += 2) P(this, E, E + 1);
        return this;
      }, a.prototype.swap32 = function() {
        const m = this.length;
        if (m % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let E = 0; E < m; E += 4) P(this, E, E + 3), P(this, E + 1, E + 2);
        return this;
      }, a.prototype.swap64 = function() {
        const m = this.length;
        if (m % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let E = 0; E < m; E += 8) P(this, E, E + 7), P(this, E + 1, E + 6), P(this, E + 2, E + 5), P(this, E + 3, E + 4);
        return this;
      }, a.prototype.toString = function() {
        const m = this.length;
        return m === 0 ? "" : arguments.length === 0 ? $(this, 0, m) : O.apply(this, arguments);
      }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(m) {
        if (!a.isBuffer(m)) throw new TypeError("Argument must be a Buffer");
        return this === m ? true : a.compare(this, m) === 0;
      }, a.prototype.inspect = function() {
        let m = "";
        const E = i.INSPECT_MAX_BYTES;
        return m = this.toString("hex", 0, E).replace(/(.{2})/g, "$1 ").trim(), this.length > E && (m += " ... "), "<Buffer " + m + ">";
      }, r && (a.prototype[r] = a.prototype.inspect), a.prototype.compare = function(m, E, b, M, k) {
        if (hn(m, Uint8Array) && (m = a.from(m, m.offset, m.byteLength)), !a.isBuffer(m)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof m);
        if (E === void 0 && (E = 0), b === void 0 && (b = m ? m.length : 0), M === void 0 && (M = 0), k === void 0 && (k = this.length), E < 0 || b > m.length || M < 0 || k > this.length) throw new RangeError("out of range index");
        if (M >= k && E >= b) return 0;
        if (M >= k) return -1;
        if (E >= b) return 1;
        if (E >>>= 0, b >>>= 0, M >>>= 0, k >>>= 0, this === m) return 0;
        let X = k - M, we = b - E;
        const et = Math.min(X, we), at = this.slice(M, k), Bt = m.slice(E, b);
        for (let ct = 0; ct < et; ++ct) if (at[ct] !== Bt[ct]) {
          X = at[ct], we = Bt[ct];
          break;
        }
        return X < we ? -1 : we < X ? 1 : 0;
      };
      function C(T, m, E, b, M) {
        if (T.length === 0) return -1;
        if (typeof E === "string" ? (b = E, E = 0) : E > 2147483647 ? E = 2147483647 : E < -2147483648 && (E = -2147483648), E = +E, Mi(E) && (E = M ? 0 : T.length - 1), E < 0 && (E = T.length + E), E >= T.length) {
          if (M) return -1;
          E = T.length - 1;
        } else if (E < 0) if (M) E = 0;
        else return -1;
        if (typeof m === "string" && (m = a.from(m, b)), a.isBuffer(m)) return m.length === 0 ? -1 : V(T, m, E, b, M);
        if (typeof m === "number") return m = m & 255, typeof Uint8Array.prototype.indexOf === "function" ? M ? Uint8Array.prototype.indexOf.call(T, m, E) : Uint8Array.prototype.lastIndexOf.call(T, m, E) : V(T, [m], E, b, M);
        throw new TypeError("val must be string, number or Buffer");
      }
      function V(T, m, E, b, M) {
        let k = 1, X = T.length, we = m.length;
        if (b !== void 0 && (b = String(b).toLowerCase(), b === "ucs2" || b === "ucs-2" || b === "utf16le" || b === "utf-16le")) {
          if (T.length < 2 || m.length < 2) return -1;
          k = 2, X /= 2, we /= 2, E /= 2;
        }
        function et(Bt, ct) {
          return k === 1 ? Bt[ct] : Bt.readUInt16BE(ct * k);
        }
        let at;
        if (M) {
          let Bt = -1;
          for (at = E; at < X; at++) if (et(T, at) === et(m, Bt === -1 ? 0 : at - Bt)) {
            if (Bt === -1 && (Bt = at), at - Bt + 1 === we) return Bt * k;
          } else Bt !== -1 && (at -= at - Bt), Bt = -1;
        } else for (E + we > X && (E = X - we), at = E; at >= 0; at--) {
          let Bt = true;
          for (let ct = 0; ct < we; ct++) if (et(T, at + ct) !== et(m, ct)) {
            Bt = false;
            break;
          }
          if (Bt) return at;
        }
        return -1;
      }
      a.prototype.includes = function(m, E, b) {
        return this.indexOf(m, E, b) !== -1;
      }, a.prototype.indexOf = function(m, E, b) {
        return C(this, m, E, b, true);
      }, a.prototype.lastIndexOf = function(m, E, b) {
        return C(this, m, E, b, false);
      };
      function F(T, m, E, b) {
        E = Number(E) || 0;
        const M = T.length - E;
        b ? (b = Number(b), b > M && (b = M)) : b = M;
        const k = m.length;
        b > k / 2 && (b = k / 2);
        let X;
        for (X = 0; X < b; ++X) {
          const we = parseInt(m.substr(X * 2, 2), 16);
          if (Mi(we)) return X;
          T[E + X] = we;
        }
        return X;
      }
      function K(T, m, E, b) {
        return Lo(ic(m, T.length - E), T, E, b);
      }
      function L(T, m, E, b) {
        return Lo(Ou(m), T, E, b);
      }
      function H(T, m, E, b) {
        return Lo(Hl(m), T, E, b);
      }
      function W(T, m, E, b) {
        return Lo(oc(m, T.length - E), T, E, b);
      }
      a.prototype.write = function(m, E, b, M) {
        if (E === void 0) M = "utf8", b = this.length, E = 0;
        else if (b === void 0 && typeof E === "string") M = E, b = this.length, E = 0;
        else if (isFinite(E)) E = E >>> 0, isFinite(b) ? (b = b >>> 0, M === void 0 && (M = "utf8")) : (M = b, b = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const k = this.length - E;
        if ((b === void 0 || b > k) && (b = k), m.length > 0 && (b < 0 || E < 0) || E > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        M || (M = "utf8");
        let X = false;
        for (; ; ) switch (M) {
          case "hex":
            return F(this, m, E, b);
          case "utf8":
          case "utf-8":
            return K(this, m, E, b);
          case "ascii":
          case "latin1":
          case "binary":
            return L(this, m, E, b);
          case "base64":
            return H(this, m, E, b);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return W(this, m, E, b);
          default:
            if (X) throw new TypeError("Unknown encoding: " + M);
            M = ("" + M).toLowerCase(), X = true;
        }
      }, a.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      function z(T, m, E) {
        return m === 0 && E === T.length ? e.fromByteArray(T) : e.fromByteArray(T.slice(m, E));
      }
      function $(T, m, E) {
        E = Math.min(T.length, E);
        const b = [];
        let M = m;
        for (; M < E; ) {
          const k = T[M];
          let X = null, we = k > 239 ? 4 : k > 223 ? 3 : k > 191 ? 2 : 1;
          if (M + we <= E) {
            let et, at, Bt, ct;
            switch (we) {
              case 1:
                k < 128 && (X = k);
                break;
              case 2:
                et = T[M + 1], (et & 192) === 128 && (ct = (k & 31) << 6 | et & 63, ct > 127 && (X = ct));
                break;
              case 3:
                et = T[M + 1], at = T[M + 2], (et & 192) === 128 && (at & 192) === 128 && (ct = (k & 15) << 12 | (et & 63) << 6 | at & 63, ct > 2047 && (ct < 55296 || ct > 57343) && (X = ct));
                break;
              case 4:
                et = T[M + 1], at = T[M + 2], Bt = T[M + 3], (et & 192) === 128 && (at & 192) === 128 && (Bt & 192) === 128 && (ct = (k & 15) << 18 | (et & 63) << 12 | (at & 63) << 6 | Bt & 63, ct > 65535 && ct < 1114112 && (X = ct));
            }
          }
          X === null ? (X = 65533, we = 1) : X > 65535 && (X -= 65536, b.push(X >>> 10 & 1023 | 55296), X = 56320 | X & 1023), b.push(X), M += we;
        }
        return ie(b);
      }
      const q = 4096;
      function ie(T) {
        const m = T.length;
        if (m <= q) return String.fromCharCode.apply(String, T);
        let E = "", b = 0;
        for (; b < m; ) E += String.fromCharCode.apply(String, T.slice(b, b += q));
        return E;
      }
      function ge(T, m, E) {
        let b = "";
        E = Math.min(T.length, E);
        for (let M = m; M < E; ++M) b += String.fromCharCode(T[M] & 127);
        return b;
      }
      function Ae(T, m, E) {
        let b = "";
        E = Math.min(T.length, E);
        for (let M = m; M < E; ++M) b += String.fromCharCode(T[M]);
        return b;
      }
      function he(T, m, E) {
        const b = T.length;
        (!m || m < 0) && (m = 0), (!E || E < 0 || E > b) && (E = b);
        let M = "";
        for (let k = m; k < E; ++k) M += Q[T[k]];
        return M;
      }
      function x(T, m, E) {
        const b = T.slice(m, E);
        let M = "";
        for (let k = 0; k < b.length - 1; k += 2) M += String.fromCharCode(b[k] + b[k + 1] * 256);
        return M;
      }
      a.prototype.slice = function(m, E) {
        const b = this.length;
        m = ~~m, E = E === void 0 ? b : ~~E, m < 0 ? (m += b, m < 0 && (m = 0)) : m > b && (m = b), E < 0 ? (E += b, E < 0 && (E = 0)) : E > b && (E = b), E < m && (E = m);
        const M = this.subarray(m, E);
        return Object.setPrototypeOf(M, a.prototype), M;
      };
      function ce(T, m, E) {
        if (T % 1 !== 0 || T < 0) throw new RangeError("offset is not uint");
        if (T + m > E) throw new RangeError("Trying to access beyond buffer length");
      }
      a.prototype.readUintLE = a.prototype.readUIntLE = function(m, E, b) {
        m = m >>> 0, E = E >>> 0, b || ce(m, E, this.length);
        let M = this[m], k = 1, X = 0;
        for (; ++X < E && (k *= 256); ) M += this[m + X] * k;
        return M;
      }, a.prototype.readUintBE = a.prototype.readUIntBE = function(m, E, b) {
        m = m >>> 0, E = E >>> 0, b || ce(m, E, this.length);
        let M = this[m + --E], k = 1;
        for (; E > 0 && (k *= 256); ) M += this[m + --E] * k;
        return M;
      }, a.prototype.readUint8 = a.prototype.readUInt8 = function(m, E) {
        return m = m >>> 0, E || ce(m, 1, this.length), this[m];
      }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(m, E) {
        return m = m >>> 0, E || ce(m, 2, this.length), this[m] | this[m + 1] << 8;
      }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(m, E) {
        return m = m >>> 0, E || ce(m, 2, this.length), this[m] << 8 | this[m + 1];
      }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(m, E) {
        return m = m >>> 0, E || ce(m, 4, this.length), (this[m] | this[m + 1] << 8 | this[m + 2] << 16) + this[m + 3] * 16777216;
      }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(m, E) {
        return m = m >>> 0, E || ce(m, 4, this.length), this[m] * 16777216 + (this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3]);
      }, a.prototype.readBigUInt64LE = te(function(m) {
        m = m >>> 0, tt(m, "offset");
        const E = this[m], b = this[m + 7];
        (E === void 0 || b === void 0) && yt(m, this.length - 8);
        const M = E + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + this[++m] * 2 ** 24, k = this[++m] + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + b * 2 ** 24;
        return BigInt(M) + (BigInt(k) << BigInt(32));
      }), a.prototype.readBigUInt64BE = te(function(m) {
        m = m >>> 0, tt(m, "offset");
        const E = this[m], b = this[m + 7];
        (E === void 0 || b === void 0) && yt(m, this.length - 8);
        const M = E * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + this[++m], k = this[++m] * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + b;
        return (BigInt(M) << BigInt(32)) + BigInt(k);
      }), a.prototype.readIntLE = function(m, E, b) {
        m = m >>> 0, E = E >>> 0, b || ce(m, E, this.length);
        let M = this[m], k = 1, X = 0;
        for (; ++X < E && (k *= 256); ) M += this[m + X] * k;
        return k *= 128, M >= k && (M -= Math.pow(2, 8 * E)), M;
      }, a.prototype.readIntBE = function(m, E, b) {
        m = m >>> 0, E = E >>> 0, b || ce(m, E, this.length);
        let M = E, k = 1, X = this[m + --M];
        for (; M > 0 && (k *= 256); ) X += this[m + --M] * k;
        return k *= 128, X >= k && (X -= Math.pow(2, 8 * E)), X;
      }, a.prototype.readInt8 = function(m, E) {
        return m = m >>> 0, E || ce(m, 1, this.length), this[m] & 128 ? (255 - this[m] + 1) * -1 : this[m];
      }, a.prototype.readInt16LE = function(m, E) {
        m = m >>> 0, E || ce(m, 2, this.length);
        const b = this[m] | this[m + 1] << 8;
        return b & 32768 ? b | 4294901760 : b;
      }, a.prototype.readInt16BE = function(m, E) {
        m = m >>> 0, E || ce(m, 2, this.length);
        const b = this[m + 1] | this[m] << 8;
        return b & 32768 ? b | 4294901760 : b;
      }, a.prototype.readInt32LE = function(m, E) {
        return m = m >>> 0, E || ce(m, 4, this.length), this[m] | this[m + 1] << 8 | this[m + 2] << 16 | this[m + 3] << 24;
      }, a.prototype.readInt32BE = function(m, E) {
        return m = m >>> 0, E || ce(m, 4, this.length), this[m] << 24 | this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3];
      }, a.prototype.readBigInt64LE = te(function(m) {
        m = m >>> 0, tt(m, "offset");
        const E = this[m], b = this[m + 7];
        (E === void 0 || b === void 0) && yt(m, this.length - 8);
        const M = this[m + 4] + this[m + 5] * 2 ** 8 + this[m + 6] * 2 ** 16 + (b << 24);
        return (BigInt(M) << BigInt(32)) + BigInt(E + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + this[++m] * 2 ** 24);
      }), a.prototype.readBigInt64BE = te(function(m) {
        m = m >>> 0, tt(m, "offset");
        const E = this[m], b = this[m + 7];
        (E === void 0 || b === void 0) && yt(m, this.length - 8);
        const M = (E << 24) + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + this[++m];
        return (BigInt(M) << BigInt(32)) + BigInt(this[++m] * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + b);
      }), a.prototype.readFloatLE = function(m, E) {
        return m = m >>> 0, E || ce(m, 4, this.length), t.read(this, m, true, 23, 4);
      }, a.prototype.readFloatBE = function(m, E) {
        return m = m >>> 0, E || ce(m, 4, this.length), t.read(this, m, false, 23, 4);
      }, a.prototype.readDoubleLE = function(m, E) {
        return m = m >>> 0, E || ce(m, 8, this.length), t.read(this, m, true, 52, 8);
      }, a.prototype.readDoubleBE = function(m, E) {
        return m = m >>> 0, E || ce(m, 8, this.length), t.read(this, m, false, 52, 8);
      };
      function de(T, m, E, b, M, k) {
        if (!a.isBuffer(T)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (m > M || m < k) throw new RangeError('"value" argument is out of bounds');
        if (E + b > T.length) throw new RangeError("Index out of range");
      }
      a.prototype.writeUintLE = a.prototype.writeUIntLE = function(m, E, b, M) {
        if (m = +m, E = E >>> 0, b = b >>> 0, !M) {
          const we = Math.pow(2, 8 * b) - 1;
          de(this, m, E, b, we, 0);
        }
        let k = 1, X = 0;
        for (this[E] = m & 255; ++X < b && (k *= 256); ) this[E + X] = m / k & 255;
        return E + b;
      }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(m, E, b, M) {
        if (m = +m, E = E >>> 0, b = b >>> 0, !M) {
          const we = Math.pow(2, 8 * b) - 1;
          de(this, m, E, b, we, 0);
        }
        let k = b - 1, X = 1;
        for (this[E + k] = m & 255; --k >= 0 && (X *= 256); ) this[E + k] = m / X & 255;
        return E + b;
      }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(m, E, b) {
        return m = +m, E = E >>> 0, b || de(this, m, E, 1, 255, 0), this[E] = m & 255, E + 1;
      }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(m, E, b) {
        return m = +m, E = E >>> 0, b || de(this, m, E, 2, 65535, 0), this[E] = m & 255, this[E + 1] = m >>> 8, E + 2;
      }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(m, E, b) {
        return m = +m, E = E >>> 0, b || de(this, m, E, 2, 65535, 0), this[E] = m >>> 8, this[E + 1] = m & 255, E + 2;
      }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(m, E, b) {
        return m = +m, E = E >>> 0, b || de(this, m, E, 4, 4294967295, 0), this[E + 3] = m >>> 24, this[E + 2] = m >>> 16, this[E + 1] = m >>> 8, this[E] = m & 255, E + 4;
      }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(m, E, b) {
        return m = +m, E = E >>> 0, b || de(this, m, E, 4, 4294967295, 0), this[E] = m >>> 24, this[E + 1] = m >>> 16, this[E + 2] = m >>> 8, this[E + 3] = m & 255, E + 4;
      };
      function ke(T, m, E, b, M) {
        Qe(m, b, M, T, E, 7);
        let k = Number(m & BigInt(4294967295));
        T[E++] = k, k = k >> 8, T[E++] = k, k = k >> 8, T[E++] = k, k = k >> 8, T[E++] = k;
        let X = Number(m >> BigInt(32) & BigInt(4294967295));
        return T[E++] = X, X = X >> 8, T[E++] = X, X = X >> 8, T[E++] = X, X = X >> 8, T[E++] = X, E;
      }
      function pe(T, m, E, b, M) {
        Qe(m, b, M, T, E, 7);
        let k = Number(m & BigInt(4294967295));
        T[E + 7] = k, k = k >> 8, T[E + 6] = k, k = k >> 8, T[E + 5] = k, k = k >> 8, T[E + 4] = k;
        let X = Number(m >> BigInt(32) & BigInt(4294967295));
        return T[E + 3] = X, X = X >> 8, T[E + 2] = X, X = X >> 8, T[E + 1] = X, X = X >> 8, T[E] = X, E + 8;
      }
      a.prototype.writeBigUInt64LE = te(function(m, E = 0) {
        return ke(this, m, E, BigInt(0), BigInt("0xffffffffffffffff"));
      }), a.prototype.writeBigUInt64BE = te(function(m, E = 0) {
        return pe(this, m, E, BigInt(0), BigInt("0xffffffffffffffff"));
      }), a.prototype.writeIntLE = function(m, E, b, M) {
        if (m = +m, E = E >>> 0, !M) {
          const et = Math.pow(2, 8 * b - 1);
          de(this, m, E, b, et - 1, -et);
        }
        let k = 0, X = 1, we = 0;
        for (this[E] = m & 255; ++k < b && (X *= 256); ) m < 0 && we === 0 && this[E + k - 1] !== 0 && (we = 1), this[E + k] = (m / X >> 0) - we & 255;
        return E + b;
      }, a.prototype.writeIntBE = function(m, E, b, M) {
        if (m = +m, E = E >>> 0, !M) {
          const et = Math.pow(2, 8 * b - 1);
          de(this, m, E, b, et - 1, -et);
        }
        let k = b - 1, X = 1, we = 0;
        for (this[E + k] = m & 255; --k >= 0 && (X *= 256); ) m < 0 && we === 0 && this[E + k + 1] !== 0 && (we = 1), this[E + k] = (m / X >> 0) - we & 255;
        return E + b;
      }, a.prototype.writeInt8 = function(m, E, b) {
        return m = +m, E = E >>> 0, b || de(this, m, E, 1, 127, -128), m < 0 && (m = 255 + m + 1), this[E] = m & 255, E + 1;
      }, a.prototype.writeInt16LE = function(m, E, b) {
        return m = +m, E = E >>> 0, b || de(this, m, E, 2, 32767, -32768), this[E] = m & 255, this[E + 1] = m >>> 8, E + 2;
      }, a.prototype.writeInt16BE = function(m, E, b) {
        return m = +m, E = E >>> 0, b || de(this, m, E, 2, 32767, -32768), this[E] = m >>> 8, this[E + 1] = m & 255, E + 2;
      }, a.prototype.writeInt32LE = function(m, E, b) {
        return m = +m, E = E >>> 0, b || de(this, m, E, 4, 2147483647, -2147483648), this[E] = m & 255, this[E + 1] = m >>> 8, this[E + 2] = m >>> 16, this[E + 3] = m >>> 24, E + 4;
      }, a.prototype.writeInt32BE = function(m, E, b) {
        return m = +m, E = E >>> 0, b || de(this, m, E, 4, 2147483647, -2147483648), m < 0 && (m = 4294967295 + m + 1), this[E] = m >>> 24, this[E + 1] = m >>> 16, this[E + 2] = m >>> 8, this[E + 3] = m & 255, E + 4;
      }, a.prototype.writeBigInt64LE = te(function(m, E = 0) {
        return ke(this, m, E, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), a.prototype.writeBigInt64BE = te(function(m, E = 0) {
        return pe(this, m, E, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function j(T, m, E, b, M, k) {
        if (E + b > T.length) throw new RangeError("Index out of range");
        if (E < 0) throw new RangeError("Index out of range");
      }
      function re(T, m, E, b, M) {
        return m = +m, E = E >>> 0, M || j(T, m, E, 4), t.write(T, m, E, b, 23, 4), E + 4;
      }
      a.prototype.writeFloatLE = function(m, E, b) {
        return re(this, m, E, true, b);
      }, a.prototype.writeFloatBE = function(m, E, b) {
        return re(this, m, E, false, b);
      };
      function se(T, m, E, b, M) {
        return m = +m, E = E >>> 0, M || j(T, m, E, 8), t.write(T, m, E, b, 52, 8), E + 8;
      }
      a.prototype.writeDoubleLE = function(m, E, b) {
        return se(this, m, E, true, b);
      }, a.prototype.writeDoubleBE = function(m, E, b) {
        return se(this, m, E, false, b);
      }, a.prototype.copy = function(m, E, b, M) {
        if (!a.isBuffer(m)) throw new TypeError("argument should be a Buffer");
        if (b || (b = 0), !M && M !== 0 && (M = this.length), E >= m.length && (E = m.length), E || (E = 0), M > 0 && M < b && (M = b), M === b || m.length === 0 || this.length === 0) return 0;
        if (E < 0) throw new RangeError("targetStart out of bounds");
        if (b < 0 || b >= this.length) throw new RangeError("Index out of range");
        if (M < 0) throw new RangeError("sourceEnd out of bounds");
        M > this.length && (M = this.length), m.length - E < M - b && (M = m.length - E + b);
        const k = M - b;
        return this === m && typeof Uint8Array.prototype.copyWithin === "function" ? this.copyWithin(E, b, M) : Uint8Array.prototype.set.call(m, this.subarray(b, M), E), k;
      }, a.prototype.fill = function(m, E, b, M) {
        if (typeof m === "string") {
          if (typeof E === "string" ? (M = E, E = 0, b = this.length) : typeof b === "string" && (M = b, b = this.length), M !== void 0 && typeof M !== "string") throw new TypeError("encoding must be a string");
          if (typeof M === "string" && !a.isEncoding(M)) throw new TypeError("Unknown encoding: " + M);
          if (m.length === 1) {
            const X = m.charCodeAt(0);
            (M === "utf8" && X < 128 || M === "latin1") && (m = X);
          }
        } else typeof m === "number" ? m = m & 255 : typeof m === "boolean" && (m = Number(m));
        if (E < 0 || this.length < E || this.length < b) throw new RangeError("Out of range index");
        if (b <= E) return this;
        E = E >>> 0, b = b === void 0 ? this.length : b >>> 0, m || (m = 0);
        let k;
        if (typeof m === "number") for (k = E; k < b; ++k) this[k] = m;
        else {
          const X = a.isBuffer(m) ? m : a.from(m, M), we = X.length;
          if (we === 0) throw new TypeError('The value "' + m + '" is invalid for argument "value"');
          for (k = 0; k < b - E; ++k) this[k + E] = X[k % we];
        }
        return this;
      };
      const ae = {};
      function le(T, m, E) {
        ae[T] = class extends E {
          constructor() {
            super(), Object.defineProperty(this, "message", { value: m.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${T}]`, this.stack, delete this.name;
          }
          get code() {
            return T;
          }
          set code(M) {
            Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: M, writable: true });
          }
          toString() {
            return `${this.name} [${T}]: ${this.message}`;
          }
        };
      }
      le("ERR_BUFFER_OUT_OF_BOUNDS", function(T) {
        return T ? `${T} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      }, RangeError), le("ERR_INVALID_ARG_TYPE", function(T, m) {
        return `The "${T}" argument must be of type number. Received type ${typeof m}`;
      }, TypeError), le("ERR_OUT_OF_RANGE", function(T, m, E) {
        let b = `The value of "${T}" is out of range.`, M = E;
        return Number.isInteger(E) && Math.abs(E) > 2 ** 32 ? M = Pe(String(E)) : typeof E === "bigint" && (M = String(E), (E > BigInt(2) ** BigInt(32) || E < -(BigInt(2) ** BigInt(32))) && (M = Pe(M)), M += "n"), b += ` It must be ${m}. Received ${M}`, b;
      }, RangeError);
      function Pe(T) {
        let m = "", E = T.length;
        const b = T[0] === "-" ? 1 : 0;
        for (; E >= b + 4; E -= 3) m = `_${T.slice(E - 3, E)}${m}`;
        return `${T.slice(0, E)}${m}`;
      }
      function Ke(T, m, E) {
        tt(m, "offset"), (T[m] === void 0 || T[m + E] === void 0) && yt(m, T.length - (E + 1));
      }
      function Qe(T, m, E, b, M, k) {
        if (T > E || T < m) {
          const X = typeof m === "bigint" ? "n" : "";
          let we;
          throw k > 3 ? m === 0 || m === BigInt(0) ? we = `>= 0${X} and < 2${X} ** ${(k + 1) * 8}${X}` : we = `>= -(2${X} ** ${(k + 1) * 8 - 1}${X}) and < 2 ** ${(k + 1) * 8 - 1}${X}` : we = `>= ${m}${X} and <= ${E}${X}`, new ae.ERR_OUT_OF_RANGE("value", we, T);
        }
        Ke(b, M, k);
      }
      function tt(T, m) {
        if (typeof T !== "number") throw new ae.ERR_INVALID_ARG_TYPE(m, "number", T);
      }
      function yt(T, m, E) {
        throw Math.floor(T) !== T ? (tt(T, E), new ae.ERR_OUT_OF_RANGE(E || "offset", "an integer", T)) : m < 0 ? new ae.ERR_BUFFER_OUT_OF_BOUNDS() : new ae.ERR_OUT_OF_RANGE(E || "offset", `>= ${E ? 1 : 0} and <= ${m}`, T);
      }
      const jt = /[^+/0-9A-Za-z-_]/g;
      function xu(T) {
        if (T = T.split("=")[0], T = T.trim().replace(jt, ""), T.length < 2) return "";
        for (; T.length % 4 !== 0; ) T = T + "=";
        return T;
      }
      function ic(T, m) {
        m = m || 1 / 0;
        let E;
        const b = T.length;
        let M = null;
        const k = [];
        for (let X = 0; X < b; ++X) {
          if (E = T.charCodeAt(X), E > 55295 && E < 57344) {
            if (!M) {
              if (E > 56319) {
                (m -= 3) > -1 && k.push(239, 191, 189);
                continue;
              } else if (X + 1 === b) {
                (m -= 3) > -1 && k.push(239, 191, 189);
                continue;
              }
              M = E;
              continue;
            }
            if (E < 56320) {
              (m -= 3) > -1 && k.push(239, 191, 189), M = E;
              continue;
            }
            E = (M - 55296 << 10 | E - 56320) + 65536;
          } else M && (m -= 3) > -1 && k.push(239, 191, 189);
          if (M = null, E < 128) {
            if ((m -= 1) < 0) break;
            k.push(E);
          } else if (E < 2048) {
            if ((m -= 2) < 0) break;
            k.push(E >> 6 | 192, E & 63 | 128);
          } else if (E < 65536) {
            if ((m -= 3) < 0) break;
            k.push(E >> 12 | 224, E >> 6 & 63 | 128, E & 63 | 128);
          } else if (E < 1114112) {
            if ((m -= 4) < 0) break;
            k.push(E >> 18 | 240, E >> 12 & 63 | 128, E >> 6 & 63 | 128, E & 63 | 128);
          } else throw new Error("Invalid code point");
        }
        return k;
      }
      function Ou(T) {
        const m = [];
        for (let E = 0; E < T.length; ++E) m.push(T.charCodeAt(E) & 255);
        return m;
      }
      function oc(T, m) {
        let E, b, M;
        const k = [];
        for (let X = 0; X < T.length && !((m -= 2) < 0); ++X) E = T.charCodeAt(X), b = E >> 8, M = E % 256, k.push(M), k.push(b);
        return k;
      }
      function Hl(T) {
        return e.toByteArray(xu(T));
      }
      function Lo(T, m, E, b) {
        let M;
        for (M = 0; M < b && !(M + E >= m.length || M >= T.length); ++M) m[M + E] = T[M];
        return M;
      }
      function hn(T, m) {
        return T instanceof m || T != null && T.constructor != null && T.constructor.name != null && T.constructor.name === m.name;
      }
      function Mi(T) {
        return T !== T;
      }
      const Q = (function() {
        const T = "0123456789abcdef", m = new Array(256);
        for (let E = 0; E < 16; ++E) {
          const b = E * 16;
          for (let M = 0; M < 16; ++M) m[b + M] = T[E] + T[M];
        }
        return m;
      })();
      function te(T) {
        return typeof BigInt > "u" ? ue : T;
      }
      function ue() {
        throw new Error("BigInt not supported");
      }
    })(rs);
    const lE = hE;
    function hE(i, e) {
      for (var t = new Array(arguments.length - 1), r = 0, n = 2, s = true; n < arguments.length; ) t[r++] = arguments[n++];
      return new Promise(function(a, p) {
        t[r] = function(f) {
          if (s) if (s = false, f) p(f);
          else {
            for (var g = new Array(arguments.length - 1), d = 0; d < g.length; ) g[d++] = arguments[d];
            a.apply(null, g);
          }
        };
        try {
          i.apply(e || null, t);
        } catch (h) {
          s && (s = false, p(h));
        }
      });
    }
    const uE = mo(lE);
    const fE = fu;
    function fu() {
      this._listeners = {};
    }
    fu.prototype.on = function(e, t, r) {
      return (this._listeners[e] || (this._listeners[e] = [])).push({ fn: t, ctx: r || this }), this;
    };
    fu.prototype.off = function(e, t) {
      if (e === void 0) this._listeners = {};
      else if (t === void 0) this._listeners[e] = [];
      else for (let r = this._listeners[e], n = 0; n < r.length; ) r[n].fn === t ? r.splice(n, 1) : ++n;
      return this;
    };
    fu.prototype.emit = function(e) {
      const t = this._listeners[e];
      if (t) {
        for (var r = [], n = 1; n < arguments.length; ) r.push(arguments[n++]);
        for (n = 0; n < t.length; ) t[n].fn.apply(t[n++].ctx, r);
      }
      return this;
    };
    const gE = mo(fE);
    const dE = Gy(Gy);
    function Gy(i) {
      return typeof Float32Array < "u" ? (function() {
        const e = new Float32Array([-0]), t = new Uint8Array(e.buffer), r = t[3] === 128;
        function n(p, h, f) {
          e[0] = p, h[f] = t[0], h[f + 1] = t[1], h[f + 2] = t[2], h[f + 3] = t[3];
        }
        function s(p, h, f) {
          e[0] = p, h[f] = t[3], h[f + 1] = t[2], h[f + 2] = t[1], h[f + 3] = t[0];
        }
        i.writeFloatLE = r ? n : s, i.writeFloatBE = r ? s : n;
        function o(p, h) {
          return t[0] = p[h], t[1] = p[h + 1], t[2] = p[h + 2], t[3] = p[h + 3], e[0];
        }
        function a(p, h) {
          return t[3] = p[h], t[2] = p[h + 1], t[1] = p[h + 2], t[0] = p[h + 3], e[0];
        }
        i.readFloatLE = r ? o : a, i.readFloatBE = r ? a : o;
      })() : (function() {
        function e(r, n, s, o) {
          const a = n < 0 ? 1 : 0;
          if (a && (n = -n), n === 0) r(1 / n > 0 ? 0 : 2147483648, s, o);
          else if (isNaN(n)) r(2143289344, s, o);
          else if (n > 34028234663852886e22) r((a << 31 | 2139095040) >>> 0, s, o);
          else if (n < 11754943508222875e-54) r((a << 31 | Math.round(n / 1401298464324817e-60)) >>> 0, s, o);
          else {
            const p = Math.floor(Math.log(n) / Math.LN2), h = Math.round(n * Math.pow(2, -p) * 8388608) & 8388607;
            r((a << 31 | p + 127 << 23 | h) >>> 0, s, o);
          }
        }
        i.writeFloatLE = e.bind(null, Ky), i.writeFloatBE = e.bind(null, zy);
        function t(r, n, s) {
          const o = r(n, s), a = (o >> 31) * 2 + 1, p = o >>> 23 & 255, h = o & 8388607;
          return p === 255 ? h ? NaN : a * (1 / 0) : p === 0 ? a * 1401298464324817e-60 * h : a * Math.pow(2, p - 150) * (h + 8388608);
        }
        i.readFloatLE = t.bind(null, jy), i.readFloatBE = t.bind(null, Jy);
      })(), typeof Float64Array < "u" ? (function() {
        const e = new Float64Array([-0]), t = new Uint8Array(e.buffer), r = t[7] === 128;
        function n(p, h, f) {
          e[0] = p, h[f] = t[0], h[f + 1] = t[1], h[f + 2] = t[2], h[f + 3] = t[3], h[f + 4] = t[4], h[f + 5] = t[5], h[f + 6] = t[6], h[f + 7] = t[7];
        }
        function s(p, h, f) {
          e[0] = p, h[f] = t[7], h[f + 1] = t[6], h[f + 2] = t[5], h[f + 3] = t[4], h[f + 4] = t[3], h[f + 5] = t[2], h[f + 6] = t[1], h[f + 7] = t[0];
        }
        i.writeDoubleLE = r ? n : s, i.writeDoubleBE = r ? s : n;
        function o(p, h) {
          return t[0] = p[h], t[1] = p[h + 1], t[2] = p[h + 2], t[3] = p[h + 3], t[4] = p[h + 4], t[5] = p[h + 5], t[6] = p[h + 6], t[7] = p[h + 7], e[0];
        }
        function a(p, h) {
          return t[7] = p[h], t[6] = p[h + 1], t[5] = p[h + 2], t[4] = p[h + 3], t[3] = p[h + 4], t[2] = p[h + 5], t[1] = p[h + 6], t[0] = p[h + 7], e[0];
        }
        i.readDoubleLE = r ? o : a, i.readDoubleBE = r ? a : o;
      })() : (function() {
        function e(r, n, s, o, a, p) {
          const h = o < 0 ? 1 : 0;
          if (h && (o = -o), o === 0) r(0, a, p + n), r(1 / o > 0 ? 0 : 2147483648, a, p + s);
          else if (isNaN(o)) r(0, a, p + n), r(2146959360, a, p + s);
          else if (o > 17976931348623157e292) r(0, a, p + n), r((h << 31 | 2146435072) >>> 0, a, p + s);
          else {
            let f;
            if (o < 22250738585072014e-324) f = o / 5e-324, r(f >>> 0, a, p + n), r((h << 31 | f / 4294967296) >>> 0, a, p + s);
            else {
              let g = Math.floor(Math.log(o) / Math.LN2);
              g === 1024 && (g = 1023), f = o * Math.pow(2, -g), r(f * 4503599627370496 >>> 0, a, p + n), r((h << 31 | g + 1023 << 20 | f * 1048576 & 1048575) >>> 0, a, p + s);
            }
          }
        }
        i.writeDoubleLE = e.bind(null, Ky, 0, 4), i.writeDoubleBE = e.bind(null, zy, 4, 0);
        function t(r, n, s, o, a) {
          const p = r(o, a + n), h = r(o, a + s), f = (h >> 31) * 2 + 1, g = h >>> 20 & 2047, d = 4294967296 * (h & 1048575) + p;
          return g === 2047 ? d ? NaN : f * (1 / 0) : g === 0 ? f * 5e-324 * d : f * Math.pow(2, g - 1075) * (d + 4503599627370496);
        }
        i.readDoubleLE = t.bind(null, jy, 0, 4), i.readDoubleBE = t.bind(null, Jy, 4, 0);
      })(), i;
    }
    function Ky(i, e, t) {
      e[t] = i & 255, e[t + 1] = i >>> 8 & 255, e[t + 2] = i >>> 16 & 255, e[t + 3] = i >>> 24;
    }
    function zy(i, e, t) {
      e[t] = i >>> 24, e[t + 1] = i >>> 16 & 255, e[t + 2] = i >>> 8 & 255, e[t + 3] = i & 255;
    }
    function jy(i, e) {
      return (i[e] | i[e + 1] << 8 | i[e + 2] << 16 | i[e + 3] << 24) >>> 0;
    }
    function Jy(i, e) {
      return (i[e] << 24 | i[e + 1] << 16 | i[e + 2] << 8 | i[e + 3]) >>> 0;
    }
    const yE = mo(dE);
    const $_ = {};
    (function(i) {
      const e = i;
      e.length = function(r) {
        for (var n = 0, s = 0, o = 0; o < r.length; ++o) s = r.charCodeAt(o), s < 128 ? n += 1 : s < 2048 ? n += 2 : (s & 64512) === 55296 && (r.charCodeAt(o + 1) & 64512) === 56320 ? (++o, n += 4) : n += 3;
        return n;
      }, e.read = function(r, n, s) {
        const o = s - n;
        if (o < 1) return "";
        for (var a = null, p = [], h = 0, f; n < s; ) f = r[n++], f < 128 ? p[h++] = f : f > 191 && f < 224 ? p[h++] = (f & 31) << 6 | r[n++] & 63 : f > 239 && f < 365 ? (f = ((f & 7) << 18 | (r[n++] & 63) << 12 | (r[n++] & 63) << 6 | r[n++] & 63) - 65536, p[h++] = 55296 + (f >> 10), p[h++] = 56320 + (f & 1023)) : p[h++] = (f & 15) << 12 | (r[n++] & 63) << 6 | r[n++] & 63, h > 8191 && ((a || (a = [])).push(String.fromCharCode.apply(String, p)), h = 0);
        return a ? (h && a.push(String.fromCharCode.apply(String, p.slice(0, h))), a.join("")) : String.fromCharCode.apply(String, p.slice(0, h));
      }, e.write = function(r, n, s) {
        for (var o = s, a, p, h = 0; h < r.length; ++h) a = r.charCodeAt(h), a < 128 ? n[s++] = a : a < 2048 ? (n[s++] = a >> 6 | 192, n[s++] = a & 63 | 128) : (a & 64512) === 55296 && ((p = r.charCodeAt(h + 1)) & 64512) === 56320 ? (a = 65536 + ((a & 1023) << 10) + (p & 1023), ++h, n[s++] = a >> 18 | 240, n[s++] = a >> 12 & 63 | 128, n[s++] = a >> 6 & 63 | 128, n[s++] = a & 63 | 128) : (n[s++] = a >> 12 | 224, n[s++] = a >> 6 & 63 | 128, n[s++] = a & 63 | 128);
        return s - o;
      };
    })($_);
    const mE = mo($_);
    const _E = AE;
    function AE(i, e, t) {
      let r = t || 8192, n = r >>> 1, s = null, o = r;
      return function(p) {
        if (p < 1 || p > n) return i(p);
        o + p > r && (s = i(r), o = 0);
        const h = e.call(s, o, o += p);
        return o & 7 && (o = (o | 7) + 1), h;
      };
    }
    const EE = mo(_E);
    function U_(i, e, t = false) {
      for (let r = Object.keys(e), n = 0; n < r.length; ++n) (i[r[n]] === void 0 || !t) && (i[r[n]] = e[r[n]]);
      return i;
    }
    function Yy(i) {
      function e(t, r) {
        if (!(this instanceof e)) return new e(t, r);
        Object.defineProperty(this, "message", { get: function() {
          return t;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, e) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), r && U_(this, r);
      }
      return (e.prototype = Object.create(Error.prototype)).constructor = e, Object.defineProperty(e.prototype, "name", { get: function() {
        return i;
      } }), e.prototype.toString = function() {
        return this.name + ": " + this.message;
      }, e;
    }
    const He = { asPromise: uE, base64: mf, EventEmitter: gE, float: yE, utf8: mE, pool: EE, emptyArray: Object.freeze ? Object.freeze([]) : [], emptyBytes: new Uint8Array(), emptyObject: Object.freeze ? Object.freeze({}) : {}, isInteger: Number.isInteger || function(e) {
      return typeof e === "number" && isFinite(e) && Math.floor(e) === e;
    }, isString: function(e) {
      return typeof e === "string" || e instanceof String;
    }, isObject: function(e) {
      return e && typeof e === "object";
    }, get isset() {
      return this.isSet;
    }, isSet(i, e) {
      const t = i[e];
      return t != null && i.hasOwnProperty(e) ? typeof t !== "object" || (Array.isArray(t) ? t.length : Object.keys(t).length) > 0 : false;
    }, Buffer: (function() {
      return rs.Buffer.prototype.utf8Write ? rs.Buffer : null;
    })(), newBuffer: function(e) {
      return typeof e === "number" ? He.Buffer ? He._Buffer_allocUnsafe(e) : new He.Array(e) : He.Buffer ? He._Buffer_from(e) : typeof Uint8Array > "u" ? e : new Uint8Array(e);
    }, Array: typeof Uint8Array < "u" ? Uint8Array : Array, Long: zt, key2Re: /^true|false|0|1$/, key32Re: /^-?(?:0|[1-9][0-9]*)$/, key64Re: /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, merge: U_, lcFirst(i) {
      return i.charAt(0).toLowerCase() + i.substring(1);
    }, newError: Yy, ProtocolError: Yy("ProtocolError"), oneOfGetter: function(e) {
      for (var t = {}, r = 0; r < e.length; ++r) t[e[r]] = 1;
      return function() {
        for (let n = Object.keys(this), s = n.length - 1; s > -1; --s) if (t[n[s]] === 1 && this[n[s]] !== void 0 && this[n[s]] !== null) return n[s];
      };
    }, oneOfSetter: function(e) {
      return function(t) {
        for (let r = 0; r < e.length; ++r) e[r] !== t && delete this[e[r]];
      };
    }, toJSONOptions: { longs: String, enums: String, bytes: String, json: true }, _Buffer_from: null, _Buffer_allocUnsafe: null, _configure2: function() {
      const i = He.Buffer;
      if (!i) {
        He._Buffer_from = He._Buffer_allocUnsafe = null;
        return;
      }
      He._Buffer_from = i.from !== Uint8Array.from && i.from || function(t, r) {
        return new i(t, r);
      }, He._Buffer_allocUnsafe = i.allocUnsafe || function(t) {
        return new i(t);
      };
    }, isReservedId: function(e, t) {
      if (e) {
        for (let r = 0; r < e.length; ++r) if (typeof e[r] !== "string" && e[r][0] <= t && e[r][1] > t) return true;
      }
      return false;
    }, isReservedName: function(e, t) {
      if (e) {
        for (let r = 0; r < e.length; ++r) if (e[r] === t) return true;
      }
      return false;
    } };
    let kl;
    const xs = class _xs {
      constructor(e, t) {
        if (this.name = e, this.options = t, this.resolved = false, this.comment = null, this.filename = null, !He.isString(e)) throw TypeError("name must be a string");
        if (t && !He.isObject(t)) throw TypeError("options must be an object");
        this.options = t, this.name = e, this.parent = null, this.resolved = false, this.comment = null, this.filename = null;
      }
      static _configure(e, t, r, n) {
        kl = e;
      }
      get root() {
        let e = this;
        for (; ; ) if (e && e.parent) e = e.parent;
        else return e;
      }
      get fullName() {
        for (var e = [this.name], t = this.parent; t; ) e.unshift(t.name), t = t.parent;
        return e.join(".");
      }
      onAdd(e) {
        this.parent && this.parent !== e && this.parent.remove(this), this.parent = e, this.resolved = false;
        const t = e.root;
        t instanceof kl && t._handleAdd(this);
      }
      onRemove(e) {
        const t = e.root;
        t instanceof kl && t._handleRemove(this), this.parent = null, this.resolved = false;
      }
      resolve() {
        return this.resolved ? this : (this.root instanceof kl && (this.resolved = true), this);
      }
      getOption(e) {
        if (this.options) return this.options[e];
      }
      setOption(e, t, r = false) {
        return (!r || !this.options || this.options[e] === void 0) && ((this.options || (this.options = {}))[e] = t), this;
      }
      setOptions(e, t = false) {
        if (e) for (let r = Object.keys(e), n = 0; n < r.length; ++n) this.setOption(r[n], e[r[n]], t);
        return this;
      }
      toString() {
        const e = _xs.className, t = this.fullName;
        return t.length ? e + " " + t : e;
      }
    };
    xs.className = "ReflectionObject";
    const IE = ld;
    function ld(i, e) {
      typeof i === "string" && (e = i, i = void 0);
      const t = [];
      function r(s) {
        if (typeof s !== "string") {
          let o = n();
          if (ld.verbose && , o = "return " + o, s) {
            for (var a = Object.keys(s), p = new Array(a.length + 1), h = new Array(a.length), f = 0; f < a.length; ) p[f] = a[f], h[f] = s[a[f++]];
            return p[f] = o, Function.apply(null, p).apply(null, h);
          }
          return Function(o)();
        }
        for (var g = new Array(arguments.length - 1), d = 0; d < g.length; ) g[d] = arguments[++d];
        if (d = 0, s = s.replace(/%([%dfijs])/g, function(_, I) {
          const S = g[d++];
          switch (I) {
            case "d":
            case "f":
              return String(Number(S));
            case "i":
              return String(Math.floor(S));
            case "j":
              return JSON.stringify(S);
            case "s":
              return String(S);
          }
          return "%";
        }), d !== g.length) throw Error("parameter count mismatch");
        return t.push(s), r;
      }
      function n(s) {
        return "function " + (s || e || "") + "(" + (i && i.join(",") || "") + `){
  ` + t.join(`
  `) + `
}`;
      }
      return r.toString = n, r;
    }
    ld.verbose = false;
    const TE = mo(IE);
    const Gt = class _Gt {
      constructor(e, t) {
        this.lo = e >>> 0, this.hi = t >>> 0;
      }
      static fromNumber(e) {
        if (e === 0) return $i;
        const t = e < 0;
        t && (e = -e);
        let r = e >>> 0, n = (e - r) / 4294967296 >>> 0;
        return t && (n = ~n >>> 0, r = ~r >>> 0, ++r > 4294967295 && (r = 0, ++n > 4294967295 && (n = 0))), new _Gt(r, n);
      }
      static from(e) {
        if (typeof e === "number") return _Gt.fromNumber(e);
        if (He.isString(e)) if (He.Long) e = He.Long.fromString(e);
        else return _Gt.fromNumber(parseInt(e, 10));
        const t = e;
        return t.low || t.high ? new _Gt(t.low >>> 0, t.high >>> 0) : $i;
      }
      toNumber(e = false) {
        if (!e && this.hi >>> 31) {
          let t = ~this.lo + 1 >>> 0, r = ~this.hi >>> 0;
          return t || (r = r + 1 >>> 0), -(t + r * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      }
      toLong(e = false) {
        return He.Long ? new He.Long(this.lo | 0, this.hi | 0, !!e) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!e };
      }
      static fromHash(e) {
        if (e === _Gt.zeroHash) return $i;
        const t = String.prototype.charCodeAt;
        return new _Gt((t.call(e, 0) | t.call(e, 1) << 8 | t.call(e, 2) << 16 | t.call(e, 3) << 24) >>> 0, (t.call(e, 4) | t.call(e, 5) << 8 | t.call(e, 6) << 16 | t.call(e, 7) << 24) >>> 0);
      }
      toHash() {
        return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
      }
      zzEncode() {
        const e = this.hi >> 31;
        return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;
      }
      zzDecode() {
        const e = -(this.lo & 1);
        return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;
      }
      length() {
        const e = this.lo, t = (this.lo >>> 28 | this.hi << 4) >>> 0, r = this.hi >>> 24;
        return r === 0 ? t === 0 ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : r < 128 ? 9 : 10;
      }
    };
    Gt.zeroHash = "\0\0\0\0\0\0\0\0";
    const $i = Gt.zero = new Gt(0, 0);
    $i.toNumber = function() {
      return 0;
    };
    $i.zzEncode = $i.zzDecode = function() {
      return this;
    };
    $i.length = function() {
      return 1;
    };
    Gt.zeroHash;
    const Qy = {};
    let Wy;
    let Xy;
    let qy;
    let SE = 0;
    const sa = { _configure: function(i, e, t) {
      Wy = i, Xy = e, qy = t;
    }, decorateType: function(i, e) {
      const t = e || i.name;
      if (i.hasOwnProperty("$type") || i.$type && i.$type.name === t) return e && i.$type.name !== e && (this.decorateRoot.remove(i.$type), i.$type.name = e, this.decorateRoot.add(i.$type)), i.$type;
      const r = i.$type, n = new qy(t);
      return this.decorateRoot.add(n), r && (Object.setPrototypeOf(n.fields, r.fields), n.oneofs = {}, r.oneofs || (r.oneofs = {}), Object.setPrototypeOf(n.oneofs, r.oneofs)), n.ctor = i, Object.defineProperty(i, "$type", { value: n, enumerable: false }), Object.defineProperty(i.prototype, "$type", { value: n, enumerable: false }), n;
    }, decorateEnum: function(i) {
      if (i.$type) return i.$type;
      const e = new Wy("Enum" + SE++, i);
      return this.decorateRoot.add(e), Object.defineProperty(i, "$type", { value: e, enumerable: false }), e;
    }, get decorateRoot() {
      return Qy.decorated || (Qy.decorated = new Xy());
    } };
    const wE = /\\/g;
    const bE = /"/g;
    const NE = /_([a-z])/g;
    const Se = Object.assign(sa, He, { codegen: TE, LongBits: Gt, longToHash(i) {
      return i ? Gt.from(i).toHash() : Gt.zeroHash;
    }, longFromHash(i, e = false) {
      const t = Gt.fromHash(i);
      return He.Long ? He.Long.fromBits(t.lo, t.hi, e) : t.toNumber(!!e);
    }, compareFieldsById(i, e) {
      return i.id - e.id;
    }, toArray(i) {
      if (i) {
        for (var e = Object.keys(i), t = new Array(e.length), r = 0; r < e.length; ) t[r] = i[e[r++]];
        return t;
      }
      return [];
    }, toObject(i) {
      const e = {};
      let t = 0;
      for (; t < i.length; ) {
        const r = i[t++], n = i[t++];
        n !== void 0 && (e[r] = n);
      }
      return e;
    }, isReserved(i) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(i);
    }, safeProp(i) {
      return !/^[$\w_]+$/.test(i) || this.isReserved(i) ? '["' + i.replace(wE, "\\\\").replace(bE, '\\"') + '"]' : "." + i;
    }, ucFirst(i) {
      return i.charAt(0).toUpperCase() + i.substring(1);
    }, camelCase(i) {
      return i.substring(0, 1) + i.substring(1).replace(NE, function(e, t) {
        return t.toUpperCase();
      });
    } });
    const br = class V_ extends xs {
      constructor(e, t, r, n, s) {
        if (super(e, r), t && typeof t !== "object") throw TypeError("values must be an object");
        if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.keys = [], this.comment = n, this.comments = s || {}, this.reserved = void 0, t) for (let o = Object.keys(t), a = 0; a < o.length; ++a) {
          const p = o[a], h = t[p];
          typeof h === "number" && (this.values[p] = h, this.valuesById[h] = p, this.keys.push(p));
        }
      }
      lookupType(e) {
        throw new Error("Method not implemented.");
      }
      lookup() {
        throw new Error("Method not implemented.");
      }
      get() {
        throw new Error("Method not implemented.");
      }
      static fromJSON(e, t) {
        const r = new V_(e, t.values, t.options, t.comment, t.comments);
        return r.reserved = t.reserved, r;
      }
      toJSON(e) {
        const t = e ? !!e.keepComments : false;
        return Se.toObject(["options", this.options, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "comment", t ? this.comment : void 0, "comments", t ? this.comments : void 0]);
      }
      add(e, t, r) {
        if (!Se.isString(e)) throw TypeError("name must be a string");
        if (!Se.isInteger(t)) throw TypeError("id must be an integer");
        if (this.values[e] !== void 0) throw Error("duplicate name '" + e + "' in " + this);
        if (this.isReservedId(t)) throw Error("id " + t + " is reserved in " + this);
        if (this.isReservedName(e)) throw Error("name '" + e + "' is reserved in " + this);
        if (this.valuesById[t] !== void 0) {
          if (!(this.options && this.options.allow_alias)) throw Error("duplicate id " + t + " in " + this);
          this.values[e] = t;
        } else this.valuesById[this.values[e] = t] = e, this.keys.push(e);
        return this.comments[e] = r, this;
      }
      remove(e) {
        if (!Se.isString(e)) throw TypeError("name must be a string");
        const t = this.values[e];
        if (t == null) throw Error("name '" + e + "' does not exist in " + this);
        return delete this.valuesById[t], delete this.values[e], delete this.comments[e], this;
      }
      isReservedId(e) {
        return Se.isReservedId(this.reserved, e);
      }
      isReservedName(e) {
        return Se.isReservedName(this.reserved, e);
      }
    };
    br.className = "Enum";
    const xE = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64", "sint64", "fixed64", "sfixed64", "bool", "string", "bytes"];
    function Tl(i, e = 0) {
      let t = 0;
      const r = {};
      for (e |= 0; t < i.length; ) r[xE[t + e]] = i[t++];
      return r;
    }
    const ta = Tl([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]);
    const OE = Tl([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, "", He.emptyBytes, null]);
    const G_ = Tl([0, 0, 0, 1, 1], 7);
    const hd = Tl([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2);
    const ud = Tl([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]);
    const CE = /^required|optional|repeated$/;
    let Ru;
    const is = class extends xs {
      constructor(e, t, r, n, s, o, a) {
        if (Se.isObject(n) ? (a = s, o = n, n = s = void 0) : Se.isObject(s) && (a = o, o = s, s = void 0), super(e, o), !Se.isInteger(t) || t < 0) throw TypeError("id must be a non-negative integer");
        if (!Se.isString(r)) throw TypeError("type must be a string");
        if (n !== void 0 && !CE.test(n = n.toString().toLowerCase())) throw TypeError("rule must be a string rule");
        if (s !== void 0 && !Se.isString(s)) throw TypeError("extend must be a string");
        this.rule = n && n !== "optional" ? n : void 0, this.type = r, this.id = t, this.extend = s || void 0, this.optional = n === "optional", this.required = n === "required" || !this.optional, this.repeated = n === "repeated", this.map = false, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = Se.Long ? G_[r] !== void 0 : false, this.bytes = r === "bytes", this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this.comment = a;
      }
      add(e, t, r) {
        throw new Error("Method not implemented.");
      }
      lookupType(e, t, r) {
        throw new Error("Method not implemented.");
      }
      lookup(e, t, r) {
        throw new Error("Method not implemented.");
      }
      get(e, t, r) {
        throw new Error("Method not implemented.");
      }
      static fromJSON(e, t) {
        return new A(e, t.id, t.type, t.rule, t.extend, t.options, t.comment);
      }
      get packed() {
        return this._packed === null && (this._packed = this.getOption("packed") !== false), this._packed;
      }
      setOption(e, t, r = false) {
        return e === "packed" && (this._packed = null), super.setOption(e, t, r);
      }
      toJSON(e) {
        const t = e ? !!e.keepComments : false;
        return Se.toObject(["rule", this.rule !== "optional" && this.rule || void 0, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t ? this.comment : void 0]);
      }
      resolve() {
        if (this.resolved) return this;
        (this.typeDefault = OE[this.type]) === void 0 && (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof Ru ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]);
        const e = this.options && this.options.default != null;
        if (e && (this.typeDefault = this.options.default, this.resolvedType instanceof br && typeof this.typeDefault === "string" && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && ((this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof br)) && delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long) this.typeDefault = Se.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u"), Object.freeze && Object.freeze(this.typeDefault);
        else if (this.bytes && typeof this.typeDefault === "string") {
          let t;
          Se.base64.test(this.typeDefault) ? Se.base64.decode(this.typeDefault, t = Se.newBuffer(Se.base64.length(this.typeDefault)), 0) : Se.utf8.write(this.typeDefault, t = Se.newBuffer(Se.utf8.length(this.typeDefault)), 0), this.typeDefault = t;
        }
        return this.map ? this.defaultValue = Se.emptyObject : this.repeated ? this.defaultValue = Se.emptyArray : !e && this.optional ? this.defaultValue = void 0 : this.defaultValue == null && (this.defaultValue = this.typeDefault), this.parent instanceof Ru && (this.parent.ctor.prototype[this.name] = this.defaultValue), super.resolve();
      }
      static _configure(e) {
        Ru = e;
      }
    };
    is.className = "Field";
    const A = class K_ extends is {
      static d(e, t, r, n) {
        let s;
        typeof t === "function" ? s = sa.decorateType(t).name : typeof t === "object" ? s = sa.decorateEnum(t).name : s = t;
        const o = /* @__PURE__ */ Symbol.for("field");
        return function(p, h) {
          const f = p.constructor;
          (f[o] || (f[o] = [])).push(new K_(h, e, s, r, { default: n }));
        };
      }
    };
    let vo;
    let ko;
    let Zy;
    const Ht = class _Ht extends xs {
      constructor(e, t) {
        super(e, t), this._nestedArray = null;
      }
      static fromJSON(e, t) {
        return new _Ht(e, t.options).addJSON(t.nested);
      }
      static arrayToJSON(e, t) {
        if (!(e && e.length)) return;
        const r = {};
        for (let n = 0; n < e.length; ++n) r[e[n].name] = e[n].toJSON(t);
        return r;
      }
      static isReservedId(e, t) {
        return Se.isReservedId(e, t);
      }
      static isReservedName(e, t) {
        return Se.isReservedName(e, t);
      }
      get nestedArray() {
        return this._nestedArray || (this._nestedArray = Se.toArray(this.nested));
      }
      toJSON(e) {
        return Se.toObject(["options", this.options, "nested", _Ht.arrayToJSON(this.nestedArray, e)]);
      }
      addJSON(e) {
        if (e) for (let t = Object.keys(e), r = 0, n; r < t.length; ++r) n = e[t[r]], this.add((n.fields !== void 0 ? vo.fromJSON : n.values !== void 0 ? ko.fromJSON : n.id !== void 0 ? Zy.fromJSON : _Ht.fromJSON)(t[r], n));
        return this;
      }
      get(e) {
        return this.nested && this.nested[e] || null;
      }
      getEnum(e) {
        if (this.nested && this.nested[e] instanceof ko) return this.nested[e].values;
        throw Error("no such enum: " + e);
      }
      add(e) {
        if (!(e instanceof is && e.extend !== void 0 || e instanceof vo || e instanceof ko || e instanceof _Ht)) throw TypeError("object must be a valid nested object");
        if (!this.nested) this.nested = {};
        else {
          const t = this.get(e.name);
          if (t) if (t instanceof _Ht && e instanceof _Ht && !(t instanceof vo)) {
            const r = t.nestedArray;
            for (let n = 0; n < r.length; ++n) e.add(r[n]);
            this.remove(t), this.nested || (this.nested = {}), e.setOptions(t.options, true);
          } else throw Error("duplicate name '" + e.name + "' in " + this);
        }
        return this.nested[e.name] = e, e.onAdd(this), this._nestedArray = null, this;
      }
      remove(e) {
        if (!(e instanceof xs)) throw TypeError("object must be a ReflectionObject");
        if (e.parent !== this) throw Error(e + " is not a member of " + this);
        return this.nested && (delete this.nested[e.name], Object.keys(this.nested).length || (this.nested = void 0)), e.onRemove(this), this._nestedArray = null, this;
      }
      define(e, t) {
        if (typeof e === "string") e = e.split(".");
        else if (!Array.isArray(e)) throw TypeError("illegal path");
        if (e && e.length && e[0] === "") throw Error("path must be relative");
        let r = this;
        for (; e.length > 0; ) {
          let n = e.shift();
          if (r.nested && r.nested[n]) {
            if (r = r.nested[n], !(r instanceof _Ht)) throw Error("path conflicts with non-namespace objects");
          } else r.add(r = new _Ht(n));
        }
        return t && r.addJSON(t), r;
      }
      resolveAll() {
        for (let e = this.nestedArray, t = 0; t < e.length; ) e[t] instanceof _Ht ? e[t++].resolveAll() : e[t++].resolve();
        return this.resolve();
      }
      lookup(e, t, r = false) {
        if (typeof t === "boolean" ? (r = t, t = void 0) : t && !Array.isArray(t) && (t = [t]), Se.isString(e) && e.length) {
          if (e === ".") return this.root;
          e = e.split(".");
        } else if (!e.length) return this;
        if (e[0] === "") return this.root.lookup(e.slice(1), t);
        let n = this.get(e[0]);
        if (n) {
          if (e.length === 1) {
            if (!t || t.indexOf(n.constructor) > -1) return n;
          } else if (n instanceof _Ht && (n = n.lookup(e.slice(1), t, true))) return n;
        } else for (let s = 0; s < this.nestedArray.length; ++s) if (this._nestedArray[s] instanceof _Ht && (n = this._nestedArray[s].lookup(e, t, true))) return n;
        return this.parent === null || r ? null : this.parent.lookup(e, t);
      }
      lookupType(e) {
        const t = this.lookup(e, [vo]);
        if (!t) throw Error("no such type: " + e);
        return t;
      }
      lookupEnum(e) {
        const t = this.lookup(e, [ko]);
        if (!t) throw Error("no such Enum '" + e + "' in " + this);
        return t;
      }
      lookupTypeOrEnum(e) {
        const t = this.lookup(e, [vo, ko]);
        if (!t) throw Error("no such Type or Enum '" + e + "' in " + this);
        return t;
      }
      static _configure(e, t, r) {
        vo = e, ko = t, Zy = r;
      }
    };
    Ht.className = "Namespace";
    const Ns = class _Ns extends xs {
      constructor(e, t, r, n) {
        if (Array.isArray(t) || (r = t, t = void 0), super(e, r), !(t === void 0 || Array.isArray(t))) throw TypeError("fieldNames must be an Array");
        this.oneof = t || [], this.fieldsArray = [], this.comment = n;
      }
      lookup(e, t, r) {
        throw new Error("Method not implemented.");
      }
      lookupType(e, t, r) {
        throw new Error("Method not implemented.");
      }
      get(e) {
        throw new Error("Method not implemented.");
      }
      static fromJSON(e, t) {
        return new _Ns(e, t.oneof, t.options, t.comment);
      }
      toJSON(e) {
        const t = e ? !!e.keepComments : false;
        return Se.toObject(["options", this.options, "oneof", this.oneof, "comment", t ? this.comment : void 0]);
      }
      add(e) {
        const t = this;
        if (!(e instanceof is)) throw TypeError("field must be a Field");
        return e.parent && e.parent !== this.parent && e.parent.remove(e), this.oneof.push(e.name), this.fieldsArray.push(e), e.partOf = t, em(t), this;
      }
      remove(e) {
        if (!(e instanceof is)) throw TypeError("field must be a Field");
        let t = this.fieldsArray.indexOf(e);
        if (t < 0) throw Error(e + " is not a member of " + this);
        return this.fieldsArray.splice(t, 1), t = this.oneof.indexOf(e.name), t > -1 && this.oneof.splice(t, 1), e.partOf = null, this;
      }
      onAdd(e) {
        super.onAdd(e);
        for (let t = 0; t < this.oneof.length; ++t) {
          const r = e.get(this.oneof[t]);
          r && !r.partOf && (r.partOf = this, this.fieldsArray.push(r));
        }
        em(this);
      }
      onRemove(e) {
        for (let t = 0, r; t < this.fieldsArray.length; ++t) (r = this.fieldsArray[t]).parent && r.parent.remove(r);
        super.onRemove(e);
      }
      static d(...e) {
        let t = new Array(arguments.length), r = 0;
        for (; r < arguments.length; ) t[r] = arguments[r++];
        const n = /* @__PURE__ */ Symbol.for("field");
        return function(o, a) {
          const p = o.constructor;
          (p[n] || (p[n] = [])).push(new _Ns(a, t)), Object.defineProperty(o, a, { get: Se.oneOfGetter(t), set: Se.oneOfSetter(t) });
        };
      }
    };
    Ns.className = "OneOf";
    function em(i) {
      if (i.parent) for (let e = 0; e < i.fieldsArray.length; ++e) i.fieldsArray[e].parent || i.parent.add(i.fieldsArray[e]);
    }
    const Dl = /^[A-Z]/;
    let tm;
    const ci = class _ci extends Ht {
      constructor(e) {
        super("", e), this.deferred = [], this.files = [];
      }
      static fromJSON(e, t) {
        return t || (t = new _ci()), e.options && t.setOptions(e.options), t.addJSON(e.nested);
      }
      resolveAll() {
        if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function(e) {
          return "'extend " + e.extend + "' in " + e.parent.fullName;
        }).join(", "));
        return super.resolveAll();
      }
      _handleAdd(e) {
        const t = e;
        if (e instanceof is) e.extend !== void 0 && !e.extensionField && (rm(this, e) || this.deferred.push(e));
        else if (e instanceof br) Dl.test(e.name) && (t.parent[e.name] = e.values);
        else if (!(e instanceof Ns)) {
          if (e instanceof tm) for (let r = 0; r < this.deferred.length; ) rm(this, this.deferred[r]) ? this.deferred.splice(r, 1) : ++r;
          for (let n = 0; n < t.nestedArray.length; ++n) this._handleAdd(t._nestedArray[n]);
          Dl.test(e.name) && (t.parent[e.name] = e);
        }
      }
      _handleRemove(e) {
        const t = e;
        if (e instanceof is) {
          if (e.extend !== void 0) if (e.extensionField) t.extensionField.parent.remove(e.extensionField), e.extensionField = null;
          else {
            const r = this.deferred.indexOf(e);
            r > -1 && this.deferred.splice(r, 1);
          }
        } else if (e instanceof br) Dl.test(e.name) && delete t.parent[e.name];
        else if (e instanceof Ht) {
          const s = e;
          for (let n = 0; n < e.nestedArray.length; ++n) this._handleRemove(s._nestedArray[n]);
          Dl.test(e.name) && delete s.parent[e.name];
        }
      }
      static _configure(e) {
        tm = e;
      }
    };
    ci.className = "Root";
    function rm(i, e) {
      const t = e.parent.lookup(e.extend);
      if (t) {
        const r = new A(e.fullName, e.id, e.type, e.rule, void 0, e.options);
        return r.declaringField = e, e.extensionField = r, t.add(r), true;
      }
      return false;
    }
    const fr = class _fr extends is {
      constructor(e, t, r, n, s, o) {
        if (super(e, t, n, void 0, void 0, s, o), this.map = true, !Se.isString(r)) throw TypeError("keyType must be a string");
        this.keyType = r, this.resolvedKeyType = null, this.map = true;
      }
      static fromJSON(e, t) {
        return new _fr(e, t.id, t.keyType, t.type, t.options, t.comment);
      }
      toJSON(e) {
        const t = e ? !!e.keepComments : false;
        return Se.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t ? this.comment : void 0]);
      }
      resolve() {
        if (this.resolved) return this;
        if (hd[this.keyType] === void 0) throw Error("invalid key type: " + this.keyType);
        return super.resolve();
      }
      static d(e, t, r) {
        let n;
        typeof r === "function" ? n = sa.decorateType(r).name : typeof r === "object" ? n = sa.decorateEnum(r).name : n = r;
        const s = /* @__PURE__ */ Symbol.for("field");
        return function(a, p) {
          const h = a.constructor;
          const f = h[s] || (h[s] = []);
          f.push(new _fr(p, e, t, n));
        };
      }
    };
    fr.className = "MapField";
    const Y = class {
      constructor(e) {
        if (e) {
          const t = Object.keys(e);
          for (const r of t) this[r] = e[r];
        }
      }
      getBytes() {
        return this.$type.encode(this).finish();
      }
      static create(e) {
        return this.$type.create(e);
      }
      static encode(e, t) {
        return this.$type.encode(e, t);
      }
      static encodeDelimited(e, t) {
        return this.$type.encodeDelimited(e, t);
      }
      static decode(e) {
        return this.$type.decode(e);
      }
      static decodeDelimited(e) {
        return this.$type.decodeDelimited(e);
      }
      static verify(e) {
        return this.$type.verify(e);
      }
      static fromObject(e) {
        return this.$type.fromObject(e);
      }
      static toObject(e, t = He.toJSONOptions) {
        return this.$type.toObject(e, t);
      }
      toObject() {
        return this.$type.toObject(this, He.toJSONOptions);
      }
      toJSON() {
        return this.$type.toObject(this, { defaults: true });
      }
      clone() {
        return this.$type.decode(this.$type.encode(this).finish());
      }
    };
    let z_;
    const RE = He.utf8;
    function Mn(i, e) {
      return new RangeError("index out of range: " + i.pos + " + " + (e || 1) + " > " + i.len);
    }
    const nm = typeof Uint8Array < "u" ? function(e) {
      if (e instanceof Uint8Array || Array.isArray(e)) return new Xr(e);
      throw Error("illegal buffer");
    } : function(e) {
      if (Array.isArray(e)) return new Xr(e);
      throw Error("illegal buffer");
    };
    const Xr = class _Xr {
      constructor(e) {
        this.pos = 0, this.uint32 = /* @__PURE__ */ (function() {
          let r = 4294967295;
          return function() {
            if (r = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (r = (r | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (r = (r | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (r = (r | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (r = (r | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return r;
            if ((this.pos += 5) > this.len) throw this.pos = this.len, Mn(this, 10);
            return r;
          };
        })(), this._slice = He.Array.prototype.subarray || He.Array.prototype.slice, this.buf = e, this.len = e.length;
      }
      int32() {
        return this.uint32() | 0;
      }
      sint32() {
        const e = this.uint32();
        return e >>> 1 ^ -(e & 1) | 0;
      }
      bool() {
        return this.uint32() !== 0;
      }
      fixed32() {
        if (this.pos + 4 > this.len) throw Mn(this, 4);
        return sh(this.buf, this.pos += 4);
      }
      sfixed32() {
        if (this.pos + 4 > this.len) throw Mn(this, 4);
        return sh(this.buf, this.pos += 4) | 0;
      }
      float() {
        if (this.pos + 4 > this.len) throw Mn(this, 4);
        const e = He.float.readFloatLE(this.buf, this.pos);
        return this.pos += 4, e;
      }
      double() {
        if (this.pos + 8 > this.len) throw Mn(this, 4);
        const e = He.float.readDoubleLE(this.buf, this.pos);
        return this.pos += 8, e;
      }
      bytes() {
        const e = this.uint32(), t = this.pos, r = this.pos + e;
        if (r > this.len) throw Mn(this, e);
        if (this.pos += e, Array.isArray(this.buf)) return this.buf.slice(t, r);
        if (t === r) {
          const n = this.buf.constructor;
          return new n(0);
        }
        return this._slice.call(this.buf, t, r);
      }
      string() {
        const e = this.bytes();
        return RE.read(e, 0, e.length);
      }
      skip(e) {
        if (typeof e === "number") {
          if (this.pos + e > this.len) throw Mn(this, e);
          this.pos += e;
        } else do
          if (this.pos >= this.len) throw Mn(this);
        while (this.buf[this.pos++] & 128);
        return this;
      }
      skipType(e) {
        switch (e) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            for (; (e = this.uint32() & 7) !== 4; ) this.skipType(e);
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + e + " at offset " + this.pos);
        }
        return this;
      }
      static _configure(e) {
        z_ = e;
        const t = He.Long ? "toLong" : "toNumber";
        He.merge(_Xr.prototype, { int64: function() {
          return Bu.call(this)[t](false);
        }, uint64: function() {
          return Bu.call(this)[t](true);
        }, sint64: function() {
          return Bu.call(this).zzDecode()[t](false);
        }, fixed64: function() {
          return sm.call(this)[t](true);
        }, sfixed64: function() {
          return sm.call(this)[t](false);
        } });
      }
    };
    Xr.create = He.Buffer ? function(e) {
      return (Xr.create = function(r) {
        return He.Buffer.isBuffer(r) ? new z_(r) : nm(r);
      })(e);
    } : nm;
    function sh(i, e) {
      return (i[e - 4] | i[e - 3] << 8 | i[e - 2] << 16 | i[e - 1] << 24) >>> 0;
    }
    function Bu() {
      let i = new Gt(0, 0), e = 0;
      if (this.len - this.pos > 4) {
        for (; e < 4; ++e) if (i.lo = (i.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128) return i;
        if (i.lo = (i.lo | (this.buf[this.pos] & 127) << 28) >>> 0, i.hi = (i.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128) return i;
        e = 0;
      } else {
        for (; e < 3; ++e) {
          if (this.pos >= this.len) throw Mn(this);
          if (i.lo = (i.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128) return i;
        }
        return i.lo = (i.lo | (this.buf[this.pos++] & 127) << e * 7) >>> 0, i;
      }
      if (this.len - this.pos > 4) {
        for (; e < 5; ++e) if (i.hi = (i.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return i;
      } else for (; e < 5; ++e) {
        if (this.pos >= this.len) throw Mn(this);
        if (i.hi = (i.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return i;
      }
      throw Error("invalid varint encoding");
    }
    function sm() {
      if (this.pos + 8 > this.len) throw Mn(this, 8);
      return new Gt(sh(this.buf, this.pos += 4), sh(this.buf, this.pos += 4));
    }
    let j_;
    const _c = class {
      constructor(e, t, r) {
        this.fn = e, this.len = t, this.next = void 0, this.val = r;
      }
      fn(e, t, r) {
      }
    };
    function Pu() {
    }
    const BE = class {
      constructor(e) {
        this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;
      }
    };
    const kn = class _kn {
      constructor() {
        this.len = 0, this.head = new _c(Pu, 0, 0), this.tail = this.head, this.states = null;
      }
      static alloc(e) {
        return new He.Array(e);
      }
      _push(e, t, r) {
        return this.tail = this.tail.next = new _c(e, t, r), this.len += t, this;
      }
      uint32(e) {
        return this.len += (this.tail = this.tail.next = new PE((e = e >>> 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;
      }
      int32(e) {
        return e < 0 ? this._push(Lu, 10, Gt.fromNumber(e)) : this.uint32(e);
      }
      sint32(e) {
        return this.uint32((e << 1 ^ e >> 31) >>> 0);
      }
      uint64(e) {
        const t = Gt.from(e);
        return this._push(Lu, t.length(), t);
      }
      int64(e) {
        return this.uint64(e);
      }
      sint64(e) {
        const t = Gt.from(e).zzEncode();
        return this._push(Lu, t.length(), t);
      }
      bool(e) {
        return this._push(Mu, 1, e ? 1 : 0);
      }
      fixed32(e) {
        return this._push(Hu, 4, e >>> 0);
      }
      sfixed32(e) {
        return this.fixed32(e);
      }
      fixed64(e) {
        const t = Gt.from(e);
        return this._push(Hu, 4, t.lo)._push(Hu, 4, t.hi);
      }
      sfixed64(e) {
        return this.fixed64(e);
      }
      float(e) {
        return this._push(He.float.writeFloatLE, 4, e);
      }
      double(e) {
        return this._push(He.float.writeDoubleLE, 8, e);
      }
      bytes(e) {
        let t = e.length >>> 0;
        if (!t) return this._push(Mu, 1, 0);
        if (He.isString(e)) {
          const r = _kn.alloc(t = He.base64.length(e));
          He.base64.decode(e, r, 0), e = r;
        }
        return this.uint32(t)._push(ME, t, e);
      }
      string(e) {
        const t = He.utf8.length(e);
        return t ? this.uint32(t)._push(He.utf8.write, t, e) : this._push(Mu, 1, 0);
      }
      fork() {
        return this.states = new BE(this), this.head = this.tail = new _c(Pu, 0, 0), this.len = 0, this;
      }
      reset() {
        return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new _c(Pu, 0, 0), this.len = 0), this;
      }
      ldelim() {
        const e = this.head, t = this.tail, r = this.len;
        return this.reset().uint32(r), r && (this.tail.next = e.next, this.tail = t, this.len += r), this;
      }
      finish() {
        for (var e = this.head.next, t = this.constructor.alloc(this.len), r = 0; e; ) e.fn(e.val, t, r), r += e.len, e = e.next;
        return t;
      }
      static _configure(e) {
        j_ = e;
      }
    };
    kn.create = He.Buffer ? function() {
      return (kn.create = function() {
        return new j_();
      })();
    } : function() {
      return new kn();
    };
    He.Array !== Array && (kn.alloc = He.pool(kn.alloc, He.Array.prototype.subarray));
    function Mu(i, e, t) {
      e[t] = i & 255;
    }
    function im(i, e, t) {
      for (; i > 127; ) e[t++] = i & 127 | 128, i >>>= 7;
      e[t] = i;
    }
    const PE = class extends _c {
      constructor(e, t) {
        super(im, e, t), this.len = e, this.next = void 0, this.val = t;
      }
      fn(e, t, r) {
        return im(e, t, r);
      }
    };
    function Lu(i, e, t) {
      for (; i.hi; ) e[t++] = i.lo & 127 | 128, i.lo = (i.lo >>> 7 | i.hi << 25) >>> 0, i.hi >>>= 7;
      for (; i.lo > 127; ) e[t++] = i.lo & 127 | 128, i.lo = i.lo >>> 7;
      e[t++] = i.lo;
    }
    function Hu(i, e, t) {
      e[t] = i & 255, e[t + 1] = i >>> 8 & 255, e[t + 2] = i >>> 16 & 255, e[t + 3] = i >>> 24;
    }
    function ME(i, e, t) {
      e.set(i, t);
    }
    function om(i, e, t, r) {
      return e.resolvedType.group ? i("%s&&types[%i].encode(%s,w.uint32(%i)).uint32(%i)", r, t, r, (e.id << 3 | 3) >>> 0, (e.id << 3 | 4) >>> 0) : i("%s&&types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", r, t, r, (e.id << 3 | 2) >>> 0);
    }
    function LE(i) {
      let e = Se.codegen(["m", "w"], i.name + "$encode")("if(!w)")("w=Writer.create()"), t, r = i.fieldsArray.slice().toSorted(Se.compareFieldsById);
      if (i._fieldsArray instanceof Array) for (let n = 0; n < r.length; ++n) {
        const s = r[n].resolve(), o = i._fieldsArray.indexOf(s), a = s.resolvedType instanceof br ? "int32" : s.type, p = ta[a];
        if (t = "m" + Se.safeProp(s.name), s.map) e("if(%s!=null){", t)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", t)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (s.id << 3 | 2) >>> 0, 8 | hd[s.keyType], s.keyType), p === void 0 ? e("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", o, t) : e(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | p, a, t), e("}")("}");
        else if (s.repeated) e("if(%s!=null&&%s.length){", t, t), s.packed && ud[a] !== void 0 ? e("w.uint32(%i).fork()", (s.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", t)("w.%s(%s[i])", a, t)("w.ldelim()") : (e("for(var i=0;i<%s.length;++i)", t), p === void 0 ? om(e, s, o, t + "[i]") : e("w.uint32(%i).%s(%s[i])", (s.id << 3 | p) >>> 0, a, t)), e("}");
        else if (a === "bytes") e("if(%s!=null&&%s.length)", t, t), e("w.uint32(%i).%s(%s)", (s.id << 3 | p) >>> 0, a, t);
        else {
          if (a.endsWith("64")) if (s.defaultValue) {
            const { unsigned: h, high: f, low: g } = s.defaultValue;
            e(`if(${t}!=null && 
                   (  ${h}!==${t}.unsigned
                   || ${f}!==${t}.high
                   || ${g}!==${t}.low
                   )
                 )`);
          } else e(`if(${t}!=null)`);
          else e("if(%s!=null&&%s!==%j)", t, t, s.defaultValue);
          p === void 0 ? om(e, s, o, t) : e("w.uint32(%i).%s(%s)", (s.id << 3 | p) >>> 0, a, t);
        }
      }
      return e("return w");
    }
    function HE(i) {
      return "missing required '" + i.name + "'";
    }
    function vE(i) {
      let e = Se.codegen(["r", "l"], i.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (i.fieldsArray.filter(function(a) {
        return a.map;
      }).length ? ",k" : "")), t = 0;
      if (i._fieldsArray instanceof Array) {
        for (; t < i.fieldsArray.length; ++t) {
          var r = i._fieldsArray[t].resolve();
          r.repeated ? e("%s=[]", "m" + Se.safeProp(r.name)) : r.map && e("%s={}", "m" + Se.safeProp(r.name));
        }
        for (e("while(r.pos<c){")("var t=r.uint32()"), i.group && e("if((t&7)===4)")("break"), e("switch(t>>>3){"), t = 0; t < i.fieldsArray.length; ++t) {
          var r = i._fieldsArray[t].resolve(), n = r.resolvedType instanceof br ? "int32" : r.type, s = "m" + Se.safeProp(r.name);
          e("case %i:", r.id);
          const p = r.resolvedType;
          r.map ? (e("r.skip().pos++")("k=r.%s()", r.keyType)("r.pos++"), G_[r.keyType] !== void 0 ? ta[n] === void 0 ? e('%s[typeof k==="object"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())', s, t) : e('%s[typeof k==="object"?util.longToHash(k):k]=r.%s()', s, n) : ta[n] === void 0 ? e("%s[k]=types[%i].decode(r,r.uint32())", s, t) : e("%s[k]=r.%s()", s, n)) : r.repeated ? (ud[n] !== void 0 && e("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", s, n)("}else"), ta[n] === void 0 ? e(p.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", s, t) : e("%s.push(r.%s())", s, n)) : ta[n] === void 0 ? e(p.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", s, t) : e("%s=r.%s()", s, n), e("break");
        }
        for (e("default:")("r.skipType(t&7)")("break")("}")("}"), t = 0; t < i._fieldsArray.length; ++t) {
          const o = i._fieldsArray[t];
          o.required && e("if(m.%s==null)", o.name)("throw util.ProtocolError(%j,{instance:m})", HE(o));
        }
      }
      return e("return m");
    }
    function _n(i, e) {
      return i.name + ": " + e + (i.repeated && e !== "array" ? "[]" : i.map && e !== "object" ? "{k:" + i.keyType + "}" : "") + " expected";
    }
    function vu(i, e, t, r) {
      if (e.resolvedType) if (e.resolvedType instanceof br) {
        i("switch(%s){", r)("default:")("return%j", _n(e, "enum value"));
        for (let n = Object.keys(e.resolvedType.values), s = 0; s < n.length; ++s) i("case %i:", e.resolvedType.values[n[s]]);
        i("break")("}");
      } else i("{")("var e=types[%i].verify(%s);", t, r)("if(e)")("return%j+e", e.name + ".")("}");
      else switch (e.type) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          i("if(!util.isInteger(%s))", r)("return%j", _n(e, "integer"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          i("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", r, r, r, r)("return%j", _n(e, "integer|Long"));
          break;
        case "float":
        case "double":
          i('if(typeof %s!=="number")', r)("return%j", _n(e, "number"));
          break;
        case "bool":
          i('if(typeof %s!=="boolean")', r)("return%j", _n(e, "boolean"));
          break;
        case "string":
          i("if(!util.isString(%s))", r)("return%j", _n(e, "string"));
          break;
        case "bytes":
          i('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', r, r, r)("return%j", _n(e, "buffer"));
          break;
      }
      return i;
    }
    function kE(i, e, t) {
      switch (e.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          i("if(!util.key32Re.test(%s))", t)("return%j", _n(e, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          i("if(!util.key64Re.test(%s))", t)("return%j", _n(e, "integer|Long key"));
          break;
        case "bool":
          i("if(!util.key2Re.test(%s))", t)("return%j", _n(e, "boolean key"));
          break;
      }
      return i;
    }
    function DE(i) {
      const e = Se.codegen(["m"], i.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected"), t = i.oneofsArray, r = {};
      if (t.length && e("var p={}"), i._fieldsArray instanceof Array) for (let n = 0; n < i.fieldsArray.length; ++n) {
        const s = i._fieldsArray[n].resolve(), o = "m" + Se.safeProp(s.name);
        if (s.optional && e("if(%s!=null){", o), s.map) e("if(!util.isObject(%s))", o)("return%j", _n(s, "object"))("var k=Object.keys(%s)", o)("for(var i=0;i<k.length;++i){"), kE(e, s, "k[i]"), vu(e, s, n, o + "[k[i]]")("}");
        else if (s.repeated) e("if(!Array.isArray(%s))", o)("return%j", _n(s, "array"))("for(var i=0;i<%s.length;++i){", o), vu(e, s, n, o + "[i]")("}");
        else {
          if (s.partOf) {
            const a = Se.safeProp(s.partOf.name);
            r[s.partOf.name] === 1 && e("if(p%s===1)", a)("return%j", s.partOf.name + ": multiple values"), r[s.partOf.name] = 1, e("p%s=1", a);
          }
          vu(e, s, n, o);
        }
        s.optional && e("}");
      }
      return e("return null");
    }
    function Fl(i, e, t, r) {
      if (e.resolvedType) if (e.resolvedType instanceof br) {
        i("switch(d%s){", r);
        let n = e.resolvedType.values, s = e.resolvedType.keys, o = 0;
        for (; o < s.length; ++o) e.repeated && n[s[o]] === e.typeDefault && i("default:"), i("case%j:", s[o])("case %i:", n[s[o]])("m%s=%j", r, n[s[o]])("break");
        i("}");
      } else i('if(typeof d%s!=="object")', r)("throw TypeError(%j)", e.fullName + ": object expected")("m%s=types[%i]._ctor.fromObject(d%s)", r, t, r);
      else {
        let n = false;
        switch (e.type) {
          case "double":
          case "float":
            i("m%s=Number(d%s)", r, r);
            break;
          case "uint32":
          case "fixed32":
            i("m%s=d%s>>>0", r, r);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            i("m%s=d%s|0", r, r);
            break;
          case "uint64":
            n = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            i("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", r, r, n)('else if(typeof d%s==="string")', r)("m%s=parseInt(d%s,10)", r, r)('else if(typeof d%s==="number")', r)("m%s=d%s", r, r)('else if(typeof d%s==="object")', r)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", r, r, r, n ? "true" : "");
            break;
          case "bytes":
            i('if(typeof d%s==="string")', r)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", r, r, r)("else if(d%s.length)", r)("m%s=d%s", r, r);
            break;
          case "string":
            i("m%s=String(d%s)", r, r);
            break;
          case "bool":
            i("m%s=Boolean(d%s)", r, r);
            break;
        }
      }
      return i;
    }
    function ku(i, e, t, r) {
      if (e.resolvedType) e.resolvedType instanceof br ? i("d%s=o.enums===String?types[%i].values[m%s]:m%s", r, t, r, r) : i("d%s=types[%i].toObject(m%s,o)", r, t, r);
      else {
        let n = false;
        switch (e.type) {
          case "double":
          case "float":
            i("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", r, r, r, r);
            break;
          case "uint64":
            n = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            i('if(typeof m%s==="number")', r)("d%s=o.longs===String?String(m%s):m%s", r, r, r)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", r, r, r, r, n ? "true" : "", r);
            break;
          case "bytes":
            i("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", r, r, r, r, r);
            break;
          default:
            i("d%s=m%s", r, r);
            break;
        }
      }
      return i;
    }
    const am = { fromObject(i) {
      const e = i.fieldsArray, t = Se.codegen(["d"], i.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!e.length) return t("return new this.ctor");
      t("var m=new this.ctor");
      for (let r = 0; r < e.length; ++r) {
        const n = e[r].resolve(), s = Se.safeProp(n.name);
        n.map ? (t("m%s={}", s)("if(d%s){", s)('if(typeof d%s!=="object")', s)("throw TypeError(%j)", n.fullName + ": object expected")("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", s), Fl(t, n, r, s + "[ks[i]]")("}")("}")) : n.repeated ? (t("m%s=[]", s)("if(d%s){", s)("if(!Array.isArray(d%s))", s)("throw TypeError(%j)", n.fullName + ": array expected")("for(var i=0;i<d%s.length;++i){", s), Fl(t, n, r, s + "[i]")("}")("}")) : n.resolvedType instanceof br ? Fl(t, n, r, s) : (n.resolvedType && n.required && (t("if(d%s==null)", s), t("d%s={}", s)), t("if(d%s!=null){", s), Fl(t, n, r, s), t("}"));
      }
      return t("return m");
    }, toObject(i) {
      const e = i.fieldsArray.slice().toSorted(Se.compareFieldsById);
      if (!e.length) return Se.codegen()("return {}");
      const t = Se.codegen(["m", "o"], i.name + "$toObject")("if(!o)")("o={}")("var d={}"), r = [], n = [], s = [];
      let o = 0;
      for (; o < e.length; ++o) e[o].partOf || (e[o].resolve().repeated ? r : e[o].map ? n : s).push(e[o]);
      if (r.length) {
        for (t("if(o.arrays||o.defaults){"), o = 0; o < r.length; ++o) t("d%s=[]", Se.safeProp(r[o].name));
        t("}");
      }
      if (n.length) {
        for (t("if(o.objects||o.defaults){"), o = 0; o < n.length; ++o) t("d%s={}", Se.safeProp(n[o].name));
        t("}");
      }
      if (s.length) {
        for (t("if(o.defaults){"), o = 0; o < s.length; ++o) {
          const p = s[o], h = Se.safeProp(p.name);
          if (p.resolvedType instanceof br) t("d%s=o.enums===String?%j:%j", h, p.resolvedType.valuesById[p.typeDefault], p.typeDefault);
          else if (p.long) t("if(util.Long){")("var n=new util.Long(%i,%i,%j)", p.typeDefault.low, p.typeDefault.high, p.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", h)("}else")("d%s=o.longs===String?%j:%i", h, p.typeDefault.toString(), p.typeDefault.toNumber());
          else if (p.bytes) {
            const f = "[" + Array.prototype.slice.call(p.typeDefault).join(",") + "]";
            t("if(o.bytes===String)d%s=%j", h, String.fromCharCode.apply(String, p.typeDefault))("else{")("d%s=%s", h, f)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", h, h)("}");
          } else t("d%s=%j", h, p.typeDefault);
        }
        t("}");
      }
      let a = false;
      for (o = 0; o < e.length; ++o) {
        let p = e[o], h = i._fieldsArray.indexOf(p), f = Se.safeProp(p.name);
        p.map ? (a || (a = true, t("var ks2")), t("if(m%s&&(ks2=Object.keys(m%s)).length){", f, f)("d%s={}", f)("for(var j=0;j<ks2.length;++j){"), ku(t, p, h, f + "[ks2[j]]")("}")) : p.repeated ? (t("if(m%s&&m%s.length){", f, f)("d%s=[]", f)("for(var j=0;j<m%s.length;++j){", f), ku(t, p, h, f + "[j]")("}")) : (t("if(m%s!=null&&m.hasOwnProperty(%j)){", f, p.name), ku(t, p, h, f), p.partOf && t("if(o.oneofs)")("d%s=%j", Se.safeProp(p.partOf.name), p.name)), t("}");
      }
      return t("return d");
    } };
    const cm = /* @__PURE__ */ Symbol("bindThisProps");
    function De(i, e, t) {
      if (!t || typeof t.value !== "function") throw new TypeError(`Only methods can be decorated with @bind. <${e}> is not a method!`);
      return { configurable: true, get() {
        let r = this[cm];
        if (r && r.has(e)) return t.value;
        const n = t.value.bind(this);
        return Object.defineProperty(this, e, { value: n, configurable: true, writable: true }), r || (r = this[cm] = /* @__PURE__ */ new Set()), r.add(e), n;
      } };
    }
    const pm = /* @__PURE__ */ Symbol("CACHE_GETTER_KEYS_STORE");
    function J_(i) {
      let e = Reflect.get(i, pm);
      return e || (e = /* @__PURE__ */ new Map(), Reflect.set(i, pm, e)), e;
    }
    function FE(i, e) {
      const t = J_(i);
      let r = t.get(e);
      return r || (r = /* @__PURE__ */ Symbol(`[${typeof e}]${String(e)}`), t.set(e, r)), r;
    }
    function oe(i, e, t) {
      if (typeof t.get !== "function") throw new TypeError(`property ${String(e)} must has an getter function.`);
      const r = t.get, n = FE(i, e), s = function() {
        if (n in this) return this[n].value;
        {
          const o = r.call(this), a = { target: this, value: o, sourceFun: r };
          if (this[n] = a, t.set === void 0) try {
            Object.defineProperty(this, e, { value: o, writable: false, configurable: true, enumerable: t.enumerable });
          } catch (p) {
            
          }
          return o;
        }
      };
      return Reflect.set(s, "source_fun", r), t.get = s, t;
    }
    function $E(i) {
      const e = J_(i);
      for (const [t, r] of e) UE(i, t, r);
    }
    function UE(i, e, t) {
      const r = Reflect.get(i, t);
      return r === void 0 || Reflect.deleteProperty(r.target, t) !== false && (Reflect.deleteProperty(r.target, e), true);
    }
    const Du = class {
      constructor(e = Math.random().toString(36).slice(2)) {
        this.pid = e, this.CLASS_PROTO_ARRAYDATA_POOL = /* @__PURE__ */ new Map(), this.PA_ID_VALUE = 0, this.PA_ID_KEY = /* @__PURE__ */ Symbol(`@PAID:${e}`);
      }
      get(e, t) {
        const r = /* @__PURE__ */ new Set(), n = this.CLASS_PROTO_ARRAYDATA_POOL.get(t);
        if (n) do
          if (e.hasOwnProperty(this.PA_ID_KEY)) {
            const s = n.get(e[this.PA_ID_KEY]);
            if (s) for (const o of s) r.add(o);
          }
        while (e = Object.getPrototypeOf(e));
        return r;
      }
      add(e, t, r) {
        let n = this.CLASS_PROTO_ARRAYDATA_POOL.get(t);
        n || (n = /* @__PURE__ */ new Map(), this.CLASS_PROTO_ARRAYDATA_POOL.set(t, n));
        const s = e.hasOwnProperty(this.PA_ID_KEY) ? e[this.PA_ID_KEY] : e[this.PA_ID_KEY] = /* @__PURE__ */ Symbol(`@PAID:${this.pid}#${this.PA_ID_VALUE++}`);
        let o = n.get(s);
        o ? o.push(r) : (o = [r], n.set(s, o));
      }
      remove(e, t, r) {
        const n = this.CLASS_PROTO_ARRAYDATA_POOL.get(t);
        if (n) do {
          if (!e.hasOwnProperty(this.PA_ID_KEY)) break;
          const s = e[this.PA_ID_KEY], o = n.get(s);
          if (!o) return;
          const a = o.indexOf(r);
          if (a !== -1) return void o.splice(a, 1);
        } while (e = Object.getPrototypeOf(e));
      }
    };
    l([De, u("design:type", Function), u("design:paramtypes", [Object, Object]), u("design:returntype", void 0)], Du.prototype, "get", null), l([De, u("design:type", Function), u("design:paramtypes", [Object, Object, Object]), u("design:returntype", void 0)], Du.prototype, "add", null), l([De, u("design:type", Function), u("design:paramtypes", [Object, Object, Object]), u("design:returntype", void 0)], Du.prototype, "remove", null);
    const _f = (i) => {
    };
    const VE = ((i) => (i[i.WAIT_RESULT_RETURN = 0] = "WAIT_RESULT_RETURN", i[i.NO_WAIT_EXEC_TIME = 1] = "NO_WAIT_EXEC_TIME", i))(VE || {});
    const R = class _R extends Ht {
      constructor(e, t) {
        super(e, t), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null;
      }
      get fieldsById() {
        if (this._fieldsById) return this._fieldsById;
        this._fieldsById = {};
        for (let e = Object.keys(this.fields), t = 0; t < e.length; ++t) {
          const r = this.fields[e[t]], n = r.id;
          if (this._fieldsById[n]) throw Error("duplicate id " + n + " in " + this);
          this._fieldsById[n] = r;
        }
        return this._fieldsById;
      }
      get fieldsArray() {
        let e = this._fieldsArray;
        if (!e) {
          e = [];
          for (let t in this.fields) e.push(this.fields[t]);
          this._fieldsArray = e;
        }
        return e;
      }
      get oneofsArray() {
        let e = this._oneofsArray;
        if (!e) {
          e = [];
          for (let t in this.oneofs) e.push(this.oneofs[t]);
          this._oneofsArray = e;
        }
        return e;
      }
      get ctor() {
        return this._ctor || (this.ctor = _R.generateConstructor(this)());
      }
      set ctor(e) {
        const t = e.prototype;
        t instanceof Y || ((e.prototype = new Y()).constructor = e, Se.merge(e.prototype, t)), e.$type = this, Se.merge(e, Y, true), this._ctor = e;
        let r = 0;
        if (this._fieldsArray) for (; r < this.fieldsArray.length; ++r) this._fieldsArray[r].resolve();
        const n = {};
        if (this._oneofsArray) for (r = 0; r < this.oneofsArray.length; ++r) n[this._oneofsArray[r].resolve().name] = { get: Se.oneOfGetter(this._oneofsArray[r].oneof), set: Se.oneOfSetter(this._oneofsArray[r].oneof) };
        r && Object.defineProperties(e.prototype, n);
      }
      static generateConstructor(e) {
        for (var t = Se.codegen(["p"], e.name), r = 0, n; r < e.fieldsArray.length; ++r) (n = e._fieldsArray[r]).map ? t("this%s={}", Se.safeProp(n.name)) : n.repeated && t("this%s=[]", Se.safeProp(n.name));
        return t("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
      }
      static fromJSON(e, t) {
        const r = new _R(e, t.options);
        r.extensions = t.extensions, r.reserved = t.reserved;
        let n = Object.keys(t.fields), s = 0;
        for (; s < n.length; ++s) r.add((typeof t.fields[n[s]].keyType < "u" ? fr.fromJSON : A.fromJSON)(n[s], t.fields[n[s]]));
        if (t.oneofs) for (n = Object.keys(t.oneofs), s = 0; s < n.length; ++s) r.add(Ns.fromJSON(n[s], t.oneofs[n[s]]));
        if (t.nested) for (n = Object.keys(t.nested), s = 0; s < n.length; ++s) {
          const o = t.nested[n[s]];
          r.add((o.id !== void 0 ? A.fromJSON : o.fields !== void 0 ? _R.fromJSON : o.values !== void 0 ? br.fromJSON : Ht.fromJSON)(n[s], o));
        }
        return t.extensions && t.extensions.length && (r.extensions = t.extensions), t.reserved && t.reserved.length && (r.reserved = t.reserved), t.group && (r.group = true), t.comment && (r.comment = t.comment), r;
      }
      toJSON(e) {
        const t = super.toJSON(e), r = e ? !!e.keepComments : false;
        return Se.toObject(["options", t && t.options || void 0, "oneofs", Ht.arrayToJSON(this.oneofsArray, e), "fields", Ht.arrayToJSON(this.fieldsArray.filter(function(n) {
          return !n.declaringField;
        }), e) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : void 0, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "group", this.group || void 0, "nested", t && t.nested || void 0, "comment", r ? this.comment : void 0]);
      }
      resolveAll() {
        for (var e = this.fieldsArray, t = 0; t < e.length; ) e[t++].resolve();
        const r = this.oneofsArray;
        for (t = 0; t < r.length; ) r[t++].resolve();
        return super.resolveAll();
      }
      get(e) {
        return this.fields[e] || this.oneofs && this.oneofs[e] || this.nested && this.nested[e] || null;
      }
      add(e) {
        const t = this;
        if (this.get(e.name)) throw Error("duplicate name '" + e.name + "' in " + this);
        if (e instanceof is && e.extend === void 0) {
          if (this._fieldsById ? this._fieldsById[e.id] : this.fieldsById[e.id]) throw Error("duplicate id " + e.id + " in " + this);
          if (this.isReservedId(e.id)) throw Error("id " + e.id + " is reserved in " + this);
          if (this.isReservedName(e.name)) throw Error("name '" + e.name + "' is reserved in " + this);
          return e.parent && e.parent.remove(e), this.fields[e.name] = e, e.message = t, e.onAdd(t), $l(this);
        }
        return e instanceof Ns ? (this.oneofs || (this.oneofs = {}), this.oneofs[e.name] = e, e.onAdd(t), $l(this)) : super.add(e);
      }
      remove(e) {
        const t = this;
        if (e instanceof is && e.extend === void 0) {
          if (!this.fields || this.fields[e.name] !== e) throw Error(e + " is not a member of " + this);
          return delete this.fields[e.name], e.parent = null, e.onRemove(t), $l(this);
        }
        if (e instanceof Ns) {
          if (!this.oneofs || this.oneofs[e.name] !== e) throw Error(e + " is not a member of " + this);
          return delete this.oneofs[e.name], e.parent = null, e.onRemove(t), $l(this);
        }
        return super.remove(e);
      }
      isReservedId(e) {
        return Ht.isReservedId(this.reserved, e);
      }
      isReservedName(e) {
        return Ht.isReservedName(this.reserved, e);
      }
      create(e) {
        return new this.ctor(e);
      }
      get _types() {
        if (!this._fieldsArray) throw new ReferenceError();
        const e = [];
        for (const t of this._fieldsArray) e.push(t.resolve().resolvedType);
        return e;
      }
      setup() {
        const e = this;
        this.fullName;
        for (var t = [], r = 0; r < this.fieldsArray.length; ++r) {
          const s = this._fieldsArray;
          t.push(s[r].resolve().resolvedType);
        }
        const n = LE;
        return this.encode = n(e)({ Writer: kn, types: t, util: Se }), this.decode = vE(e)({ Reader: Xr, types: t, util: Se }), this.verify = DE(e)({ types: t, util: Se }), this.fromObject = am.fromObject(e)({ types: t, util: Se }), this;
      }
      encode(e, t) {
        return this.setup().encode(e, t);
      }
      encodeDelimited(e, t) {
        return this.encode(e, t && t.len ? t.fork() : t).ldelim();
      }
      decode(e, t) {
        return this.setup().decode(e, t);
      }
      decodeDelimited(e) {
        return e instanceof Xr || (e = Xr.create(e)), this.decode(e, e.uint32());
      }
      verify(e) {
        return this.setup().verify(e);
      }
      fromObject(e) {
        return this.setup().fromObject(e);
      }
      get toObject() {
        return am.toObject(this)({ types: this._types, util: Se });
      }
      static d(e) {
        const t = /* @__PURE__ */ Symbol.for("field");
        return function(n) {
          const s = sa.decorateType(n, e), o = n[t];
          if (o) for (let a = 0, p; p = o[a]; a += 1) s.add(p);
          delete n[t];
        };
      }
    };
    R.className = "Type";
    l([oe, u("design:type", Object), u("design:paramtypes", [])], R.prototype, "toObject", null);
    function $l(i) {
      return i._fieldsById = i._fieldsArray = i._oneofsArray = null, Reflect.deleteProperty(i, "encode"), Reflect.deleteProperty(i, "decode"), Reflect.deleteProperty(i, "verify"), i;
    }
    const Y_ = class extends Xr {
      
      string() {
        const e = this.uint32();
        return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len));
      }
    };
    He.Buffer && (Y_.prototype._slice = He.Buffer.prototype.slice);
    const Xl = He.Buffer;
    const fd = class _fd extends kn {
      
      static alloc(e) {
        return (_fd.alloc = He._Buffer_allocUnsafe)(e);
      }
      bytes(e) {
        He.isString(e) && (e = He._Buffer_from(e, "base64"));
        const t = e.length >>> 0;
        return this.uint32(t), t && this._push(GE, t, e), this;
      }
      string(e) {
        const t = Xl.byteLength(e);
        return this.uint32(t), t && this._push(KE, t, e), this;
      }
    };
    const GE = Xl && Xl.prototype instanceof Uint8Array && Xl.prototype.set.name === "set" ? function(e, t, r) {
      t.set(e, r);
    } : function(e, t, r) {
      if (e.copy) e.copy(t, r, 0, e.length);
      else for (let n = 0; n < e.length; ) t[r++] = e[n++];
    };
    function KE(i, e, t) {
      i.length < 40 ? He.utf8.write(i, e, t) : e.utf8Write(i, t);
    }
    const Fu = /[\s{}=;:[\],'"()<>]/g;
    const zE = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    const jE = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    const JE = /^ *[*/]+ */;
    const YE = /^\s*\*?\/*/;
    const QE = /\n/g;
    const WE = /\s/;
    const XE = /\\(.?)/g;
    const qE = { 0: "\0", r: "\r", n: `
`, t: "	" };
    function Q_(i) {
      return i.replace(XE, function(e, t) {
        switch (t) {
          case "\\":
          case "":
            return t;
          default:
            return qE[t] || "";
        }
      });
    }
    W_.unescape = Q_;
    function W_(i, e) {
      i = i.toString();
      let t = 0, r = i.length, n = 1, s = null, o = null, a = 0, p = false, h = [], f = null;
      function g(C) {
        return Error("illegal " + C + " (line " + n + ")");
      }
      function d() {
        const C = f === "'" ? jE : zE;
        C.lastIndex = t - 1;
        const V = C.exec(i);
        if (!V) throw g("string");
        return t = C.lastIndex, N(f), f = null, Q_(V[1]);
      }
      function y(C) {
        return i.charAt(C);
      }
      function _(C, V) {
        s = i.charAt(C++), a = n, p = false;
        let F;
        e ? F = 2 : F = 3;
        let K = C - F, L;
        do
          if (--K < 0 || (L = i.charAt(K)) === `
`) {
            p = true;
            break;
          }
        while (L === " " || L === "	");
        for (var H = i.substring(C, V).split(QE), W = 0; W < H.length; ++W) H[W] = H[W].replace(e ? YE : JE, "").trim();
        o = H.join(`
`).trim();
      }
      function I(C) {
        const V = S(C), F = i.substring(C, V), K = /^\s*\/{1,2}/.test(F);
        return K;
      }
      function S(C) {
        for (var V = C; V < r && y(V) !== `
`; ) V++;
        return V;
      }
      function w() {
        if (h.length > 0) return h.shift();
        if (f) return d();
        let C, V, F, K, L;
        do {
          if (t === r) return null;
          for (C = false; WE.test(F = y(t)); ) if (F === `
` && ++n, ++t === r) return null;
          if (y(t) === "/") {
            if (++t === r) throw g("comment");
            if (y(t) === "/") if (e) {
              if (K = t, L = false, I(t)) {
                L = true;
                do {
                  if (t = S(t), t === r) break;
                  t++;
                } while (I(t));
              } else t = Math.min(r, S(t) + 1);
              L && _(K, t), n++, C = true;
            } else {
              for (L = y(K = t + 1) === "/"; y(++t) !== `
`; ) if (t === r) return null;
              ++t, L && _(K, t - 1), ++n, C = true;
            }
            else if ((F = y(t)) === "*") {
              K = t + 1, L = e || y(K) === "*";
              do {
                if (F === `
` && ++n, ++t === r) throw g("comment");
                V = F, F = y(t);
              } while (V !== "*" || F !== "/");
              ++t, L && _(K, t - 2), C = true;
            } else return "/";
          }
        } while (C);
        let H = t;
        Fu.lastIndex = 0;
        const W = Fu.test(y(H++));
        if (!W) for (; H < r && !Fu.test(y(H)); ) ++H;
        const z = i.substring(t, t = H);
        return (z === '"' || z === "'") && (f = z), z;
      }
      function N(C) {
        h.push(C);
      }
      function B() {
        if (!h.length) {
          const C = w();
          if (C === null) return null;
          N(C);
        }
        return h[0];
      }
      function O(C, V = false) {
        const F = B(), K = F === C;
        if (K) return w(), true;
        if (!V) throw g("token '" + F + "', '" + C + "' expected");
        return false;
      }
      function P(C) {
        let V = null;
        return C === void 0 ? a === n - 1 && (e || s === "*" || p) && (V = o) : (a < C && B(), a === C && !p && (e || s === "/") && (V = o)), V;
      }
      return Object.defineProperty({ next: w, peek: B, push: N, skip: O, cmnt: P }, "line", { get: function() {
        return n;
      } });
    }
    Object.defineProperty(ri, "filename", { value: null });
    ri.defaults = { keepCase: false };
    const ZE = /^[1-9][0-9]*$/;
    const eI = /^-?[1-9][0-9]*$/;
    const tI = /^0[x][0-9a-fA-F]+$/;
    const rI = /^-?0[x][0-9a-fA-F]+$/;
    const nI = /^0[0-7]+$/;
    const sI = /^-?0[0-7]+$/;
    const iI = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    const Js = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    const Ys = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    const oI = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
    function ri(i, e, t) {
      e instanceof ci || (t = e, e = new ci()), t || (t = ri.defaults);
      let r = W_(i, t.alternateCommentMode || false), n = r.next, s = r.push, o = r.peek, a = r.skip, p = r.cmnt, h = true, f, g, d, y, _ = false, I = e, S = t.keepCase ? function(j) {
        return j;
      } : Se.camelCase;
      function w(j, re, se) {
        const ae = Object.getOwnPropertyDescriptor(ri, "filename");
        return se || Object.defineProperty(ri, "filename", { value: null }), Error("illegal " + (re || "token") + " '" + j + "' (" + (ae ? ae + ", " : "") + "line " + r.line + ")");
      }
      function N() {
        let j = [], re;
        do {
          if ((re = n()) !== '"' && re !== "'") throw w(re);
          j.push(n()), a(re), re = o();
        } while (re === '"' || re === "'");
        return j.join("");
      }
      function B(j) {
        const re = n();
        switch (re) {
          case "'":
          case '"':
            return s(re), N();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return P(re, true);
        } catch {
          if (j && Ys.test(re)) return re;
          throw w(re, "value");
        }
      }
      function O(j, re) {
        let se, ae;
        do
          re && ((se = o()) === '"' || se === "'") ? j.push(N()) : j.push([ae = C(n()), a("to", true) ? C(n()) : ae]);
        while (a(",", true));
        a(";");
      }
      function P(j, re) {
        let se = 1;
        switch (j.charAt(0) === "-" && (se = -1, j = j.substring(1)), j) {
          case "inf":
          case "INF":
          case "Inf":
            return se * (1 / 0);
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (ZE.test(j)) return se * parseInt(j, 10);
        if (tI.test(j)) return se * parseInt(j, 16);
        if (nI.test(j)) return se * parseInt(j, 8);
        if (iI.test(j)) return se * parseFloat(j);
        throw w(j, "number", re);
      }
      function C(j, re) {
        switch (j) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!re && j.charAt(0) === "-") throw w(j, "id");
        if (eI.test(j)) return parseInt(j, 10);
        if (rI.test(j)) return parseInt(j, 16);
        if (sI.test(j)) return parseInt(j, 8);
        throw w(j, "id");
      }
      function V() {
        if (f !== void 0) throw w("package");
        if (f = n(), !Ys.test(f)) throw w(f, "name");
        I = I.define(f), a(";");
      }
      function F() {
        let j = o(), re;
        switch (j) {
          case "weak":
            re = d || (d = []), n();
            break;
          case "public":
            n();
          default:
            re = g || (g = []);
            break;
        }
        j = N(), a(";"), re.push(j);
      }
      function K() {
        if (a("="), y = N(), _ = y === "proto3", !_ && y !== "proto2") throw w(y, "syntax");
        a(";");
      }
      function L(j, re) {
        switch (re) {
          case "option":
            return he(j, re), a(";"), true;
          case "message":
            return W(j, re), true;
          case "enum":
            return ge(j, re), true;
          case "extend":
            return ke(j, re), true;
        }
        return false;
      }
      function H(j, re, se) {
        const ae = r.line;
        if (j && (j.comment = p(), j.filename = Object.getOwnPropertyDescriptor(ri, "filename")), a("{", true)) {
          for (let le; (le = n()) !== "}"; ) re(le);
          a(";", true);
        } else se && se(), a(";"), j && typeof j.comment !== "string" && (j.comment = p(ae));
      }
      function W(j, re) {
        if (!Js.test(re = n())) throw w(re, "type name");
        const se = new R(re);
        H(se, function(le) {
          if (!L(se, le)) switch (le) {
            case "map":
              q(se);
              break;
            case "required":
            case "optional":
            case "repeated":
              z(se, le);
              break;
            case "oneof":
              ie(se, le);
              break;
            case "extensions":
              O(se.extensions || (se.extensions = []));
              break;
            case "reserved":
              O(se.reserved || (se.reserved = []), true);
              break;
            default:
              if (!_ || !Ys.test(le)) throw w(le);
              s(le), z(se, "optional");
              break;
          }
        }), j.add(se);
      }
      function z(j, re, se) {
        const ae = n();
        if (ae === "group") {
          $(j, re);
          return;
        }
        if (!Ys.test(ae)) throw w(ae, "type");
        let le = n();
        if (!Js.test(le)) throw w(le, "name");
        le = S(le), a("=");
        const Pe = new A(le, C(n()), ae, re, se);
        H(Pe, function(Qe) {
          if (Qe === "option") he(Pe, Qe), a(";");
          else throw w(Qe);
        }, function() {
          de(Pe);
        }), j.add(Pe), !_ && Pe.repeated && (ud[ae] !== void 0 || ta[ae] === void 0) && Pe.setOption("packed", false, true);
      }
      function $(j, re) {
        let se = n();
        if (!Js.test(se)) throw w(se, "name");
        const ae = Se.lcFirst(se);
        se === ae && (se = Se.ucFirst(se)), a("=");
        const le = C(n()), Pe = new R(se);
        Pe.group = true;
        const Ke = new A(ae, le, se, re);
        Ke.filename = Object.getOwnPropertyDescriptor(ri, "filename"), H(Pe, function(tt) {
          switch (tt) {
            case "option":
              he(Pe, tt), a(";");
              break;
            case "required":
            case "optional":
            case "repeated":
              z(Pe, tt);
              break;
            default:
              throw w(tt);
          }
        }), j.add(Pe).add(Ke);
      }
      function q(j, re) {
        a("<");
        const se = n();
        if (hd[se] === void 0) throw w(se, "type");
        a(",");
        const ae = n();
        if (!Ys.test(ae)) throw w(ae, "type");
        a(">");
        const le = n();
        if (!Js.test(le)) throw w(le, "name");
        a("=");
        const Pe = new fr(S(le), C(n()), se, ae);
        H(Pe, function(Qe) {
          if (Qe === "option") he(Pe, Qe), a(";");
          else throw w(Qe);
        }, function() {
          de(Pe);
        }), j.add(Pe);
      }
      function ie(j, re) {
        if (!Js.test(re = n())) throw w(re, "name");
        const se = new Ns(S(re));
        H(se, function(le) {
          le === "option" ? (he(se, le), a(";")) : (s(le), z(se, "optional"));
        }), j.add(se);
      }
      function ge(j, re) {
        if (!Js.test(re = n())) throw w(re, "name");
        const se = new br(re);
        H(se, function(le) {
          switch (le) {
            case "option":
              he(se, le), a(";");
              break;
            case "reserved":
              O(se.reserved || (se.reserved = []), true);
              break;
            default:
              Ae(se, le);
          }
        }), j.add(se);
      }
      function Ae(j, re) {
        if (!Js.test(re)) throw w(re, "name");
        a("=");
        const se = C(n(), true), ae = {};
        H(ae, function(Pe) {
          if (Pe === "option") he(ae, Pe), a(";");
          else throw w(Pe);
        }, function() {
          de(ae);
        }), j.add(re, se, ae.comment);
      }
      function he(j, re) {
        const se = a("(", true);
        if (!Ys.test(re = n())) throw w(re, "name");
        let ae = re;
        se && (a(")"), ae = "(" + ae + ")", re = o(), oI.test(re) && (ae += re, n())), a("="), x(j, ae);
      }
      function x(j, re) {
        if (a("{", true)) do {
          if (!Js.test(pe = n())) throw w(pe, "name");
          o() === "{" ? x(j, re + "." + pe) : (a(":"), o() === "{" ? x(j, re + "." + pe) : ce(j, re + "." + pe, B(true))), a(",", true);
        } while (!a("}", true));
        else ce(j, re, B(true));
      }
      function ce(j, re, se) {
        j.setOption && j.setOption(re, se);
      }
      function de(j) {
        if (a("[", true)) {
          do
            he(j, "option");
          while (a(",", true));
          a("]");
        }
        return j;
      }
      function ke(j, re) {
        if (!Ys.test(re = n())) throw w(re, "reference");
        const se = re;
        H(null, function(le) {
          switch (le) {
            case "required":
            case "repeated":
            case "optional":
              z(j, le, se);
              break;
            default:
              if (!_ || !Ys.test(le)) throw w(le);
              s(le), z(j, "optional", se);
              break;
          }
        });
      }
      for (var pe; (pe = n()) !== null; ) switch (pe) {
        case "package":
          if (!h) throw w(pe);
          V();
          break;
        case "import":
          if (!h) throw w(pe);
          F();
          break;
        case "syntax":
          if (!h) throw w(pe);
          K();
          break;
        case "option":
          if (!h) throw w(pe);
          he(I, pe), a(";");
          break;
        default:
          if (L(I, pe)) {
            h = false;
            continue;
          }
          throw w(pe);
      }
      return Object.defineProperty(ri, "filename", { value: null }), { package: f, imports: g, weakImports: d, syntax: y, root: e };
    }
    Se._configure(br, ci, R);
    Se._configure2();
    xs._configure(ci);
    Ht._configure(R, br, A);
    ci._configure(R);
    A._configure(R);
    Xr._configure(Y_);
    kn._configure(fd);
    const Sc = Se.Long;
    let os = class extends Y {
      toJSON() {
        return { numerator: this.numerator, denominator: this.denominator };
      }
    };
    l([A.d(1, "int32"), u("design:type", Number)], os.prototype, "numerator", void 0);
    l([A.d(2, "int32"), u("design:type", Number)], os.prototype, "denominator", void 0);
    os = l([R.d("Fraction")], os);
    let Nr = class extends Y {
      toJSON() {
        return { numerator: this.numerator, denominator: this.denominator };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], Nr.prototype, "numerator", void 0);
    l([A.d(2, "string"), u("design:type", String)], Nr.prototype, "denominator", void 0);
    Nr = l([R.d("FractionBigIntModel")], Nr);
    let ia = class extends Y {
      toJSON() {
        return { start: this.start, end: this.end };
      }
    };
    l([A.d(1, "uint32"), u("design:type", Number)], ia.prototype, "start", void 0);
    l([A.d(2, "uint32"), u("design:type", Number)], ia.prototype, "end", void 0);
    ia = l([R.d("Range")], ia);
    let oa = class extends Y {
      toJSON() {
        return { prevWeight: this.prevWeight, nextWeight: this.nextWeight };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], oa.prototype, "prevWeight", void 0);
    l([A.d(2, "string"), u("design:type", String)], oa.prototype, "nextWeight", void 0);
    oa = l([R.d("RateModel")], oa);
    const bi = class {
      constructor(e, t) {
        this._raw = e, this.valueCode = t, this._m = /* @__PURE__ */ new Map();
        for (const [r, n] of Object.entries(this._raw)) this._m.set(r, t.decode(n, r));
      }
      set(e, t) {
        return this._m.set(e, t), this._raw[e] = this.valueCode.encode(t, e), this;
      }
      delete(e) {
        return this._m.delete(e) ? (delete this._raw[e], true) : false;
      }
      clear() {
        for (const e in this._raw) delete this._raw[e];
        return this._m.clear();
      }
      toObject() {
        const e = {};
        for (const [t, r] of this._m) e[t[0]] = r;
        return e;
      }
      toJSON() {
        const e = {};
        for (const t of this._m.entries()) {
          const r = t[1];
          e[t[0]] = r && typeof r.toJSON === "function" ? r.toJSON() : r;
        }
        return e;
      }
      get has() {
        return this._m.has.bind(this._m);
      }
      get get() {
        return this._m.get.bind(this._m);
      }
      get size() {
        return this._m.size;
      }
      get [Symbol.iterator]() {
        return this._m[Symbol.iterator].bind(this._m);
      }
      get entries() {
        return this._m.entries.bind(this._m);
      }
      get keys() {
        return this._m.keys.bind(this._m);
      }
      get values() {
        return this._m.values.bind(this._m);
      }
      get [Symbol.toStringTag]() {
        return "TypedMap";
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], bi.prototype, "has", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], bi.prototype, "get", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], bi.prototype, Symbol.iterator, null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], bi.prototype, "entries", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], bi.prototype, "keys", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], bi.prototype, "values", null);
    const pi = class extends bi {
      constructor(e) {
        super(e, { decode: (t) => t, encode: (t) => t });
      }
    };
    const X_ = class extends bi {
      constructor(e) {
        super(e, { decode: (t) => JSON.parse(t), encode: (t) => JSON.stringify(t) });
      }
    };
    const Sl = class {
      constructor(e) {
        this._l = e, this._s = new Set(e);
      }
      add(e) {
        return this._s.has(e) || (this._l.push(e), this._s.add(e)), this;
      }
      delete(e) {
        if (this._s.delete(e)) {
          const t = this._l.indexOf(e);
          return this._l.splice(t, 1), true;
        }
        return false;
      }
      clear() {
        this._s.clear(), this._l.length = 0;
      }
      get has() {
        return this._s.has.bind(this._s);
      }
      get size() {
        return this._s.size;
      }
      get [Symbol.iterator]() {
        return this._s[Symbol.iterator].bind(this._s);
      }
      get entries() {
        return this._s.entries.bind(this._s);
      }
      get keys() {
        return this._s.keys.bind(this._s);
      }
      get values() {
        return this._s.values.bind(this._s);
      }
      get [Symbol.toStringTag]() {
        return "TypedSet";
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Sl.prototype, "has", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Sl.prototype, Symbol.iterator, null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Sl.prototype, "entries", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Sl.prototype, "keys", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Sl.prototype, "values", null);
    let Rc = class extends Y {
      get remarkMap() {
        return this._remarkMap || (this._remarkMap = new pi(this.remark)), this._remarkMap;
      }
      toJSON() {
        return { remark: this.remark };
      }
      getBytes() {
        return this.$type.encode(this).finish();
      }
    };
    l([fr.d(1, "string", "string"), u("design:type", Object)], Rc.prototype, "remark", void 0);
    l([Vs, u("design:type", Function), u("design:paramtypes", []), u("design:returntype", void 0)], Rc.prototype, "getBytes", null);
    Rc = l([R.d("TemplateRemark")], Rc);
    const Af = /* @__PURE__ */ new WeakMap();
    const aI = new Uint8Array();
    const ih = [];
    const oh = /* @__PURE__ */ Object.create({});
    for (let i = 0; i < 256; i++) {
      const e = i.toString(16).padStart(2, "0");
      ih[i] = e, oh[e] = i, oh[e.toUpperCase()] = i;
    }
    const Ef = [];
    {
      const i = new Uint16Array(1), e = new Uint8Array(i.buffer);
      for (const t of ih) for (const r of ih) e[0] = oh[t], e[1] = oh[r], Ef[i[0]] = t + r;
    }
    const Ac = new Uint8Array(40);
    const lm = new Uint16Array(Ac.buffer);
    function cI(i) {
      const e = i.length >> 1;
      let t = "";
      if (Ac.length >= i.length) {
        Ac.set(i, 0);
        for (let r = 0; r < e; r++) t += Ef[lm[r]];
      } else {
        let r = 0;
        do {
          const n = Math.min(Ac.length, i.length - r);
          for (let o = 0; o < n; ++o) Ac[o] = i[o + r];
          const s = n >> 1;
          for (let o = 0; o < s; o++) t += Ef[lm[o]];
          r += n;
        } while (r < i.length);
      }
      return e << 1 !== i.length && (t += ih[i[i.length - 1]]), t;
    }
    function q_(i) {
      const e = new Uint8Array(i.length >> 1);
      let t = 0, r = 0;
      for (; r < e.length; ) {
        let n = i.charCodeAt(t++);
        n <= 57 ? n = n - 48 << 4 : n <= 70 ? n = n - 55 << 4 : n <= 102 && (n = n - 87 << 4);
        let s = i.charCodeAt(t++);
        s <= 57 ? s -= 48 : s <= 70 ? s -= 55 : s <= 102 && (s -= 87), e[r++] = n + s;
      }
      return e;
    }
    function gd(i) {
      if (!i) return "";
      let e;
      return i.length === i.byteLength && (e = Af.get(i), typeof e === "string") || (e = cI(i), Af.set(i, e)), e;
    }
    const xe = gd;
    function Z_(i) {
      if (!i) return aI;
      const e = q_(i);
      return Af.set(e, i), e;
    }
    const _e = Z_;
    let Wa;
    let gt = Wa = class extends Y {
      get publicKey() {
        return xe(this.publicKeyBuffer);
      }
      set publicKey(e) {
        this.publicKeyBuffer = _e(e);
      }
      get signature() {
        return xe(this.signatureBuffer);
      }
      set signature(e) {
        this.signatureBuffer = _e(e);
      }
      get secondPublicKey() {
        return this.secondPublicKeyBuffer && xe(this.secondPublicKeyBuffer) || void 0;
      }
      set secondPublicKey(e) {
        this.secondPublicKeyBuffer = _e(e);
      }
      get signSignature() {
        return this.signSignatureBuffer && xe(this.signSignatureBuffer) || void 0;
      }
      set signSignature(e) {
        this.signSignatureBuffer = _e(e);
      }
      toJSON() {
        const e = { publicKey: this.publicKey, signature: this.signature };
        return this.secondPublicKey && (e.secondPublicKey = this.secondPublicKey), this.signSignature && (e.signSignature = this.signSignature), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.publicKey && (t.publicKey = e.publicKey), e.signature && (t.signature = e.signature), e.secondPublicKey && (t.secondPublicKey = e.secondPublicKey), e.signSignature && (t.signSignature = e.signSignature)), t;
      }
    };
    gt.INC = 1;
    l([A.d(Wa.INC++, "bytes"), u("design:type", Uint8Array)], gt.prototype, "publicKeyBuffer", void 0);
    l([A.d(Wa.INC++, "bytes"), u("design:type", Uint8Array)], gt.prototype, "signatureBuffer", void 0);
    l([A.d(Wa.INC++, "bytes"), u("design:type", Uint8Array)], gt.prototype, "secondPublicKeyBuffer", void 0);
    l([A.d(Wa.INC++, "bytes"), u("design:type", Uint8Array)], gt.prototype, "signSignatureBuffer", void 0);
    gt = Wa = l([R.d("AccountSignatureModel")], gt);
    let Qt = class extends Y {
      toJSON() {
        return { taxCollector: this.taxCollector, taxAssetPrealnum: this.taxAssetPrealnum };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], Qt.prototype, "taxCollector", void 0);
    l([A.d(2, "string"), u("design:type", String)], Qt.prototype, "taxAssetPrealnum", void 0);
    Qt = l([R.d("TaxInformationModel")], Qt);
    let ah;
    (function(i) {
      i.TESTNET = "c", i.MAINNET = "b";
    })(ah || (ah = {}));
    const eA = "100000000";
    let hm;
    (function(i) {
      i[i.CHAIN = 2] = "CHAIN", i[i.DAPP = 4] = "DAPP", i[i.LNS = 8] = "LNS";
    })(hm || (hm = {}));
    const ch = { ENDPOINT: /* @__PURE__ */ Symbol("endpoint"), REFUSETIME: /* @__PURE__ */ Symbol("refuseTime") };
    let G;
    (function(i) {
      i[i.DAPP = 1] = "DAPP", i[i.LOCATION_NAME = 2] = "LOCATION_NAME", i[i.ENTITY = 3] = "ENTITY", i[i.ASSETS = 5] = "ASSETS", i[i.CERTIFICATE = 6] = "CERTIFICATE";
    })(G || (G = {}));
    let ht;
    (function(i) {
      i[i.GIFT = 0] = "GIFT", i[i.EXCHANGE = 1] = "EXCHANGE", i[i.TRUST = 2] = "TRUST", i[i.ENTITY = 3] = "ENTITY";
    })(ht || (ht = {}));
    let Fi;
    (function(i) {
      i[i.P_0 = 0] = "P_0", i[i.P_1 = 1] = "P_1", i[i.P_2 = 2] = "P_2", i[i.P_3 = 3] = "P_3", i[i.P_4 = 4] = "P_4", i[i.P_5 = 5] = "P_5", i[i.P_6 = 6] = "P_6", i[i.P_7 = 7] = "P_7", i[i.P_8 = 8] = "P_8", i[i.P_9 = 9] = "P_9", i.P_10 = "A", i.P_11 = "B", i.P_12 = "C", i.P_13 = "D", i.P_14 = "E", i.P_15 = "F", i.P_16 = "G", i.P_17 = "H", i.P_18 = "I", i.P_19 = "J", i.P_20 = "K", i.P_21 = "L", i.P_22 = "M", i.P_23 = "N", i.P_24 = "O", i.P_25 = "P", i.P_26 = "Q", i.P_27 = "R", i.P_28 = "S", i.P_29 = "T", i.P_30 = "U", i.P_31 = "V", i.P_32 = "W", i.P_33 = "X", i.P_34 = "Y", i.P_35 = "Z";
    })(Fi || (Fi = {}));
    let ph;
    (function(i) {
      i.DIFFERENT_PRE_BLOCK_SIGNATURE = "the previous block signature is inconsistent", i.GENERATE_BLOCK_FAIL = "generate block fail", i.REPLY_BLOCK_FAIL = "reply block fail";
    })(ph || (ph = {}));
    let v;
    (function(i) {
      i.SIGNATURE = "BSE-01", i.DAPP = "WOD-00", i.DAPP_PURCHASING = "WOD-01", i.REGISTER_CHAIN = "WOD-02", i.MARK = "EXT-00", i.ISSUE_ASSET = "AST-00", i.INCREASE_ASSET = "AST-01", i.TRANSFER_ASSET = "AST-02", i.DESTROY_ASSET = "AST-03", i.GIFT_ASSET = "AST-04", i.GRAB_ASSET = "AST-05", i.TRUST_ASSET = "AST-06", i.SIGN_FOR_ASSET = "AST-07", i.EMIGRATE_ASSET = "AST-08", i.IMMIGRATE_ASSET = "AST-09", i.TO_EXCHANGE_ASSET = "AST-10", i.BE_EXCHANGE_ASSET = "AST-11", i.STAKE_ASSET = "AST-12", i.UNSTAKE_ASSET = "AST-13", i.LOCATION_NAME = "LNS-00", i.SET_LNS_RECORD_VALUE = "LNS-01", i.SET_LNS_MANAGER = "LNS-02", i.ISSUE_ENTITY_FACTORY = "ETY-00", i.ISSUE_ENTITY_FACTORY_V1 = "ETY-01", i.ISSUE_ENTITY = "ETY-02", i.DESTROY_ENTITY = "ETY-03", i.ISSUE_ENTITY_MULTI = "ETY-04", i.TRANSFER_ANY = "ANY-00", i.GIFT_ANY = "ANY-01", i.GRAB_ANY = "ANY-02", i.TO_EXCHANGE_ANY = "ANY-03", i.BE_EXCHANGE_ANY = "ANY-04", i.TO_EXCHANGE_ANY_MULTI = "ANY-05", i.BE_EXCHANGE_ANY_MULTI = "ANY-06", i.TO_EXCHANGE_ANY_MULTI_ALL = "ANY-07", i.BE_EXCHANGE_ANY_MULTI_ALL = "ANY-08", i.ISSUE_CERTIFICATE = "CRT-00", i.DESTROY_CERTIFICATE = "CRT-01", i.MULTIPLE = "MTP-00", i.PROMISE = "PMS-00", i.PROMISE_RESOLVE = "PMS-01", i.MACRO = "MAC-00", i.MACRO_CALL = "MAC-01";
    })(v || (v = {}));
    const Re = { VK: /* @__PURE__ */ new Map(), KV: /* @__PURE__ */ new Map(), VM: /* @__PURE__ */ new Map(), MV: /* @__PURE__ */ new Map(), trsTypeToV(i) {
      const e = i.indexOf("-", i.indexOf("-") + 1);
      return i.substr(e + 1);
    } };
    const wt = class _wt extends Map {
      constructor(e, t, r = (s) => s, n) {
        super(t), this.creater = e, this.transformKey = r, this._afterDelete = n;
      }
      static from(e) {
        return new _wt(e.creater, e.entries, e.transformKey, e.afterDelete);
      }
      forceGet(e, t = this.creater) {
        const r = this.transformKey(e);
        if (super.has(r)) return super.get(r);
        const n = t(e, r);
        return super.set(r, n), n;
      }
      tryGet(e) {
        return this.get(this.transformKey(e));
      }
      trySet(e, t) {
        return this.set(this.transformKey(e), t);
      }
      tryDelete(e) {
        return this.delete(this.transformKey(e));
      }
      tryHas(e) {
        return this.has(this.transformKey(e));
      }
      delete(e) {
        const t = super.delete(e);
        return t && this._afterDelete && this._afterDelete(e), t;
      }
      get [Symbol.toStringTag]() {
        return "EasyMap";
      }
      static call(e, t, r, n, s) {
        if (!(e instanceof _wt)) throw new TypeError("please use new keyword to create EasyMap instance.");
        const o = new _wt(t, r, n, s), a = Object.getPrototypeOf(o), p = Object.getPrototypeOf(a), h = Object.getOwnPropertyDescriptors(p);
        for (const d in h) if (d !== "constructor") {
          const y = h[d];
          typeof y.value === "function" ? y.value = y.value.bind(o) : (typeof y.get === "function" && (y.get = y.get.bind(o)), typeof y.set === "function" && (y.set = y.set.bind(o))), Object.defineProperty(e, d, y);
        }
        const f = Object.getOwnPropertyDescriptors(a);
        for (const d in f) if (d !== "constructor") {
          const y = f[d];
          typeof y.value === "function" ? y.value = y.value.bind(o) : (typeof y.get === "function" && (y.get = y.get.bind(o)), typeof y.set === "function" && (y.set = y.set.bind(o))), Object.defineProperty(e, d, y);
        }
        const g = Object.getOwnPropertyDescriptors(o);
        for (const d in g) d !== "constructor" && Object.defineProperty(e, d, { enumerable: true, configurable: true, get: () => Reflect.get(o, d), set(y) {
          Reflect.set(o, d, y);
        } });
        return e;
      }
    };
    const ss = class _ss extends WeakMap {
      constructor(e, t, r = (s) => s, n) {
        super(t), this.creater = e, this.transformKey = r, this._afterDelete = n;
      }
      static from(e) {
        return new _ss(e.creater, e.entries, e.transformKey, e.afterDelete);
      }
      forceGet(e, t = this.creater) {
        const r = this.transformKey(e);
        if (this.has(r)) return this.get(r);
        const n = t(e, r);
        return this.set(r, n), n;
      }
      tryGet(e) {
        return this.get(this.transformKey(e));
      }
      trySet(e, t) {
        return this.set(this.transformKey(e), t);
      }
      tryDelete(e) {
        return this.delete(this.transformKey(e));
      }
      tryHas(e) {
        return this.has(this.transformKey(e));
      }
      delete(e) {
        const t = super.delete(e);
        return t && this._afterDelete && this._afterDelete(e), t;
      }
      get [Symbol.toStringTag]() {
        return "EasyWeakMap";
      }
      static call(e, t, r, n, s) {
        if (!(e instanceof _ss)) throw new TypeError("please use new keyword to create EasyWeakMap instance.");
        const o = new _ss(t, r, n, s), a = Object.getPrototypeOf(o), p = Object.getPrototypeOf(a), h = Object.getOwnPropertyDescriptors(p);
        for (const d in h) if (d !== "constructor") {
          const y = h[d];
          typeof y.value === "function" ? y.value = y.value.bind(o) : (typeof y.get === "function" && (y.get = y.get.bind(o)), typeof y.set === "function" && (y.set = y.set.bind(o))), Object.defineProperty(e, d, y);
        }
        const f = Object.getOwnPropertyDescriptors(a);
        for (const d in f) if (d !== "constructor") {
          const y = f[d];
          typeof y.value === "function" ? y.value = y.value.bind(o) : (typeof y.get === "function" && (y.get = y.get.bind(o)), typeof y.set === "function" && (y.set = y.set.bind(o))), Object.defineProperty(e, d, y);
        }
        const g = Object.getOwnPropertyDescriptors(o);
        for (const d in g) d !== "constructor" && Object.defineProperty(e, d, { enumerable: true, configurable: true, get: () => Reflect.get(o, d), set(y) {
          Reflect.set(o, d, y);
        } });
        return e;
      }
    };
    let gu;
    let Rt;
    const pI = new ss((i) => new pi(i.remark));
    const lI = new ss((i) => {
      const e = {}, t = "blob+sha256+hex://";
      for (const r in i.remark) {
        const n = i.remark[r];
        if (n.startsWith(t)) {
          const s = n.slice(t.length).split("?");
          if (s.length !== 2) continue;
          try {
            const o = q_(s[0]);
            if (o.length === 32) {
              const a = s[1].split("=");
              if (a.length !== 2 || a[0] !== "size") continue;
              const p = Number(a[1]);
              if (Number.isNaN(p)) continue;
              e[r] = ["SHA256", s[0], o, p];
            }
          } catch {
          }
        }
      }
      return new pi(e);
    });
    let as = gu = class extends Y {
      toJSON() {
        return { key: this.key, value: this.value };
      }
    };
    as.INC = 1;
    l([A.d(gu.INC++, "string"), u("design:type", String)], as.prototype, "key", void 0);
    l([A.d(gu.INC++, "string"), u("design:type", String)], as.prototype, "value", void 0);
    as = gu = l([R.d("TransactionBaseStorageModel")], as);
    let Je = Rt = class extends Y {
      get senderPublicKey() {
        return xe(this.senderPublicKeyBuffer);
      }
      set senderPublicKey(e) {
        this.senderPublicKeyBuffer = _e(e);
      }
      get senderSecondPublicKey() {
        return this.senderSecondPublicKeyBuffer && xe(this.senderSecondPublicKeyBuffer) || void 0;
      }
      set senderSecondPublicKey(e) {
        this.senderSecondPublicKeyBuffer = _e(e);
      }
      get signature() {
        return xe(this.signatureBuffer);
      }
      set signature(e) {
        this.signatureBuffer = _e(e);
      }
      get storageKey() {
        return this.storage && this.storage.key;
      }
      get storageValue() {
        return this.storage && this.storage.value;
      }
      get signSignature() {
        return this.signSignatureBuffer && xe(this.signSignatureBuffer) || void 0;
      }
      set signSignature(e) {
        this.signSignatureBuffer = _e(e);
      }
      get remarkMap() {
        return pI.forceGet(this);
      }
      get blobMap() {
        return lI.forceGet(this);
      }
      getBlobSize(e = false) {
        let t = 0;
        const r = this.blobMap.values();
        for (const n of r) t += n[3];
        return t;
      }
      getBytes(e, t) {
        const r = {};
        e && (r.signatureBuffer = { value: null }), t && (r.signSignatureBuffer = { value: null });
        const n = Object.create(this, r);
        return this.$type.encode(n).finish();
      }
      toJSON() {
        const e = { version: this.version, type: this.type, senderId: this.senderId, senderPublicKey: this.senderPublicKey, rangeType: this.rangeType, range: this.range, fee: this.fee, timestamp: this.timestamp, fromMagic: this.fromMagic, toMagic: this.toMagic, applyBlockHeight: this.applyBlockHeight, effectiveBlockHeight: this.effectiveBlockHeight, signature: this.signature, remark: this.remark, asset: this.asset.toJSON() };
        return this.recipientId && (e.recipientId = this.recipientId), this.dappid && (e.dappid = this.dappid), this.lns && (e.lns = this.lns), this.sourceIP && (e.sourceIP = this.sourceIP), this.senderSecondPublicKey && (e.senderSecondPublicKey = this.senderSecondPublicKey), this.signSignature && (e.signSignature = this.signSignature), this.storageKey && (e.storageKey = this.storageKey), this.storageValue && (e.storageValue = this.storageValue), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.senderPublicKey && (t.senderPublicKey = e.senderPublicKey), e.senderSecondPublicKey && (t.senderSecondPublicKey = e.senderSecondPublicKey), e.signature && (t.signature = e.signature), e.signSignature && (t.signSignature = e.signSignature), !t.storage && typeof e.storageKey === "string" && typeof e.storageValue === "string" && (t.storage = new as({ key: e.storageKey, value: e.storageValue }))), t;
      }
      as(e, t) {
      }
    };
    Je.INC = 1;
    l([A.d(Rt.INC++, "uint32"), u("design:type", Number)], Je.prototype, "version", void 0);
    l([A.d(Rt.INC++, "string"), u("design:type", String)], Je.prototype, "type", void 0);
    l([A.d(Rt.INC++, "string"), u("design:type", String)], Je.prototype, "senderId", void 0);
    l([A.d(Rt.INC++, "bytes"), u("design:type", Uint8Array)], Je.prototype, "senderPublicKeyBuffer", void 0);
    l([A.d(Rt.INC++, "bytes", "optional"), u("design:type", Uint8Array)], Je.prototype, "senderSecondPublicKeyBuffer", void 0);
    l([A.d(Rt.INC++, "string", "optional"), u("design:type", String)], Je.prototype, "recipientId", void 0);
    l([A.d(Rt.INC++, "uint32"), u("design:type", Number)], Je.prototype, "rangeType", void 0);
    l([A.d(Rt.INC++, "string", "repeated"), u("design:type", Array)], Je.prototype, "range", void 0);
    l([A.d(Rt.INC++, "string"), u("design:type", String)], Je.prototype, "fee", void 0);
    l([A.d(Rt.INC++, "uint32"), u("design:type", Number)], Je.prototype, "timestamp", void 0);
    l([A.d(Rt.INC++, "string", "optional"), u("design:type", String)], Je.prototype, "dappid", void 0);
    l([A.d(Rt.INC++, "string", "optional"), u("design:type", String)], Je.prototype, "lns", void 0);
    l([A.d(Rt.INC++, "string", "optional"), u("design:type", String)], Je.prototype, "sourceIP", void 0);
    l([A.d(Rt.INC++, "string"), u("design:type", String)], Je.prototype, "fromMagic", void 0);
    l([A.d(Rt.INC++, "string"), u("design:type", String)], Je.prototype, "toMagic", void 0);
    l([A.d(Rt.INC++, "uint32"), u("design:type", Number)], Je.prototype, "applyBlockHeight", void 0);
    l([A.d(Rt.INC++, "uint32"), u("design:type", Number)], Je.prototype, "effectiveBlockHeight", void 0);
    l([A.d(Rt.INC++, "bytes"), u("design:type", Uint8Array)], Je.prototype, "signatureBuffer", void 0);
    l([A.d(Rt.INC++, as, "optional"), u("design:type", as)], Je.prototype, "storage", void 0);
    l([A.d(Rt.INC++, "bytes", "optional"), u("design:type", Uint8Array)], Je.prototype, "signSignatureBuffer", void 0);
    l([fr.d(Rt.INC++, "string", "string"), u("design:type", Object)], Je.prototype, "remark", void 0);
    l([Vs, u("design:type", Function), u("design:paramtypes", [Boolean, Boolean]), u("design:returntype", void 0)], Je.prototype, "getBytes", null);
    Je = Rt = l([R.d("Transaction")], Je);
    let Ve = class extends Je {
      as(e, t) {
        const r = Re.MV.get(e), n = Re.trsTypeToV(this.type);
        if (r === n) if (t) {
          if (this.signature === t) return this;
        } else return this;
      }
    };
    Ve = l([R.d("AbstractTransaction")], Ve);
    let Bc = class extends Y {
      get publicKey() {
        return xe(this.publicKeyBuffer);
      }
      set publicKey(e) {
        this.publicKeyBuffer = _e(e);
      }
      toJSON() {
        return { publicKey: this.publicKey };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.publicKey && (t.publicKey = e.publicKey), t;
      }
    };
    l([A.d(1, "bytes"), u("design:type", Uint8Array)], Bc.prototype, "publicKeyBuffer", void 0);
    Bc = l([R.d("SignatureModel")], Bc);
    let Pc = class extends Y {
      toJSON() {
        return { signature: this.signature.toJSON() };
      }
    };
    l([A.d(1, Bc), u("design:type", Bc)], Pc.prototype, "signature", void 0);
    Pc = l([R.d("SignatureAssetModel")], Pc);
    let _o;
    let $r = _o = class extends Y {
      toJSON() {
        const e = { sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, dappid: this.dappid, type: this.type };
        return this.purchaseAsset && (e.purchaseAsset = this.purchaseAsset), e;
      }
    };
    $r.INC = 1;
    l([A.d(_o.INC++, "string"), u("design:type", String)], $r.prototype, "sourceChainName", void 0);
    l([A.d(_o.INC++, "string"), u("design:type", String)], $r.prototype, "sourceChainMagic", void 0);
    l([A.d(_o.INC++, "string"), u("design:type", String)], $r.prototype, "dappid", void 0);
    l([A.d(_o.INC++, "uint32"), u("design:type", Number)], $r.prototype, "type", void 0);
    l([A.d(_o.INC++, "string", "optional"), u("design:type", String)], $r.prototype, "purchaseAsset", void 0);
    $r = _o = l([R.d("DAppModel")], $r);
    let Mc = class extends Y {
      toJSON() {
        return { dapp: this.dapp.toJSON() };
      }
    };
    l([A.d(1, $r), u("design:type", $r)], Mc.prototype, "dapp", void 0);
    Mc = l([R.d("DAppAssetModel")], Mc);
    let dd;
    let aa = dd = class extends Y {
      toJSON() {
        return { dappAsset: this.dappAsset.toJSON() };
      }
    };
    aa.INC = 1;
    l([A.d(dd.INC++, $r), u("design:type", $r)], aa.prototype, "dappAsset", void 0);
    aa = dd = l([R.d("DAppPurchasingModel")], aa);
    let Lc = class extends Y {
      toJSON() {
        return { dappPurchasing: this.dappPurchasing.toJSON() };
      }
    };
    l([A.d(1, aa), u("design:type", aa)], Lc.prototype, "dappPurchasing", void 0);
    Lc = l([R.d("DAppPurchasingAssetModel")], Lc);
    let wl;
    let li = wl = class extends Y {
      toJSON() {
        return { content: this.content, action: this.action, dapp: this.dapp.toJSON() };
      }
    };
    li.INC = 1;
    l([A.d(wl.INC++, "string"), u("design:type", String)], li.prototype, "content", void 0);
    l([A.d(wl.INC++, "string"), u("design:type", String)], li.prototype, "action", void 0);
    l([A.d(wl.INC++, $r), u("design:type", $r)], li.prototype, "dapp", void 0);
    li = wl = l([R.d("MarkModel")], li);
    let Hc = class extends Y {
      toJSON() {
        return { mark: this.mark.toJSON() };
      }
    };
    l([A.d(1, li), u("design:type", li)], Hc.prototype, "mark", void 0);
    Hc = l([R.d("MarkAssetModel")], Hc);
    let hi = class extends Y {
      toJSON() {
        return { sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, assetType: this.assetType, expectedIssuedAssets: this.expectedIssuedAssets };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], hi.prototype, "sourceChainName", void 0);
    l([A.d(2, "string"), u("design:type", String)], hi.prototype, "sourceChainMagic", void 0);
    l([A.d(3, "string"), u("design:type", String)], hi.prototype, "assetType", void 0);
    l([A.d(4, "string"), u("design:type", String)], hi.prototype, "expectedIssuedAssets", void 0);
    hi = l([R.d("IssueAssetModel")], hi);
    let vc = class extends Y {
      toJSON() {
        return { issueAsset: this.issueAsset.toJSON() };
      }
    };
    l([A.d(1, hi), u("design:type", hi)], vc.prototype, "issueAsset", void 0);
    vc = l([R.d("IssueAssetAssetModel")], vc);
    let cs = class extends Y {
      toJSON() {
        return { applyAddress: this.applyAddress, sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, assetType: this.assetType, increasedAssetPrealnum: this.increasedAssetPrealnum, frozenMainAssetPrealnum: this.frozenMainAssetPrealnum };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], cs.prototype, "applyAddress", void 0);
    l([A.d(2, "string"), u("design:type", String)], cs.prototype, "sourceChainName", void 0);
    l([A.d(3, "string"), u("design:type", String)], cs.prototype, "sourceChainMagic", void 0);
    l([A.d(4, "string"), u("design:type", String)], cs.prototype, "assetType", void 0);
    l([A.d(5, "string"), u("design:type", String)], cs.prototype, "increasedAssetPrealnum", void 0);
    l([A.d(6, "string"), u("design:type", String)], cs.prototype, "frozenMainAssetPrealnum", void 0);
    cs = l([R.d("IncreaseAssetModel")], cs);
    let kc = class extends Y {
      toJSON() {
        return { increaseAsset: this.increaseAsset.toJSON() };
      }
    };
    l([A.d(1, cs), u("design:type", cs)], kc.prototype, "increaseAsset", void 0);
    kc = l([R.d("IncreaseAssetAssetModel")], kc);
    let ui = class extends Y {
      toJSON() {
        return { sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, assetType: this.assetType, amount: this.amount };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], ui.prototype, "sourceChainName", void 0);
    l([A.d(2, "string"), u("design:type", String)], ui.prototype, "sourceChainMagic", void 0);
    l([A.d(3, "string"), u("design:type", String)], ui.prototype, "assetType", void 0);
    l([A.d(4, "string"), u("design:type", String)], ui.prototype, "amount", void 0);
    ui = l([R.d("TransferAssetModel")], ui);
    let Dc = class extends Y {
      toJSON() {
        return { transferAsset: this.transferAsset.toJSON() };
      }
    };
    l([A.d(1, ui), u("design:type", ui)], Dc.prototype, "transferAsset", void 0);
    Dc = l([R.d("TransferAssetAssetModel")], Dc);
    let fi = class extends Y {
      toJSON() {
        return { sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, assetType: this.assetType, amount: this.amount };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], fi.prototype, "sourceChainName", void 0);
    l([A.d(2, "string"), u("design:type", String)], fi.prototype, "sourceChainMagic", void 0);
    l([A.d(3, "string"), u("design:type", String)], fi.prototype, "assetType", void 0);
    l([A.d(4, "string"), u("design:type", String)], fi.prototype, "amount", void 0);
    fi = l([R.d("DestroyAssetModel")], fi);
    let Fc = class extends Y {
      toJSON() {
        return { destroyAsset: this.destroyAsset.toJSON() };
      }
    };
    l([A.d(1, fi), u("design:type", fi)], Fc.prototype, "destroyAsset", void 0);
    Fc = l([R.d("DestroyAssetAssetModel")], Fc);
    let ms;
    const um = /* @__PURE__ */ new WeakMap();
    let Lr = ms = class extends Y {
      get cipherPublicKeys() {
        const { cipherPublicKeysBuffer: e } = this;
        let t = um.get(e);
        return t || (t = this.cipherPublicKeysBuffer.map((r) => xe(r))), t;
      }
      set cipherPublicKeys(e) {
        const t = e.map((r) => _e(r));
        um.set(t, e), this.cipherPublicKeysBuffer = t;
      }
      toJSON() {
        const e = { cipherPublicKeys: this.cipherPublicKeys, sourceChainMagic: this.sourceChainMagic, sourceChainName: this.sourceChainName, assetType: this.assetType, amount: this.amount, totalGrabableTimes: this.totalGrabableTimes, giftDistributionRule: this.giftDistributionRule };
        return this.beginUnfrozenBlockHeight && (e.beginUnfrozenBlockHeight = this.beginUnfrozenBlockHeight), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.cipherPublicKeys && (t.cipherPublicKeys = e.cipherPublicKeys), t;
      }
    };
    Lr.INC = 1;
    l([A.d(ms.INC++, "bytes", "repeated"), u("design:type", Array)], Lr.prototype, "cipherPublicKeysBuffer", void 0);
    l([A.d(ms.INC++, "string"), u("design:type", String)], Lr.prototype, "sourceChainMagic", void 0);
    l([A.d(ms.INC++, "string"), u("design:type", String)], Lr.prototype, "sourceChainName", void 0);
    l([A.d(ms.INC++, "string"), u("design:type", String)], Lr.prototype, "assetType", void 0);
    l([A.d(ms.INC++, "string"), u("design:type", String)], Lr.prototype, "amount", void 0);
    l([A.d(ms.INC++, "uint32"), u("design:type", Number)], Lr.prototype, "totalGrabableTimes", void 0);
    l([A.d(ms.INC++, "uint32", "optional"), u("design:type", Number)], Lr.prototype, "beginUnfrozenBlockHeight", void 0);
    l([A.d(ms.INC++, "uint32"), u("design:type", Number)], Lr.prototype, "giftDistributionRule", void 0);
    Lr = ms = l([R.d("GiftAssetModel")], Lr);
    let $c = class extends Y {
      toJSON() {
        return { giftAsset: this.giftAsset.toJSON() };
      }
    };
    l([A.d(1, Lr), u("design:type", Lr)], $c.prototype, "giftAsset", void 0);
    $c = l([R.d("GiftAssetAssetModel")], $c);
    let Ao;
    const $u = /* @__PURE__ */ new WeakMap();
    let Dn = Ao = class extends Y {
      get blockSignature() {
        return xe(this.blockSignatureBuffer);
      }
      set blockSignature(e) {
        this.blockSignatureBuffer = _e(e);
      }
      get transactionSignature() {
        return xe(this.transactionSignatureBuffer);
      }
      set transactionSignature(e) {
        this.transactionSignatureBuffer = _e(e);
      }
      get ciphertextSignature() {
        const { ciphertextSignatureBuffer: e } = this;
        if (!e) return;
        const t = gt.decode(e);
        return $u.set(t, e), t;
      }
      set ciphertextSignature(e) {
        if (e) {
          let t = $u.get(e);
          t || (t = gt.encode(e).finish(), $u.set(e, t)), this.ciphertextSignatureBuffer = t;
        } else this.ciphertextSignatureBuffer = void 0;
      }
      toJSON() {
        const e = { blockSignature: this.blockSignature, transactionSignature: this.transactionSignature, amount: this.amount, giftAsset: this.giftAsset.toJSON() };
        return this.ciphertextSignature && (e.ciphertextSignature = this.ciphertextSignature.toJSON()), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.blockSignature && (t.blockSignature = e.blockSignature), e.transactionSignature && (t.transactionSignature = e.transactionSignature), e.ciphertextSignature && (t.ciphertextSignature = gt.fromObject(e.ciphertextSignature))), t;
      }
    };
    Dn.INC = 1;
    l([A.d(Ao.INC++, "bytes"), u("design:type", Uint8Array)], Dn.prototype, "blockSignatureBuffer", void 0);
    l([A.d(Ao.INC++, "bytes"), u("design:type", Uint8Array)], Dn.prototype, "transactionSignatureBuffer", void 0);
    l([A.d(Ao.INC++, "string"), u("design:type", String)], Dn.prototype, "amount", void 0);
    l([A.d(Ao.INC++, "bytes", "optional"), u("design:type", Uint8Array)], Dn.prototype, "ciphertextSignatureBuffer", void 0);
    l([A.d(Ao.INC++, Lr), u("design:type", Lr)], Dn.prototype, "giftAsset", void 0);
    Dn = Ao = l([R.d("GrabAssetModel")], Dn);
    let Uc = class extends Y {
      toJSON() {
        return { grabAsset: this.grabAsset.toJSON() };
      }
    };
    l([A.d(1, Dn), u("design:type", Dn)], Uc.prototype, "grabAsset", void 0);
    Uc = l([R.d("GrabAssetAssetModel")], Uc);
    let Ni;
    let en = Ni = class extends Y {
      toJSON() {
        return { trustees: this.trustees, numberOfSignFor: this.numberOfSignFor, sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, assetType: this.assetType, amount: this.amount };
      }
    };
    en.INC = 1;
    l([A.d(Ni.INC++, "string", "repeated"), u("design:type", Array)], en.prototype, "trustees", void 0);
    l([A.d(Ni.INC++, "uint32"), u("design:type", Number)], en.prototype, "numberOfSignFor", void 0);
    l([A.d(Ni.INC++, "string"), u("design:type", String)], en.prototype, "sourceChainName", void 0);
    l([A.d(Ni.INC++, "string"), u("design:type", String)], en.prototype, "sourceChainMagic", void 0);
    l([A.d(Ni.INC++, "string"), u("design:type", String)], en.prototype, "assetType", void 0);
    l([A.d(Ni.INC++, "string"), u("design:type", String)], en.prototype, "amount", void 0);
    en = Ni = l([R.d("TrustAssetModel")], en);
    let Vc = class extends Y {
      toJSON() {
        return { trustAsset: this.trustAsset.toJSON() };
      }
    };
    l([A.d(1, en), u("design:type", en)], Vc.prototype, "trustAsset", void 0);
    Vc = l([R.d("TrustAssetAssetModel")], Vc);
    let Xa;
    let ps = Xa = class extends Y {
      get transactionSignature() {
        return xe(this.transactionSignatureBuffer);
      }
      set transactionSignature(e) {
        this.transactionSignatureBuffer = _e(e);
      }
      getBytes() {
        const t = Object.create(this, { signatureBufferList: { value: null } });
        return this.$type.encode(t).finish();
      }
      toJSON() {
        return { transactionSignature: this.transactionSignature, trustSenderId: this.trustSenderId, trustRecipientId: this.trustRecipientId, trustAsset: this.trustAsset.toJSON() };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.transactionSignature && (t.transactionSignature = e.transactionSignature), t;
      }
    };
    ps.INC = 1;
    l([A.d(Xa.INC++, "bytes"), u("design:type", Uint8Array)], ps.prototype, "transactionSignatureBuffer", void 0);
    l([A.d(Xa.INC++, "string"), u("design:type", String)], ps.prototype, "trustSenderId", void 0);
    l([A.d(Xa.INC++, "string"), u("design:type", String)], ps.prototype, "trustRecipientId", void 0);
    l([A.d(Xa.INC++, en), u("design:type", en)], ps.prototype, "trustAsset", void 0);
    l([Vs, u("design:type", Function), u("design:paramtypes", []), u("design:returntype", void 0)], ps.prototype, "getBytes", null);
    ps = Xa = l([R.d("SignForAssetModel")], ps);
    let Gc = class extends Y {
      toJSON() {
        return { signForAsset: this.signForAsset.toJSON() };
      }
    };
    l([A.d(1, ps), u("design:type", ps)], Gc.prototype, "signForAsset", void 0);
    Gc = l([R.d("SignForAssetAssetModel")], Gc);
    let Kc = class extends Y {
      toJSON() {
        return { migrateCertificate: this.migrateCertificate };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], Kc.prototype, "migrateCertificate", void 0);
    Kc = l([R.d("EmigrateAssetModel")], Kc);
    let zc = class extends Y {
      toJSON() {
        return { emigrateAsset: this.emigrateAsset.toJSON() };
      }
    };
    l([A.d(1, Kc), u("design:type", Kc)], zc.prototype, "emigrateAsset", void 0);
    zc = l([R.d("EmigrateAssetAssetModel")], zc);
    let jc = class extends Y {
      toJSON() {
        return { migrateCertificate: this.migrateCertificate };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], jc.prototype, "migrateCertificate", void 0);
    jc = l([R.d("ImmigrateAssetModel")], jc);
    let Jc = class extends Y {
      toJSON() {
        return { immigrateAsset: this.immigrateAsset.toJSON() };
      }
    };
    l([A.d(1, jc), u("design:type", jc)], Jc.prototype, "immigrateAsset", void 0);
    Jc = l([R.d("ImmigrateAssetAssetModel")], Jc);
    let Yn;
    const Uu = /* @__PURE__ */ new WeakMap();
    let ar = Yn = class extends Y {
      get cipherPublicKeys() {
        const { cipherPublicKeysBuffer: e } = this;
        let t = Uu.get(e);
        return t || (t = Object.freeze(e.map((r) => xe(r))), Uu.set(e, t)), t;
      }
      set cipherPublicKeys(e) {
        const t = [];
        for (const r of e) t.push(_e(r));
        Object.isFrozen(e) && Uu.set(t, e), this.cipherPublicKeysBuffer = t;
      }
      get to() {
        return { magic: this.toExchangeSource, chainName: this.toExchangeChainName, assetType: this.toExchangeAsset, amount: this.toExchangeNumber };
      }
      get be() {
        return { magic: this.beExchangeSource, chainName: this.beExchangeChainName, assetType: this.beExchangeAsset };
      }
      toJSON() {
        return { cipherPublicKeys: this.cipherPublicKeys, toExchangeSource: this.toExchangeSource, beExchangeSource: this.beExchangeSource, toExchangeChainName: this.toExchangeChainName, beExchangeChainName: this.beExchangeChainName, toExchangeAsset: this.toExchangeAsset, beExchangeAsset: this.beExchangeAsset, toExchangeNumber: this.toExchangeNumber, exchangeRate: this.exchangeRate.toJSON() };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.cipherPublicKeys && (t.cipherPublicKeys = e.cipherPublicKeys), t;
      }
    };
    ar.INC = 1;
    l([A.d(Yn.INC++, "bytes", "repeated"), u("design:type", Array)], ar.prototype, "cipherPublicKeysBuffer", void 0);
    l([A.d(Yn.INC++, "string"), u("design:type", String)], ar.prototype, "toExchangeSource", void 0);
    l([A.d(Yn.INC++, "string"), u("design:type", String)], ar.prototype, "beExchangeSource", void 0);
    l([A.d(Yn.INC++, "string"), u("design:type", String)], ar.prototype, "toExchangeChainName", void 0);
    l([A.d(Yn.INC++, "string"), u("design:type", String)], ar.prototype, "beExchangeChainName", void 0);
    l([A.d(Yn.INC++, "string"), u("design:type", String)], ar.prototype, "toExchangeAsset", void 0);
    l([A.d(Yn.INC++, "string"), u("design:type", String)], ar.prototype, "beExchangeAsset", void 0);
    l([A.d(Yn.INC++, "string"), u("design:type", String)], ar.prototype, "toExchangeNumber", void 0);
    l([A.d(Yn.INC++, oa), u("design:type", oa)], ar.prototype, "exchangeRate", void 0);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ar.prototype, "to", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ar.prototype, "be", null);
    ar = Yn = l([R.d("ToExchangeAssetModel")], ar);
    let Yc = class extends Y {
      toJSON() {
        return { toExchangeAsset: this.toExchangeAsset.toJSON() };
      }
    };
    l([A.d(1, ar), u("design:type", ar)], Yc.prototype, "toExchangeAsset", void 0);
    Yc = l([R.d("ToExchangeAssetAssetModel")], Yc);
    let Eo;
    const Vu = /* @__PURE__ */ new WeakMap();
    let Fn = Eo = class extends Y {
      get transactionSignature() {
        return xe(this.transactionSignatureBuffer);
      }
      set transactionSignature(e) {
        this.transactionSignatureBuffer = _e(e);
      }
      get ciphertextSignature() {
        const { ciphertextSignatureBuffer: e } = this;
        if (!e) return;
        const t = gt.decode(e);
        return Vu.set(t, e), t;
      }
      set ciphertextSignature(e) {
        if (e) {
          let t = Vu.get(e);
          t || (t = gt.encode(e).finish(), Vu.set(e, t)), this.ciphertextSignatureBuffer = t;
        } else this.ciphertextSignatureBuffer = void 0;
      }
      get to() {
        return { magic: this.exchangeAsset.toExchangeSource, chainName: this.exchangeAsset.toExchangeChainName, assetType: this.exchangeAsset.toExchangeAsset, amount: this.toExchangeNumber };
      }
      get be() {
        return { magic: this.exchangeAsset.beExchangeSource, chainName: this.exchangeAsset.beExchangeChainName, assetType: this.exchangeAsset.beExchangeAsset, amount: this.beExchangeNumber };
      }
      get exchangeRate() {
        return this.exchangeAsset.exchangeRate;
      }
      toJSON() {
        const e = { transactionSignature: this.transactionSignature, toExchangeNumber: this.toExchangeNumber, beExchangeNumber: this.beExchangeNumber, exchangeAsset: this.exchangeAsset.toJSON() };
        return this.ciphertextSignature && (e.ciphertextSignature = this.ciphertextSignature.toJSON()), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.transactionSignature && (t.transactionSignature = e.transactionSignature), e.ciphertextSignature && (t.ciphertextSignature = gt.fromObject(e.ciphertextSignature))), t;
      }
    };
    Fn.INC = 1;
    l([A.d(Eo.INC++, "bytes"), u("design:type", Uint8Array)], Fn.prototype, "transactionSignatureBuffer", void 0);
    l([A.d(Eo.INC++, "bytes", "optional"), u("design:type", Uint8Array)], Fn.prototype, "ciphertextSignatureBuffer", void 0);
    l([A.d(Eo.INC++, "string"), u("design:type", String)], Fn.prototype, "toExchangeNumber", void 0);
    l([A.d(Eo.INC++, "string"), u("design:type", String)], Fn.prototype, "beExchangeNumber", void 0);
    l([A.d(Eo.INC++, ar), u("design:type", ar)], Fn.prototype, "exchangeAsset", void 0);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Fn.prototype, "to", null);
    Fn = Eo = l([R.d("BeExchangeAssetModel")], Fn);
    let Qc = class extends Y {
      toJSON() {
        return { beExchangeAsset: this.beExchangeAsset.toJSON() };
      }
    };
    l([A.d(1, Fn), u("design:type", Fn)], Qc.prototype, "beExchangeAsset", void 0);
    Qc = l([R.d("BeExchangeAssetAssetModel")], Qc);
    let xi;
    let $n = xi = class extends Y {
      toJSON() {
        return { stakeId: this.stakeId, sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, assetType: this.assetType, assetPrealnum: this.assetPrealnum, beginUnstakeHeight: this.beginUnstakeHeight };
      }
    };
    $n.INC = 1;
    l([A.d(xi.INC++, "string"), u("design:type", String)], $n.prototype, "stakeId", void 0);
    l([A.d(xi.INC++, "string"), u("design:type", String)], $n.prototype, "sourceChainName", void 0);
    l([A.d(xi.INC++, "string"), u("design:type", String)], $n.prototype, "sourceChainMagic", void 0);
    l([A.d(xi.INC++, "string"), u("design:type", String)], $n.prototype, "assetType", void 0);
    l([A.d(xi.INC++, "string"), u("design:type", String)], $n.prototype, "assetPrealnum", void 0);
    l([A.d(xi.INC++, "uint32"), u("design:type", Number)], $n.prototype, "beginUnstakeHeight", void 0);
    $n = xi = l([R.d("StakeAssetModel")], $n);
    let Wc = class extends Y {
      toJSON() {
        return { stakeAsset: this.stakeAsset.toJSON() };
      }
    };
    l([A.d(1, $n), u("design:type", $n)], Wc.prototype, "stakeAsset", void 0);
    Wc = l([R.d("StakeAssetAssetModel")], Wc);
    let Io;
    let ls = Io = class extends Y {
      toJSON() {
        return { stakeId: this.stakeId, sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, assetType: this.assetType, assetPrealnum: this.assetPrealnum };
      }
    };
    ls.INC = 1;
    l([A.d(Io.INC++, "string"), u("design:type", String)], ls.prototype, "stakeId", void 0);
    l([A.d(Io.INC++, "string"), u("design:type", String)], ls.prototype, "sourceChainName", void 0);
    l([A.d(Io.INC++, "string"), u("design:type", String)], ls.prototype, "sourceChainMagic", void 0);
    l([A.d(Io.INC++, "string"), u("design:type", String)], ls.prototype, "assetType", void 0);
    l([A.d(Io.INC++, "string"), u("design:type", String)], ls.prototype, "assetPrealnum", void 0);
    ls = Io = l([R.d("UnstakeAssetModel")], ls);
    let Xc = class extends Y {
      toJSON() {
        return { unstakeAsset: this.unstakeAsset.toJSON() };
      }
    };
    l([A.d(1, ls), u("design:type", ls)], Xc.prototype, "unstakeAsset", void 0);
    Xc = l([R.d("UnstakeAssetAssetModel")], Xc);
    let gi = class extends Y {
      toJSON() {
        return { name: this.name, sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, operationType: this.operationType };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], gi.prototype, "name", void 0);
    l([A.d(2, "string"), u("design:type", String)], gi.prototype, "sourceChainName", void 0);
    l([A.d(3, "string"), u("design:type", String)], gi.prototype, "sourceChainMagic", void 0);
    l([A.d(4, "uint32"), u("design:type", Number)], gi.prototype, "operationType", void 0);
    gi = l([R.d("LocationNameInfo")], gi);
    let qc = class extends Y {
      toJSON() {
        return { locationName: this.locationName.toJSON() };
      }
    };
    l([A.d(1, gi), u("design:type", gi)], qc.prototype, "locationName", void 0);
    qc = l([R.d("LocationNameAssetModel")], qc);
    let Vi = class extends Y {
      toJSON() {
        return { name: this.name, sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], Vi.prototype, "name", void 0);
    l([A.d(2, "string"), u("design:type", String)], Vi.prototype, "sourceChainName", void 0);
    l([A.d(3, "string"), u("design:type", String)], Vi.prototype, "sourceChainMagic", void 0);
    Vi = l([R.d("SetLnsManagerModel")], Vi);
    let Zc = class extends Y {
      toJSON() {
        return { lnsManager: this.lnsManager.toJSON() };
      }
    };
    l([A.d(1, Vi), u("design:type", Vi)], Zc.prototype, "lnsManager", void 0);
    Zc = l([R.d("SetLnsManagerAssetModel")], Zc);
    let di = class extends Y {
      toJSON() {
        return { recordType: this.recordType, recordValue: this.recordValue };
      }
    };
    l([A.d(1, "int32"), u("design:type", Number)], di.prototype, "recordType", void 0);
    l([A.d(2, "string"), u("design:type", String)], di.prototype, "recordValue", void 0);
    di = l([R.d("LocationNameRecordInfo")], di);
    let Oi;
    let Un = Oi = class extends Y {
      toJSON() {
        const e = { name: this.name, sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, operationType: this.operationType };
        return this.addRecord && (e.addRecord = this.addRecord.toJSON()), this.deleteRecord && (e.deleteRecord = this.deleteRecord.toJSON()), e;
      }
    };
    Un.INC = 1;
    l([A.d(Oi.INC++, "string"), u("design:type", String)], Un.prototype, "name", void 0);
    l([A.d(Oi.INC++, "string"), u("design:type", String)], Un.prototype, "sourceChainName", void 0);
    l([A.d(Oi.INC++, "string"), u("design:type", String)], Un.prototype, "sourceChainMagic", void 0);
    l([A.d(Oi.INC++, "uint32"), u("design:type", Number)], Un.prototype, "operationType", void 0);
    l([A.d(Oi.INC++, di, "optional"), u("design:type", di)], Un.prototype, "addRecord", void 0);
    l([A.d(Oi.INC++, di, "optional"), u("design:type", di)], Un.prototype, "deleteRecord", void 0);
    Un = Oi = l([R.d("SetLnsRecordValueModel")], Un);
    let ep = class extends Y {
      toJSON() {
        return { lnsRecordValue: this.lnsRecordValue.toJSON() };
      }
    };
    l([A.d(1, Un), u("design:type", Un)], ep.prototype, "lnsRecordValue", void 0);
    ep = l([R.d("SetLnsRecordValueAssetModel")], ep);
    let lh = class extends Y {
      toJSON() {
        return { senderPaidFeeRate: this.senderPaidFeeRate.toJSON(), recipientPaidFeeRate: this.recipientPaidFeeRate.toJSON() };
      }
    };
    l([A.d(1, os), u("design:type", os)], lh.prototype, "senderPaidFeeRate", void 0);
    l([A.d(2, os), u("design:type", os)], lh.prototype, "recipientPaidFeeRate", void 0);
    lh = l([R.d("FeeRateModel")], lh);
    let Ci;
    let Zt = Ci = class extends Y {
      toJSON() {
        return { sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, factoryId: this.factoryId, entityPrealnum: this.entityPrealnum, entityFrozenAssetPrealnum: this.entityFrozenAssetPrealnum, purchaseAssetPrealnum: this.purchaseAssetPrealnum };
      }
    };
    Zt.INC = 1;
    l([A.d(Ci.INC++, "string"), u("design:type", String)], Zt.prototype, "sourceChainName", void 0);
    l([A.d(Ci.INC++, "string"), u("design:type", String)], Zt.prototype, "sourceChainMagic", void 0);
    l([A.d(Ci.INC++, "string"), u("design:type", String)], Zt.prototype, "factoryId", void 0);
    l([A.d(Ci.INC++, "string"), u("design:type", String)], Zt.prototype, "entityPrealnum", void 0);
    l([A.d(Ci.INC++, "string"), u("design:type", String)], Zt.prototype, "entityFrozenAssetPrealnum", void 0);
    l([A.d(Ci.INC++, "string"), u("design:type", String)], Zt.prototype, "purchaseAssetPrealnum", void 0);
    Zt = Ci = l([R.d("IssueEntityFactoryModel")], Zt);
    let Gi = class extends Y {
      toJSON() {
        return { issueEntityFactory: this.issueEntityFactory.toJSON() };
      }
    };
    l([A.d(1, Zt), u("design:type", Zt)], Gi.prototype, "issueEntityFactory", void 0);
    Gi = l([R.d("IssueEntityFactoryAssetModel")], Gi);
    let To;
    let In = To = class extends Y {
      toJSON() {
        const e = { sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, entityId: this.entityId, taxAssetPrealnum: this.taxAssetPrealnum, entityFactoryPossessor: this.entityFactoryPossessor, entityFactory: this.entityFactory.toJSON() };
        return this.taxAssetRecipientId && (e.taxAssetRecipientId = this.taxAssetRecipientId), e;
      }
    };
    In.INC = 1;
    l([A.d(To.INC++, "string"), u("design:type", String)], In.prototype, "sourceChainName", void 0);
    l([A.d(To.INC++, "string"), u("design:type", String)], In.prototype, "sourceChainMagic", void 0);
    l([A.d(To.INC++, "string"), u("design:type", String)], In.prototype, "entityId", void 0);
    l([A.d(Zt.INC++, "string"), u("design:type", String)], In.prototype, "taxAssetPrealnum", void 0);
    l([A.d(To.INC++, "string"), u("design:type", String)], In.prototype, "entityFactoryPossessor", void 0);
    l([A.d(To.INC++, Zt), u("design:type", Zt)], In.prototype, "entityFactory", void 0);
    l([A.d(Zt.INC++, "string", "optional"), u("design:type", String)], In.prototype, "taxAssetRecipientId", void 0);
    In = To = l([R.d("IssueEntityModel")], In);
    let tp = class extends Y {
      toJSON() {
        return { issueEntity: this.issueEntity.toJSON() };
      }
    };
    l([A.d(1, In), u("design:type", In)], tp.prototype, "issueEntity", void 0);
    tp = l([R.d("IssueEntityAssetModel")], tp);
    let Gs;
    let Tn = Gs = class extends Y {
      get transactionSignature() {
        return xe(this.transactionSignatureBuffer);
      }
      set transactionSignature(e) {
        this.transactionSignatureBuffer = _e(e);
      }
      toJSON() {
        return { transactionSignature: this.transactionSignature, sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, entityId: this.entityId, entityFactoryApplicant: this.entityFactoryApplicant, entityFactoryPossessor: this.entityFactoryPossessor, entityFactory: this.entityFactory.toJSON() };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.transactionSignature && (t.transactionSignature = e.transactionSignature), t;
      }
    };
    Tn.INC = 1;
    l([A.d(Gs.INC++, "bytes"), u("design:type", Uint8Array)], Tn.prototype, "transactionSignatureBuffer", void 0);
    l([A.d(Gs.INC++, "string"), u("design:type", String)], Tn.prototype, "sourceChainName", void 0);
    l([A.d(Gs.INC++, "string"), u("design:type", String)], Tn.prototype, "sourceChainMagic", void 0);
    l([A.d(Gs.INC++, "string"), u("design:type", String)], Tn.prototype, "entityId", void 0);
    l([A.d(Gs.INC++, "string"), u("design:type", String)], Tn.prototype, "entityFactoryApplicant", void 0);
    l([A.d(Gs.INC++, "string"), u("design:type", String)], Tn.prototype, "entityFactoryPossessor", void 0);
    l([A.d(Gs.INC++, Zt), u("design:type", Zt)], Tn.prototype, "entityFactory", void 0);
    Tn = Gs = l([R.d("DestroyEntityModel")], Tn);
    let rp = class extends Y {
      toJSON() {
        return { destroyEntity: this.destroyEntity.toJSON() };
      }
    };
    l([A.d(1, Tn), u("design:type", Tn)], rp.prototype, "destroyEntity", void 0);
    rp = l([R.d("DestroyEntityAssetModel")], rp);
    let So;
    let ca = class extends Y {
      toJSON() {
        const e = { entityId: this.entityId, taxAssetPrealnum: this.taxAssetPrealnum };
        return this.taxAssetRecipientId && (e.taxAssetRecipientId = this.taxAssetRecipientId), e;
      }
    };
    l([A.d(1, "string"), u("design:type", String)], ca.prototype, "entityId", void 0);
    l([A.d(2, "string"), u("design:type", String)], ca.prototype, "taxAssetPrealnum", void 0);
    l([A.d(3, "string", "optional"), u("design:type", String)], ca.prototype, "taxAssetRecipientId", void 0);
    ca = l([R.d("EntityStructModel")], ca);
    let hs = So = class extends Y {
      toJSON() {
        return { sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, entityStructList: this.entityStructList.map((t) => t.toJSON()), entityFactoryPossessor: this.entityFactoryPossessor, entityFactory: this.entityFactory.toJSON() };
      }
    };
    hs.INC = 1;
    l([A.d(So.INC++, "string"), u("design:type", String)], hs.prototype, "sourceChainName", void 0);
    l([A.d(So.INC++, "string"), u("design:type", String)], hs.prototype, "sourceChainMagic", void 0);
    l([A.d(So.INC++, ca, "repeated"), u("design:type", Array)], hs.prototype, "entityStructList", void 0);
    l([A.d(So.INC++, "string"), u("design:type", String)], hs.prototype, "entityFactoryPossessor", void 0);
    l([A.d(So.INC++, Zt), u("design:type", Zt)], hs.prototype, "entityFactory", void 0);
    hs = So = l([R.d("IssueEntityMultiModel")], hs);
    let np = class extends Y {
      toJSON() {
        return { issueEntityMulti: this.issueEntityMulti.toJSON() };
      }
    };
    l([A.d(1, hs), u("design:type", hs)], np.prototype, "issueEntityMulti", void 0);
    np = l([R.d("IssueEntityMultiAssetModel")], np);
    let us = class extends Y {
      toJSON() {
        const e = { sourceChainName: this.sourceChainName, sourceChainMagic: this.sourceChainMagic, parentAssetType: this.parentAssetType, assetType: this.assetType, amount: this.amount };
        return this.taxInformation && (e.taxInformation = this.taxInformation.toJSON()), e;
      }
    };
    l([A.d(1, "string"), u("design:type", String)], us.prototype, "sourceChainName", void 0);
    l([A.d(2, "string"), u("design:type", String)], us.prototype, "sourceChainMagic", void 0);
    l([A.d(3, G), u("design:type", Number)], us.prototype, "parentAssetType", void 0);
    l([A.d(4, "string"), u("design:type", String)], us.prototype, "assetType", void 0);
    l([A.d(5, "string"), u("design:type", String)], us.prototype, "amount", void 0);
    l([A.d(6, Qt, "optional"), u("design:type", Qt)], us.prototype, "taxInformation", void 0);
    us = l([R.d("TransferAnyModel")], us);
    let sp = class extends Y {
      toJSON() {
        return { transferAny: this.transferAny.toJSON() };
      }
    };
    l([A.d(1, us), u("design:type", us)], sp.prototype, "transferAny", void 0);
    sp = l([R.d("TransferAnyAssetModel")], sp);
    let bn;
    const fm = /* @__PURE__ */ new WeakMap();
    let gr = bn = class extends Y {
      get cipherPublicKeys() {
        const { cipherPublicKeysBuffer: e } = this;
        let t = fm.get(e);
        return t || (t = this.cipherPublicKeysBuffer.map((r) => xe(r))), t;
      }
      set cipherPublicKeys(e) {
        const t = e.map((r) => _e(r));
        fm.set(t, e), this.cipherPublicKeysBuffer = t;
      }
      toJSON() {
        const e = { cipherPublicKeys: this.cipherPublicKeys, sourceChainMagic: this.sourceChainMagic, sourceChainName: this.sourceChainName, parentAssetType: this.parentAssetType, assetType: this.assetType, amount: this.amount, totalGrabableTimes: this.totalGrabableTimes };
        return this.giftDistributionRule !== void 0 && (e.giftDistributionRule = this.giftDistributionRule), this.beginUnfrozenBlockHeight && (e.beginUnfrozenBlockHeight = this.beginUnfrozenBlockHeight), this.taxInformation && (e.taxInformation = this.taxInformation.toJSON()), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.cipherPublicKeys && (t.cipherPublicKeys = e.cipherPublicKeys), t;
      }
    };
    gr.INC = 1;
    l([A.d(bn.INC++, "bytes", "repeated"), u("design:type", Array)], gr.prototype, "cipherPublicKeysBuffer", void 0);
    l([A.d(bn.INC++, "string"), u("design:type", String)], gr.prototype, "sourceChainMagic", void 0);
    l([A.d(bn.INC++, "string"), u("design:type", String)], gr.prototype, "sourceChainName", void 0);
    l([A.d(bn.INC++, G), u("design:type", Number)], gr.prototype, "parentAssetType", void 0);
    l([A.d(bn.INC++, "string"), u("design:type", String)], gr.prototype, "assetType", void 0);
    l([A.d(bn.INC++, "string"), u("design:type", String)], gr.prototype, "amount", void 0);
    l([A.d(bn.INC++, "uint32"), u("design:type", Number)], gr.prototype, "totalGrabableTimes", void 0);
    l([A.d(bn.INC++, "uint32", "optional"), u("design:type", Number)], gr.prototype, "beginUnfrozenBlockHeight", void 0);
    l([A.d(bn.INC++, "uint32", "optional"), u("design:type", Number)], gr.prototype, "giftDistributionRule", void 0);
    l([A.d(bn.INC++, Qt, "optional"), u("design:type", Qt)], gr.prototype, "taxInformation", void 0);
    gr = bn = l([R.d("GiftAnyModel")], gr);
    let ip = class extends Y {
      toJSON() {
        return { giftAny: this.giftAny.toJSON() };
      }
    };
    l([A.d(1, gr), u("design:type", gr)], ip.prototype, "giftAny", void 0);
    ip = l([R.d("GiftAnyAssetModel")], ip);
    let wo;
    const Gu = /* @__PURE__ */ new WeakMap();
    let fs = wo = class extends Y {
      get blockSignature() {
        return xe(this.blockSignatureBuffer);
      }
      set blockSignature(e) {
        this.blockSignatureBuffer = _e(e);
      }
      get transactionSignature() {
        return xe(this.transactionSignatureBuffer);
      }
      set transactionSignature(e) {
        this.transactionSignatureBuffer = _e(e);
      }
      get ciphertextSignature() {
        const { ciphertextSignatureBuffer: e } = this;
        if (!e) return;
        const t = gt.decode(e);
        return Gu.set(t, e), t;
      }
      set ciphertextSignature(e) {
        if (e) {
          let t = Gu.get(e);
          t || (t = gt.encode(e).finish(), Gu.set(e, t)), this.ciphertextSignatureBuffer = t;
        } else this.ciphertextSignatureBuffer = void 0;
      }
      toJSON() {
        const e = { blockSignature: this.blockSignature, transactionSignature: this.transactionSignature, amount: this.amount, giftAny: this.giftAny.toJSON() };
        return this.ciphertextSignature && (e.ciphertextSignature = this.ciphertextSignature.toJSON()), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.blockSignature && (t.blockSignature = e.blockSignature), e.transactionSignature && (t.transactionSignature = e.transactionSignature), e.ciphertextSignature && (t.ciphertextSignature = gt.fromObject(e.ciphertextSignature))), t;
      }
    };
    fs.INC = 1;
    l([A.d(wo.INC++, "bytes"), u("design:type", Uint8Array)], fs.prototype, "blockSignatureBuffer", void 0);
    l([A.d(wo.INC++, "bytes"), u("design:type", Uint8Array)], fs.prototype, "transactionSignatureBuffer", void 0);
    l([A.d(wo.INC++, "string"), u("design:type", String)], fs.prototype, "amount", void 0);
    l([A.d(wo.INC++, "bytes", "optional"), u("design:type", Uint8Array)], fs.prototype, "ciphertextSignatureBuffer", void 0);
    l([A.d(wo.INC++, gr), u("design:type", gr)], fs.prototype, "giftAny", void 0);
    fs = wo = l([R.d("GrabAnyModel")], fs);
    let op = class extends Y {
      toJSON() {
        return { grabAny: this.grabAny.toJSON() };
      }
    };
    l([A.d(1, fs), u("design:type", fs)], op.prototype, "grabAny", void 0);
    op = l([R.d("GrabAnyAssetModel")], op);
    let vr;
    const gm = /* @__PURE__ */ new WeakMap();
    let yi = class extends Y {
      toJSON() {
        return { toExchangeAssetWeight: this.toExchangeAssetWeight, beExchangeAssetWeight: this.beExchangeAssetWeight };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], yi.prototype, "toExchangeAssetWeight", void 0);
    l([A.d(2, "string"), u("design:type", String)], yi.prototype, "beExchangeAssetWeight", void 0);
    yi = l([R.d("AssetExchangeWeightRatioModel")], yi);
    let Dt = vr = class extends Y {
      get cipherPublicKeys() {
        const { cipherPublicKeysBuffer: e } = this;
        let t = gm.get(e);
        return t || (t = this.cipherPublicKeysBuffer.map((r) => xe(r))), t;
      }
      set cipherPublicKeys(e) {
        const t = e.map((r) => _e(r));
        gm.set(t, e), this.cipherPublicKeysBuffer = t;
      }
      get to() {
        return { magic: this.toExchangeSource, chainName: this.toExchangeChainName, toExchangeAssetType: this.toExchangeAssetType, toExchangeParentAssetType: this.toExchangeParentAssetType, toExchangeAssetPrealnum: this.toExchangeAssetPrealnum };
      }
      get be() {
        return { magic: this.beExchangeSource, chainName: this.beExchangeChainName, beExchangeAssetType: this.beExchangeAssetType, beExchangeParentAssetType: this.beExchangeParentAssetType, beExchangeAssetPrealnum: this.beExchangeAssetPrealnum || "1" };
      }
      toJSON() {
        const e = { cipherPublicKeys: this.cipherPublicKeys, toExchangeSource: this.toExchangeSource, beExchangeSource: this.beExchangeSource, toExchangeChainName: this.toExchangeChainName, beExchangeChainName: this.beExchangeChainName, toExchangeAssetType: this.toExchangeAssetType, beExchangeAssetType: this.beExchangeAssetType, toExchangeParentAssetType: this.toExchangeParentAssetType, beExchangeParentAssetType: this.beExchangeParentAssetType, toExchangeAssetPrealnum: this.toExchangeAssetPrealnum };
        return this.beExchangeAssetPrealnum && (e.beExchangeAssetPrealnum = this.beExchangeAssetPrealnum), this.assetExchangeWeightRatio && (e.assetExchangeWeightRatio = this.assetExchangeWeightRatio.toJSON()), this.taxInformation && (e.taxInformation = this.taxInformation.toJSON()), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.cipherPublicKeys && (t.cipherPublicKeys = e.cipherPublicKeys), t;
      }
    };
    Dt.INC = 1;
    l([A.d(vr.INC++, "bytes", "repeated"), u("design:type", Array)], Dt.prototype, "cipherPublicKeysBuffer", void 0);
    l([A.d(vr.INC++, "string"), u("design:type", String)], Dt.prototype, "toExchangeSource", void 0);
    l([A.d(vr.INC++, "string"), u("design:type", String)], Dt.prototype, "beExchangeSource", void 0);
    l([A.d(vr.INC++, "string"), u("design:type", String)], Dt.prototype, "toExchangeChainName", void 0);
    l([A.d(vr.INC++, "string"), u("design:type", String)], Dt.prototype, "beExchangeChainName", void 0);
    l([A.d(vr.INC++, G), u("design:type", Number)], Dt.prototype, "toExchangeParentAssetType", void 0);
    l([A.d(vr.INC++, G), u("design:type", Number)], Dt.prototype, "beExchangeParentAssetType", void 0);
    l([A.d(vr.INC++, "string"), u("design:type", String)], Dt.prototype, "toExchangeAssetType", void 0);
    l([A.d(vr.INC++, "string"), u("design:type", String)], Dt.prototype, "beExchangeAssetType", void 0);
    l([A.d(vr.INC++, "string"), u("design:type", String)], Dt.prototype, "toExchangeAssetPrealnum", void 0);
    l([A.d(vr.INC++, "string", "optional"), u("design:type", String)], Dt.prototype, "beExchangeAssetPrealnum", void 0);
    l([A.d(vr.INC++, yi, "optional"), u("design:type", yi)], Dt.prototype, "assetExchangeWeightRatio", void 0);
    l([A.d(vr.INC++, Qt, "optional"), u("design:type", Qt)], Dt.prototype, "taxInformation", void 0);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Dt.prototype, "to", null);
    Dt = vr = l([R.d("ToExchangeAnyModel")], Dt);
    let ap = class extends Y {
      toJSON() {
        return { toExchangeAny: this.toExchangeAny.toJSON() };
      }
    };
    l([A.d(1, Dt), u("design:type", Dt)], ap.prototype, "toExchangeAny", void 0);
    ap = l([R.d("ToExchangeAnyAssetModel")], ap);
    let bo;
    const Ku = /* @__PURE__ */ new WeakMap();
    let Vn = bo = class extends Y {
      get transactionSignature() {
        return xe(this.transactionSignatureBuffer);
      }
      set transactionSignature(e) {
        this.transactionSignatureBuffer = _e(e);
      }
      get ciphertextSignature() {
        const { ciphertextSignatureBuffer: e } = this;
        if (!e) return;
        const t = gt.decode(e);
        return Ku.set(t, e), t;
      }
      set ciphertextSignature(e) {
        if (e) {
          let t = Ku.get(e);
          t || (t = gt.encode(e).finish(), Ku.set(e, t)), this.ciphertextSignatureBuffer = t;
        } else this.ciphertextSignatureBuffer = void 0;
      }
      toJSON() {
        const e = { transactionSignature: this.transactionSignature, toExchangeAssetPrealnum: this.toExchangeAssetPrealnum, beExchangeAssetPrealnum: this.beExchangeAssetPrealnum, exchangeAny: this.exchangeAny.toJSON() };
        return this.ciphertextSignature && (e.ciphertextSignature = this.ciphertextSignature.toJSON()), this.taxInformation && (e.taxInformation = this.taxInformation.toJSON()), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.transactionSignature && (t.transactionSignature = e.transactionSignature), e.ciphertextSignature && (t.ciphertextSignature = gt.fromObject(e.ciphertextSignature))), t;
      }
    };
    Vn.INC = 1;
    l([A.d(bo.INC++, "bytes"), u("design:type", Uint8Array)], Vn.prototype, "transactionSignatureBuffer", void 0);
    l([A.d(bo.INC++, "bytes", "optional"), u("design:type", Uint8Array)], Vn.prototype, "ciphertextSignatureBuffer", void 0);
    l([A.d(bo.INC++, "string"), u("design:type", String)], Vn.prototype, "toExchangeAssetPrealnum", void 0);
    l([A.d(bo.INC++, "string"), u("design:type", String)], Vn.prototype, "beExchangeAssetPrealnum", void 0);
    l([A.d(bo.INC++, Dt), u("design:type", Dt)], Vn.prototype, "exchangeAny", void 0);
    l([A.d(Dt.INC++, Qt, "optional"), u("design:type", Qt)], Vn.prototype, "taxInformation", void 0);
    Vn = bo = l([R.d("BeExchangeAnyModel")], Vn);
    let cp = class extends Y {
      toJSON() {
        return { beExchangeAny: this.beExchangeAny.toJSON() };
      }
    };
    l([A.d(1, Vn), u("design:type", Vn)], cp.prototype, "beExchangeAny", void 0);
    cp = l([R.d("BeExchangeAnyAssetModel")], cp);
    let Ks;
    let No;
    let bl;
    const dm = /* @__PURE__ */ new WeakMap();
    let tn = Ks = class extends Y {
      toJSON() {
        const e = { toExchangeSource: this.toExchangeSource, toExchangeChainName: this.toExchangeChainName, toExchangeParentAssetType: this.toExchangeParentAssetType, toExchangeAssetType: this.toExchangeAssetType, toExchangeAssetPrealnum: this.toExchangeAssetPrealnum };
        return this.assetExchangeWeightRatio && (e.assetExchangeWeightRatio = this.assetExchangeWeightRatio.toJSON()), this.taxInformation && (e.taxInformation = this.taxInformation.toJSON()), e;
      }
    };
    tn.INC = 1;
    l([A.d(Ks.INC++, "string"), u("design:type", String)], tn.prototype, "toExchangeSource", void 0);
    l([A.d(Ks.INC++, "string"), u("design:type", String)], tn.prototype, "toExchangeChainName", void 0);
    l([A.d(Ks.INC++, G), u("design:type", Number)], tn.prototype, "toExchangeParentAssetType", void 0);
    l([A.d(Ks.INC++, "string"), u("design:type", String)], tn.prototype, "toExchangeAssetType", void 0);
    l([A.d(Ks.INC++, "string"), u("design:type", String)], tn.prototype, "toExchangeAssetPrealnum", void 0);
    l([A.d(Ks.INC++, yi, "optional"), u("design:type", yi)], tn.prototype, "assetExchangeWeightRatio", void 0);
    l([A.d(Ks.INC++, Qt, "optional"), u("design:type", Qt)], tn.prototype, "taxInformation", void 0);
    tn = Ks = l([R.d("ToExchangeAssetV1Model")], tn);
    let rn = No = class extends Y {
      toJSON() {
        const e = { beExchangeSource: this.beExchangeSource, beExchangeChainName: this.beExchangeChainName, beExchangeParentAssetType: this.beExchangeParentAssetType, beExchangeAssetType: this.beExchangeAssetType };
        return this.beExchangeAssetPrealnum && (e.beExchangeAssetPrealnum = this.beExchangeAssetPrealnum), this.taxInformation && (e.taxInformation = this.taxInformation.toJSON()), e;
      }
    };
    rn.INC = 1;
    l([A.d(No.INC++, "string"), u("design:type", String)], rn.prototype, "beExchangeSource", void 0);
    l([A.d(No.INC++, "string"), u("design:type", String)], rn.prototype, "beExchangeChainName", void 0);
    l([A.d(No.INC++, G), u("design:type", Number)], rn.prototype, "beExchangeParentAssetType", void 0);
    l([A.d(No.INC++, "string"), u("design:type", String)], rn.prototype, "beExchangeAssetType", void 0);
    l([A.d(No.INC++, "string", "optional"), u("design:type", String)], rn.prototype, "beExchangeAssetPrealnum", void 0);
    l([A.d(tn.INC++, Qt, "optional"), u("design:type", Qt)], rn.prototype, "taxInformation", void 0);
    rn = No = l([R.d("BeExchangeAssetV1Model")], rn);
    let Os = bl = class extends Y {
      get cipherPublicKeys() {
        const { cipherPublicKeysBuffer: e } = this;
        let t = dm.get(e);
        return t || (t = this.cipherPublicKeysBuffer.map((r) => xe(r))), t;
      }
      set cipherPublicKeys(e) {
        const t = e.map((r) => _e(r));
        dm.set(t, e), this.cipherPublicKeysBuffer = t;
      }
      get to() {
        return this.toExchangeAssets.map((e) => e.toJSON());
      }
      get be() {
        return this.beExchangeAsset.toJSON();
      }
      toJSON() {
        return { cipherPublicKeys: this.cipherPublicKeys, toExchangeAssets: this.toExchangeAssets.map((t) => t.toJSON()), beExchangeAsset: this.beExchangeAsset.toJSON() };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.cipherPublicKeys && (t.cipherPublicKeys = e.cipherPublicKeys), t;
      }
    };
    Os.INC = 1;
    l([A.d(bl.INC++, "bytes", "repeated"), u("design:type", Array)], Os.prototype, "cipherPublicKeysBuffer", void 0);
    l([A.d(bl.INC++, tn, "repeated"), u("design:type", Array)], Os.prototype, "toExchangeAssets", void 0);
    l([A.d(bl.INC++, rn), u("design:type", rn)], Os.prototype, "beExchangeAsset", void 0);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Os.prototype, "to", null);
    Os = bl = l([R.d("ToExchangeAnyMultiModel")], Os);
    let pp = class extends Y {
      toJSON() {
        return { toExchangeAnyMulti: this.toExchangeAnyMulti.toJSON() };
      }
    };
    l([A.d(1, Os), u("design:type", Os)], pp.prototype, "toExchangeAnyMulti", void 0);
    pp = l([R.d("ToExchangeAnyMultiAssetModel")], pp);
    let qa;
    const zu = /* @__PURE__ */ new WeakMap();
    let Cs = qa = class extends Y {
      get transactionSignature() {
        return xe(this.transactionSignatureBuffer);
      }
      set transactionSignature(e) {
        this.transactionSignatureBuffer = _e(e);
      }
      get ciphertextSignature() {
        const { ciphertextSignatureBuffer: e } = this;
        if (!e) return;
        const t = gt.decode(e);
        return zu.set(t, e), t;
      }
      set ciphertextSignature(e) {
        if (e) {
          let t = zu.get(e);
          t || (t = gt.encode(e).finish(), zu.set(e, t)), this.ciphertextSignatureBuffer = t;
        } else this.ciphertextSignatureBuffer = void 0;
      }
      toJSON() {
        const e = { transactionSignature: this.transactionSignature, toExchangeAssets: this.toExchangeAssets.map((t) => t.toJSON()), beExchangeAsset: this.beExchangeAsset.toJSON() };
        return this.ciphertextSignature && (e.ciphertextSignature = this.ciphertextSignature.toJSON()), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.transactionSignature && (t.transactionSignature = e.transactionSignature), e.ciphertextSignature && (t.ciphertextSignature = gt.fromObject(e.ciphertextSignature))), t;
      }
    };
    Cs.INC = 1;
    l([A.d(qa.INC++, "bytes"), u("design:type", Uint8Array)], Cs.prototype, "transactionSignatureBuffer", void 0);
    l([A.d(qa.INC++, "bytes", "optional"), u("design:type", Uint8Array)], Cs.prototype, "ciphertextSignatureBuffer", void 0);
    l([A.d(qa.INC++, tn, "repeated"), u("design:type", Array)], Cs.prototype, "toExchangeAssets", void 0);
    l([A.d(qa.INC++, rn), u("design:type", rn)], Cs.prototype, "beExchangeAsset", void 0);
    Cs = qa = l([R.d("BeExchangeAnyMultiModel")], Cs);
    let lp = class extends Y {
      toJSON() {
        return { beExchangeAnyMulti: this.beExchangeAnyMulti.toJSON() };
      }
    };
    l([A.d(1, Cs), u("design:type", Cs)], lp.prototype, "beExchangeAnyMulti", void 0);
    lp = l([R.d("BeExchangeAnyMultiAssetModel")], lp);
    let Ri;
    let xo;
    let Nl;
    const ym = /* @__PURE__ */ new WeakMap();
    let Sn = Ri = class extends Y {
      toJSON() {
        const e = { toExchangeSource: this.toExchangeSource, toExchangeChainName: this.toExchangeChainName, toExchangeParentAssetType: this.toExchangeParentAssetType, toExchangeAssetType: this.toExchangeAssetType, toExchangeAssetPrealnum: this.toExchangeAssetPrealnum };
        return this.taxInformation && (e.taxInformation = this.taxInformation.toJSON()), e;
      }
    };
    Sn.INC = 1;
    l([A.d(Ri.INC++, "string"), u("design:type", String)], Sn.prototype, "toExchangeSource", void 0);
    l([A.d(Ri.INC++, "string"), u("design:type", String)], Sn.prototype, "toExchangeChainName", void 0);
    l([A.d(Ri.INC++, G), u("design:type", Number)], Sn.prototype, "toExchangeParentAssetType", void 0);
    l([A.d(Ri.INC++, "string"), u("design:type", String)], Sn.prototype, "toExchangeAssetType", void 0);
    l([A.d(Ri.INC++, "string"), u("design:type", String)], Sn.prototype, "toExchangeAssetPrealnum", void 0);
    l([A.d(Ri.INC++, Qt, "optional"), u("design:type", Qt)], Sn.prototype, "taxInformation", void 0);
    Sn = Ri = l([R.d("ToExchangeAssetV2Model")], Sn);
    let Gn = xo = class extends Y {
      toJSON() {
        const e = { beExchangeSource: this.beExchangeSource, beExchangeChainName: this.beExchangeChainName, beExchangeParentAssetType: this.beExchangeParentAssetType, beExchangeAssetType: this.beExchangeAssetType, beExchangeAssetPrealnum: this.beExchangeAssetPrealnum };
        return this.taxInformation && (e.taxInformation = this.taxInformation.toJSON()), e;
      }
    };
    Gn.INC = 1;
    l([A.d(xo.INC++, "string"), u("design:type", String)], Gn.prototype, "beExchangeSource", void 0);
    l([A.d(xo.INC++, "string"), u("design:type", String)], Gn.prototype, "beExchangeChainName", void 0);
    l([A.d(xo.INC++, G), u("design:type", Number)], Gn.prototype, "beExchangeParentAssetType", void 0);
    l([A.d(xo.INC++, "string"), u("design:type", String)], Gn.prototype, "beExchangeAssetType", void 0);
    l([A.d(xo.INC++, "string"), u("design:type", String)], Gn.prototype, "beExchangeAssetPrealnum", void 0);
    l([A.d(Sn.INC++, Qt, "optional"), u("design:type", Qt)], Gn.prototype, "taxInformation", void 0);
    Gn = xo = l([R.d("BeExchangeAssetV2Model")], Gn);
    let Rs = Nl = class extends Y {
      get cipherPublicKeys() {
        const { cipherPublicKeysBuffer: e } = this;
        let t = ym.get(e);
        return t || (t = this.cipherPublicKeysBuffer.map((r) => xe(r))), t;
      }
      set cipherPublicKeys(e) {
        const t = e.map((r) => _e(r));
        ym.set(t, e), this.cipherPublicKeysBuffer = t;
      }
      get to() {
        return this.toExchangeAssets.map((e) => e.toJSON());
      }
      get be() {
        return this.beExchangeAssets.map((e) => e.toJSON());
      }
      toJSON() {
        return { cipherPublicKeys: this.cipherPublicKeys, toExchangeAssets: this.toExchangeAssets.map((t) => t.toJSON()), beExchangeAssets: this.beExchangeAssets.map((t) => t.toJSON()) };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.cipherPublicKeys && (t.cipherPublicKeys = e.cipherPublicKeys), t;
      }
    };
    Rs.INC = 1;
    l([A.d(Nl.INC++, "bytes", "repeated"), u("design:type", Array)], Rs.prototype, "cipherPublicKeysBuffer", void 0);
    l([A.d(Nl.INC++, Sn, "repeated"), u("design:type", Array)], Rs.prototype, "toExchangeAssets", void 0);
    l([A.d(Nl.INC++, Gn, "repeated"), u("design:type", Array)], Rs.prototype, "beExchangeAssets", void 0);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Rs.prototype, "to", null);
    Rs = Nl = l([R.d("ToExchangeAnyMultiAllModel")], Rs);
    let hp = class extends Y {
      toJSON() {
        return { toExchangeAnyMultiAll: this.toExchangeAnyMultiAll.toJSON() };
      }
    };
    l([A.d(1, Rs), u("design:type", Rs)], hp.prototype, "toExchangeAnyMultiAll", void 0);
    hp = l([R.d("ToExchangeAnyMultiAllAssetModel")], hp);
    let Za;
    const ju = /* @__PURE__ */ new WeakMap();
    let Bs = Za = class extends Y {
      get transactionSignature() {
        return xe(this.transactionSignatureBuffer);
      }
      set transactionSignature(e) {
        this.transactionSignatureBuffer = _e(e);
      }
      get ciphertextSignature() {
        const { ciphertextSignatureBuffer: e } = this;
        if (!e) return;
        const t = gt.decode(e);
        return ju.set(t, e), t;
      }
      set ciphertextSignature(e) {
        if (e) {
          let t = ju.get(e);
          t || (t = gt.encode(e).finish(), ju.set(e, t)), this.ciphertextSignatureBuffer = t;
        } else this.ciphertextSignatureBuffer = void 0;
      }
      toJSON() {
        const e = { transactionSignature: this.transactionSignature, toExchangeAssets: this.toExchangeAssets.map((t) => t.toJSON()), beExchangeAssets: this.beExchangeAssets.map((t) => t.toJSON()) };
        return this.ciphertextSignature && (e.ciphertextSignature = this.ciphertextSignature.toJSON()), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.transactionSignature && (t.transactionSignature = e.transactionSignature), e.ciphertextSignature && (t.ciphertextSignature = gt.fromObject(e.ciphertextSignature))), t;
      }
    };
    Bs.INC = 1;
    l([A.d(Za.INC++, "bytes"), u("design:type", Uint8Array)], Bs.prototype, "transactionSignatureBuffer", void 0);
    l([A.d(Za.INC++, "bytes", "optional"), u("design:type", Uint8Array)], Bs.prototype, "ciphertextSignatureBuffer", void 0);
    l([A.d(Za.INC++, Sn, "repeated"), u("design:type", Array)], Bs.prototype, "toExchangeAssets", void 0);
    l([A.d(Za.INC++, Gn, "repeated"), u("design:type", Array)], Bs.prototype, "beExchangeAssets", void 0);
    Bs = Za = l([R.d("BeExchangeAnyMultiAllModel")], Bs);
    let up = class extends Y {
      toJSON() {
        return { beExchangeAnyMultiAll: this.beExchangeAnyMultiAll.toJSON() };
      }
    };
    l([A.d(1, Bs), u("design:type", Bs)], up.prototype, "beExchangeAnyMultiAll", void 0);
    up = l([R.d("BeExchangeAnyMultiAllAssetModel")], up);
    let ec;
    let Ps = ec = class extends Y {
      toJSON() {
        return { sourceChainMagic: this.sourceChainMagic, sourceChainName: this.sourceChainName, certificateId: this.certificateId, type: this.type };
      }
    };
    Ps.INC = 1;
    l([A.d(ec.INC++, "string"), u("design:type", String)], Ps.prototype, "sourceChainName", void 0);
    l([A.d(ec.INC++, "string"), u("design:type", String)], Ps.prototype, "sourceChainMagic", void 0);
    l([A.d(ec.INC++, "string"), u("design:type", String)], Ps.prototype, "certificateId", void 0);
    l([A.d(ec.INC++, "uint32"), u("design:type", Number)], Ps.prototype, "type", void 0);
    Ps = ec = l([R.d("IssueCertificateModel")], Ps);
    let fp = class extends Y {
      toJSON() {
        return { issueCertificate: this.issueCertificate.toJSON() };
      }
    };
    l([A.d(1, Ps), u("design:type", Ps)], fp.prototype, "issueCertificate", void 0);
    fp = l([R.d("IssueCertificateAssetModel")], fp);
    let tc;
    let Ms = tc = class extends Y {
      toJSON() {
        return { sourceChainMagic: this.sourceChainMagic, sourceChainName: this.sourceChainName, certificateId: this.certificateId, type: this.type };
      }
    };
    Ms.INC = 1;
    l([A.d(tc.INC++, "string"), u("design:type", String)], Ms.prototype, "sourceChainName", void 0);
    l([A.d(tc.INC++, "string"), u("design:type", String)], Ms.prototype, "sourceChainMagic", void 0);
    l([A.d(tc.INC++, "string"), u("design:type", String)], Ms.prototype, "certificateId", void 0);
    l([A.d(tc.INC++, "uint32"), u("design:type", Number)], Ms.prototype, "type", void 0);
    Ms = tc = l([R.d("DestroyCertificateModel")], Ms);
    let gp = class extends Y {
      toJSON() {
        return { destroyCertificate: this.destroyCertificate.toJSON() };
      }
    };
    l([A.d(1, Ms), u("design:type", Ms)], gp.prototype, "destroyCertificate", void 0);
    gp = l([R.d("DestroyCertificateAssetModel")], gp);
    let yd;
    let dp = yd = class extends Ve {
    };
    l([A.d(yd.INC++, Pc), u("design:type", Pc)], dp.prototype, "asset", void 0);
    dp = yd = l([R.d("SignatureTransaction")], dp);
    let md;
    let yp = md = class extends Ve {
    };
    l([A.d(md.INC++, Mc), u("design:type", Mc)], yp.prototype, "asset", void 0);
    yp = md = l([R.d("DAppTransaction")], yp);
    let _d;
    let mp = _d = class extends Ve {
    };
    l([A.d(_d.INC++, Lc), u("design:type", Lc)], mp.prototype, "asset", void 0);
    mp = _d = l([R.d("DAppPurchasingTransaction")], mp);
    let Ad;
    let _p = Ad = class extends Ve {
    };
    l([A.d(Ad.INC++, Hc), u("design:type", Hc)], _p.prototype, "asset", void 0);
    _p = Ad = l([R.d("MarkTransaction")], _p);
    let Ed;
    let Ap = Ed = class extends Ve {
    };
    l([A.d(Ed.INC++, vc), u("design:type", vc)], Ap.prototype, "asset", void 0);
    Ap = Ed = l([R.d("IssueAssetTransaction")], Ap);
    let Id;
    let Ep = Id = class extends Ve {
    };
    l([A.d(Id.INC++, kc), u("design:type", kc)], Ep.prototype, "asset", void 0);
    Ep = Id = l([R.d("IncreaseAssetTransaction")], Ep);
    let Td;
    let Ip = Td = class extends Ve {
    };
    l([A.d(Td.INC++, Dc), u("design:type", Dc)], Ip.prototype, "asset", void 0);
    Ip = Td = l([R.d("TransferAssetTransaction")], Ip);
    let Sd;
    let Tp = Sd = class extends Ve {
    };
    l([A.d(Sd.INC++, Fc), u("design:type", Fc)], Tp.prototype, "asset", void 0);
    Tp = Sd = l([R.d("DestroyAssetTransaction")], Tp);
    let wd;
    let Ki = wd = class extends Ve {
    };
    l([A.d(wd.INC++, $c), u("design:type", $c)], Ki.prototype, "asset", void 0);
    Ki = wd = l([R.d("GiftAssetTransaction")], Ki);
    let bd;
    let Sp = bd = class extends Ve {
    };
    l([A.d(bd.INC++, Uc), u("design:type", Uc)], Sp.prototype, "asset", void 0);
    Sp = bd = l([R.d("GrabAssetTransaction")], Sp);
    let Nd;
    let pa = Nd = class extends Ve {
    };
    l([A.d(Nd.INC++, Vc), u("design:type", Vc)], pa.prototype, "asset", void 0);
    pa = Nd = l([R.d("TrustAssetTransaction")], pa);
    let xd;
    let wp = xd = class extends Ve {
    };
    l([A.d(xd.INC++, Gc), u("design:type", Gc)], wp.prototype, "asset", void 0);
    wp = xd = l([R.d("SignForAssetTransaction")], wp);
    let Od;
    let bp = Od = class extends Ve {
    };
    l([A.d(Od.INC++, zc), u("design:type", zc)], bp.prototype, "asset", void 0);
    bp = Od = l([R.d("EmigrateAssetTransaction")], bp);
    let Cd;
    let Np = Cd = class extends Ve {
    };
    l([A.d(Cd.INC++, Jc), u("design:type", Jc)], Np.prototype, "asset", void 0);
    Np = Cd = l([R.d("ImmigrateAssetTransaction")], Np);
    let Rd;
    let la = Rd = class extends Ve {
    };
    l([A.d(Rd.INC++, Yc), u("design:type", Yc)], la.prototype, "asset", void 0);
    la = Rd = l([R.d("ToExchangeAssetTransaction")], la);
    let Bd;
    let xp = Bd = class extends Ve {
    };
    l([A.d(Bd.INC++, Qc), u("design:type", Qc)], xp.prototype, "asset", void 0);
    xp = Bd = l([R.d("BeExchangeAssetTransaction")], xp);
    let Pd;
    let zi = Pd = class extends Ve {
    };
    l([A.d(Pd.INC++, Wc), u("design:type", Wc)], zi.prototype, "asset", void 0);
    zi = Pd = l([R.d("StakeAssetTransaction")], zi);
    let Md;
    let Op = Md = class extends Ve {
    };
    l([A.d(Md.INC++, Xc), u("design:type", Xc)], Op.prototype, "asset", void 0);
    Op = Md = l([R.d("UnstakeAssetTransaction")], Op);
    let Ld;
    let Cp = Ld = class extends Ve {
    };
    l([A.d(Ld.INC++, qc), u("design:type", qc)], Cp.prototype, "asset", void 0);
    Cp = Ld = l([R.d("LocationNameTransaction")], Cp);
    let Hd;
    let Rp = Hd = class extends Ve {
    };
    l([A.d(Hd.INC++, Zc), u("design:type", Zc)], Rp.prototype, "asset", void 0);
    Rp = Hd = l([R.d("SetLnsManagerTransaction")], Rp);
    let vd;
    let Bp = vd = class extends Ve {
    };
    l([A.d(vd.INC++, ep), u("design:type", ep)], Bp.prototype, "asset", void 0);
    Bp = vd = l([R.d("SetLnsRecordValueTransaction")], Bp);
    let kd;
    let Pp = kd = class extends Ve {
    };
    l([A.d(kd.INC++, Gi), u("design:type", Gi)], Pp.prototype, "asset", void 0);
    Pp = kd = l([R.d("IssueEntityFactoryTransaction")], Pp);
    let Dd;
    let Mp = Dd = class extends Ve {
    };
    l([A.d(Dd.INC++, Gi), u("design:type", Gi)], Mp.prototype, "asset", void 0);
    Mp = Dd = l([R.d("IssueEntityFactoryTransactionV1")], Mp);
    let Fd;
    let ji = Fd = class extends Ve {
    };
    l([A.d(Fd.INC++, tp), u("design:type", tp)], ji.prototype, "asset", void 0);
    ji = Fd = l([R.d("IssueEntityTransaction")], ji);
    let $d;
    let Lp = $d = class extends Ve {
    };
    l([A.d($d.INC++, rp), u("design:type", rp)], Lp.prototype, "asset", void 0);
    Lp = $d = l([R.d("DestroyEntityTransaction")], Lp);
    let Ud;
    let Ji = Ud = class extends Ve {
    };
    l([A.d(Ud.INC++, np), u("design:type", np)], Ji.prototype, "asset", void 0);
    Ji = Ud = l([R.d("IssueEntityMultiTransaction")], Ji);
    let Vd;
    let Hp = Vd = class extends Ve {
    };
    l([A.d(Vd.INC++, sp), u("design:type", sp)], Hp.prototype, "asset", void 0);
    Hp = Vd = l([R.d("TransferAnyTransaction")], Hp);
    let Gd;
    let Yi = Gd = class extends Ve {
    };
    l([A.d(Gd.INC++, ip), u("design:type", ip)], Yi.prototype, "asset", void 0);
    Yi = Gd = l([R.d("GiftAnyTransaction")], Yi);
    let Kd;
    let vp = Kd = class extends Ve {
    };
    l([A.d(Kd.INC++, op), u("design:type", op)], vp.prototype, "asset", void 0);
    vp = Kd = l([R.d("GrabAnyTransaction")], vp);
    let zd;
    let ha = zd = class extends Ve {
    };
    l([A.d(zd.INC++, ap), u("design:type", ap)], ha.prototype, "asset", void 0);
    ha = zd = l([R.d("ToExchangeAnyTransaction")], ha);
    let jd;
    let kp = jd = class extends Ve {
    };
    l([A.d(jd.INC++, cp), u("design:type", cp)], kp.prototype, "asset", void 0);
    kp = jd = l([R.d("BeExchangeAnyTransaction")], kp);
    let Jd;
    let ua = Jd = class extends Ve {
    };
    l([A.d(Jd.INC++, pp), u("design:type", pp)], ua.prototype, "asset", void 0);
    ua = Jd = l([R.d("ToExchangeAnyMultiTransaction")], ua);
    let Yd;
    let Dp = Yd = class extends Ve {
    };
    l([A.d(Yd.INC++, lp), u("design:type", lp)], Dp.prototype, "asset", void 0);
    Dp = Yd = l([R.d("BeExchangeAnyMultiTransaction")], Dp);
    let Qd;
    let fa = Qd = class extends Ve {
    };
    l([A.d(Qd.INC++, hp), u("design:type", hp)], fa.prototype, "asset", void 0);
    fa = Qd = l([R.d("ToExchangeAnyMultiAllTransaction")], fa);
    let Wd;
    let Fp = Wd = class extends Ve {
    };
    l([A.d(Wd.INC++, up), u("design:type", up)], Fp.prototype, "asset", void 0);
    Fp = Wd = l([R.d("BeExchangeAnyMultiAllTransaction")], Fp);
    let Xd;
    let $p = Xd = class extends Ve {
    };
    l([A.d(Xd.INC++, fp), u("design:type", fp)], $p.prototype, "asset", void 0);
    $p = Xd = l([R.d("IssueCertificateTransaction")], $p);
    let qd;
    let Up = qd = class extends Ve {
    };
    l([A.d(qd.INC++, gp), u("design:type", gp)], Up.prototype, "asset", void 0);
    Up = qd = l([R.d("DestroyCertificateTransaction")], Up);
    const U = class {
      constructor(e, t) {
        this.__code = e, this.__message = t;
      }
      get code() {
        return this.__code;
      }
      get message() {
        return this.__message;
      }
      set message(e) {
        this.__message = e;
      }
      build(e) {
        return e ? this.__message.replace(/\{([^\\]+?)\}/g, (t, r) => e[r] ?? t) : this.__message;
      }
    };
    const Zd = /* @__PURE__ */ Symbol("InjectionToken");
    const If = /* @__PURE__ */ Symbol("SingletonToken");
    const tA = /* @__PURE__ */ Symbol("GroupToken");
    const Tf = /* @__PURE__ */ new WeakMap();
    const rA = /* @__PURE__ */ new WeakMap();
    const hh = [];
    function hI(i) {
      return rA.get(i) || hh[hh.length - 1];
    }
    const nA = "injectProps:afertInit";
    const sA = "injectProps:onInit";
    function iA(i) {
      return i[Zd];
    }
    function oA(i) {
      const e = /* @__PURE__ */ new Set();
      let t = i;
      for (; ; ) {
        const r = t[tA];
        if (!r) break;
        for (const n of r) e.add(n);
        if (t = Object.getPrototypeOf(t), !t) break;
      }
      return e;
    }
    let mm;
    (function(i) {
      (function(e) {
        let t = typeof Fy === "object" ? Fy : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")(), r = n(i);
        typeof t.Reflect > "u" ? t.Reflect = i : r = n(t.Reflect, r), e(r);
        function n(s, o) {
          return function(a, p) {
            typeof s[a] !== "function" && Object.defineProperty(s, a, { configurable: true, writable: true, value: p }), o && o(a, p);
          };
        }
      })(function(e) {
        const t = Object.prototype.hasOwnProperty, r = typeof Symbol === "function", n = r && typeof Symbol.toPrimitive < "u" ? Symbol.toPrimitive : "@@toPrimitive", s = r && typeof Symbol.iterator < "u" ? Symbol.iterator : "@@iterator", o = typeof Object.create === "function", a = { __proto__: [] } instanceof Array, p = !o && !a, h = { create: o ? function() {
          return Mi(/* @__PURE__ */ Object.create(null));
        } : a ? function() {
          return Mi({ __proto__: null });
        } : function() {
          return Mi({});
        }, has: p ? function(Q, te) {
          return t.call(Q, te);
        } : function(Q, te) {
          return te in Q;
        }, get: p ? function(Q, te) {
          return t.call(Q, te) ? Q[te] : void 0;
        } : function(Q, te) {
          return Q[te];
        } }, f = Object.getPrototypeOf(Function), g = typeof process === "object" && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL === "true", d = !g && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : Hl(), y = !g && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : Lo(), _ = !g && typeof WeakMap === "function" ? WeakMap : hn(), I = new _();
        function S(Q, te, ue, T) {
          if (ce(ue)) {
            if (!Pe(Q)) throw new TypeError();
            if (!Qe(te)) throw new TypeError();
            return L(Q, te);
          } else {
            if (!Pe(Q)) throw new TypeError();
            if (!pe(te)) throw new TypeError();
            if (!pe(T) && !ce(T) && !de(T)) throw new TypeError();
            return de(T) && (T = void 0), ue = le(ue), H(Q, te, ue, T);
          }
        }
        e("decorate", S);
        function w(Q, te) {
          function ue(T, m) {
            if (!pe(T)) throw new TypeError();
            if (!ce(m) && !tt(m)) throw new TypeError();
            ge(Q, te, T, m);
          }
          return ue;
        }
        e("metadata", w);
        function N(Q, te, ue, T) {
          if (!pe(ue)) throw new TypeError();
          return ce(T) || (T = le(T)), ge(Q, te, ue, T);
        }
        e("defineMetadata", N);
        function B(Q, te, ue) {
          if (!pe(te)) throw new TypeError();
          return ce(ue) || (ue = le(ue)), z(Q, te, ue);
        }
        e("hasMetadata", B);
        function O(Q, te, ue) {
          if (!pe(te)) throw new TypeError();
          return ce(ue) || (ue = le(ue)), $(Q, te, ue);
        }
        e("hasOwnMetadata", O);
        function P(Q, te, ue) {
          if (!pe(te)) throw new TypeError();
          return ce(ue) || (ue = le(ue)), q(Q, te, ue);
        }
        e("getMetadata", P);
        function C(Q, te, ue) {
          if (!pe(te)) throw new TypeError();
          return ce(ue) || (ue = le(ue)), ie(Q, te, ue);
        }
        e("getOwnMetadata", C);
        function V(Q, te) {
          if (!pe(Q)) throw new TypeError();
          return ce(te) || (te = le(te)), Ae(Q, te);
        }
        e("getMetadataKeys", V);
        function F(Q, te) {
          if (!pe(Q)) throw new TypeError();
          return ce(te) || (te = le(te)), he(Q, te);
        }
        e("getOwnMetadataKeys", F);
        function K(Q, te, ue) {
          if (!pe(te)) throw new TypeError();
          ce(ue) || (ue = le(ue));
          const T = W(te, ue, false);
          if (ce(T) || !T.delete(Q)) return false;
          if (T.size > 0) return true;
          const m = I.get(te);
          return m.delete(ue), m.size > 0 || I.delete(te), true;
        }
        e("deleteMetadata", K);
        function L(Q, te) {
          for (let ue = Q.length - 1; ue >= 0; --ue) {
            const T = Q[ue], m = T(te);
            if (!ce(m) && !de(m)) {
              if (!Qe(m)) throw new TypeError();
              te = m;
            }
          }
          return te;
        }
        function H(Q, te, ue, T) {
          for (let m = Q.length - 1; m >= 0; --m) {
            const E = Q[m], b = E(te, ue, T);
            if (!ce(b) && !de(b)) {
              if (!pe(b)) throw new TypeError();
              T = b;
            }
          }
          return T;
        }
        function W(Q, te, ue) {
          let T = I.get(Q);
          if (ce(T)) {
            if (!ue) return;
            T = new d(), I.set(Q, T);
          }
          let m = T.get(te);
          if (ce(m)) {
            if (!ue) return;
            m = new d(), T.set(te, m);
          }
          return m;
        }
        function z(Q, te, ue) {
          const T = $(Q, te, ue);
          if (T) return true;
          const m = oc(te);
          return de(m) ? false : z(Q, m, ue);
        }
        function $(Q, te, ue) {
          const T = W(te, ue, false);
          return ce(T) ? false : se(T.has(Q));
        }
        function q(Q, te, ue) {
          const T = $(Q, te, ue);
          if (T) return ie(Q, te, ue);
          const m = oc(te);
          if (!de(m)) return q(Q, m, ue);
        }
        function ie(Q, te, ue) {
          const T = W(te, ue, false);
          if (!ce(T)) return T.get(Q);
        }
        function ge(Q, te, ue, T) {
          const m = W(ue, T, true);
          m.set(Q, te);
        }
        function Ae(Q, te) {
          const ue = he(Q, te), T = oc(Q);
          if (T === null) return ue;
          const m = Ae(T, te);
          if (m.length <= 0) return ue;
          if (ue.length <= 0) return m;
          for (var E = new y(), b = [], M = 0, k = ue; M < k.length; M++) {
            var X = k[M], we = E.has(X);
            we || (E.add(X), b.push(X));
          }
          for (let et = 0, at = m; et < at.length; et++) {
            var X = at[et], we = E.has(X);
            we || (E.add(X), b.push(X));
          }
          return b;
        }
        function he(Q, te) {
          const ue = [], T = W(Q, te, false);
          if (ce(T)) return ue;
          for (let m = T.keys(), E = jt(m), b = 0; ; ) {
            const M = ic(E);
            if (!M) return ue.length = b, ue;
            const k = xu(M);
            try {
              ue[b] = k;
            } catch (X) {
              try {
                Ou(E);
              } finally {
                throw X;
              }
            }
            b++;
          }
        }
        function x(Q) {
          if (Q === null) return 1;
          switch (typeof Q) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return Q === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function ce(Q) {
          return Q === void 0;
        }
        function de(Q) {
          return Q === null;
        }
        function ke(Q) {
          return typeof Q === "symbol";
        }
        function pe(Q) {
          return typeof Q === "object" ? Q !== null : typeof Q === "function";
        }
        function j(Q, te) {
          switch (x(Q)) {
            case 0:
              return Q;
            case 1:
              return Q;
            case 2:
              return Q;
            case 3:
              return Q;
            case 4:
              return Q;
            case 5:
              return Q;
          }
          const ue = te === 3 ? "string" : te === 5 ? "number" : "default", T = yt(Q, n);
          if (T !== void 0) {
            const m = T.call(Q, ue);
            if (pe(m)) throw new TypeError();
            return m;
          }
          return re(Q, ue === "default" ? "number" : ue);
        }
        function re(Q, te) {
          if (te === "string") {
            const ue = Q.toString;
            if (Ke(ue)) {
              var T = ue.call(Q);
              if (!pe(T)) return T;
            }
            var m = Q.valueOf;
            if (Ke(m)) {
              var T = m.call(Q);
              if (!pe(T)) return T;
            }
          } else {
            var m = Q.valueOf;
            if (Ke(m)) {
              var T = m.call(Q);
              if (!pe(T)) return T;
            }
            const E = Q.toString;
            if (Ke(E)) {
              var T = E.call(Q);
              if (!pe(T)) return T;
            }
          }
          throw new TypeError();
        }
        function se(Q) {
          return !!Q;
        }
        function ae(Q) {
          return "" + Q;
        }
        function le(Q) {
          const te = j(Q, 3);
          return ke(te) ? te : ae(te);
        }
        function Pe(Q) {
          return Array.isArray ? Array.isArray(Q) : Q instanceof Object ? Q instanceof Array : Object.prototype.toString.call(Q) === "[object Array]";
        }
        function Ke(Q) {
          return typeof Q === "function";
        }
        function Qe(Q) {
          return typeof Q === "function";
        }
        function tt(Q) {
          switch (x(Q)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function yt(Q, te) {
          const ue = Q[te];
          if (ue != null) {
            if (!Ke(ue)) throw new TypeError();
            return ue;
          }
        }
        function jt(Q) {
          const te = yt(Q, s);
          if (!Ke(te)) throw new TypeError();
          const ue = te.call(Q);
          if (!pe(ue)) throw new TypeError();
          return ue;
        }
        function xu(Q) {
          return Q.value;
        }
        function ic(Q) {
          const te = Q.next();
          return te.done ? false : te;
        }
        function Ou(Q) {
          const te = Q.return;
          te && te.call(Q);
        }
        function oc(Q) {
          const te = Object.getPrototypeOf(Q);
          if (typeof Q !== "function" || Q === f || te !== f) return te;
          const ue = Q.prototype, T = ue && Object.getPrototypeOf(ue);
          if (T == null || T === Object.prototype) return te;
          const m = T.constructor;
          return typeof m !== "function" || m === Q ? te : m;
        }
        function Hl() {
          const Q = {}, te = [], ue = (function() {
            function b(M, k, X) {
              this._index = 0, this._keys = M, this._values = k, this._selector = X;
            }
            return b.prototype["@@iterator"] = function() {
              return this;
            }, b.prototype[s] = function() {
              return this;
            }, b.prototype.next = function() {
              const M = this._index;
              if (M >= 0 && M < this._keys.length) {
                const k = this._selector(this._keys[M], this._values[M]);
                return M + 1 >= this._keys.length ? (this._index = -1, this._keys = te, this._values = te) : this._index++, { value: k, done: false };
              }
              return { value: void 0, done: true };
            }, b.prototype.throw = function(M) {
              throw this._index >= 0 && (this._index = -1, this._keys = te, this._values = te), M;
            }, b.prototype.return = function(M) {
              return this._index >= 0 && (this._index = -1, this._keys = te, this._values = te), { value: M, done: true };
            }, b;
          })();
          return (function() {
            function b() {
              this._keys = [], this._values = [], this._cacheKey = Q, this._cacheIndex = -2;
            }
            return Object.defineProperty(b.prototype, "size", { get: function() {
              return this._keys.length;
            }, enumerable: true, configurable: true }), b.prototype.has = function(M) {
              return this._find(M, false) >= 0;
            }, b.prototype.get = function(M) {
              const k = this._find(M, false);
              return k >= 0 ? this._values[k] : void 0;
            }, b.prototype.set = function(M, k) {
              const X = this._find(M, true);
              return this._values[X] = k, this;
            }, b.prototype.delete = function(M) {
              const k = this._find(M, false);
              if (k >= 0) {
                for (let X = this._keys.length, we = k + 1; we < X; we++) this._keys[we - 1] = this._keys[we], this._values[we - 1] = this._values[we];
                return this._keys.length--, this._values.length--, M === this._cacheKey && (this._cacheKey = Q, this._cacheIndex = -2), true;
              }
              return false;
            }, b.prototype.clear = function() {
              this._keys.length = 0, this._values.length = 0, this._cacheKey = Q, this._cacheIndex = -2;
            }, b.prototype.keys = function() {
              return new ue(this._keys, this._values, T);
            }, b.prototype.values = function() {
              return new ue(this._keys, this._values, m);
            }, b.prototype.entries = function() {
              return new ue(this._keys, this._values, E);
            }, b.prototype["@@iterator"] = function() {
              return this.entries();
            }, b.prototype[s] = function() {
              return this.entries();
            }, b.prototype._find = function(M, k) {
              return this._cacheKey !== M && (this._cacheIndex = this._keys.indexOf(this._cacheKey = M)), this._cacheIndex < 0 && k && (this._cacheIndex = this._keys.length, this._keys.push(M), this._values.push(void 0)), this._cacheIndex;
            }, b;
          })();
          function T(b, M) {
            return b;
          }
          function m(b, M) {
            return M;
          }
          function E(b, M) {
            return [b, M];
          }
        }
        function Lo() {
          return (function() {
            function Q() {
              this._map = new d();
            }
            return Object.defineProperty(Q.prototype, "size", { get: function() {
              return this._map.size;
            }, enumerable: true, configurable: true }), Q.prototype.has = function(te) {
              return this._map.has(te);
            }, Q.prototype.add = function(te) {
              return this._map.set(te, te), this;
            }, Q.prototype.delete = function(te) {
              return this._map.delete(te);
            }, Q.prototype.clear = function() {
              this._map.clear();
            }, Q.prototype.keys = function() {
              return this._map.keys();
            }, Q.prototype.values = function() {
              return this._map.values();
            }, Q.prototype.entries = function() {
              return this._map.entries();
            }, Q.prototype["@@iterator"] = function() {
              return this.keys();
            }, Q.prototype[s] = function() {
              return this.keys();
            }, Q;
          })();
        }
        function hn() {
          const Q = 16, te = h.create(), ue = T();
          return (function() {
            function k() {
              this._key = T();
            }
            return k.prototype.has = function(X) {
              const we = m(X, false);
              return we !== void 0 ? h.has(we, this._key) : false;
            }, k.prototype.get = function(X) {
              const we = m(X, false);
              return we !== void 0 ? h.get(we, this._key) : void 0;
            }, k.prototype.set = function(X, we) {
              const et = m(X, true);
              return et[this._key] = we, this;
            }, k.prototype.delete = function(X) {
              const we = m(X, false);
              return we !== void 0 ? delete we[this._key] : false;
            }, k.prototype.clear = function() {
              this._key = T();
            }, k;
          })();
          function T() {
            let k;
            do
              k = "@@WeakMap@@" + M();
            while (h.has(te, k));
            return te[k] = true, k;
          }
          function m(k, X) {
            if (!t.call(k, ue)) {
              if (!X) return;
              Object.defineProperty(k, ue, { value: h.create() });
            }
            return k[ue];
          }
          function E(k, X) {
            for (let we = 0; we < X; ++we) k[we] = Math.random() * 255 | 0;
            return k;
          }
          function b(k) {
            return typeof Uint8Array === "function" ? typeof crypto < "u" ? crypto.getRandomValues(new Uint8Array(k)) : typeof msCrypto < "u" ? msCrypto.getRandomValues(new Uint8Array(k)) : E(new Uint8Array(k), k) : E(new Array(k), k);
          }
          function M() {
            const k = b(Q);
            k[6] = k[6] & 79 | 64, k[8] = k[8] & 191 | 128;
            for (var X = "", we = 0; we < Q; ++we) {
              const et = k[we];
              (we === 4 || we === 6 || we === 8) && (X += "-"), et < 16 && (X += "0"), X += et.toString(16).toLowerCase();
            }
            return X;
          }
        }
        function Mi(Q) {
          return Q.__ = void 0, delete Q.__, Q;
        }
      });
    })(mm || (mm = {}));
    function J(i, e) {
      return (t) => {
        let r, n, s;
        typeof i === "object" ? (r = i.module_name, e = i, n = i.singleton) : r = i, r === void 0 && (r = Symbol(t.name)), e && (e.singleton !== void 0 && (n = e.singleton), e.group !== void 0 && (typeof e.group === "boolean" ? e.group === true && (s = [r]) : s = e.group instanceof Array ? e.group : [e.group])), t[Zd] = r, t[If] = !!n, s && (t[tA] = s);
      };
    }
    let aA;
    let cA;
    let pA;
    const Sf = /* @__PURE__ */ Symbol("module-map");
    const ql = /* @__PURE__ */ Symbol("mask-level");
    const wf = /* @__PURE__ */ Symbol("mask-self");
    let ze = class {
      constructor(i, e) {
        this.parent = e, this[aA] = "ModuleStroge", this[cA] = 0, this[pA] = this, this._stroge = new Map(i), this.set(Sf, this);
      }
      clear() {
        return this._stroge.clear();
      }
      delete(i) {
        return this._stroge.delete(i);
      }
      forEach(i, e) {
        return this._stroge.forEach(i, e);
      }
      set(i, e) {
        return this._stroge.set(i, e), this;
      }
      get size() {
        return this._stroge.size;
      }
      [Symbol.iterator]() {
        return this._stroge[Symbol.iterator]();
      }
      entries() {
        return this._stroge.entries();
      }
      keys() {
        return this._stroge.keys();
      }
      values() {
        return this._stroge.values();
      }
      get(i) {
        return !this.parent || this._stroge.has(i) ? this._stroge.get(i) : this.parent.get(i);
      }
      has(i) {
        return !!this._stroge.has(i) || !!this.parent && this.parent.has(i);
      }
      installMask(i) {
        const e = (n) => n === Sf && i.get(n) === i ? r : i.has(n) ? i.get(n) : this.get(n), t = (n) => i.has(n) || this.has(n), r = new Proxy(this, { get: (n, s, o) => s === "_mask" ? i : s === ql ? this[ql] + 1 : s === wf ? this : s === "get" ? e : s === "has" ? t : Reflect.get(n, s, o) });
        return r;
      }
      uninstallMask(i = 1) {
        i = Math.min(this[ql], i);
        let e = this;
        for (let t = 0; t < i; t += 1) e = this[wf];
        return e;
      }
      groupInsert(i, e) {
        (this._groupCollection || (this._groupCollection = new wt((t) => /* @__PURE__ */ new Set()))).forceGet(i).add(e);
      }
      groupGet(...i) {
        let e;
        for (const t of i) {
          let r;
          switch (typeof t) {
            case "function":
              r = [...oA(t)];
              break;
            case "object":
              r = t;
              break;
            default:
              r = [t];
          }
          if (!(r instanceof Array)) throw new TypeError();
          const n = this.groupsGet_(r);
          if (n) if (e) for (const s of n) e.add(s);
          else e = n;
          if (this.parent) {
            const s = this.parent.groupsGet_(r);
            if (s) if (e) for (const o of s) e.add(o);
            else e = s;
          }
        }
        return e || /* @__PURE__ */ new Set();
      }
      groupsGet_(i) {
        let e;
        i = i.slice();
        let t = (r) => true;
        for (; ; ) {
          const r = i.shift();
          if (r === void 0) break;
          e = /* @__PURE__ */ new Set();
          for (const n of this.groupGet_(r)) t(n) && e.add(n);
          if (!e.size) break;
          {
            const n = e;
            t = (s) => n.has(s);
          }
        }
        return e;
      }
      groupGet_(i) {
        const e = [];
        if (this._groupCollection) {
          const t = this._groupCollection.get(i);
          t && e.push(...t);
        }
        return this.parent && e.push(...this.parent.groupGet_(i)), e;
      }
    };
    aA = Symbol.toStringTag, cA = ql, pA = wf, ze = l([J(Sf), u("design:paramtypes", [Object, ze])], ze);
    const uI = /* @__PURE__ */ new Map();
    function fI(i) {
      for (; ; ) {
        const e = Tf.get(i);
        if (e) return e;
        if ((i = Object.getPrototypeOf(i)) === Object.prototype || !i) break;
      }
      return uI;
    }
    function bt(i, e = new ze()) {
      const t = i[Zd], r = i[If], n = oA(i);
      let s;
      if (r instanceof i ? e.set(t, s = r) : s = e.get(t), !s) {
        const o = fI(i), a = Reflect.getMetadata("design:paramtypes", i), p = a ? a.map((g, d) => {
          const y = o && o.get(d);
          if (y !== void 0) {
            if (!(y.conf && y.conf.optional)) {
              if (!e.has(y.id)) throw new ReferenceError(`Need Inject Module '${String(y.id)}' in ${String(t)}`);
            }
            return e.get(y.id);
          }
          return bt(g, e);
        }) : [];
        hh.push(e), s = new i(...p), hh.pop(), rA.set(s, e), r && (i[If] = s), t !== void 0 && e.set(t, s);
        for (const g of n) e.groupInsert(g, s);
        typeof s.bfOnInit === "function" && s.bfOnInit();
        const h = Reflect.getMetadata(sA, i.prototype);
        if (h) for (const [g, d] of h) s[g] = bt(d.injectModel, e);
        typeof s.bfAfterInit === "function" && queueMicrotask(() => {
          s.bfAfterInit();
        });
        const f = Reflect.getMetadata(nA, i.prototype);
        f && queueMicrotask(() => {
          for (const [g, d] of f) s[g] = bt(d.injectModel, e);
        });
      }
      return s;
    }
    function D(i, e) {
      return (t, r, n) => {
        if (typeof n !== "number") {
          if (i === void 0) throw new ReferenceError("inject_moudle should not be empty");
          return dI(i, e)(t, r, n);
        }
        {
          const s = typeof i === "function" ? iA(i) : i;
          if (s !== void 0) {
            const o = Tf.get(t) || /* @__PURE__ */ new Map();
            Tf.set(t, o), o.set(n, { id: s, conf: e });
          }
        }
      };
    }
    const gI = ((i) => (i[i.NO_RESOLVE = 0] = "NO_RESOLVE", i[i.ON_GETTER = 1] = "ON_GETTER", i[i.ON_INIT = 2] = "ON_INIT", i[i.AFTER_INIT = 3] = "AFTER_INIT", i))(gI || {});
    function _m(i, e) {
      let t = Reflect.getMetadata(e, i);
      return t || (t = /* @__PURE__ */ new Map(), Reflect.metadata(e, t)(i)), t;
    }
    function dI(i, e = {}) {
      const { dynamics: t, optional: r, autoResolve: n, writable: s = true } = e;
      let o;
      o = n === false ? 0 : n === true || n === void 0 ? 1 : n;
      const a = typeof i === "function" ? iA(i) : i;
      if (a === void 0) throw new TypeError("module name is undefined");
      return (p, h, f) => {
        if (o !== 0 && o !== 1) {
          if (typeof i !== "function") throw new TypeError(`${p} could not resolve prop '${h}', inject_module not an function.`);
          o === 3 ? _m(p, nA).set(h, { injectModel: i }) : o === 2 && _m(p, sA).set(h, { injectModel: i });
        }
        const g = (I) => {
          const S = hI(I);
          if (!S) throw new ReferenceError(`instance of ${I.constructor.name} is not an instance which is created by Resolve`);
          return S;
        }, d = (I, S) => {
          g(I).set(a, S);
        }, y = (I) => {
          const S = g(I);
          if (S.has(a)) return S.get(a);
          if (o !== 0 && typeof i === "function") return bt(i, S);
          if (!r) throw new ReferenceError(`module of ${String(a)} must been Injected first.`);
        }, _ = { configurable: true, enumerable: true };
        if (t) s && (_.set = function(I) {
          d(this, I);
        }), _.get = function() {
          return y(this);
        };
        else {
          const I = (S, w) => {
            Object.defineProperty(S, h, { value: w, writable: s, configurable: true, enumerable: true });
          };
          s && (_.set = function(S) {
            d(this, S), I(this, S);
          }), _.get = function() {
            const S = y(this);
            return I(this, S), S;
          };
        }
        Object.defineProperty(p, h, _);
      };
    }
    function Oo(i) {
      return (e) => {
      };
    }
    let bf;
    let wc;
    (function(i) {
      i.CHINESE = "zh_CN.UTF-8", i.ENGLISH = "en_US.UTF-8";
    })(wc || (wc = {}));
    const lA = /* @__PURE__ */ Symbol("errorCodeLang");
    let Nf = bf = class {
      constructor(i = wc.ENGLISH) {
        this.__store = /* @__PURE__ */ new Map(), this.__checkLanguage(i), this.__lang = i;
      }
      static from(i, e = new ze()) {
        return bt(bf, e.installMask(new ze([[lA, i]])));
      }
      __checkLanguage(i) {
        if (i !== wc.CHINESE && i !== wc.ENGLISH) throw new Error(`Invalid lang type ${i}`);
      }
      getErrorCodeList(i) {
        const e = this.__store.get(i);
        if (!e) throw new Error(`Failed to get error code list by ${i}`);
        return e.sourceErrorCodeList;
      }
      formatErrorCodeList(i, e) {
        const t = e.get(this.__lang);
        if (!t) return console.debug(`Translated error code list not found, language ${this.__lang}`), i;
        for (const r in i) {
          const n = i[r];
          n.message = t[n.code] || n.message;
        }
        return i;
      }
      addErrorCodeList(i, e, t) {
        this.formatErrorCodeList(e, t), this.__store.set(i, { sourceErrorCodeList: e, translatedErrorCodeListMap: t });
      }
      setLanguage(i) {
        if (this.__lang !== i) {
          this.__checkLanguage(i), this.__lang = i;
          for (const { sourceErrorCodeList: e, translatedErrorCodeListMap: t } of this.__store.values()) this.formatErrorCodeList(e, t);
        }
      }
    };
    Nf = bf = l([J(), be(0, D(lA, { optional: true })), u("design:paramtypes", [String])], Nf);
    const yI = { "001-00001": "params {param} lost", "001-00002": "{prop} in {target} is required", "001-00003": "{prop} in {target} is invalid", "001-00004": "{to_compare_prop} in {to_target} and {be_compare_prop} in {be_target} not match", "001-00005": "{prop} in {target} should greater than {field}", "001-00006": "{prop} in {target} should greater than or equals to {field}", "001-00007": "{prop} in {target} should less than {field}", "001-00008": "{prop} in {target} should less than or equals to {field}", "001-00009": "{prop} in {target} should equals to {field}", "001-00010": "{to_compare_prop} in {to_target} should be {be_compare_prop}", "001-00011": "{to_compare_prop} in {to_target} should not be {be_compare_prop}", "001-00012": "{prop} in {target} not exist", "001-00013": "{prop} in {target} should not exist", "001-00014": "Transaction fee is not enough, errorId {errorId}, minFee {minFee}", "001-00015": "{prop} in {target} not in [{min}, {max}]", "001-00016": "{prop} in {target} is over length {limit}", "001-00017": "{prop} in {target} should not start with or end with {field}", "001-00018": "{prop} in {target} not a string, value {value}", "001-00019": "{prop} in {target} not a ip, value {value}", "001-00020": "{prop} in {target} not a ipv4, value {value}", "001-00021": "{prop} in {target} not a ipv6, value {value}", "001-00022": "{prop} in {target} not a longitude-latitude, value {value}", "001-00023": "{prop} in {target} not a longitude, value {value}", "001-00024": "{prop} in {target} not a latitude, value {value}", "001-00025": "{prop} in {target} not a address, value {value}", "001-00026": "{prop} in {target} not a locationName, value {value}", "001-00027": "{prop} in {target} not a dns, value {value}", "001-00028": "{prop} in {target} not a email, value {value}", "001-00029": "{prop} in {target} not a url, value {value}", "001-00030": "Permission denied at operation {operationName}", "001-00031": "{prop} in {target} should not inclue {value}", "001-00032": "{prop} in {target} should inclue {value}", "001-00033": "{prop} in {target} should not duplicate", "001-00034": "{prop} in {target} already exist, errorId {errorId}", "001-00035": "Genesis generator not enough, at least {expected}, actual {actual}", "001-00036": "{prop} in {target} should be an array", "001-00037": "Invalid block generator, reason {reason}", "001-00038": "transaction's porf of work verify fail", "001-00039": "{prop} not found", "001-00040": "{prop} is too large, reason {reason}, errorId {errorId}", "001-00041": "{prop} length in {target} should less than {field}", "001-00042": "{prop} length in {target} should less than or equals to {field}", "001-00043": "{prop} length in {target} should greater than {field}", "001-00044": "{prop} length in {target} should greater than or equals to {field}", "001-00045": "{prop} length in {target} should equals to {field}", "001-00046": "{prop} length in {target} should not equals to {field}", "001-00047": "Invalid transaction base type: {base_type}", "001-00048": "Invalid block constructor: {name}", "001-00049": "Invalid block type: {type}", "001-00050": "Custom transaction verify fail: {message}", "001-00051": "Disabled create {trsName} Transaction", "001-00052": "Disabled insert {trsName} Transaction", "001-00053": "Transaction is in unchangable state", "001-00054": "AssetStatistic index: {index} already in use", "001-00055": "Invalid {taskLabel} signature", "001-00056": "Invalid {taskLabel} signSignature", "001-00057": "Invalid base type {base_type}", "001-00058": "Unregistered TransactionFactory {factoryName}", "001-00059": "Unregistered Transaction base type {trs_base}", "001-00060": "Unregistered Transaction type {trs_key}", "001-00061": "Invalid {taskLabel} fromAuthSignature", "001-00062": "Invalid {taskLabel} fromAuthSignSignature", "001-00063": "Invalid {taskLabel} toAuthSignature", "001-00064": "Invalid {taskLabel} toAuthSignSignature", "001-00065": "Invalid macro input type: {type}", "001-00066": "{prop} in {target} already expired", "001-11001": "{prop} in {target} lose", "001-11002": "Account with address {address} was frozen, status {status}, errorId {errorId}", "001-11003": "Transaction signSignature is required, signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}", "001-11004": "Transaction sender second secret have already change, signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}", "001-11005": "Transaction should not have senderSecondPublicKey, signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}", "001-11006": "Transaction should not have signSignature, signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}", "001-11007": "Invalid transaction({signature}) apply block height, reason {reason}", "001-11008": "Invalid transaction({signature}) effective block height, reason {reason}", "001-11009": "Invalid transaction from magic, reason {reason} signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}", "001-11010": "Invalid transaction to magic, reason {reason} signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}", "001-11011": "Invalid transaction timestamp, reason {reason} signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}", "001-11012": "DAppid is not exist, dappid {dappid}", "001-11013": "DAppid is already exist, dappid {dappid}, errorId {errorId}", "001-11014": "LocationName is not exist, locationName {locationName}, errorId {errorId}", "001-11015": "LocationName is already exist, locationName {locationName}, errorId {errorId}", "001-11016": "Entity factory is not exist, factoryId {factoryId}", "001-11017": "Entity factory is already exist, factoryId {factoryId}, errorId {errorId}", "001-11018": "Entity is not exist, entityId {entityId}", "001-11019": "Entity is already exist, entityId {entityId}, errorId {errorId}", "001-11020": "Unknow rangeType, rangeType {rangeType}", "001-11021": "Invalid transaction byte length, reason {reason}", "001-11022": "Need purchase dappid before use, dappid {dappid}", "001-11025": "Can not delete locationName {locationName}, reason {reason}", "001-11026": "Set locationName {locationName} manager field, reason {reason}, errorId {errorId}", "001-11027": "Set locationName {locationName} recordValue field, reason {reason}, errorId {errorId}", "001-11028": "Asset not enough, reason {reason}, errorId {errorId}", "001-11029": "Account remain equity not enough, reason {reason}, errorId {errorId}", "001-11030": "Frozen asset is not begin to unfrozen yet, frozenId {frozenId}", "001-11031": "Frozen asset is already expiration, frozenId {frozenId}", "001-11032": "Gift asset unfrozen time use up, frozenId {frozenId}", "001-11034": "Account with address {address} is already an generator, errorId {errorId}", "001-11035": "Account with address {address} is not an generator, errorId {errorId}", "001-11038": "{prop} in {target} is forbidden", "001-11039": "Asset not exist, magic {magic} assetType {assetType}", "001-11040": "Account with address {address} not dappid {dappid} possessor, errorId {errorId}", "001-11041": "Account with address {address} not locationName {locationName} possessor, errorId {errorId}", "001-11042": "Account with address {address} not entityId {entityId} possessor, errorId {errorId}", "001-11043": "DAppid not frozen, dappid {dappid}", "001-11044": "DAppid already frozen, dappid {dappid}", "001-11045": "LocationName not frozen, locationName {locationName}", "001-11046": "LocationName already frozen, locationName {locationName}", "001-11047": "Entity not frozen, entityId {entityId}", "001-11048": "Entity already frozen, entityId {entityId}", "001-11049": "No need to purchase asset, type {type} asset {asset}", "001-11050": "Only top level location name can exchange", "001-11051": "Can not destroy entityId {entityId}, reason {reason}", "001-11052": "Entity already destroy, entityId {entityId}", "001-11053": "Asset is already migration, migrateCertificateId {migrateCertificateId}", "001-11054": "{prop} in {target} not exist or expired", "001-11055": "Transaction with signature {signature} is not an expected related transaction", "001-11056": "Can not secondary transaction, reason {reason}", "001-11057": "The register generator quota is full in round {round}", "001-11058": "Generator can not migrate asset", "001-11059": "You can only migrate main asset, {assetType} is not main asset {mainAsset}", "001-11060": "Can not carry second publicKey", "001-11061": "Can not carry second signature", "001-11063": "Account possess frozen asset", "001-11064": "Need emigrate total asset, address {address}", "001-11065": "Account possess asset expect chain asset", "001-11066": "Account possess frozen asset expect chain asset", "001-11067": "Account with address {address} can not be frozen, reason {reason}, errorId {errorId}", "001-11068": "You can only trust main asset, {assetType} is not main asset {mainAsset}", "001-11070": "Issue entity times use up, entityFactory {entityFactory}", "001-11071": "Asset already exist, magic {magic} assetType {assetType}", "001-11072": "Frozen asset with frozenAddress {frozenAddress} signature {signature} assetType {assetType} in blockChain not exist or expired", "001-11073": "Not enough issue entity times, entityFactory {entityFactory}", "001-11074": "Promise is not begin to resolve yet, promiseId {promiseId}", "001-11075": "Certificate is not exist, certificateId {certificateId}", "001-11076": "Certificate is already exist, certificateId {certificateId}, errorId {errorId}", "001-11077": "Can not destroy certificate, certificateId {certificateId}, reason {reason}", "001-11078": "Account with address {address} not certificate {certificateId} possessor, errorId {errorId}", "001-11079": "Certificate not frozen, certificateId {certificateId}", "001-11080": "Certificate already frozen, certificateId {certificateId}", "001-11081": "Certificate already destroy, certificateId {certificateId}", "001-12001": "Block signSignature is required, signature {signature} generatorAddress {generatorAddress} height {height}", "001-12002": "Block generator second secret have already change, signature {signature} generatorAddress {generatorAddress} height {height}", "001-12003": "Block should not have generatorSecondPublicKey, signature {signature} generatorAddress {generatorAddress} height {height}", "001-12004": "Block should not have signSignature, signature {signature} generatorAddress {generatorAddress} height {height}", "001-12005": "{variable} out of range", "001-12006": "Failed to find nearest same block in one round, should not happen", "001-12007": "GenesisBlock not match, the signature of genesisBlock and synchronized peer's genesisBlock's signature not equal", "000-12008": "Falied to get blocks by range({minHeight}~{maxHeight})", "001-22001": "Invalid params: {params}", "001-22002": "Invalid params field: {field}", "001-22003": "GenesisBlock maybe no equal", "001-22004": "Invalid QueryBlockArg query params, no query conditions", "001-22005": "QueryBlock ({query}) from peer({peerId}) timeout", "001-22006": "ReqId reuse", "001-22007": "ChainChannel closed", "001-22008": "Refuse response query transaction", "001-22009": "Refuse response index transaction", "001-22010": "Refuse response download transaction", "001-22011": "Refuse response broadcast transaction", "001-22012": "Refuse response query block", "001-22013": "Refuse response broadcast block", "001-22014": "Message type error", "001-22015": "OnMessage get invalid req_id: {req_id}", "001-22016": "Request limit", "001-22017": "Invalid message cmd", "001-22018": "ChainChannel Timeout, cmd {cmd}", "001-22019": "Task {task_id} abort because the free chainChannel size is zero", "001-22020": "Refuse response open blob", "001-22021": "Refuse response read blob", "001-22022": "Refuse response close blob", "001-23001": "blob({hash}) algorithm({algorithm}) is invalid", "001-23002": "Fail to download blob({hash}) size({size})" };
    const mI = { "001-00001": "\u53C2\u6570 {param} \u4E22\u5931", "001-00002": "{target} \u7684 {prop} \u662F\u5FC5\u987B\u7684", "001-00003": "{target} \u7684 {prop} \u4E0D\u5408\u6CD5", "001-00004": "{to_target} \u7684 {to_compare_prop} \u548C {be_target} \u7684 {be_compare_prop} \u4E0D\u5339\u914D", "001-00005": "{target} \u7684 {prop} \u5FC5\u987B\u5927\u4E8E {field}", "001-00006": "{target} \u7684 {prop} \u5FC5\u987B\u5927\u4E8E\u6216\u7B49\u4E8E {field}", "001-00007": "{target} \u7684 {prop} \u5FC5\u987B\u5C0F\u4E8E {field}", "001-00008": "{target} \u7684 {prop} \u5FC5\u987B\u5C0F\u4E8E\u6216\u7B49\u4E8E {field}", "001-00009": "{target} \u7684 {prop} \u5FC5\u987B\u7B49\u4E8E {field}", "001-00010": "{to_target} \u7684 {to_compare_prop} \u5FC5\u987B\u662F {be_compare_prop}", "001-00011": "{to_target} \u7684 {to_compare_prop} \u4E0D\u80FD\u662F {be_compare_prop}", "001-00012": "{target} \u7684 {prop} \u4E0D\u5B58\u5728", "001-00013": "{target} \u7684 {prop} \u4E0D\u5E94\u8BE5\u5B58\u5728", "001-00014": "\u4E8B\u4EF6\u7684\u624B\u7EED\u8D39\u4E0D\u8DB3\uFF0C\u9519\u8BEF id {errorId}\uFF0C\u6700\u5C0F\u9700\u8981\u7684\u624B\u7EED\u8D39 {minFee}", "001-00015": "{target} \u7684 {prop} \u4E0D\u5728 [{min}, {max}] \u8303\u56F4", "001-00016": "{target} \u7684 {prop} \u8D85\u51FA\u957F\u5EA6\u9650\u5236\uFF0C\u6700\u5927\u957F\u5EA6 {limit}", "001-00017": "{target} \u7684 {prop} \u4E0D\u80FD\u7528 {field} \u5F00\u5934\u6216\u7ED3\u5C3E", "001-00018": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5B57\u7B26\u4E32\uFF0C\u8F93\u5165\u503C {value}", "001-00019": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684 ip, \u8F93\u5165\u503C {value}", "001-00020": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684 ipv4, \u8F93\u5165\u503C {value}", "001-00021": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684 ipv6, \u8F93\u5165\u503C {value}", "001-00022": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684\u7ECF\u7EAC\u5EA6, \u8F93\u5165\u503C {value}", "001-00023": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684\u7ECF\u5EA6, \u8F93\u5165\u503C {value}", "001-00024": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684\u7EAC\u5EA6, \u8F93\u5165\u503C {value}", "001-00025": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684\u8D26\u6237\u5730\u5740, \u8F93\u5165\u503C {value}", "001-00026": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684\u4F4D\u540D, \u8F93\u5165\u503C {value}", "001-00027": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684 dns, \u8F93\u5165\u503C {value}", "001-00028": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684 email, \u8F93\u5165\u503C {value}", "001-00029": "{target} \u7684 {prop} \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684 url, \u8F93\u5165\u503C {value}", "001-00030": "\u6CA1\u6709\u505A {operationName} \u7684\u6743\u9650", "001-00031": "{target} \u7684 {prop} \u4E0D\u80FD\u5305\u542B {value}", "001-00032": "{target} \u7684 {prop} \u5FC5\u987B\u5305\u542B {value}", "001-00033": "{target} \u7684 {prop} \u4E0D\u80FD\u91CD\u590D", "001-00034": "{target} \u7684 {prop} \u5DF2\u7ECF\u5B58\u5728\uFF0C\u9519\u8BEF id {errorId}", "001-00035": "\u521B\u4E16\u53D7\u6258\u4EBA\u4E0D\u8DB3\uFF0C\u6700\u5C11\u9700\u8981 {expected}\uFF0C\u5B9E\u9645\u53EA\u6709 {actual}", "001-00036": "{target} \u7684 {prop} \u5FC5\u987B\u662F\u4E00\u4E2A\u5B57\u7B26\u4E32", "001-00037": "\u533A\u5757\u953B\u9020\u8005\u4E0D\u5408\u6CD5\uFF0C\u539F\u56E0 {reason}", "001-00038": "\u4E8B\u4EF6\u7684\u5DE5\u4F5C\u91CF\u9A8C\u8BC1\u5931\u8D25", "001-00039": "{prop} \u672A\u627E\u5230", "001-00040": "{prop} \u592A\u5927\u4E86\uFF0C\u539F\u56E0 {reason}\uFF0C\u9519\u8BEF id {errorId}", "001-00041": "{target} \u7684 {prop} \u7684\u957F\u5EA6\u5FC5\u987B\u5C0F\u4E8E {field}", "001-00042": "{target} \u7684 {prop} \u7684\u957F\u5EA6\u5FC5\u987B\u5C0F\u4E8E\u6216\u7B49\u4E8E {field}", "001-00043": "{target} \u7684 {prop} \u7684\u957F\u5EA6\u5FC5\u987B\u5927\u4E8E {field}", "001-00044": "{target} \u7684 {prop} \u7684\u957F\u5EA6\u5FC5\u987B\u5927\u4E8E\u6216\u7B49\u4E8E {field}", "001-00045": "{target} \u7684 {prop} \u7684\u957F\u5EA6\u5FC5\u987B\u7B49\u4E8E {field}", "001-00046": "{target} \u7684 {prop} \u7684\u957F\u5EA6\u4E0D\u80FD\u7B49\u4E8E {field}", "001-00047": "\u4E8B\u4EF6\u7684\u57FA\u7840\u7C7B\u578B\u4E0D\u5408\u6CD5\uFF1A{base_type}", "001-00048": "\u533A\u5757\u7684\u6784\u9020\u51FD\u6570\u4E0D\u5408\u6CD5\uFF1A{name}", "001-00049": "\u533A\u5757\u7684\u7C7B\u578B\u4E0D\u5408\u6CD5\uFF1A{type}", "001-00050": "\u81EA\u5B9A\u4E49\u4E8B\u4EF6\u68C0\u9A8C\u5931\u8D25\uFF1A{message}", "001-00051": "\u7981\u6B62\u521B\u5EFA\u4E8B\u4EF6 {trsName}", "001-00052": "\u7981\u6B62\u63D2\u5165\u4E8B\u4EF6 {trsName}", "001-00053": "\u4E8B\u4EF6\u5904\u4E8E\u4E0D\u53EF\u53D8\u72B6\u6001", "001-00054": "\u8D44\u4EA7\u7EDF\u8BA1\u7D22\u5F15\uFF1A{index} \u5DF2\u7ECF\u88AB\u4F7F\u7528", "001-00055": "\u4E0D\u5408\u6CD5\u7684 {taskLabel} signature", "001-00056": "\u4E0D\u5408\u6CD5\u7684 {taskLabel} signSignature", "001-00057": "\u4E0D\u5408\u6CD5\u7684 base type {base_type}", "001-00058": "\u672A\u6CE8\u518C\u7684\u4E8B\u4EF6 factory {factoryName}", "001-00059": "\u672A\u6CE8\u518C\u7684\u4E8B\u4EF6 base type {trs_base}", "001-00060": "\u672A\u6CE8\u518C\u7684\u4E8B\u4EF6 type {trs_key}", "001-00061": "\u4E0D\u5408\u6CD5\u7684 {taskLabel} fromAuthSignature", "001-00062": "\u4E0D\u5408\u6CD5\u7684 {taskLabel} fromAuthSignSignature", "001-00063": "\u4E0D\u5408\u6CD5\u7684 {taskLabel} toAuthSignature", "001-00064": "\u4E0D\u5408\u6CD5\u7684 {taskLabel} toAuthSignSignature", "001-00065": "\u4E0D\u5408\u6CD5\u7684\u5B8F\u8F93\u5165\u7C7B\u578B: {type}", "001-00066": "{target} \u7684 {prop} \u5DF2\u7ECF\u8FC7\u671F", "001-11001": "{target} \u7684 {prop} \u4E22\u5931", "001-11002": "\u8D26\u6237 {address} \u5DF2\u7ECF\u51BB\u7ED3\uFF0C\u72B6\u6001 {status}\uFF0C\u9519\u8BEF id {errorId}", "001-11003": "\u4E8B\u4EF6\u7684\u5B89\u5168\u7B7E\u540D\u662F\u5FC5\u987B\u7684\uFF0C\u4E8B\u4EF6\u7B7E\u540D {signature} \u4E8B\u4EF6\u53D1\u8D77\u8D26\u6237\u5730\u5740 {senderId} \u4E8B\u4EF6\u53D1\u8D77\u9AD8\u5EA6 {applyBlockHeight} \u4E8B\u4EF6\u7C7B\u578B {type}", "001-11004": "\u4E8B\u4EF6\u7684\u53D1\u8D77\u8D26\u6237\u5B89\u5168\u5BC6\u94A5\u5DF2\u7ECF\u6539\u53D8\uFF0C\u4E8B\u4EF6\u7B7E\u540D {signature} \u4E8B\u4EF6\u53D1\u8D77\u8D26\u6237\u5730\u5740 {senderId} \u4E8B\u4EF6\u53D1\u8D77\u9AD8\u5EA6 {applyBlockHeight} \u4E8B\u4EF6\u7C7B\u578B {type}", "001-11005": "\u4E8B\u4EF6\u4E0D\u5E94\u8BE5\u643A\u5E26\u53D1\u8D77\u8D26\u6237\u7684\u5B89\u5168\u516C\u94A5\uFF0C\u4E8B\u4EF6\u7B7E\u540D {signature} \u4E8B\u4EF6\u53D1\u8D77\u8D26\u6237\u5730\u5740 {senderId} \u4E8B\u4EF6\u53D1\u8D77\u9AD8\u5EA6 {applyBlockHeight} \u4E8B\u4EF6\u7C7B\u578B {type}", "001-11006": "\u4EF6\u4E0D\u5E94\u8BE5\u643A\u5E26\u5B89\u5168\u7B7E\u540D\uFF0C\u4E8B\u4EF6\u7B7E\u540D {signature} \u4E8B\u4EF6\u53D1\u8D77\u8D26\u6237\u5730\u5740 {senderId} \u4E8B\u4EF6\u53D1\u8D77\u9AD8\u5EA6 {applyBlockHeight} \u4E8B\u4EF6\u7C7B\u578B {type}", "001-11007": "\u4E8B\u4EF6\uFF08{signature}\uFF09\u7684\u53D1\u8D77\u9AD8\u5EA6\u4E0D\u5408\u6CD5\uFF0C\u539F\u56E0 {reason}", "001-11008": "\u4E8B\u4EF6\uFF08{signature}\uFF09\u7684\u6709\u6548\u9AD8\u5EA6\u4E0D\u5408\u6CD5\uFF0C\u539F\u56E0 {reason}", "001-11009": "\u4E8B\u4EF6\u7684\u6765\u6E90\u94FE\u7684\u7F51\u7EDC\u6807\u8BC6\u7B26\u4E0D\u5408\u6CD5\uFF0C\u539F\u56E0 {reason}\uFF0C\u4E8B\u4EF6\u7B7E\u540D {signature} \u4E8B\u4EF6\u53D1\u8D77\u8D26\u6237\u5730\u5740 {senderId} \u4E8B\u4EF6\u53D1\u8D77\u9AD8\u5EA6 {applyBlockHeight} \u4E8B\u4EF6\u7C7B\u578B {type}", "001-11010": "\u4E8B\u4EF6\u7684\u53BB\u5F80\u94FE\u7684\u7F51\u7EDC\u6807\u8BC6\u7B26\u4E0D\u5408\u6CD5\uFF0C\u539F\u56E0 {reason}\uFF0C\u4E8B\u4EF6\u7B7E\u540D {signature} \u4E8B\u4EF6\u53D1\u8D77\u8D26\u6237\u5730\u5740 {senderId} \u4E8B\u4EF6\u53D1\u8D77\u9AD8\u5EA6 {applyBlockHeight} \u4E8B\u4EF6\u7C7B\u578B {type}", "001-11011": "\u4E8B\u4EF6\u7684\u65F6\u95F4\u6233\u4E0D\u5408\u6CD5\uFF0C\u539F\u56E0 {reason}\uFF0C\u4E8B\u4EF6\u7B7E\u540D {signature} \u4E8B\u4EF6\u53D1\u8D77\u8D26\u6237\u5730\u5740 {senderId} \u4E8B\u4EF6\u53D1\u8D77\u9AD8\u5EA6 {applyBlockHeight} \u4E8B\u4EF6\u7C7B\u578B {type}", "001-11012": "DAppid \u4E0D\u5B58\u5728\uFF0Cdappid {dappid}", "001-11013": "DAppid \u5DF2\u7ECF\u5B58\u5728, dappid {dappid}\uFF0C\u9519\u8BEF id {errorId}", "001-11014": "\u4F4D\u540D\u4E0D\u5B58\u5728, \u4F4D\u540D {locationName}\uFF0C\u9519\u8BEF id {errorId}", "001-11015": "\u4F4D\u540D\u5DF2\u7ECF\u5B58\u5728\uFF0C\u4F4D\u540D {locationName}\uFF0C\u9519\u8BEF id {errorId}", "001-11016": "Entity factory \u4E0D\u5B58\u5728, factoryId {factoryId}", "001-11017": "Entity factory \u5DF2\u7ECF\u5B58\u5728, factoryId {factoryId}\uFF0C\u9519\u8BEF id {errorId}", "001-11018": "Entity \u4E0D\u5B58\u5728, entityId {entityId}", "001-11019": "Entity \u5DF2\u7ECF\u5B58\u5728, entityId {entityId}\uFF0C\u9519\u8BEF id {errorId}", "001-11020": "\u672A\u77E5\u7684 rangeType\uFF0CrangeType {rangeType}", "001-11021": "\u4E8B\u4EF6\u7684\u5B57\u8282\u6570\u4E0D\u5408\u6CD5\uFF0C\u539F\u56E0 {reason}", "001-11022": "\u5728\u4F7F\u7528 dappid \u4E4B\u524D\u5FC5\u987B\u5148\u8D2D\u4E70\uFF0Cdappid {dappid}", "001-11023": "\u5728\u4F7F\u7528 dappid \u4E4B\u524D\u5FC5\u987B\u5148\u7ED9 dappid \u7684\u62E5\u6709\u8005\u6295\u7968\uFF0Cdappid {dappid}\uFF0C\u9519\u8BEF id {errorId}", "001-11024": "\u4E8B\u4EF6\u7684\u5DE5\u4F5C\u91CF\u9A8C\u8BC1\u9519\u8BEF\uFF0C\u9519\u8BEF id {errorId\uFF0C\u539F\u56E0 {reason}", "001-11025": "\u4E0D\u80FD\u9500\u6BC1\u4F4D\u540D {locationName}\uFF0C\u539F\u56E0 {reason}", "001-11026": "\u8BBE\u7F6E\u4F4D\u540D {locationName} \u7684\u7BA1\u7406\u5458\u5931\u8D25\uFF0C\u539F\u56E0 {reason}\uFF0C\u9519\u8BEF id {errorId}", "001-11027": "\u8BBE\u7F6E\u4F4D\u540D {locationName} \u7684\u89E3\u6790\u503C\u5931\u8D25\uFF0C\u539F\u56E0 {reason}\uFF0C\u9519\u8BEF id {errorId}", "001-11028": "\u6743\u76CA\u4E0D\u8DB3\uFF0C\u539F\u56E0 {reason}\uFF0C\u9519\u8BEF id {errorId}", "001-11029": "\u8D26\u6237\u5269\u4F59\u7684\u6295\u7968\u6743\u76CA\u4E0D\u8DB3\uFF0C\u539F\u56E0 {reason}\uFF0C\u9519\u8BEF id {errorId}", "001-11030": "\u51BB\u7ED3\u7684\u6743\u76CA\u5C1A\u672A\u5F00\u59CB\u89E3\u51BB\uFF0CfrozenId {frozenId}", "001-11031": "\u51BB\u7ED3\u7684\u6743\u76CA\u5DF2\u7ECF\u8FC7\u671F\uFF0CfrozenId {frozenId}", "001-11032": "\u8D60\u9001\u6743\u76CA\u7684\u88AB\u89E3\u51BB\u6B21\u6570\u5DF2\u7ECF\u7528\u5B8C\uFF0CfrozenId {frozenId}", "001-11033": "\u7528\u6237\u540D\u5DF2\u7ECF\u5B58\u5728\uFF0C\u9519\u8BEF id {errorId}", "001-11034": "\u8D26\u6237 {address} \u5DF2\u7ECF\u662F\u53D7\u6258\u4EBA\uFF0C\u9519\u8BEF id {errorId}", "001-11035": "\u8D26\u6237 {address} \u4E0D\u662F\u53D7\u6258\u4EBA\uFF0C\u9519\u8BEF id {errorId}", "001-11036": "\u53D7\u6258\u4EBA {address} \u5DF2\u7ECF\u5F00\u542F\u6536\u7968\uFF0C\u9519\u8BEF id {errorId}", "001-11037": "\u53D7\u6258\u4EBA {address} \u5DF2\u7ECF\u5173\u95ED\u6536\u7968\uFF0C\u9519\u8BEF id {errorId}", "001-11038": "{target} \u7684 {prop} \u88AB\u7981\u7528", "001-11039": "\u6743\u76CA\u4E0D\u5B58\u5728\uFF0C\u6240\u5C5E\u94FE\u7684\u7F51\u7EDC\u6807\u8BC6\u7B26 {magic} \u6743\u76CA\u540D {assetType}", "001-11040": "\u8D26\u6237 {address} \u4E0D\u662F dappid {dappid} \u7684\u62E5\u6709\u8005\uFF0C\u9519\u8BEF id {errorId}", "001-11041": "\u8D26\u6237 {address} \u4E0D\u662F locationName {locationName} \u7684\u62E5\u6709\u8005\uFF0C\u9519\u8BEF id {errorId}", "001-11042": "\u8D26\u6237 {address} \u4E0D\u662F entityId {entityId} \u7684\u62E5\u6709\u8005\uFF0C\u9519\u8BEF id {errorId}", "001-11043": "DAppid \u5C1A\u672A\u51BB\u7ED3\uFF0Cdappid {dappid}", "001-11044": "DAppid \u5DF2\u7ECF\u51BB\u7ED3\uFF0Cdappid {dappid}", "001-11045": "\u4F4D\u540D\u5C1A\u672A\u51BB\u7ED3\uFF0C\u4F4D\u540D {locationName}", "001-11046": "\u4F4D\u540D\u5DF2\u7ECF\u51BB\u7ED3\uFF0C\u4F4D\u540D {locationName}", "001-11047": "Entity \u5C1A\u672A\u51BB\u7ED3\uFF0CEntityId {entityId}", "001-11048": "Entity \u5DF2\u7ECF\u51BB\u7ED3\uFF0CentityId {entityId}", "001-11049": "\u4E0D\u9700\u8981\u8D2D\u4E70\u8D44\u4EA7\uFF0C\u8D44\u4EA7\u7C7B\u578B {type}\uFF0C\u8D44\u4EA7\u540D {asset}", "001-11050": "\u53EA\u6709\u9876\u7EA7\u4F4D\u540D\u53EF\u4EE5\u4EA4\u6362", "001-11051": "\u65E0\u6CD5\u9500\u6BC1 entityId {entityId}\uFF0C\u539F\u56E0 {reason}", "001-11052": "Entity \u5DF2\u7ECF\u9500\u6BC1 entityId {entityId}", "001-11053": "\u6743\u76CA\u5DF2\u7ECF\u8FC1\u79FB\uFF0C\u8FC1\u79FB\u51ED\u8BC1\u7684 id {migrateCertificateId}", "001-11054": "{target} \u7684 {prop} \u4E0D\u5B58\u5728\u6216\u5DF2\u7ECF\u8FC7\u671F", "001-11055": "\u4E8B\u4EF6 {signature} \u4E0D\u662F\u9884\u671F\u7684\u5173\u8054\u4E8B\u4EF6", "001-11056": "\u4E0D\u80FD\u4E8C\u6B21\u4F7F\u7528\u540C\u4E00\u7B14\u4E8B\u4EF6\uFF0C\u539F\u56E0 {reason}", "001-11057": "\u8F6E\u6B21 {round} \u7684\u6CE8\u518C\u53D7\u6258\u4EBA\u540D\u989D\u5DF2\u6EE1", "001-11058": "\u53D7\u6258\u4EBA\u4E0D\u80FD\u8FC1\u79FB\u6743\u76CA", "001-11059": "\u4F60\u53EA\u80FD\u8FC1\u79FB\u4E3B\u6743\u76CA\uFF0C{assetType} \u4E0D\u662F\u4E3B\u6743\u76CA {mainAsset}", "001-11060": "\u4E0D\u80FD\u643A\u5E26\u5B89\u5168\u516C\u94A5", "001-11061": "\u4E0D\u80FD\u643A\u5E26\u5B89\u5168\u7B7E\u540D", "001-11062": "\u8D26\u6237\u8FD1\u671F\u53C2\u4E0E\u4E86\u6295\u7968", "001-11063": "\u8D26\u6237\u62E5\u6709\u51BB\u7ED3\u7684\u6743\u76CA", "001-11064": "\u9700\u8981\u8FC1\u51FA\u5168\u90E8\u6743\u76CA\uFF0C\u5730\u5740 {address}", "001-11065": "\u8D26\u6237\u6301\u6709\u9664\u4E3B\u6743\u76CA\u5916\u7684\u5176\u4ED6\u6743\u76CA", "001-11066": "\u8D26\u6237\u6301\u6709\u9664\u4E3B\u6743\u76CA\u5916\u7684\u5176\u4ED6\u6743\u76CA\u7684\u51BB\u7ED3\u6743\u76CA", "001-11067": "\u8D26\u6237 {address} \u4E0D\u80FD\u88AB\u51BB\u7ED3\uFF0C\u539F\u56E0 {reason}\uFF0C\u9519\u8BEF id {errorId}", "001-11068": "\u4F60\u53EA\u80FD\u89C1\u8BC1\u4E3B\u6743\u76CA\uFF0C{assetType} \u4E0D\u662F\u4E3B\u6743\u76CA {mainAsset}", "001-11069": "\u8D26\u6237\u5DF2\u7ECF\u8BBE\u7F6E\u4E86\u7528\u6237\u540D\uFF0C\u9519\u8BEF id {errorId}", "001-11070": "\u6A21\u677F\u53D1\u884C entity \u7684\u6B21\u6570\u7528\u5B8C\uFF0CentityFactory {entityFactory}", "001-11071": "\u6743\u76CA\u5DF2\u7ECF\u5B58\u5728\uFF0C\u6240\u5C5E\u94FE\u7684\u7F51\u7EDC\u6807\u8BC6\u7B26 {magic} \u6743\u76CA\u540D {assetType}", "001-11072": "\u94FE\u4E0A\u7684\u51BB\u7ED3\u8D44\u4EA7 frozenAddress {frozenAddress} signature {signature} assetType {assetType} \u4E0D\u5B58\u5728\u6216\u8005\u5DF2\u7ECF\u8FC7\u671F", "001-11073": "\u6A21\u677F\u6CA1\u6709\u8DB3\u591F\u7684\u53D1\u884C entity \u6B21\u6570\uFF0CentityFactory {entityFactory}", "001-11074": "\u627F\u8BFA\u5C1A\u672A\u5F00\u59CB\u5151\u73B0\uFF0CpromiseId {promiseId}", "001-11075": "\u51ED\u8BC1\u4E0D\u5B58\u5728\uFF0C certificateId {certificateId}", "001-11076": "\u51ED\u8BC1\u5DF2\u7ECF\u5B58\u5728\uFF0CcertificateId {certificateId}\uFF0C\u9519\u8BEF id {errorId}", "001-11077": "\u65E0\u6CD5\u9500\u6BC1\u51ED\u8BC1\uFF0CcertificateId {certificateId}\uFF0Creason {reason}", "001-11078": "\u8D26\u6237 address {address} \u4E0D\u662F\u51ED\u8BC1 {certificateId} \u7684\u62E5\u6709\u8005\uFF0C\u9519\u8BEF id {errorId}", "001-11079": "\u51ED\u8BC1\u5C1A\u672A\u88AB\u51BB\u7ED3\uFF0CcertificateId {certificateId}", "001-11080": "\u51ED\u8BC1\u5DF2\u7ECF\u88AB\u51BB\u7ED3\uFF0CcertificateId {certificateId}", "001-11081": "\u51ED\u8BC1\u5DF2\u7ECF\u88AB\u9500\u6BC1\uFF0CcertificateId {certificateId}", "001-12001": "\u533A\u5757\u7684\u5B89\u5168\u7B7E\u540D\u662F\u5FC5\u987B\u7684\uFF0C\u533A\u5757\u7B7E\u540D {signature} \u953B\u9020\u8005\u7684\u5730\u5740 {generatorAddress} \u533A\u5757\u9AD8\u5EA6 {height}", "001-12002": "\u533A\u5757\u953B\u9020\u8005\u7684\u5B89\u5168\u7B7E\u540D\u5DF2\u7ECF\u6539\u53D8\uFF0C\u533A\u5757\u7B7E\u540D {signature} \u953B\u9020\u8005\u7684\u5730\u5740 {generatorAddress} \u533A\u5757\u9AD8\u5EA6 {height}", "001-12003": "\u533A\u5757\u4E0D\u5E94\u8BE5\u643A\u5E26\u953B\u9020\u8005\u7684\u5B89\u5168\u516C\u94A5\uFF0C\u533A\u5757\u7B7E\u540D {signature} \u953B\u9020\u8005\u7684\u5730\u5740 {generatorAddress} \u533A\u5757\u9AD8\u5EA6 {height}", "001-12004": "\u533A\u5757\u4E0D\u5E94\u8BE5\u643A\u5E26\u5B89\u5168\u7B7E\u540D\uFF0C\u533A\u5757\u7B7E\u540D {signature} \u953B\u9020\u8005\u7684\u5730\u5740 {generatorAddress} \u533A\u5757\u9AD8\u5EA6 {height}", "001-12005": "{variable} \u8D85\u51FA\u8303\u56F4", "001-12006": "\u83B7\u53D6\u6700\u63A5\u8FD1\u7684\u76F8\u540C\u533A\u5757\u5931\u8D25\uFF0C\u4E0D\u5E94\u8BE5\u53D1\u751F", "001-12007": "\u521B\u4E16\u5757\u4E0D\u5339\u914D, \u521B\u4E16\u5757\u7684 signature \u548C\u88AB\u540C\u6B65\u8282\u70B9\u7684\u521B\u4E16\u5757\u7684 signature \u4E0D\u76F8\u7B49", "000-12008": "\u6839\u636E\u8303\u56F4\u83B7\u53D6\u533A\u5757\u5931\u8D25\uFF08{minHeigh\uFF08t}~{maxHeight}\uFF09", "001-22001": "\u53C2\u6570\u4E0D\u5408\u6CD5\uFF1A{params}", "001-22002": "\u53C2\u6570\u5B57\u6BB5\u4E0D\u5408\u6CD5\uFF1A{field}", "001-22003": "\u521B\u4E16\u5757\u6216\u8BB8\u4E0D\u76F8\u7B49", "001-22004": "\u4E0D\u5408\u6CD5\u7684 QueryBlockArg \u67E5\u8BE2\u53C2\u6570\uFF0C\u6CA1\u6709\u67E5\u8BE2\u6761\u4EF6", "001-22005": "\u4ECE\u8282\u70B9 \uFF08{peerId}\uFF09 \u67E5\u8BE2\u533A\u5757 \uFF08{query}\uFF09 \u8D85\u65F6", "001-22006": "ReqId \u91CD\u590D\u4F7F\u7528", "001-22007": "ChainChannel \u5DF2\u7ECF\u5173\u95ED", "001-22008": "\u62D2\u7EDD\u54CD\u5E94\u67E5\u8BE2\u4E8B\u4EF6", "001-22009": "\u62D2\u7EDD\u54CD\u5E94\u67E5\u8BE2\u4E8B\u4EF6\u7D22\u5F15", "001-22010": "\u62D2\u7EDD\u54CD\u5E94\u4E0B\u8F7D\u4E8B\u4EF6", "001-22011": "\u62D2\u7EDD\u54CD\u5E94\u5E7F\u64AD\u4E8B\u4EF6", "001-22012": "\u62D2\u7EDD\u54CD\u5E94\u67E5\u8BE2\u533A\u5757", "001-22013": "\u62D2\u7EDD\u54CD\u5E94\u5E7F\u64AD\u533A\u5757", "001-22014": "Message \u7C7B\u578B\u9519\u8BEF", "001-22015": "OnMessage \u83B7\u53D6\u5230\u4E0D\u5408\u6CD5\u7684 req_id\uFF1A{req_id}", "001-22016": "\u8BF7\u6C42\u9650\u5236", "001-22017": "\u4E0D\u5408\u6CD5\u7684 message cmd", "001-22018": "ChainChannel \u8D85\u65F6\uFF0Ccmd {cmd}", "001-22019": "Task {task_id} \u4E2D\u65AD\uFF0C\u56E0\u4E3A\u7A7A\u95F2 chainChannel \u6570\u4E3A 0", "001-22020": "\u62D2\u7EDD\u54CD\u5E94\u5F00\u542F blob", "001-22021": "\u62D2\u7EDD\u54CD\u5E94\u8BFB\u53D6 blob", "001-22022": "\u62D2\u7EDD\u54CD\u5E94\u5173\u95ED blob", "001-23001": "blob({hash}) \u7684 algorithm({algorithm}) \u4E0D\u5408\u6CD5", "001-23002": "\u4E0B\u8F7D blob({hash}) size({size}) \u5931\u8D25" };
    const ey = /* @__PURE__ */ new Map();
    ey.set("en_US.UTF-8", yI);
    ey.set("zh_CN.UTF-8", mI);
    const _I = ey;
    const c = { PARAM_LOST: new U("001-00001", "params {param} lost"), PROP_IS_REQUIRE: new U("001-00002", "{prop} in {target} is required"), PROP_IS_INVALID: new U("001-00003", "{prop} in {target} is invalid"), NOT_MATCH: new U("001-00004", "{to_compare_prop} in {to_target} and {be_compare_prop} in {be_target} not match"), PROP_SHOULD_GT_FIELD: new U("001-00005", "{prop} in {target} should greater than {field}"), PROP_SHOULD_GTE_FIELD: new U("001-00006", "{prop} in {target} should greater than or equals to {field}"), PROP_SHOULD_LT_FIELD: new U("001-00007", "{prop} in {target} should less than {field}"), PROP_SHOULD_LTE_FIELD: new U("001-00008", "{prop} in {target} should less than or equals to {field}"), PROP_SHOULD_EQ_FIELD: new U("001-00009", "{prop} in {target} should equals to {field}"), SHOULD_BE: new U("001-00010", "{to_compare_prop} in {to_target} should be {be_compare_prop}"), SHOULD_NOT_BE: new U("001-00011", "{to_compare_prop} in {to_target} should not be {be_compare_prop}"), NOT_EXIST: new U("001-00012", "{prop} in {target} not exist"), SHOULD_NOT_EXIST: new U("001-00013", "{prop} in {target} should not exist"), TRANSACTION_FEE_NOT_ENOUGH: new U("001-00014", "Transaction fee is not enough, errorId {errorId}, minFee {minFee}"), NOT_IN_EXPECTED_RANGE: new U("001-00015", "{prop} in {target} not in [{min}, {max}]"), OVER_LENGTH: new U("001-00016", "{prop} in {target} is over length {limit}"), SHOULD_NOT_START_WITH_OR_END_WITH: new U("001-00017", "{prop} in {target} should not start with or end with {field}"), NOT_A_STRING: new U("001-00018", "{prop} in {target} not a string, value {value}"), NOT_A_IP: new U("001-00019", "{prop} in {target} not a ip, value {value}"), NOT_A_IPV4: new U("001-00020", "{prop} in {target} not a ipv4, value {value}"), NOT_A_IPV6: new U("001-00021", "{prop} in {target} not a ipv6, value {value}"), NOT_A_LONGITUDE_LATITUDE: new U("001-00022", "{prop} in {target} not a longitude-latitude, value {value}"), NOT_A_LONGITUDE: new U("001-00023", "{prop} in {target} not a longitude, value {value}"), NOT_A_LATITUDE: new U("001-00024", "{prop} in {target} not a latitude, value {value}"), NOT_A_ADDRESS: new U("001-00025", "{prop} in {target} not a address, value {value}"), NOT_A_LOCATION_NAME: new U("001-00026", "{prop} in {target} not a locationName, value {value}"), NOT_A_DNS: new U("001-00027", "{prop} in {target} not a dns, value {value}"), NOT_A_EMAIL: new U("001-00028", "{prop} in {target} not a email, value {value}"), NOT_A_URL: new U("001-00029", "{prop} in {target} not a url, value {value}"), PERMISSION_DENIED: new U("001-00030", "Permission denied at operation {operationName}"), SHOULD_NOT_INCLUDE: new U("001-00031", "{prop} in {target} should not inclue {value}"), SHOULD_INCLUDE: new U("001-00032", "{prop} in {target} should inclue {value}"), SHOULD_NOT_DUPLICATE: new U("001-00033", "{prop} in {target} should not duplicate"), ALREADY_EXIST: new U("001-00034", "{prop} in {target} already exist, errorId {errorId}"), GENESIS_GENERATOR_NOT_ENOUGH: new U("001-00035", "Genesis generator not enough, at least {expected}, actual {actual}"), PROP_SHOULD_BE_ARRAY: new U("001-00036", "{prop} in {target} should be an array"), INVALID_BLOCK_GENERATOR: new U("001-00037", "Invalid block generator, reason {reason}"), NOT_FOUND: new U("001-00039", "{prop} not found"), TOO_LARGE: new U("001-00040", "{prop} is too large, reason {reason}, errorId {errorId}"), PROP_LENGTH_SHOULD_LT_FIELD: new U("001-00041", "{prop} length in {target} should less than {field}"), PROP_LENGTH_SHOULD_LTE_FIELD: new U("001-00042", "{prop} length in {target} should less than or equals to {field}"), PROP_LENGTH_SHOULD_GT_FIELD: new U("001-00043", "{prop} length in {target} should greater than {field}"), PROP_LENGTH_SHOULD_GTE_FIELD: new U("001-00044", "{prop} length in {target} should greater than or equals to {field}"), PROP_LENGTH_SHOULD_EQ_FIELD: new U("001-00045", "{prop} length in {target} should equals to {field}"), PROP_LENGTH_SHOULD_NOT_EQ_FIELD: new U("001-00046", "{prop} length in {target} should not equals to {field}"), INVALID_TRANSACTION_BASE_TYPE: new U("001-00047", "Invalid transaction base type: {base_type}"), INVALID_BLOCK_CONSTRUCTOR: new U("001-00048", "Invalid block constructor: {name}"), INVALID_BLOCK_TYPE: new U("001-00049", "Invalid block type: {type}"), CUSTOM_TRANS_VERIFY_FAIL: new U("001-00050", "Custom transaction verify fail: {message}"), DISABLED_CREATE_TRANSACTION: new U("001-00051", "Disabled create {trsName} Transaction"), DISABLED_INSERT_TRANSACTION: new U("001-00052", "Disabled insert {trsName} Transaction"), TRANSACTION_IS_IN_UNCHANGABLE_STATE: new U("001-00053", "Transaction is in unchangable state"), ASSETSTATISTIC_INDEX_ALREADY_IN_USE: new U("001-00054", "AssetStatistic index: {index} already in use"), INVALID_SIGNATURE: new U("001-00055", "Invalid {taskLabel} signature"), INVALID_SIGNSIGNATURE: new U("001-00056", "Invalid {taskLabel} signSignature"), INVALID_BASE_TYPE: new U("001-00057", "Invalid base type {base_type}"), UNREGISTERED_TRANSACTION_FACTORY: new U("001-00058", "Unregistered TransactionFactory {factoryName}"), UNREGISTERED_TRANSACTION_BASE_TYPE: new U("001-00059", "Unregistered Transaction base type {trs_base}"), UNREGISTERED_TRANSACTION_TYPE: new U("001-00060", "Unregistered Transaction type {trs_key}"), INVALID_FROMAUTHSIGNATURE: new U("001-00061", "Invalid {taskLabel} fromAuthSignature"), INVALID_FROMAUTHSIGNSIGNATURE: new U("001-00062", "Invalid {taskLabel} fromAuthSignSignature"), INVALID_TOAUTHSIGNATURE: new U("001-00063", "Invalid {taskLabel} toAuthSignature"), INVALID_TOAUTHSIGNSIGNATURE: new U("001-00064", "Invalid {taskLabel} toAuthSignSignature"), INVALID_MACRO_INPUT_TYPE: new U("001-00065", "Invalid macro input type: {type}"), ALREADY_EXPIRED: new U("001-00066", "{prop} in {target} already expired"), PROP_LOSE: new U("001-11001", "{prop} in {target} lose"), ACCOUNT_FROZEN: new U("001-11002", "Account with address {address} was frozen, status {status}, errorId {errorId}"), TRANSACTION_SIGN_SIGNATURE_IS_REQUIRED: new U("001-11003", "Transaction signSignature is required, signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}"), TRANSACTION_SENDER_SECOND_PUBLICKEY_ALREADY_CHANGE: new U("001-11004", "Transaction sender second secret have already change, signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}"), TRANSACTION_SHOULD_NOT_HAVE_SENDER_SECOND_PUBLICKEY: new U("001-11005", "Transaction should not have senderSecondPublicKey, signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}"), TRANSACTION_SHOULD_NOT_HAVE_SIGN_SIGNATURE: new U("001-11006", "Transaction should not have signSignature, signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}"), INVALID_TRANSACTION_APPLY_BLOCK_HEIGHT: new U("001-11007", "Invalid transaction({signature}) apply block height, reason {reason}"), INVALID_TRANSACTION_EFFECTIVE_BLOCK_HEIGHT: new U("001-11008", "Invalid transaction({signature}) effective block height, reason {reason}"), INVALID_TRANSACTION_FROM_MAGIC: new U("001-11009", "Invalid transaction from magic, reason {reason} signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}"), INVALID_TRANSACTION_TO_MAGIC: new U("001-11010", "Invalid transaction to magic, reason {reason} signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}"), INVALID_TRANSACTION_TIMESTAMP: new U("001-11011", "Invalid transaction timestamp, reason {reason} signature {signature} senderId {senderId} applyBlockHeight {applyBlockHeight} type {type}"), DAPPID_IS_NOT_EXIST: new U("001-11012", "DAppid is not exist, dappid {dappid}"), DAPPID_IS_ALREADY_EXIST: new U("001-11013", "DAppid is already exist, dappid {dappid}, errorId {errorId}"), LOCATION_NAME_IS_NOT_EXIST: new U("001-11014", "LocationName is not exist, locationName {locationName}, errorId {errorId}"), LOCATION_NAME_IS_ALREADY_EXIST: new U("001-11015", "LocationName is already exist, locationName {locationName}, errorId {errorId}"), ENTITY_FACTORY_IS_NOT_EXIST: new U("001-11016", "Entity factory is not exist, factoryId {factoryId}"), ENTITY_FACTORY_IS_ALREADY_EXIST: new U("001-11017", "Entity factory is already exist, factoryId {factoryId}, errorId {errorId}"), ENTITY_IS_NOT_EXIST: new U("001-11018", "Entity is not exist, entityId {entityId}"), ENTITY_IS_ALREADY_EXIST: new U("001-11019", "Entity is already exist, entityId {entityId}, errorId {errorId}"), UNKNOWN_RANGE_TYPE: new U("001-11020", "Unknow rangeType, rangeType {rangeType}"), INVALID_TRANSACTION_BYTE_LENGTH: new U("001-11021", "Invalid transaction byte length, reason {reason}"), NEED_PURCHASE_DAPPID_BEFORE_USE: new U("001-11022", "Need purchase dappid before use, dappid {dappid}"), CAN_NOT_DELETE_LOCATION_NAME: new U("001-11025", "Can not delete locationName {locationName}, reason {reason}"), SET_LOCATION_NAME_MANAGER_FIELD: new U("001-11026", "Set locationName {locationName} manager field, reason {reason}, errorId {errorId}"), SET_LOCATION_NAME_RECORD_VALUE_FIELD: new U("001-11027", "Set locationName {locationName} recordValue field, reason {reason}, errorId {errorId}"), ASSET_NOT_ENOUGH: new U("001-11028", "Asset not enough, reason {reason}, errorId {errorId}"), ACCOUNT_REMAIN_EQUITY_NOT_ENOUGH: new U("001-11029", "Account remain equity not enough, reason {reason}, errorId {errorId}"), NOT_BEGIN_UNFROZEN_YET: new U("001-11030", "Frozen asset is not begin to unfrozen yet, frozenId {frozenId}"), FROZEN_ASSET_EXPIRATION: new U("001-11031", "Frozen asset is already expiration, frozenId {frozenId}"), UNFROZEN_TIME_USE_UP: new U("001-11032", "Gift asset unfrozen time use up, frozenId {frozenId}"), FORBIDDEN: new U("001-11038", "{prop} in {target} is forbidden"), ASSET_NOT_EXIST: new U("001-11039", "Asset not exist, magic {magic} assetType {assetType}"), ACCOUNT_NOT_DAPPID_POSSESSOR: new U("001-11040", "Account with address {address} not dappid {dappid} possessor, errorId {errorId}"), ACCOUNT_NOT_LOCATION_NAME_POSSESSOR: new U("001-11041", "Account with address {address} not locationName {locationName} possessor, errorId {errorId}"), ACCOUNT_NOT_ENTITY_POSSESSOR: new U("001-11042", "Account with address {address} not entityId {entityId} possessor, errorId {errorId}"), DAPPID_NOT_FROZEN: new U("001-11043", "DAppid not frozen, dappid {dappid}"), DAPPID_ALREADY_FROZEN: new U("001-11044", "DAppid already frozen, dappid {dappid}"), LOCATION_NAME_NOT_FROZEN: new U("001-11045", "LocationName not frozen, locationName {locationName}"), LOCATION_NAME_ALREADY_FROZEN: new U("001-11046", "LocationName already frozen, locationName {locationName}"), ENTITY_NOT_FROZEN: new U("001-11047", "Entity not frozen, entityId {entityId}"), ENTITY_ALREADY_FROZEN: new U("001-11048", "Entity already frozen, entityId {entityId}"), NO_NEED_TO_PURCHASE_SPECIAL_ASSET: new U("001-11049", "No need to purchase asset, type {type} asset {asset}"), ONLY_TOP_LEVEL_LOCATION_NAME_CAN_EXCHANGE: new U("001-11050", "Only top level location name can exchange"), CAN_NOT_DESTROY_ENTITY: new U("001-11051", "Can not destroy entityId {entityId}, reason {reason}"), ENTITY_ALREADY_DESTROY: new U("001-11052", "Entity already destroy, entityId {entityId}"), ASSET_IS_ALREADY_MIGRATION: new U("001-11053", "Asset is already migration, migrateCertificateId {migrateCertificateId}"), NOT_EXIST_OR_EXPIRED: new U("001-11054", "{prop} in {target} not exist or expired"), NOT_EXPECTED_RELATED_TRANSACTION: new U("001-11055", "Transaction with signature {signature} is not an expected related transaction"), CAN_NOT_SECONDARY_TRANSACTION: new U("001-11056", "Can not secondary transaction, reason {reason}"), REGISTER_GENERATOR_QUOTA_FULL: new U("001-11057", "The register generator quota is full in round {round}"), GENERATOR_CAN_NOT_MIGRATE_ASSET: new U("001-11058", "Generator can not migrate asset"), MIGRATE_MAIN_ASSET_ONLY: new U("001-11059", "You can only migrate main asset, {assetType} is not main asset {mainAsset}"), CAN_NOT_CARRY_SECOND_PUBLICKEY: new U("001-11060", "Can not carry second publicKey"), CAN_NOT_CARRY_SECOND_SIGNATURE: new U("001-11061", "Can not carry second signature"), POSSESS_FROZEN_ASSET: new U("001-11063", "Account possess frozen asset"), NEED_EMIGRATE_TOTAL_ASSET: new U("001-11064", "Need emigrate total asset, address {address}"), POSSESS_ASSET_EXCEPT_CHAIN_ASSET: new U("001-11065", "Account possess asset expect chain asset"), POSSESS_FROZEN_ASSET_EXCEPT_CHAIN_ASSET: new U("001-11066", "Account possess frozen asset expect chain asset"), ACCOUNT_CAN_NOT_BE_FROZEN: new U("001-11067", "Account with address {address} can not be frozen, reason {reason}, errorId {errorId}"), TRUST_MAIN_ASSET_ONLY: new U("001-11068", "You can only trust main asset, {assetType} is not main asset {mainAsset}"), ISSUE_ENTITY_TIMES_USE_UP: new U("001-11070", "Issue entity times use up, entityFactory {entityFactory}"), ASSET_ALREADY_EXIST: new U("001-11071", "Asset already exist, magic {magic} assetType {assetType}"), FROZEN_ASSET_NOT_EXIST_OR_EXPIRED: new U("001-11072", "Frozen asset with frozenAddress {frozenAddress} signature {signature} assetType {assetType} in blockChain not exist or expired"), NOT_ENOUGH_ISSUE_ENTITY_TIMES: new U("001-11073", "Not enough issue entity times, entityFactory {entityFactory}"), NOT_BEGIN_RESOLVE_YET: new U("001-11074", "Promise is not begin to resolve yet, promiseId {promiseId}"), CERTIFICATE_IS_NOT_EXIST: new U("001-11075", "Certificate is not exist, certificateId {certificateId}"), CERTIFICATE_IS_ALREADY_EXIST: new U("001-11076", "Certificate is already exist, certificateId {certificateId}, errorId {errorId}"), CAN_NOT_DESTROY_CERTIFICATE: new U("001-11077", "Can not destroy certificate, certificateId {certificateId}, reason {reason}"), ACCOUNT_NOT_CERTIFICATE_POSSESSOR: new U("001-11078", "Account with address {address} not certificate {certificateId} possessor, errorId {errorId}"), CERTIFICATE_NOT_FROZEN: new U("001-11079", "Certificate not frozen, certificateId {certificateId}"), CERTIFICATE_ALREADY_FROZEN: new U("001-11080", "Certificate already frozen, certificateId {certificateId}"), CERTIFICATE_ALREADY_DESTROY: new U("001-11081", "Certificate already destroy, certificateId {certificateId}"), FROZEN_ASSET_NOT_ENOUGH: new U("001-11082", "Frozen asset not enough, frozenId {frozenId}, reason {reason}"), STAKE_ASSET_NOT_EXIST_OR_EXPIRED: new U("001-11083", "Stake asset with stakeAddress {stakeAddress} stakeId {stakeId} in blockChain not exist or expired"), NOT_BEGIN_UNSTAKE_YET: new U("001-11084", "Stake asset is not begin to unstake yet, stakeId {stakeId}"), STAKE_ASSET_NOT_ENOUGH: new U("001-11085", "Stake asset not enough, stakeId {stakeId}, reason {reason}"), BLOCK_SIGN_SIGNATURE_IS_REQUIRED: new U("001-12001", "Block signSignature is required, signature {signature} generatorAddress {generatorAddress} height {height}"), BLOCK_GENERATOR_SECOND_PUBLICKEY_ALREADY_CHANGE: new U("001-12002", "Block generator second secret have already change, signature {signature} generatorAddress {generatorAddress} height {height}"), BLOCK_SHOULD_NOT_HAVE_GENERATOR_SECOND_PUBLICKEY: new U("001-12003", "Block should not have generatorSecondPublicKey, signature {signature} generatorAddress {generatorAddress} height {height}"), BLOCK_SHOULD_NOT_HAVE_SIGN_SIGNATURE: new U("001-12004", "Block should not have signSignature, signature {signature} generatorAddress {generatorAddress} height {height}"), OUT_OF_RANGE: new U("001-12005", "{variable} out of range"), FAILED_TO_FIND_NEAREST_SAME_BLOCK_IN_ONE_ROUND: new U("001-12006", "Failed to find nearest same block in one round, should not happen"), GENESIS_BLOCK_NOT_MATCH: new U("001-12007", "GenesisBlock not match, the signature of genesisBlock and synchronized peer's genesisBlock's signature not equal"), FAILED_TO_GET_BLOCKS_BY_RANGE: new U("000-12008", "Falied to get blocks by range({minHeight}~{maxHeight})"), INVALID_PARAMS: new U("001-22001", "Invalid params: {params}"), INVALID_PARAMS_FIELD: new U("001-22002", "Invalid params field: {field}"), GENESIS_BLOCK_MAYBE_NO_EQUAL: new U("001-22003", "GenesisBlock maybe no equal"), INVALID_QUERYBLOCKARG_QUERY_PARAMS: new U("001-22004", "Invalid QueryBlockArg query params, no query conditions"), QUERY_BLOCK_FROM_PEER_TIMEOUT: new U("001-22005", "QueryBlock ({query}) from peer({peerId}) timeout"), REQID_REUSE: new U("001-22006", "ReqId reuse"), CHAINCHANNEL_CLOSED: new U("001-22007", "chainChannel closed"), REFUSE_RESPONSE_QUERY_TRANSACTION: new U("001-22008", "Refuse response query transaction"), REFUSE_RESPONSE_INDEX_TRANSACTION: new U("001-22009", "Refuse response index transaction"), REFUSE_RESPONSE_DOWNLOAD_TRANSACTION: new U("001-22010", "Refuse response download transaction"), REFUSE_RESPONSE_BROADCAST_TRANSACTION: new U("001-22011", "Refuse response broadcast transaction"), REFUSE_RESPONSE_QUERY_BLOCK: new U("001-22012", "Refuse response query block"), REFUSE_RESPONSE_BROADCAST_BLOCK: new U("001-22013", "Refuse response broadcast block"), MESSAGE_TYPE_ERROR: new U("001-22014", "Message type error"), ONMESSAGE_GET_INVALID_REQ_ID: new U("001-22015", "OnMessage get invalid req_id: {req_id}"), REQUEST_LIMIT: new U("001-22016", "Request limit"), INVALID_MESSAGE_CMD: new U("001-22017", "Invalid message cmd"), CHAINCHANNEL_TIMEOUT: new U("001-22018", "ChainChannel Timeout, cmd {cmd}"), TASK_ABORT: new U("001-22019", "Task {task_id} abort because the free chainChannel size is zero"), REFUSE_RESPONSE_OPEN_BLOB: new U("001-22020", "Refuse response open blob"), REFUSE_RESPONSE_READ_BLOB: new U("001-22021", "Refuse response read blob"), REFUSE_RESPONSE_CLOSE_BLOB: new U("001-22022", "Refuse response close blob"), BLOB_ALGORITHM_IS_INVALID: new U("001-23001", "blob({hash}) algorithm({algorithm}) is invalid"), FAIL_TO_DOWNLOAD_BLOB: new U("001-23002", "Fail to download blob({hash}) size({size})") };
    const AI = /* @__PURE__ */ new Map();
    const xl = Error.captureStackTrace ? (i) => {
      const e = { stack: "" };
      return Error.captureStackTrace(e, i), e.stack;
    } : Function("f", `
    let deep = 0;
    let caller = arguments.callee;
    do {
      if (caller.caller === f) {
        break;
      }
      deep += 1;
      caller = caller.caller;
      if (caller === null) {
        break;
      }
    } while (true);
    const stack = new Error().stack || "";
    const stackLineLine = stack.split('\\n');
    stackLineLine.splice(1, deep);
    return stackLineLine.join('\\n');
  `);
    const du = class _du extends Error {
      get name() {
        return this.constructor.name;
      }
      static call(e, t) {
        if (!(e instanceof _du)) throw new TypeError("please use new keyword to create CustomError instance.");
        return e.stack = xl(e.constructor), e.message = t || "", e;
      }
    };
    const Ju = () => {
    };
    const Am = /* @__PURE__ */ Symbol("cog");
    function hA(i) {
      for (const [e, t] of Object.entries(Object.getOwnPropertyDescriptors(i))) {
        const r = t.get;
        r && !r[Am] && (t.get = () => {
          const n = r();
          return Object.defineProperty(i, e, { value: n }), n;
        }, t.get[Am] = true, Object.defineProperty(i, e, t));
      }
      return i;
    }
    const uA = /* @__PURE__ */ new Map();
    const EI = ((i) => (i.BLOCKER = "blocker", i.CRITICAL = "critical", i.MAJOR = "major", i.MINOR = "minor", i))(EI || {});
    const qe = class extends du {
      constructor(e = "", t, r, n) {
        super(t ? e instanceof U ? e.build(t) : e.replace(/\{([^\\]+?)\}/g, (a, p) => t[p] ?? a) : e instanceof U ? e.message : e), this.detail = t;
        const s = this.constructor, { ERROR_CODE_MAP: o } = s;
        Object.defineProperties(this, { detail: { value: t, enumerable: false, writable: false }, sourceMessage: { value: e, enumerable: false, writable: false }, type: { value: s.TYPE, enumerable: false, writable: false }, PLATFORM: { value: s.PLATFORM, enumerable: false, writable: false }, CHANNEL: { value: s.CHANNEL, enumerable: false, writable: false }, BUSINESS: { value: s.BUSINESS, enumerable: false, writable: false }, MODULE: { value: s.MODULE, enumerable: false, writable: false }, FILE: { value: s.FILE, enumerable: false, writable: false }, CODE: { value: r ?? (e instanceof U ? e.code : o.get(e) || o.get("unknown error") || ""), enumerable: false, writable: false }, SEVERIFY: { value: n || "major", enumerable: false, writable: false } });
      }
      get name() {
        return this.constructor.TYPE;
      }
      static is(e) {
        return !(!e || e.type !== this.TYPE);
      }
    };
    function II(i, e, t, r, n, s) {
      function o(a) {
        return a.PLATFORM = i, a.CHANNEL = e, a.BUSINESS = t, a.MODULE = r, a.FILE = n, a.ERROR_CODE_MAP = s, Object.freeze(a), a;
      }
      return hA({ getException: o, get Exception() {
        const a = qe;
        return o(class extends a {
        });
      }, get OutOfRangeException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "OutOfRangeException", a));
      }, get ArgumentException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "ArgumentException", a));
      }, get ArgumentIllegalException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "ArgumentIllegalException", a));
      }, get ArgumentFormatException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "ArgumentFormatException", a));
      }, get NoFoundException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "NoFoundException", a));
      }, get ResponseException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "ResponseException", a));
      }, get IOException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "IOException", a));
      }, get NetworkIOException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "NetworkIOException", a));
      }, get BusyIOException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "BusyIOException", a));
      }, get DatebaseIOException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "DatebaseIOException", a));
      }, get InterruptedException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "InterruptedException", a));
      }, get IllegalStateException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "IllegalStateException", a));
      }, get TimeOutException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "TimeOutException", a));
      }, get BusyException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "BusyException", a));
      }, get ConsensusException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "ConsensusException", a));
      }, get AbortException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "AbortException", a));
      }, get RefuseException() {
        let a;
        return o(((a = class extends qe {
        }).TYPE = "RefuseException", a));
      } });
    }
    qe.TYPE = "Exception", qe.PLATFORM = "", qe.CHANNEL = "", qe.BUSINESS = "", qe.MODULE = "", qe.FILE = "", qe.CODE = "", qe.SEVERIFY = "major", qe.ERROR_CODE_MAP = uA, typeof Error.stackTraceLimit === "number" && (Error.stackTraceLimit += 3);
    const ga = 1e3;
    const da = 60 * ga;
    const ya = 60 * da;
    const Qi = 24 * ya;
    const TI = 7 * Qi;
    const SI = 365.25 * Qi;
    function wI(i, e = {}) {
      switch (typeof i) {
        case "string":
          if (i.length > 0) return bI(i);
          break;
        case "number":
          if (isFinite(i)) return e.long ? xI(i) : NI(i);
      }
      throw new Error(`val is not a non-empty string or a valid number. val=${JSON.stringify(i)}`);
    }
    function bI(i) {
      const e = String(i);
      if (e.length > 100) return;
      const t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
      if (!t) return;
      const r = parseFloat(t[1]);
      switch ((t[2] || "ms").toLowerCase()) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return r * SI;
        case "weeks":
        case "week":
        case "w":
          return r * TI;
        case "days":
        case "day":
        case "d":
          return r * Qi;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return r * ya;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return r * da;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return r * ga;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return r;
        default:
          return;
      }
    }
    function NI(i) {
      const e = Math.abs(i);
      return e >= Qi ? `${Math.round(i / Qi)}d` : e >= ya ? `${Math.round(i / ya)}h` : e >= da ? `${Math.round(i / da)}m` : e >= ga ? `${Math.round(i / ga)}s` : `${i}ms`;
    }
    function xI(i) {
      const e = Math.abs(i);
      return e >= Qi ? Ul(i, e, Qi, "day") : e >= ya ? Ul(i, e, ya, "hour") : e >= da ? Ul(i, e, da, "minute") : e >= ga ? Ul(i, e, ga, "second") : `${i} ms`;
    }
    function Ul(i, e, t, r) {
      const n = e >= 1.5 * t;
      return `${Math.round(i / t)} ${r}${n ? "s" : ""}`;
    }
    let Em;
    let Im;
    let Tm;
    let Fr;
    function OI(i) {
      return i.source.slice(1, -1).replace(/\.\*\?$/, "*").replace(/\\/g, "");
    }
    function Sm(i) {
      const e = i[0] === "-";
      return { type: e ? "disable" : "enable", source: i, regexp: new RegExp("^" + i.substr(e ? 1 : 0).replace(/\*/g, ".*?") + "$") };
    }
    function CI(i) {
      return (i.type === "disable" ? "-" : "") + OI(i.regexp);
    }
    const RI = class {
      constructor() {
        this.namespaceFilters = [], this._levelFilter = (e) => true, this._createdDebugCache = new wt((e) => new Ec(e, this)), this.setNamespaceFilter(this.load());
      }
      getNamespaceFilter() {
        return this.namespaceFilters.map((e) => e.source);
      }
      _resetInstancesEnabled() {
        for (const e of this._createdDebugCache.values()) {
          e.forceSetEnabled(this.isEnabled(e.namespace, e.level));
          for (const t of e.scopePrinterMap.keys()) t.enabled = this.levelFilter(t.level);
        }
      }
      setNamespaceFilter(e) {
        e = typeof e === "string" ? e : e.join(","), this.namespaceFilters.length = 0;
        const t = [...new Set(e.split(/[\s,]+/))];
        for (const r of t) r && this.namespaceFilters.push(Sm(r));
        this._resetInstancesEnabled(), this.save(t.join(","));
      }
      addNamespaceFilter(e, t) {
        this.removeNamespaceFilter(e), e = typeof e === "string" ? Sm(e) : e, t === void 0 || t > this.namespaceFilters.length - 1 || t < 0 ? this.namespaceFilters.push(e) : this.namespaceFilters.splice(t, 0, e), this._resetInstancesEnabled(), this.save(this.getNamespaceFilter().join(","));
      }
      removeNamespaceFilter(e) {
        const t = (r) => r >= 0 && r < this.namespaceFilters.length && (this.namespaceFilters.splice(r, 1), this._resetInstancesEnabled(), this.save(this.getNamespaceFilter().join(",")), true);
        return typeof e === "number" ? t(e) : typeof e === "string" ? t(this.namespaceFilters.findIndex((r) => r.source === e)) : t(this.namespaceFilters.indexOf(e)) || this.removeNamespaceFilter(CI(e));
      }
      get levelFilter() {
        return this._levelFilter;
      }
      set levelFilter(e) {
        this._levelFilter = e, this._resetInstancesEnabled();
      }
      isEnabled(e, t) {
        if (!this.levelFilter(t)) return false;
        if (e[e.length - 1] === "*") return true;
        for (let r = this.namespaceFilters.length - 1; r >= 0; r--) {
          const n = this.namespaceFilters[r];
          if (n.regexp.test(e)) return n.type === "enable";
        }
        return false;
      }
      selectColor(e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) t = (t << 5) - t + e.charCodeAt(r), t |= 0;
        return this.colors[Math.abs(t) % this.colors.length];
      }
      getCreatedDebugs() {
        return this._createdDebugCache.values();
      }
      create(e) {
        return this._createdDebugCache.forceGet(e);
      }
      destroy(e) {
        return this._createdDebugCache.delete(e);
      }
    };
    const Ec = class {
      constructor(e, t, r) {
        this.namespace = e, this._creater = t, this.__prev = 0, this.__curr = 0, this._scope = new wt((a) => {
          const p = wt.from({ creater: (h) => ({ id: this._scopeIdAcc++, color: a, level: h, enabled: this._creater.levelFilter(h) }), afterDelete: () => {
            p.size === 0 && this._scope.delete(a);
          } });
          return p;
        }), this._scopeIdAcc = 0, this.scopePrinterMap = wt.from({ creater: (a) => this._printerBuilder(a) }), this.$enableDefaultFormatter = false, typeof t.init === "function" && t.init(this);
        let n = 0, s = false, o = false;
        return r && (r.enableTime !== void 0 && (s = r.enableTime), r.enableDuration !== void 0 && (o = r.enableDuration), r.level !== void 0 && (n = r.level)), this._config = { useColors: this._creater.canUseColors(), enabled: this._creater.isEnabled(this.namespace, n), color: this._creater.selectColor(this.namespace), level: n, enableTime: s, enableDuration: o }, this;
      }
      get useColors() {
        return this._config.useColors;
      }
      forceSetUseColors(e) {
        this._config.useColors = e;
      }
      get enabled() {
        return this._config.enabled;
      }
      forceSetEnabled(e) {
        this._config.enabled = e;
      }
      get color() {
        return this._config.color;
      }
      get level() {
        return this._config.level;
      }
      get enableTime() {
        return this._config.enableTime;
      }
      get enableDuration() {
        return this._config.enableDuration;
      }
      getDiff() {
        return this._curr - this._prev;
      }
      get _prev() {
        return this.__prev;
      }
      get _curr() {
        return this.__curr || (this.__curr = Date.now());
      }
      _resetDiff() {
        this.__prev = this.__curr, this.__curr = 0;
      }
      getDuration() {
        return wI(this.getDiff());
      }
      get _dater() {
        return /* @__PURE__ */ new Date();
      }
      getTime() {
        return this._dater.setTime(Date.now()), this._dater.toLocaleTimeString();
      }
      destroy() {
        this._config.enabled = false, this._creater.destroy(this.namespace);
      }
      get print() {
        return this.scopePrinterMap.forceGet(this._config);
      }
      createPrinter(e, t) {
        const r = this._scope.forceGet(e).forceGet(t);
        return this.scopePrinterMap.forceGet(r);
      }
      deletePrinter(e, t) {
        const r = this._scope.tryGet(e);
        if (r) {
          const n = r.tryGet(t);
          if (n) return r.delete(t), this.scopePrinterMap.delete(n);
        }
        return false;
      }
      _printerBuilder(e) {
        const { _creater: t } = this, r = () => e.enabled && this.enabled, n = (...s) => {
          if (!r()) return;
          this._resetDiff();
          let o = typeof s[0] !== "string" ? "%O" : s.shift();
          if (this.$enableDefaultFormatter) {
            let p = 0;
            o = o.replace(/%([a-zA-Z%])/g, (h, f) => {
              if (h === "%%") return h;
              const g = t.formatters[f];
              return typeof g === "function" && (h = g(this, s[p]), s.splice(p, 1), p--), p++, h;
            });
          }
          const a = [o, ...s];
          t.formatArgs(this, a, e), t.printArgs(this, a, e);
        };
        return Object.defineProperty(n, "enabled", { get: r }), n;
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Ec.prototype, "_dater", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], Ec.prototype, "print", null), l([De, u("design:type", Function), u("design:paramtypes", [Object, typeof (Em = typeof BFChainUtilLogger < "u" && BFChainUtilLogger.DebugLevel) === "function" ? Em : Object]), u("design:returntype", typeof (Im = typeof BFChainUtilLogger < "u" && BFChainUtilLogger.Pinter) === "function" ? Im : Object)], Ec.prototype, "createPrinter", null), l([De, u("design:type", Function), u("design:paramtypes", [Object, typeof (Tm = typeof BFChainUtilLogger < "u" && BFChainUtilLogger.DebugLevel) === "function" ? Tm : Object]), u("design:returntype", Boolean)], Ec.prototype, "deletePrinter", null), (function(i) {
      i[i.log = 0] = "log", i[i.info = 1] = "info", i[i.warn = 2] = "warn", i[i.trace = 3] = "trace", i[i.success = 4] = "success", i[i.error = 5] = "error";
    })(Fr || (Fr = {}));
    const ws = class _ws extends RI {
      constructor() {
        super(...arguments), this.formatters = { j(e, t) {
          try {
            return JSON.stringify(t);
          } catch (r) {
            return "[UnexpectedJSONParseError]: " + (r instanceof Error ? r.message : r);
          }
        }, t(e, t) {
          let r;
          switch (typeof t) {
            case "string":
            case "number":
              r = t;
              break;
            default:
              r = t instanceof Date ? t : String(t);
          }
          return new Date(r).toLocaleString();
        }, s: (e, t) => String(t), d: (e, t) => Number(t).toString() };
      }
      get colorTypeName() {
        return "browser";
      }
      get colors() {
        return "0000CC 0000FF 0033CC 0033FF 0066CC 0050c8 006080 005c99 006800 00681a 006733 00654c 006363 006179 3300CC 3300FF 3333CC 3232fb 2b55aa 274ec4 205f7e 1e5b97 1a6700 1a671a 196633 19644b 196262 186078 6600CC 6500fd 6633CC 5c2ee6 326500 326419 9100c2 8300da 842cb1 7928ca 496100 486018 b60000 b4002d b00058 a9007e 9f009f 9500ba a72a00 a62a2a a32951 9d2776 952595 8c23af 8c4600 8b4523 715400 70541c 5c5c00 5b5b17 b50024 b20047 ad0068 a70086 ac2200 ab2222 a82243 a42163 9f207f 981e98 973d00 973c1e 804d00 804d1a 6c5600 6c5616".split(" ").map((e) => "#" + e);
      }
      get storage() {
        try {
          return localStorage;
        } catch {
        }
      }
      load() {
        let e;
        return e = this.storage && this.storage.getItem("debug"), !e && typeof process < "u" && "env" in process && (e = {}.DEBUG), e || "";
      }
      save(e) {
        this.storage && (e ? this.storage.setItem("debug", e) : this.storage.removeItem("debug"));
      }
      canUseColors() {
        return true;
      }
      static _getHtmlNamespace(e) {
        let t = this._NamespaceWithToHtmlCache.get(e);
        return t === void 0 && (t = new this._namespaceCtor(e.namespace), this._NamespaceWithToHtmlCache.set(e, t)), t;
      }
      static _getHtmlDuration(e) {
        return new this._durationCtor(e);
      }
      formatArgs(e, t, r = e) {
        const n = "color: " + r.color;
        if (e.useColors) {
          const s = [], o = _ws._getHtmlNamespace(e);
          o.buildHTML(n), e.enableTime ? (t[0] = `[%s] %o %c${t[0]}`, s[s.length] = e.getTime(), s[s.length] = o) : (t[0] = `%o ${t[0]}`, s[s.length] = o), t.splice(1, 0, ...s);
        } else t[0] = `${e.namespace} ${t[0]}`, e.enableTime && (t[0] = `[${e.getTime()}] ${t[0]}`);
        if (e.enableDuration) if (e.useColors) {
          const s = _ws._getHtmlDuration(e.getDiff());
          s.buildHTML(n), t[t.length] = s;
        } else t.push(`+${e.getDuration()}`);
        return t;
      }
      printArgs(e, t, r = e) {
        switch (r.level) {
          case Fr.log:
            
            break;
          case Fr.info:
            
            break;
          case Fr.warn:
            
            break;
          case Fr.trace:
            
            break;
          case Fr.success:
            
            break;
          case Fr.error:
            
        }
      }
    };
    ws._NamespaceWithToHtmlCache = /* @__PURE__ */ new WeakMap(), ws._namespaceCtor = new Function(`return class Namespace extends String {
    buildHTML(style) {
      if ((this.buildHTML.tmpStyle = style)) {
        this.buildHTML.tmpStyle = style;
        this.buildHTML.tmpHTML = \`<i class="logger-namespace" style="\${style}">\${this}ms</i>\`;
      }
    }
    toHTML() {
      return this.buildHTML.tmpHTML || this.toString();
    }
  }`)(), ws._durationCtor = new Function(`return class Duration extends Number {
      buildHTML(style) {
        if ((this.buildHTML.tmpStyle = style)) {
          this.buildHTML.tmpStyle = style;
          this.buildHTML.tmpHTML = \`<i class="logger-duration" style="\${style}">+\${this}</i>\`;
        }
      }
      toHTML() {
        return this.buildHTML.tmpHTML || this.toString();
      }
    }`)(), l([oe, u("design:type", Object), u("design:paramtypes", [])], ws.prototype, "colors", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], ws.prototype, "storage", null);
    const BI = () => new ws();
    const PI = BI();
    const Do = { log: "inherit", info: "inherit", trace: "inherit", success: "inherit", warn: "inherit", error: "inherit" };
    function Fo(i, e, t) {
      const r = PI.create(i);
      return e === void 0 ? r.forceSetUseColors(false) : r.forceSetUseColors(true), r.createPrinter(e === "inherit" ? r.color : e, t);
    }
    function MI(i) {
      return hA({ get log() {
        return Fo(i, Do.log, Fr.log);
      }, get info() {
        return Fo(i, Do.info, Fr.info);
      }, get warn() {
        return Fo(i, Do.warn, Fr.warn);
      }, get success() {
        return Fo(i, Do.success, Fr.success);
      }, get trace() {
        return Fo(i, Do.trace, Fr.trace);
      }, get error() {
        return Fo(i, Do.error, Fr.error);
      } });
    }
    const fA = !!(typeof process < "u" && process && process.versions && process.versions.node);
    const LI = typeof process < "u" && (process.platform === "win32" || /^(msys|cygwin)$/.test(process.env && {}.OSTYPE));
    const ty = (i, e) => {
      try {
        return new Function(`return typeof ${i} === "${e}"`)();
      } catch {
        return false;
      }
    };
    const gA = ty("cordova", "object");
    const Ol = ty("navigator", "object");
    const HI = Ol && /Android/i.test(navigator.userAgent);
    const vI = Ol && /iPhone|iPod|iPad/i.test(navigator.userAgent);
    const ry = Ol && ty("document", "object");
    const dA = Ol && !ry;
    const Ss = { getGlobalFlag(i, e = "") {
      const t = this.global();
      return t[i] || t.process && t.process.env && t.process.env[i] || t.location && t.location.href && new URL(t.location.href).searchParams.get(i) || t.localStorage && t.localStorage.getItem(i) || e;
    }, global() {
      const i = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self.globalThis = self : typeof global === "object" ? global.globalThis = global : Function("return this")();
      return this.global = () => i, i;
    }, platformName() {
      if (fA) return "Nodejs";
      const i = HI ? "Android" : vI ? "IOS" : "unknown";
      return gA ? "Cordova-" + i : ry ? "WebMaster-" + i : dA ? "WebWorker-" + i : "UNKNOWN";
    }, getChannel: () => "UNKNOWN", getBusiness: () => "UNKNOWN" };
    let wm;
    let bc;
    function kI(i, e, t, r, n, s) {
      let o = `${e.toLowerCase()}-${t.toLowerCase()}`;
      r && (o += `:${r}`), n && (o += `/${n}`);
      const a = MI(o), p = II(i, e, t, r, n, s);
      return new Proxy({}, { get: (h, f) => h[f] || a[f] || p[f] });
    }
    function DI(i) {
      const e = typeof i.platform === "string" ? i.platform : Ss.getGlobalFlag("PLATFORM") || Ss.platformName(), t = typeof i.platform === "string" ? i.platform : Ss.getGlobalFlag("CHANNEL") || Ss.getChannel(), r = typeof i.platform === "string" ? i.platform : Ss.getGlobalFlag("BUSINESS") || Ss.getBusiness();
      return function(n, s, o) {
        return kI(o.platformName || e, o.channelName || t, o.businessName || r, n, s, o.errorCodeMap);
      };
    }
    (function(i) {
      i.PLATFORM = "exception.platform", i.CHANNEL = "exception.channel", i.BUSINESS = "exception.business";
    })(bc || (bc = {}));
    let qo = class {
      constructor(i) {
        this.moduleMap = i, this.platformName = void 0, this.channelName = void 0, this.businessName = void 0, this.exceptionGeneratorDefiner = DI({ platform: this.platformName, channel: this.channelName, business: this.businessName });
      }
    };
    l([D(bc.PLATFORM, { dynamics: true, optional: true }), u("design:type", String)], qo.prototype, "platformName", void 0), l([D(bc.CHANNEL, { dynamics: true, optional: true }), u("design:type", String)], qo.prototype, "channelName", void 0), l([D(bc.BUSINESS, { dynamics: true, optional: true }), u("design:type", String)], qo.prototype, "businessName", void 0), qo = l([J("bfchain-util:custom-exception", { singleton: true }), u("design:paramtypes", [typeof (wm = ze !== void 0 && ze) === "function" ? wm : Object])], qo);
    const FI = bt(qo);
    function yA(i, e, t) {
      return FI.exceptionGeneratorDefiner(i, e, Object.assign({ errorCodeMap: uA, businessName: "util" }, t));
    }
    const mA = class extends qe {
    };
    mA.TYPE = "IdempotentException";
    function ee(i, e) {
      const t = yA(i, e, { errorCodeMap: AI, businessName: "core" });
      let r;
      return Object.create(t, { IdempotentException: { get() {
        return r ?? (r = t.getException(mA));
      } } });
    }
    let yu;
    const { ArgumentFormatException: Yu, error: Jb, IllegalStateException: $I } = ee("MODEL", "transactionModel");
    (() => {
      const i = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
      for (const n in v) {
        const s = v[n];
        e.set(n, s), i.set(s, n);
      }
      const t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
      [[v.SIGNATURE, dp], [v.DAPP, yp], [v.DAPP_PURCHASING, mp], [v.MARK, _p], [v.ISSUE_ASSET, Ap], [v.INCREASE_ASSET, Ep], [v.DESTROY_ASSET, Tp], [v.TRANSFER_ASSET, Ip], [v.GIFT_ASSET, Ki], [v.GRAB_ASSET, Sp], [v.TRUST_ASSET, pa], [v.SIGN_FOR_ASSET, wp], [v.EMIGRATE_ASSET, bp], [v.IMMIGRATE_ASSET, Np], [v.TO_EXCHANGE_ASSET, la], [v.BE_EXCHANGE_ASSET, xp], [v.STAKE_ASSET, zi], [v.UNSTAKE_ASSET, Op], [v.LOCATION_NAME, Cp], [v.SET_LNS_RECORD_VALUE, Bp], [v.SET_LNS_MANAGER, Rp], [v.ISSUE_ENTITY_FACTORY, Pp], [v.ISSUE_ENTITY_FACTORY_V1, Mp], [v.ISSUE_ENTITY, ji], [v.DESTROY_ENTITY, Lp], [v.ISSUE_ENTITY_MULTI, Ji], [v.TRANSFER_ANY, Hp], [v.GIFT_ANY, Yi], [v.GRAB_ANY, vp], [v.TO_EXCHANGE_ANY, ha], [v.BE_EXCHANGE_ANY, kp], [v.TO_EXCHANGE_ANY_MULTI, ua], [v.BE_EXCHANGE_ANY_MULTI, Dp], [v.TO_EXCHANGE_ANY_MULTI_ALL, fa], [v.BE_EXCHANGE_ANY_MULTI_ALL, Fp], [v.ISSUE_CERTIFICATE, $p], [v.DESTROY_CERTIFICATE, Up]].forEach(([n, s]) => {
        t.set(n, s), r.set(s, n);
      }), Re.VK = i, Re.KV = e, Re.VM = t, Re.MV = r;
    })();
    const Qu = /* @__PURE__ */ new WeakMap();
    let Wi = yu = class extends Y {
      get transaction() {
        let e = Qu.get(this._trs_bytes);
        if (!e) {
          const t = Re.VM.get(this._trs_base_type);
          if (!t) throw new Yu(c.INVALID_TRANSACTION_BASE_TYPE, { base_type: this._trs_base_type });
          e = t.decode(this._trs_bytes), Qu.set(this._trs_bytes, Object.freeze(e));
        }
        return e;
      }
      set transaction(e) {
        const t = Re.trsTypeToV(e.type);
        if (!Re.VK.has(t)) throw new Yu(c.INVALID_TRANSACTION_BASE_TYPE, { base_type: t });
        if (Object.isFrozen(this)) throw new $I(c.TRANSACTION_IS_IN_UNCHANGABLE_STATE);
        this._trs_base_type = t, this._trs_bytes = new Uint8Array(e.constructor.encode(e).finish()), Object.isFrozen(e) && Qu.set(this._trs_bytes, e);
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        if (e !== t) {
          const r = e.transaction;
          if (r) if (r instanceof Y) t.transaction = r;
          else {
            const n = r.type;
            if (n) {
              const s = Re.trsTypeToV(n), o = Re.VM.get(s);
              if (!o) throw new Yu(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: s });
              t.transaction = o.fromObject(r);
            }
          }
        }
        return t;
      }
      toJSON() {
        return { transaction: this.transaction.toJSON() };
      }
    };
    Wi.INC = 1;
    l([A.d(yu.INC++, "string"), u("design:type", String)], Wi.prototype, "_trs_base_type", void 0);
    l([A.d(yu.INC++, "bytes"), u("design:type", Uint8Array)], Wi.prototype, "_trs_bytes", void 0);
    Wi = yu = l([R.d("SomeTransactionModel")], Wi);
    let mu;
    let Co;
    let Xi = mu = class extends Y {
      toJSON() {
        return { remainAssetPrealnum: this.remainAssetPrealnum, frozenMainAssetPrealnum: this.frozenMainAssetPrealnum };
      }
    };
    Xi.INC = 1;
    l([A.d(mu.INC++, "string"), u("design:type", String)], Xi.prototype, "remainAssetPrealnum", void 0);
    l([A.d(mu.INC++, "string"), u("design:type", String)], Xi.prototype, "frozenMainAssetPrealnum", void 0);
    Xi = mu = l([R.d("AssetPrealnumModel")], Xi);
    let qt = Co = class extends Wi {
      get signature() {
        return xe(this.signatureBuffer);
      }
      set signature(e) {
        this.signatureBuffer = _e(e);
      }
      get signSignature() {
        return this.signSignatureBuffer && xe(this.signSignatureBuffer) || void 0;
      }
      set signSignature(e) {
        this.signSignatureBuffer = _e(e);
      }
      getBytes(e, t) {
        const r = {};
        e && (r.signatureBuffer = { value: null }), t && (r.signSignatureBuffer = { value: null });
        const n = Object.create(this, r);
        return this.$type.encode(n).finish();
      }
      toJSON() {
        const e = { tIndex: this.tIndex, height: this.height, signature: this.signature, transaction: this.transaction.toJSON() };
        return this.assetPrealnum && (e.assetPrealnum = this.assetPrealnum.toJSON()), this.signSignature && (e.signSignature = this.signSignature), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return e !== t && (e.signature && (t.signature = e.signature), e.signSignature && (t.signSignature = e.signSignature)), t;
      }
    };
    l([A.d(Co.INC++, "uint32"), u("design:type", Number)], qt.prototype, "tIndex", void 0);
    l([A.d(Co.INC++, "uint32"), u("design:type", Number)], qt.prototype, "height", void 0);
    l([A.d(Co.INC++, Xi, "optional"), u("design:type", Xi)], qt.prototype, "assetPrealnum", void 0);
    l([A.d(Co.INC++, "bytes"), u("design:type", Uint8Array)], qt.prototype, "signatureBuffer", void 0);
    l([A.d(Co.INC++, "bytes", "optional"), u("design:type", Uint8Array)], qt.prototype, "signSignatureBuffer", void 0);
    l([Vs, u("design:type", Function), u("design:paramtypes", [Boolean, Boolean]), u("design:returntype", void 0)], qt.prototype, "getBytes", null);
    qt = Co = l([R.d("TransactionInBlock")], qt);
    function ny(i, e, t) {
      const r = [];
      for (const n in i) r[r.length] = { sortKey: n, value: t(i[n]) };
      r.toSorted((n, s) => n.sortKey > s.sortKey ? 1 : -1), e.clear();
      for (const n of r) e.set(n.sortKey, n.value);
      return e;
    }
    let rc;
    let Kn = rc = class extends Y {
      toJSON() {
        return { changeAmount: this.changeAmount, changeCount: this.changeCount, moveAmount: this.moveAmount, transactionCount: this.transactionCount };
      }
    };
    Kn.INC = 1;
    l([A.d(rc.INC++, "string", "required", "0"), u("design:type", String)], Kn.prototype, "changeAmount", void 0);
    l([A.d(rc.INC++, "uint32", "required", 0), u("design:type", Number)], Kn.prototype, "changeCount", void 0);
    l([A.d(rc.INC++, "string", "required", "0"), u("design:type", String)], Kn.prototype, "moveAmount", void 0);
    l([A.d(rc.INC++, "uint32", "required", 0), u("design:type", Number)], Kn.prototype, "transactionCount", void 0);
    Kn = rc = l([R.d("CountAndAmountStatisticModel")], Kn);
    let _u;
    let sy;
    let qi = _u = class extends Y {
      get typeStatisticMap() {
        return this._typeStatisticMap || (this._typeStatisticMap = new pi(this.typeStatisticHashMap));
      }
      toJSON() {
        return { typeStatisticHashMap: this.typeStatisticMap.toJSON(), total: this.total.toJSON() };
      }
      static fromObject(e) {
        return e.total || (e = Object.create(e, { total: {} })), super.fromObject(e);
      }
      format() {
        return ny(this.typeStatisticHashMap, this.typeStatisticMap, (e) => e), this;
      }
    };
    qi.INC = 1;
    l([fr.d(_u.INC++, "string", Kn), u("design:type", Object)], qi.prototype, "typeStatisticHashMap", void 0);
    l([A.d(_u.INC++, Kn), u("design:type", Kn)], qi.prototype, "total", void 0);
    qi = _u = l([R.d("AssetStatisticModel")], qi);
    let Zi = sy = class extends Y {
      get assetTypeTypeStatisticMap() {
        return this._assetTypeTypeStatisticMap || (this._assetTypeTypeStatisticMap = new pi(this.assetTypeTypeStatisticHashMap));
      }
      toJSON() {
        return { assetTypeTypeStatisticHashMap: this.assetTypeTypeStatisticMap.toJSON() };
      }
      format() {
        return ny(this.assetTypeTypeStatisticHashMap, this.assetTypeTypeStatisticMap, (e) => e.format()), this;
      }
      static fromObject(e) {
        return super.fromObject(e);
      }
    };
    Zi.INC = 1;
    l([fr.d(sy.INC++, "string", qi), u("design:type", Object)], Zi.prototype, "assetTypeTypeStatisticHashMap", void 0);
    Zi = sy = l([R.d("AssetTypeAssetStatisticModel")], Zi);
    let Bi;
    let nn = Bi = class extends Y {
      get magicAssetTypeTypeStatisticMap() {
        return this._magicAssetTypeTypeStatisticMap || (this._magicAssetTypeTypeStatisticMap = new pi(this.magicAssetTypeTypeStatisticHashMap));
      }
      get numberOfTransactionsMap() {
        return this._numberOfTransactionsMap || (this._numberOfTransactionsMap = new pi(this.numberOfTransactionsHashMap));
      }
      get numberOfTransactions() {
        let e = 0;
        const t = this.numberOfTransactionsHashMap;
        for (const r in t) e += t[r];
        return e;
      }
      toJSON() {
        return { totalFee: this.totalFee, totalAsset: this.totalAsset, totalChainAsset: this.totalChainAsset, totalAccount: this.totalAccount, magicAssetTypeTypeStatisticHashMap: this.magicAssetTypeTypeStatisticMap.toJSON(), numberOfTransactionsHashMap: this.numberOfTransactionsHashMap };
      }
      getBytes() {
        return super.getBytes();
      }
      format() {
        return ny(this.magicAssetTypeTypeStatisticHashMap, this.magicAssetTypeTypeStatisticMap, (e) => e.format()), this;
      }
    };
    nn.INC = 1;
    l([A.d(Bi.INC++, "string", "required", "0"), u("design:type", String)], nn.prototype, "totalFee", void 0);
    l([A.d(Bi.INC++, "string", "required", "0"), u("design:type", String)], nn.prototype, "totalAsset", void 0);
    l([A.d(Bi.INC++, "string", "required", "0"), u("design:type", String)], nn.prototype, "totalChainAsset", void 0);
    l([A.d(Bi.INC++, "uint32", "required", 0), u("design:type", Number)], nn.prototype, "totalAccount", void 0);
    l([fr.d(Bi.INC++, "string", Zi), u("design:type", Object)], nn.prototype, "magicAssetTypeTypeStatisticHashMap", void 0);
    l([fr.d(Bi.INC++, "string", "uint32"), u("design:type", Object)], nn.prototype, "numberOfTransactionsHashMap", void 0);
    l([Vs, u("design:type", Function), u("design:paramtypes", []), u("design:returntype", void 0)], nn.prototype, "getBytes", null);
    nn = Bi = l([R.d("StatisticInfoModel")], nn);
    let _s;
    let nc;
    const UI = new ss((i) => new pi(i.remark));
    const bm = /* @__PURE__ */ new WeakMap();
    const Wu = /* @__PURE__ */ new WeakMap();
    let xf = class extends Y {
    };
    l([A.d(1, "uint32"), u("design:type", Number)], xf.prototype, "version", void 0);
    xf = l([R.d("BlockVersionReader")], xf);
    let sn = _s = class extends Y {
      get payloadHash() {
        return xe(this.payloadHashBuffer);
      }
      set payloadHash(e) {
        this.payloadHashBuffer = _e(e);
      }
      get blobSize() {
        return this.blobSizeLong.toNumber();
      }
      set blobSize(e) {
        this.blobSizeLong = Sc.fromNumber(e, true);
      }
      get totalAmount() {
        return this.statisticInfo.totalAsset || "0";
      }
      get totalFee() {
        return this.statisticInfo.totalFee || "0";
      }
      get transactionInBlocks() {
        const { transactionInBlockBufferList: e } = this;
        let t = bm.get(e);
        return t || (t = this.transactionInBlockBufferList.map((r) => {
          const n = qt.decode(r);
          return Wu.set(n, r), n;
        })), t;
      }
      set transactionInBlocks(e) {
        const t = e.map((r) => {
          let n = Wu.get(r);
          return n || (n = qt.encode(r).finish(), Wu.set(r, n)), n;
        });
        bm.set(t, e), this.transactionInBlockBufferList = t;
      }
      toJSON() {
        return { startTindex: this.startTindex, offset: this.offset, numberOfTransactions: this.numberOfTransactions, payloadHash: this.payloadHash, payloadLength: this.payloadLength, blobSize: this.blobSize, totalAmount: this.totalAmount, totalFee: this.totalFee, transactionInBlocks: this.transactionInBlocks.map((t) => t.toJSON()), statisticInfo: this.statisticInfo.toJSON() };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        if (t !== e) {
          e.blobSize !== void 0 && (t.blobSize = e.blobSize), e.payloadHash && (t.payloadHash = e.payloadHash);
          const r = [];
          if (e.transactionInBlocks) {
            const n = e.transactionInBlocks;
            for (const s of n) r[r.length] = qt.fromObject(s);
          }
          t.transactionInBlocks = r;
        }
        return t;
      }
    };
    sn.INC = 1;
    l([A.d(_s.INC++, "uint32"), u("design:type", Number)], sn.prototype, "startTindex", void 0);
    l([A.d(_s.INC++, "uint32"), u("design:type", Number)], sn.prototype, "offset", void 0);
    l([A.d(_s.INC++, "uint32"), u("design:type", Number)], sn.prototype, "numberOfTransactions", void 0);
    l([A.d(_s.INC++, "bytes"), u("design:type", Uint8Array)], sn.prototype, "payloadHashBuffer", void 0);
    l([A.d(_s.INC++, "uint32"), u("design:type", Number)], sn.prototype, "payloadLength", void 0);
    l([A.d(_s.INC++, "uint64"), u("design:type", Object)], sn.prototype, "blobSizeLong", void 0);
    l([A.d(_s.INC++, nn), u("design:type", nn)], sn.prototype, "statisticInfo", void 0);
    l([A.d(_s.INC++, "bytes", "repeated"), u("design:type", Array)], sn.prototype, "transactionInBlockBufferList", void 0);
    sn = _s = l([R.d("BlockTransactionInfo")], sn);
    let Nt = nc = class extends Y {
      get signature() {
        return xe(this.signatureBuffer);
      }
      set signature(e) {
        this.signatureBuffer = _e(e);
      }
      get generatorPublicKey() {
        return xe(this.generatorPublicKeyBuffer);
      }
      set generatorPublicKey(e) {
        this.generatorPublicKeyBuffer = _e(e);
      }
      get generatorSecondPublicKey() {
        return this.generatorSecondPublicKeyBuffer && xe(this.generatorSecondPublicKeyBuffer) || void 0;
      }
      set generatorSecondPublicKey(e) {
        this.generatorSecondPublicKeyBuffer = _e(e);
      }
      get signSignature() {
        return this.signSignatureBuffer && xe(this.signSignatureBuffer) || void 0;
      }
      set signSignature(e) {
        this.signSignatureBuffer = _e(e);
      }
      get remarkMap() {
        return UI.forceGet(this);
      }
      get startTindex() {
        return this.transactionInfo.startTindex;
      }
      get offset() {
        return this.transactionInfo.offset;
      }
      get numberOfTransactions() {
        return this.transactionInfo.numberOfTransactions;
      }
      get payloadHash() {
        return this.transactionInfo.payloadHash;
      }
      get payloadLength() {
        return this.transactionInfo.payloadLength;
      }
      get blobSize() {
        return this.transactionInfo.blobSize;
      }
      get totalAmount() {
        return this.transactionInfo.totalAmount;
      }
      get totalFee() {
        return this.transactionInfo.totalFee;
      }
      get statisticInfo() {
        return this.transactionInfo.statisticInfo;
      }
      get transactionBufferList() {
        return this.transactionInfo.transactionInBlockBufferList;
      }
      get transactions() {
        return this.transactionInfo.transactionInBlocks;
      }
      getBytes(e, t, r) {
        const n = {};
        if (e && (n.signatureBuffer = { value: null }), t && (n.signSignatureBuffer = { value: null }), r) {
          const o = this.transactionInfo;
          r === true ? n.transactionInfo = { value: { startTindex: o.startTindex, offset: o.offset, numberOfTransactions: o.numberOfTransactions, payloadHashBuffer: o.payloadHashBuffer, payloadLength: o.payloadLength, blobSizeLong: o.blobSizeLong, statisticInfo: o.statisticInfo, transactionInBlockBufferList: [], totalAmount: o.totalAmount, totalFee: o.totalFee } } : n.transactionInfo = { value: { startTindex: o.startTindex, offset: o.offset, numberOfTransactions: o.numberOfTransactions, payloadHashBuffer: o.payloadHashBuffer, payloadLength: o.payloadLength, blobSizeLong: o.blobSizeLong, statisticInfo: o.statisticInfo, transactionInBlockBufferList: r, totalAmount: o.totalAmount, totalFee: o.totalFee } };
        }
        const s = Object.create(this, n);
        return this.$type.encode(s).finish();
      }
      toJSON() {
        const e = { version: this.version, height: this.height, blockSize: this.blockSize, timestamp: this.timestamp, signature: this.signature, generatorPublicKey: this.generatorPublicKey, previousBlockSignature: this.previousBlockSignature, reward: this.reward, magic: this.magic, remark: this.remark, asset: this.asset.toJSON(), transactionInfo: this.transactionInfo.toJSON() };
        return this.generatorSecondPublicKey && (e.generatorSecondPublicKey = this.generatorSecondPublicKey), this.signSignature && (e.signSignature = this.signSignature), e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return e.generatorPublicKey && (t.generatorPublicKey = e.generatorPublicKey), e.generatorSecondPublicKey && (t.generatorSecondPublicKey = e.generatorSecondPublicKey), e.signature && (t.signature = e.signature), e.signSignature && (t.signSignature = e.signSignature), t;
      }
    };
    Nt.INC = 10;
    l([A.d(1, "uint32"), u("design:type", Number)], Nt.prototype, "version", void 0);
    l([A.d(2, "uint32"), u("design:type", Number)], Nt.prototype, "height", void 0);
    l([A.d(3, "bytes"), u("design:type", Uint8Array)], Nt.prototype, "signatureBuffer", void 0);
    l([A.d(4, "uint32"), u("design:type", Number)], Nt.prototype, "timestamp", void 0);
    l([A.d(5, "bytes"), u("design:type", Uint8Array)], Nt.prototype, "generatorPublicKeyBuffer", void 0);
    l([A.d(6, "string"), u("design:type", String)], Nt.prototype, "previousBlockSignature", void 0);
    l([A.d(7, "string"), u("design:type", String)], Nt.prototype, "magic", void 0);
    l([A.d(8, "bytes", "optional"), u("design:type", Uint8Array)], Nt.prototype, "generatorSecondPublicKeyBuffer", void 0);
    l([A.d(9, "bytes", "optional"), u("design:type", Uint8Array)], Nt.prototype, "signSignatureBuffer", void 0);
    l([A.d(nc.INC++, "uint32"), u("design:type", Number)], Nt.prototype, "blockSize", void 0);
    l([fr.d(nc.INC++, "string", "string"), u("design:type", Object)], Nt.prototype, "remark", void 0);
    l([A.d(nc.INC++, "string", "required", "0"), u("design:type", String)], Nt.prototype, "reward", void 0);
    l([A.d(nc.INC++, sn), u("design:type", sn)], Nt.prototype, "transactionInfo", void 0);
    l([Vs, u("design:type", Function), u("design:paramtypes", [Boolean, Boolean, Object]), u("design:returntype", void 0)], Nt.prototype, "getBytes", null);
    Nt = nc = l([R.d("Block")], Nt);
    let iy;
    let eo = iy = class extends Y {
      get assetChangeHash() {
        if (this.assetChangeBuffer !== void 0) return xe(this.assetChangeBuffer);
      }
      set assetChangeHash(e) {
        this.assetChangeBuffer = _e(e);
      }
      toJSON() {
        const e = {};
        return this.assetChangeHash && (e.assetChangeHash = this.assetChangeHash), e;
      }
      getBytes() {
        return this.$type.encode(this).finish();
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.assetChangeHash && (t.assetChangeHash = e.assetChangeHash), t;
      }
    };
    eo.INC = 1;
    l([A.d(iy.INC++, "bytes", "optional"), u("design:type", Uint8Array)], eo.prototype, "assetChangeBuffer", void 0);
    l([Vs, u("design:type", Function), u("design:paramtypes", []), u("design:returntype", void 0)], eo.prototype, "getBytes", null);
    eo = iy = l([R.d("CommonAssetModel")], eo);
    let Vp = class extends Y {
      toJSON() {
        return { commonAsset: this.commonAsset.toJSON() };
      }
    };
    l([A.d(1, eo), u("design:type", eo)], Vp.prototype, "commonAsset", void 0);
    Vp = l([R.d("CommonBlockAssetModel")], Vp);
    let Au;
    let oy;
    let ma = Au = class extends Y {
      toJSON() {
        return { address: this.address, numberOfForgeEntities: this.numberOfForgeEntities };
      }
    };
    ma.INC = 1;
    l([A.d(Au.INC++, "string"), u("design:type", String)], ma.prototype, "address", void 0);
    l([A.d(Au.INC++, "uint32"), u("design:type", Number)], ma.prototype, "numberOfForgeEntities", void 0);
    ma = Au = l([R.d("NextRoundGeneratorModel")], ma);
    let _a = oy = class extends Y {
      get nextRoundGeneratorAddressList() {
        if (!this._next_round_generator_address_list) {
          this._next_round_generator_address_list = [];
          for (const e of this.nextRoundGenerators) this._next_round_generator_address_list.push(e.address);
        }
        return this._next_round_generator_address_list;
      }
      toJSON() {
        return { nextRoundGenerators: this.nextRoundGenerators.map((t) => t.toJSON()) };
      }
    };
    _a.INC = 1;
    l([A.d(oy.INC++, ma, "repeated"), u("design:type", Array)], _a.prototype, "nextRoundGenerators", void 0);
    _a = oy = l([R.d("RoundGeneratorModel")], _a);
    let rt;
    let Gp = class extends Y {
      toJSON() {
        return { port: this.port };
      }
    };
    l([A.d(1, "uint32"), u("design:type", Number)], Gp.prototype, "port", void 0);
    Gp = l([R.d("PortsModel")], Gp);
    let Ze = rt = class extends _a {
      get beginEpochTime() {
        return this.beginEpochTimeLong.toNumber();
      }
      set beginEpochTime(e) {
        this.beginEpochTimeLong = Sc.fromNumber(e, true);
      }
      get maxTransactionBlobSize() {
        return this.maxTransactionBlobSizeLong.toNumber();
      }
      set maxTransactionBlobSize(e) {
        this.maxTransactionBlobSizeLong = Sc.fromNumber(e, true);
      }
      get maxBlockBlobSize() {
        return this.maxBlockBlobSizeLong.toNumber();
      }
      set maxBlockBlobSize(e) {
        this.maxBlockBlobSizeLong = Sc.fromNumber(e, true);
      }
      get assetChangeHash() {
        if (this.assetChangeBuffer !== void 0) return xe(this.assetChangeBuffer);
      }
      set assetChangeHash(e) {
        this.assetChangeBuffer = _e(e);
      }
      toJSON() {
        const e = Object.assign({ chainName: this.chainName, assetType: this.assetType, magic: this.magic, bnid: this.bnid, beginEpochTime: this.beginEpochTime, genesisLocationName: this.genesisLocationName, genesisAmount: this.genesisAmount, maxSupply: this.maxSupply, minTransactionFeePerByte: this.minTransactionFeePerByte.toJSON(), maxTransactionSize: this.maxTransactionSize, maxTransactionBlobSize: this.maxTransactionBlobSize, maxBlockSize: this.maxBlockSize, maxBlockBlobSize: this.maxBlockBlobSize, maxTPSPerBlock: this.maxTPSPerBlock, consessusBeforeSyncBlockDiff: this.consessusBeforeSyncBlockDiff, maxGrabTimesOfGiftAsset: this.maxGrabTimesOfGiftAsset, issueAssetMinChainAsset: this.issueAssetMinChainAsset, maxMultipleOfAssetAndMainAsset: this.maxMultipleOfAssetAndMainAsset.toJSON(), issueEntityFactoryMinChainAsset: this.issueEntityFactoryMinChainAsset, maxMultipleOfEntityAndMainAsset: this.maxMultipleOfEntityAndMainAsset.toJSON(), registerChainMinChainAsset: this.registerChainMinChainAsset, maxApplyAndConfirmedBlockHeightDiff: this.maxApplyAndConfirmedBlockHeightDiff, blockPerRound: this.blockPerRound, whetherToAllowGeneratorContinusElections: this.whetherToAllowGeneratorContinusElections, forgeInterval: this.forgeInterval, basicRewards: this.basicRewards, ports: this.ports.toJSON() }, super.toJSON());
        return this.assetChangeHash && (e.assetChangeHash = this.assetChangeHash), e;
      }
      getBytes() {
        return this.$type.encode(this).finish();
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.beginEpochTime !== void 0 && (t.beginEpochTime = e.beginEpochTime), e.maxTransactionBlobSize !== void 0 && (t.maxTransactionBlobSize = e.maxTransactionBlobSize), e.maxBlockBlobSize !== void 0 && (t.maxBlockBlobSize = e.maxBlockBlobSize), e.assetChangeHash !== void 0 && (t.assetChangeHash = e.assetChangeHash)), t;
      }
    };
    l([A.d(rt.INC++, "string"), u("design:type", String)], Ze.prototype, "chainName", void 0);
    l([A.d(rt.INC++, "string"), u("design:type", String)], Ze.prototype, "assetType", void 0);
    l([A.d(rt.INC++, "string"), u("design:type", String)], Ze.prototype, "magic", void 0);
    l([A.d(rt.INC++, "string"), u("design:type", String)], Ze.prototype, "bnid", void 0);
    l([A.d(rt.INC++, "uint64"), u("design:type", Object)], Ze.prototype, "beginEpochTimeLong", void 0);
    l([A.d(rt.INC++, "string"), u("design:type", String)], Ze.prototype, "genesisLocationName", void 0);
    l([A.d(rt.INC++, "string"), u("design:type", String)], Ze.prototype, "genesisAmount", void 0);
    l([A.d(rt.INC++, "string"), u("design:type", String)], Ze.prototype, "maxSupply", void 0);
    l([A.d(rt.INC++, os), u("design:type", os)], Ze.prototype, "minTransactionFeePerByte", void 0);
    l([A.d(rt.INC++, "uint32"), u("design:type", Number)], Ze.prototype, "maxTransactionSize", void 0);
    l([A.d(rt.INC++, "uint64", "required"), u("design:type", Object)], Ze.prototype, "maxTransactionBlobSizeLong", void 0);
    l([A.d(rt.INC++, "uint32"), u("design:type", Number)], Ze.prototype, "maxBlockSize", void 0);
    l([A.d(rt.INC++, "uint64", "required"), u("design:type", Object)], Ze.prototype, "maxBlockBlobSizeLong", void 0);
    l([A.d(rt.INC++, "uint32"), u("design:type", Number)], Ze.prototype, "maxTPSPerBlock", void 0);
    l([A.d(rt.INC++, "uint32"), u("design:type", Number)], Ze.prototype, "consessusBeforeSyncBlockDiff", void 0);
    l([A.d(rt.INC++, "uint32"), u("design:type", Number)], Ze.prototype, "maxGrabTimesOfGiftAsset", void 0);
    l([A.d(rt.INC++, "string"), u("design:type", String)], Ze.prototype, "issueAssetMinChainAsset", void 0);
    l([A.d(rt.INC++, Nr), u("design:type", Nr)], Ze.prototype, "maxMultipleOfAssetAndMainAsset", void 0);
    l([A.d(rt.INC++, "string", "required"), u("design:type", String)], Ze.prototype, "issueEntityFactoryMinChainAsset", void 0);
    l([A.d(rt.INC++, Nr), u("design:type", Nr)], Ze.prototype, "maxMultipleOfEntityAndMainAsset", void 0);
    l([A.d(rt.INC++, "string"), u("design:type", String)], Ze.prototype, "registerChainMinChainAsset", void 0);
    l([A.d(rt.INC++, "uint32"), u("design:type", Number)], Ze.prototype, "maxApplyAndConfirmedBlockHeightDiff", void 0);
    l([A.d(rt.INC++, "uint32"), u("design:type", Number)], Ze.prototype, "blockPerRound", void 0);
    l([A.d(rt.INC++, "bool"), u("design:type", Boolean)], Ze.prototype, "whetherToAllowGeneratorContinusElections", void 0);
    l([A.d(rt.INC++, "uint32", "required"), u("design:type", Number)], Ze.prototype, "forgeInterval", void 0);
    l([A.d(rt.INC++, "string"), u("design:type", String)], Ze.prototype, "basicRewards", void 0);
    l([A.d(rt.INC++, Gp, "required"), u("design:type", Gp)], Ze.prototype, "ports", void 0);
    l([A.d(rt.INC++, "bytes", "optional"), u("design:type", Uint8Array)], Ze.prototype, "assetChangeBuffer", void 0);
    l([Vs, u("design:type", Function), u("design:paramtypes", []), u("design:returntype", void 0)], Ze.prototype, "getBytes", null);
    Ze = rt = l([R.d("GenesisAssetModel")], Ze);
    let Kp = class extends Y {
      toJSON() {
        return { genesisAsset: this.genesisAsset.toJSON() };
      }
    };
    l([A.d(1, Ze), u("design:type", Ze)], Kp.prototype, "genesisAsset", void 0);
    Kp = l([R.d("GenesisBlockAssetModel")], Kp);
    let Eu;
    let to = Eu = class extends _a {
      get assetChangeHash() {
        if (this.assetChangeBuffer !== void 0) return xe(this.assetChangeBuffer);
      }
      set assetChangeHash(e) {
        this.assetChangeBuffer = _e(e);
      }
      get chainOnChainHash() {
        return xe(this.chainOnChainBuffer);
      }
      set chainOnChainHash(e) {
        this.chainOnChainBuffer = _e(e);
      }
      toJSON() {
        const e = Object.assign({ chainOnChainHash: this.chainOnChainHash }, super.toJSON());
        return this.assetChangeHash && (e.assetChangeHash = this.assetChangeHash), e;
      }
      getBytes() {
        return this.$type.encode(this).finish();
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.assetChangeHash && (t.assetChangeHash = e.assetChangeHash), e.chainOnChainHash && (t.chainOnChainHash = e.chainOnChainHash)), t;
      }
    };
    l([A.d(Eu.INC++, "bytes", "optional"), u("design:type", Uint8Array)], to.prototype, "assetChangeBuffer", void 0);
    l([A.d(Eu.INC++, "bytes"), u("design:type", Uint8Array)], to.prototype, "chainOnChainBuffer", void 0);
    l([Vs, u("design:type", Function), u("design:paramtypes", []), u("design:returntype", void 0)], to.prototype, "getBytes", null);
    to = Eu = l([R.d("RoundLastAssetModel")], to);
    let zp = class extends Y {
      toJSON() {
        return { roundLastAsset: this.roundLastAsset.toJSON() };
      }
    };
    l([A.d(1, to), u("design:type", to)], zp.prototype, "roundLastAsset", void 0);
    zp = l([R.d("RoundLastBlockAssetModel")], zp);
    let Aa = class extends Nt {
    };
    l([A.d(21, Vp), u("design:type", Vp)], Aa.prototype, "asset", void 0);
    Aa = l([R.d("CommonBlock")], Aa);
    let ro = class extends Nt {
    };
    l([A.d(21, Kp), u("design:type", Kp)], ro.prototype, "asset", void 0);
    ro = l([R.d("GenesisBlock")], ro);
    let Ea = class extends Nt {
    };
    l([A.d(22, zp), u("design:type", zp)], Ea.prototype, "asset", void 0);
    Ea = l([R.d("RoundLastBlock")], Ea);
    let Iu;
    const { ArgumentFormatException: Nm } = ee("MODEL", "blockModel");
    let Kt;
    (function(i) {
      i[i.GENESIS = 0] = "GENESIS", i[i.COMMON = 1] = "COMMON", i[i.ROUNDEND = 2] = "ROUNDEND";
    })(Kt || (Kt = {}));
    const Zl = (() => {
      const i = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
      return [[Kt.GENESIS, ro], [Kt.COMMON, Aa], [Kt.ROUNDEND, Ea]].forEach(([t, r]) => {
        i.set(t, r), e.set(r, t);
      }), { KM: i, MK: e };
    })();
    const Xu = /* @__PURE__ */ new WeakMap();
    let mi = Iu = class extends Y {
      get block() {
        let e = Xu.get(this._block_bytes);
        if (!e) {
          const t = Zl.KM.get(this._block_type);
          if (!t) throw new Nm(c.INVALID_BLOCK_TYPE, { type: this._block_type });
          e = t.decode(this._block_bytes), Xu.set(this._block_bytes, e);
        }
        return e;
      }
      set block(e) {
        const t = e.constructor, r = Zl.MK.get(t);
        if (r === void 0) throw new Nm(c.INVALID_BLOCK_CONSTRUCTOR, { name: t.name });
        this._block_type = r, this._block_bytes = new Uint8Array(t.encode(e).finish()), Xu.set(this._block_bytes, e);
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        if (e !== t) {
          const r = e.block;
          if (r) if (r instanceof Y) t.block = r;
          else {
            let n = Kt.COMMON;
            r.height === 0 ? n = Kt.GENESIS : r.remark && "hash" in r.remark && (n = Kt.ROUNDEND);
            const s = Zl.KM.get(n);
            s && (t.block = s.fromObject(r));
          }
        }
        return t;
      }
      toJSON() {
        return { block: this.block };
      }
    };
    mi.INC = 1;
    l([A.d(Iu.INC++, Kt), u("design:type", Number)], mi.prototype, "_block_type", void 0);
    l([A.d(Iu.INC++, "bytes"), u("design:type", Uint8Array)], mi.prototype, "_block_bytes", void 0);
    mi = Iu = l([R.d("SomeBlockModel")], mi);
    let jp = class extends Y {
      toJSON() {
        return { genesisBlock: this.genesisBlock };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], jp.prototype, "genesisBlock", void 0);
    jp = l([R.d("RegisterChainModel")], jp);
    let Jp = class extends Y {
      toJSON() {
        return { registerChain: this.registerChain.toJSON() };
      }
    };
    l([A.d(1, jp), u("design:type", jp)], Jp.prototype, "registerChain", void 0);
    Jp = l([R.d("RegisterChainAssetModel")], Jp);
    let ay;
    let Ia = ay = class extends Je {
    };
    l([A.d(ay.INC++, Jp), u("design:type", Jp)], Ia.prototype, "asset", void 0);
    Ia = ay = l([R.d("RegisterChainTransaction")], Ia);
    let cy;
    const { ArgumentFormatException: xm, error: EN, IllegalStateException: IN } = ee("MODEL", "transactionModel");
    const Om = /* @__PURE__ */ new WeakMap();
    const qu = /* @__PURE__ */ new WeakMap();
    let Ta = cy = class extends Y {
      get transactions() {
        const { transactionBufferList: e } = this;
        let t = Om.get(e);
        return t || (t = this.transactionBufferList.map((r) => {
          const n = Je.decode(r), s = Re.trsTypeToV(n.type), o = Re.VM.get(s);
          if (!o) throw new xm(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: s });
          const a = o.decode(r);
          return qu.set(a, r), a;
        })), t;
      }
      set transactions(e) {
        const t = e.map((r) => {
          let n = qu.get(r);
          return n || (n = r.getBytes(), qu.set(r, n)), n;
        });
        Om.set(t, e), this.transactionBufferList = t;
      }
      toJSON() {
        return { transactions: this.transactions.map((e) => e.toJSON()) };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        if (t !== e && e.transactions) {
          const r = e.transactions, n = [];
          for (const s of r) if (s instanceof Y) n.push(s);
          else {
            const o = s.type;
            if (o) {
              const a = Re.trsTypeToV(o), p = Re.VM.get(a);
              if (!p) throw new xm(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: a });
              n.push(p.fromObject(s));
            }
          }
          t.transactions = n;
        }
        return t;
      }
    };
    Ta.INC = 1;
    l([A.d(cy.INC++, "bytes", "repeated"), u("design:type", Array)], Ta.prototype, "transactionBufferList", void 0);
    Ta = cy = l([R.d("MultipleModel")], Ta);
    let Yp = class extends Y {
      toJSON() {
        return { multiple: this.multiple.toJSON() };
      }
    };
    l([A.d(1, Ta), u("design:type", Ta)], Yp.prototype, "multiple", void 0);
    Yp = l([R.d("MultipleAssetModel")], Yp);
    let py;
    let Sa = py = class extends Je {
      as(e, t) {
        const r = Re.MV.get(e), n = Re.trsTypeToV(this.type);
        if (r === n) if (t) {
          if (this.signature === t) return this;
        } else return this;
        const { transactions: s } = this.asset.multiple;
        for (const o of s) {
          const a = o.as(e, t);
          if (a) return a;
        }
      }
      getBlobSize(e = false) {
        let t = 0;
        const r = this.blobMap.values();
        for (const n of r) t += n[3];
        if (e === false) {
          const { transactions: n } = this.asset.multiple;
          for (const s of n) t += s.getBlobSize(e);
        }
        return t;
      }
    };
    l([A.d(py.INC++, Yp), u("design:type", Yp)], Sa.prototype, "asset", void 0);
    Sa = py = l([R.d("MultipleTransaction")], Sa);
    let ly;
    const { ArgumentFormatException: Cm, error: bN, IllegalStateException: NN } = ee("MODEL", "transactionModel");
    const Zu = /* @__PURE__ */ new WeakMap();
    const ef = /* @__PURE__ */ new WeakMap();
    let wa = ly = class extends Y {
      get transaction() {
        const { transactionBuffer: e } = this;
        let t = Zu.get(e);
        if (!t) {
          const r = Je.decode(e), n = Re.trsTypeToV(r.type), s = Re.VM.get(n);
          if (!s) throw new Cm(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: n });
          t = s.decode(e), ef.set(t, e), Zu.set(e, t);
        }
        return t;
      }
      set transaction(e) {
        let t = ef.get(e);
        t || (t = e.getBytes(), ef.set(e, t), Zu.set(t, e)), this.transactionBuffer = t;
      }
      toJSON() {
        return { transaction: this.transaction.toJSON() };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        if (t !== e && e.transaction) {
          const r = e.transaction;
          if (r instanceof Y) t.transaction = r;
          else {
            const n = r.type;
            if (n) {
              const s = Re.trsTypeToV(n), o = Re.VM.get(s);
              if (!o) throw new Cm(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: s });
              t.transaction = o.fromObject(r);
            }
          }
        }
        return t;
      }
    };
    wa.INC = 1;
    l([A.d(ly.INC++, "bytes"), u("design:type", Uint8Array)], wa.prototype, "transactionBuffer", void 0);
    wa = ly = l([R.d("PromiseModel")], wa);
    let Qp = class extends Y {
      toJSON() {
        return { promise: this.promise.toJSON() };
      }
    };
    l([A.d(1, wa), u("design:type", wa)], Qp.prototype, "promise", void 0);
    Qp = l([R.d("PromiseAssetModel")], Qp);
    let hy;
    let no = hy = class extends Ve {
    };
    l([A.d(hy.INC++, Qp), u("design:type", Qp)], no.prototype, "asset", void 0);
    no = hy = l([R.d("PromiseTransaction")], no);
    let Tu;
    const { ArgumentFormatException: Rm } = ee("MODEL", "transactionModel");
    let so = Tu = class extends Y {
      get promiseId() {
        return xe(this.promiseIdBuffer);
      }
      set promiseId(e) {
        this.promiseIdBuffer = _e(e);
      }
      get transaction() {
        const { transactionBuffer: e } = this, t = Je.decode(e), r = Re.trsTypeToV(t.type), n = Re.VM.get(r);
        if (!n) throw new Rm(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: r });
        return n.decode(e);
      }
      set transaction(e) {
        this.transactionBuffer = e.getBytes();
      }
      toJSON() {
        return { promiseId: this.promiseId, transaction: this.transaction.toJSON() };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        if (t !== e && (e.promiseId && (t.promiseId = e.promiseId), e.transaction)) {
          const r = e.transaction;
          if (r instanceof Y) t.transaction = r;
          else {
            const n = r.type;
            if (n) {
              const s = Re.trsTypeToV(n), o = Re.VM.get(s);
              if (!o) throw new Rm(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: s });
              t.transaction = o.fromObject(r);
            }
          }
        }
        return t;
      }
    };
    so.INC = 1;
    l([A.d(Tu.INC++, "bytes"), u("design:type", Uint8Array)], so.prototype, "promiseIdBuffer", void 0);
    l([A.d(Tu.INC++, "bytes"), u("design:type", Uint8Array)], so.prototype, "transactionBuffer", void 0);
    so = Tu = l([R.d("PromiseResolveModel")], so);
    let Wp = class extends Y {
      toJSON() {
        return { resolve: this.resolve.toJSON() };
      }
    };
    l([A.d(1, so), u("design:type", so)], Wp.prototype, "resolve", void 0);
    Wp = l([R.d("PromiseResolveAssetModel")], Wp);
    let uy;
    let ba = uy = class extends Je {
      as(e, t) {
        const r = Re.MV.get(e);
        let n = Re.trsTypeToV(this.type);
        if (r === n) if (t) {
          if (this.signature === t) return this;
        } else return this;
        const { transaction: s } = this.asset.resolve;
        return s.as(e, t);
      }
      getBlobSize(e = false) {
        let t = 0;
        const r = this.blobMap.values();
        for (const n of r) t += n[3];
        return e === false && (t += this.asset.resolve.transaction.getBlobSize(e)), t;
      }
    };
    l([A.d(uy.INC++, Wp), u("design:type", Wp)], ba.prototype, "asset", void 0);
    ba = uy = l([R.d("PromiseResolveTransaction")], ba);
    let kt;
    (function(i) {
      i.TEXT = "text", i.ADDRESS = "address", i.PUBLICKEY = "publicKey", i.SIGNATURE = "signature", i.NUMBER = "number", i.CALC = "calc";
    })(kt || (kt = {}));
    let Na;
    (function(i) {
      i.STRING = "string", i.LITERAL = "literal";
    })(Na || (Na = {}));
    let Bm;
    (function(i) {
      i.FLOAT_32 = "float32", i.FLOAT_64 = "float64", i.FLOAT_128 = "float128", i.FLOAT_big = "bigfloat";
    })(Bm || (Bm = {}));
    let Ro;
    let zn = Ro = class extends Y {
      toJSON() {
        const e = { type: this.type, name: this.name, keyPath: this.keyPath };
        return this.pattern && (e.pattern = this.pattern), this.repeat !== void 0 && (e.repeat = this.repeat), e;
      }
    };
    zn.INC = 1;
    l([A.d(Ro.INC++, "string"), u("design:type", String)], zn.prototype, "type", void 0);
    l([A.d(Ro.INC++, "string"), u("design:type", String)], zn.prototype, "name", void 0);
    l([A.d(Ro.INC++, "string"), u("design:type", String)], zn.prototype, "keyPath", void 0);
    l([A.d(Ro.INC++, "string", "optional"), u("design:type", String)], zn.prototype, "pattern", void 0);
    l([A.d(Ro.INC++, "bool", "optional"), u("design:type", Boolean)], zn.prototype, "repeat", void 0);
    zn = Ro = l([R.d("BaseInputModel")], zn);
    let Bo;
    let Ls = Bo = class extends zn {
      toJSON() {
        const e = { ...super.toJSON(), format: this.format };
        return this.base && (e.base = this.base.toJSON()), this.min && (e.min = this.min.toJSON()), this.max && (e.max = this.max.toJSON()), this.step && (e.step = this.step.toJSON()), e;
      }
    };
    l([A.d(Bo.INC++, Nr, "optional"), u("design:type", Nr)], Ls.prototype, "base", void 0);
    l([A.d(Bo.INC++, Nr, "optional"), u("design:type", Nr)], Ls.prototype, "min", void 0);
    l([A.d(Bo.INC++, Nr, "optional"), u("design:type", Nr)], Ls.prototype, "max", void 0);
    l([A.d(Bo.INC++, Nr, "optional"), u("design:type", Nr)], Ls.prototype, "step", void 0);
    l([A.d(Bo.INC++, "string", "required", Na.LITERAL), u("design:type", String)], Ls.prototype, "format", void 0);
    Ls = Bo = l([R.d("NumberInputModel")], Ls);
    const Ct = class _Ct {
      constructor(e, t) {
        if (Object.defineProperty(this, "numerator", { enumerable: true, configurable: true, writable: true, value: e }), Object.defineProperty(this, "denominator", { enumerable: true, configurable: true, writable: true, value: t }), t < 0n) throw new RangeError("invalid denominator: should not be negative number.");
      }
      static from(e, t = 1) {
        e = e.toString().trim();
        let r = BigInt(t);
        const n = e.lastIndexOf(".");
        n !== -1 && (r = 10n ** BigInt(e.length - n - 1), e = e.slice(0, n) + e.slice(n + 1));
        let s = BigInt(e);
        return r < 0n && (r = -r, s = -s), new _Ct(s, r);
      }
      isFinite() {
        return this.denominator !== 0n;
      }
      isInfinity() {
        return this.denominator === 0n && this.numerator !== 0n;
      }
      isNaN() {
        return this.denominator === 0n && this.numerator === 0n;
      }
      isNeg() {
        return this.numerator < 0n;
      }
      toString() {
        return this.toPrecision(8);
      }
      toPrecision(e, t = Nc.ROUND) {
        if (this.isNaN()) return "NaN";
        if (this.isInfinity()) return this.isNeg() ? "-Infinity" : "Infinity";
        let { denominator: r, numerator: n } = this;
        if (r === 1n) return n.toString();
        const s = Math.floor(e), o = s + 1;
        if (o < 1) throw new Error("invalid digits");
        const a = 10n ** BigInt(o);
        let h = n * a / r, f = "";
        h < 0 && (f = "-", h = -h);
        const g = h / 10n;
        let d;
        switch (t) {
          case Nc.FLOOR:
            d = g.toString();
            break;
          case Nc.CEIL: {
            h % 10n !== 0n ? d = (g + 1n).toString() : d = g.toString();
            break;
          }
          default:
            h % 10n >= 5n ? d = (g + 1n).toString() : d = g.toString();
        }
        d = d.padStart(o, "0");
        let y = d.slice(0, -s) + "." + d.slice(-s);
        return y.endsWith("0") && (y = y.replace(/[.0]+$/, "")), f + y;
      }
    };
    let Nc;
    (function(i) {
      i[i.FLOOR = 0] = "FLOOR", i[i.ROUND = 1] = "ROUND", i[i.CEIL = 2] = "CEIL";
    })(Nc || (Nc = {}));
    const fy = (i, e, t) => {
      if (i.denominator === e.denominator) return new Ct(t(i.numerator, e.numerator, i.denominator), i.denominator);
      const r = i.numerator * e.denominator, n = e.numerator * i.denominator, s = i.denominator * e.denominator;
      return new Ct(t(r, n, s), i.denominator * e.denominator);
    };
    const VI = (i, e) => fy(i, e, (t, r) => t + r);
    const GI = (i, e) => fy(i, e, (t, r) => t - r);
    const _A = (i, e) => fy(i, e, (t, r) => t * r);
    const KI = (i, e) => _A(i, new Ct(e.denominator, e.numerator));
    new Ct(0n, 0n);
    new Ct(1n, 1n);
    new Ct(0n, 1n);
    Ct.from(Math.PI);
    Ct.from(Math.E);
    Ct.from(Math.LN2);
    Ct.from(Math.LN10);
    Ct.from(Math.LOG2E);
    Ct.from(Math.LOG10E);
    Ct.from(Math.SQRT1_2);
    const Dr = class {
      constructor(e, t = {}) {
        Object.defineProperty(this, "label", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "isBinary", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "isPrefix", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "precedence", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "updateContext", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.label = e, this.isBinary = !!t.isBinary, this.isPrefix = !!t.isPrefix, this.precedence = t.precedence ?? -1;
      }
    };
    const Tt = { start: new Dr("start"), end: new Dr("end"), parenL: new Dr("("), parenR: new Dr(")"), numeric: new Dr("numeric"), identifier: new Dr("identifier"), plus: new Dr("+", { isBinary: true, precedence: 13 }), minus: new Dr("-", { isBinary: true, precedence: 13 }), times: new Dr("*", { isBinary: true, precedence: 14 }), div: new Dr("/", { isBinary: true, precedence: 14 }), prefixPlus: new Dr("+", { isPrefix: true, precedence: 16 }), prefixMinus: new Dr("-", { isPrefix: true, precedence: 16 }) };
    Tt.parenL.updateContext = function() {
      this.allowPrefix = true;
    };
    Tt.parenR.updateContext = function() {
      this.allowPrefix = false;
    };
    Tt.numeric.updateContext = function() {
      this.allowPrefix = false;
    };
    Tt.identifier.updateContext = function() {
      this.allowPrefix = false;
    };
    const gy = class {
      constructor(e) {
        Object.defineProperty(this, "type", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "start", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "end", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.type = "", this.start = e, this.end = e;
      }
    };
    function dy(i) {
      return i >= 48 && i <= 57;
    }
    function AA(i) {
      return i === 46 ? true : dy(i);
    }
    function EA(i) {
      return i >= 65 && i <= 90 || i >= 97 && i <= 122;
    }
    function zI(i) {
      return !!(EA(i) || dy(i) || i === 95);
    }
    function jI(i) {
      let e = i;
      const t = [];
      for (let r = 0; r < e.length; r++) e.charCodeAt(r) !== 95 && t.push(e[r]);
      return t.length !== e.length && (e = t.join("")), e;
    }
    const Pm = ["+", "-", "*", "/", "(", ")"];
    const Hs = [];
    function JI(i) {
      Hs.includes(i) || Hs.unshift(i);
    }
    function IA(i, e) {
      if (typeof i !== "string" || !/^\S+$/.test(i)) throw new Error("The custom operator should be a non-empty string");
      if (Pm.includes(i)) throw new Error(`The custom operator cannot use reserved character, including: ${Pm.join(", ")}`);
      if (AA(i.charCodeAt(0))) throw new Error("The custom operator cannot start with a possible number, including: `.`, 0-9");
      if (i.charCodeAt(0) === 63) throw new Error("The custom operator cannot start with `?`");
      if (e != null && (typeof e !== "number" || e < 0)) throw new Error("The precedence should be a number greater than 0");
    }
    const TA = class {
      constructor(e, t, r, n = false) {
        Object.defineProperty(this, "value", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "codes", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "type", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "calc", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.value = e, this.codes = e.split("").map((s, o) => e.charCodeAt(o)), this.type = new Dr(e, { isBinary: !n, isPrefix: n, precedence: t }), this.calc = r;
      }
    };
    function YI(i, e, t) {
      if (IA(i, e), typeof t !== "function") throw new Error("Expected to receive a calculation method, like: `(left, right) => String(left - right)`");
      return new TA(i, e, t, false);
    }
    function QI(i, e, t) {
      if (IA(i, e), typeof t !== "function") throw new Error("Expected to receive a calculation method, like: `(value) => String(Math.abs(value))`");
      return new TA(i, e, t, true);
    }
    let SA = { "+": (i, e) => String(Number(i) + Number(e)), "-": (i, e) => String(Number(i) - Number(e)), "*": (i, e) => String(Number(i) * Number(e)), "/": (i, e) => String(Number(i) / Number(e)) };
    function WI(i) {
      const e = ["+", "-", "*", "/"];
      i = i || {}, e.forEach((t) => {
        if (typeof i[t] !== "function") throw new Error(`Missing method for calculation operator \`${t}\``);
      }), SA = i;
    }
    function XI(i, e, t) {
      switch (t) {
        case "+":
        case "-":
        case "*":
        case "/":
          return SA[t](i, e);
        default:
          for (let r = 0; r < Hs.length; r++) {
            const n = Hs[r];
            if (n.type.isBinary && n.value === t) return n.calc(i, e);
          }
      }
      throw new Error(`Unexpected binary operator: ${t}`);
    }
    function qI(i, e) {
      switch (e) {
        case "+":
          return i;
        case "-":
          return String(-i);
        default:
          for (let t = 0; t < Hs.length; t++) {
            const r = Hs[t];
            if (r.type.isPrefix && r.value === e) return r.calc(i);
          }
      }
      throw new Error(`Unexpected unary operator: ${e}`);
    }
    function Ic(i, e = {}) {
      if (i instanceof gy) {
        let t;
        switch (i.type) {
          case "Expression":
            return Ic(i.expression, e);
          case "BinaryExpression":
            return XI(Ic(i.left, e), Ic(i.right, e), i.operator);
          case "UnaryExpression":
            return qI(Ic(i.argument, e), i.operator);
          case "NumericLiteral":
            return i.value;
          case "Identifier":
            if (t = e[i.name], t === void 0) throw new Error(`The scope name \`${i.name}\` is not initialized`);
            return String(t);
          default:
            throw new Error(`Unexpected type: ${i.type}`);
        }
      }
      return i;
    }
    const Nn = class _Nn {
      static evaluate(e, t) {
        return new _Nn(e).compile()(t);
      }
      constructor(e) {
        Object.defineProperty(this, "input", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "node", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "pos", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tokenType", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "start", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "end", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "lastTokenStart", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "lastTokenEnd", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "allowPrefix", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.input = String(e), this.tokenType = Tt.start, this.value = "", this.pos = 0, this.start = 0, this.end = 0, this.lastTokenStart = 0, this.lastTokenEnd = 0, this.allowPrefix = true;
      }
      compile() {
        let e = this.node;
        return e === void 0 && (e = this.parse()), (t) => e ? Ic(e, t ?? {}) : "0";
      }
      parse() {
        this.next();
        const e = this.startNode(this.start);
        return this.tokenType === Tt.end ? this.node = null : (e.expression = this.parseExprAtom(this.start, -1), this.tokenType !== Tt.end && this.unexpected(this.value), this.node = this.finishNode(e, "Expression"));
      }
      parseExprAtom(e, t) {
        if (this.tokenType === Tt.parenL) {
          this.next();
          const r = this.parseExprAtom(this.start, -1);
          return this.expect(Tt.parenR), this.parseMaybeBinary(r, e, t);
        } else {
          const r = this.parseMaybeUnary(t);
          return this.parseMaybeBinary(r, e, t);
        }
      }
      parseMaybeBinary(e, t, r) {
        const n = this.tokenType.precedence;
        if (this.tokenType.isBinary && n > r) {
          const s = this.startNode(t), o = this.value;
          this.next();
          const a = this.start, p = this.parseExprAtom(a, n), h = this.parseMaybeBinary(p, a, n);
          return s.left = e, s.operator = o, s.right = h, this.finishNode(s, "BinaryExpression"), this.parseMaybeBinary(s, t, r);
        }
        return e;
      }
      parseMaybeUnary(e) {
        const t = this.tokenType.precedence, r = this.startNode(), n = this.start, s = this.value;
        if (this.tokenType.isPrefix && t >= e) return r.operator = s, r.prefix = true, this.next(), r.argument = this.parseExprAtom(this.start, t), this.finishNode(r, "UnaryExpression");
        if (this.tokenType === Tt.numeric) {
          const o = jI(s);
          return r.rawValue = s, r.value = o, this.next(), this.finishNode(r, "NumericLiteral");
        }
        return this.tokenType === Tt.identifier ? (r.name = s, this.next(), this.finishNode(r, "Identifier")) : this.unexpected(s, n);
      }
      next() {
        if (this.lastTokenStart = this.start, this.lastTokenEnd = this.end, this.skipSpace(), this.start = this.pos, this.pos >= this.input.length) {
          if (this.tokenType === Tt.end) return;
          this.finishToken(Tt.end);
        } else this.readToken();
      }
      readToken() {
        const e = this.codeAt(this.pos);
        return AA(e) ? this.readNumeric() : this.readTokenFromCode();
      }
      readNumeric() {
        const e = this.pos;
        let t = -1, r = true, n = false, s = false, o = -1;
        for (; this.isValidPosition(); ) {
          const p = this.codeAt(this.pos);
          if (dy(p)) t === -1 && (t = 0), this.pos++, s = false, n = true;
          else if (s) {
            o = this.pos, s = false;
            break;
          } else if (p === 69 || p === 101) {
            if (t !== 0) {
              o = this.pos;
              break;
            }
            t++, this.pos++, this.isValidPosition() && (this.codeAt(this.pos) === 43 || this.codeAt(this.pos) === 45) && this.pos++, r = false, s = true;
          } else if (p === 46) {
            if (!r) {
              o = this.pos;
              break;
            }
            r = false, this.pos++, this.pos - e === 1 && (s = true);
          } else if (p === 95) {
            if (!n) {
              o = this.pos;
              break;
            }
            n = false, s = true, this.pos++;
          } else break;
        }
        s && (o = this.pos - 1), o >= 0 && this.unexpected(this.input[o], o);
        const a = this.input.slice(e, this.pos);
        this.finishToken(Tt.numeric, a);
      }
      readTokenFromCode() {
        const e = this.codeAt(this.pos);
        let t, r, n;
        for (r = 0; r < Hs.length; r++) {
          const s = Hs[r];
          for (n = 0; n < s.codes.length && s.codes[n] === this.codeAt(this.pos + n); n++) ;
          if (n === s.codes.length) {
            t = s;
            break;
          }
        }
        if (t) return this.pos += t.codes.length, this.finishToken(t.type, t.value);
        switch (e) {
          case 40:
            return this.pos++, this.finishToken(Tt.parenL, "(");
          case 41:
            return this.pos++, this.finishToken(Tt.parenR, ")");
          case 42:
            return this.pos++, this.finishToken(Tt.times, "*");
          case 43:
            return this.pos++, this.allowPrefix ? this.finishToken(Tt.prefixPlus, "+") : this.finishToken(Tt.plus, "+");
          case 45:
            return this.pos++, this.allowPrefix ? this.finishToken(Tt.prefixMinus, "-") : this.finishToken(Tt.minus, "-");
          case 47:
            return this.pos++, this.finishToken(Tt.div, "/");
          default:
            if (EA(e)) return this.readIdentifier();
        }
        this.unexpected(this.input[this.pos]);
      }
      readIdentifier() {
        const e = this.pos;
        for (; this.isValidPosition(); ) {
          const r = this.codeAt(this.pos);
          if (zI(r)) this.pos++;
          else break;
        }
        const t = this.input.slice(e, this.pos);
        this.finishToken(Tt.identifier, t);
      }
      finishToken(e, t = "") {
        const r = this.tokenType;
        this.end = this.pos, this.tokenType = e, this.value = t, this.updateContext(r);
      }
      updateContext(e) {
        const t = this.tokenType;
        t.isBinary || t.isPrefix ? this.allowPrefix = true : t.updateContext && t.updateContext.call(this, e);
      }
      codeAt(e) {
        return this.input.charCodeAt(e);
      }
      isValidPosition() {
        return this.pos < this.input.length;
      }
      startNode(e) {
        return new gy(e ?? this.start);
      }
      finishNode(e, t) {
        return e.type = t, e.end = this.lastTokenEnd, e;
      }
      skipSpace() {
        for (; this.isValidPosition(); ) {
          const e = this.codeAt(this.pos);
          if (e === 32 || e === 160) this.pos++;
          else if (e === 13 || e === 10 || e === 8232 || e === 8233) e === 13 && this.codeAt(this.pos + 1) === 10 && this.pos++, this.pos++;
          else if (e > 8 && e < 14) this.pos++;
          else break;
        }
      }
      expect(e) {
        this.eat(e) || this.unexpected(this.value);
      }
      eat(e) {
        return this.tokenType === e ? (this.next(), true) : false;
      }
      unexpected(e = "", t) {
        this.raise(t ?? this.start, `Unexpected token ${e}`);
      }
      raise(e, t) {
        throw e > this.input.length - 1 ? t = "Unexpected end of input" : t += ` at position ${e}`, new SyntaxError(t);
      }
    };
    Object.defineProperty(Nn, "Node", { enumerable: true, configurable: true, writable: true, value: gy });
    Object.defineProperty(Nn, "TokenType", { enumerable: true, configurable: true, writable: true, value: Dr });
    Object.defineProperty(Nn, "tokenTypes", { enumerable: true, configurable: true, writable: true, value: Tt });
    Object.defineProperty(Nn, "installedOperators", { enumerable: true, configurable: true, writable: true, value: Hs });
    const wA = Nn.evaluate;
    Nn.createBinaryOperator = YI;
    Nn.createUnaryOperator = QI;
    Nn.useOperator = JI;
    Nn.useAdapter = WI;
    const ZI = { "+": (i, e) => VI(Ct.from(i), Ct.from(e)).toString(), "-": (i, e) => GI(Ct.from(i), Ct.from(e)).toString(), "*": (i, e) => _A(Ct.from(i), Ct.from(e)).toString(), "/": (i, e) => KI(Ct.from(i), Ct.from(e)).toString() };
    Nn.useAdapter(ZI);
    let Su;
    let Xp = Su = class extends Ls {
      toJSON() {
        return { ...super.toJSON(), calc: this.calc, precision: this.precision };
      }
      evaluate(e) {
        return wA(this.calc, e);
      }
    };
    l([A.d(Su.INC++, "string"), u("design:type", String)], Xp.prototype, "calc", void 0);
    l([A.d(Su.INC++, "string"), u("design:type", String)], Xp.prototype, "precision", void 0);
    Xp = Su = l([R.d("CalcInputModel")], Xp);
    let xa = class extends zn {
    };
    xa = l([R.d("TextInputModel")], xa);
    let Of = class extends xa {
    };
    Of = l([R.d("AddressInputModel")], Of);
    let Cf = class extends xa {
    };
    Cf = l([R.d("SignatureInputModel")], Cf);
    let Rf = class extends xa {
    };
    Rf = l([R.d("PublicKeyInputModel")], Rf);
    const Mm = (() => {
      const i = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
      return [[kt.NUMBER, Ls], [kt.CALC, Xp], [kt.TEXT, xa], [kt.ADDRESS, Of], [kt.PUBLICKEY, Rf], [kt.SIGNATURE, Cf]].forEach(([t, r]) => {
        i.set(t, r), e.set(r, t);
      }), { VM: i, MV: e };
    })();
    let wu;
    const { ArgumentFormatException: Vl } = ee("MODEL", "transactionModel");
    let io = wu = class extends Y {
      get inputs() {
        return this.inputBufferList.map((e) => {
          const t = zn.decode(e), r = Mm.VM.get(t.type);
          if (!r) throw new Vl(c.INVALID_MACRO_INPUT_TYPE, { type_base: t.type });
          return r.decode(e);
        });
      }
      set inputs(e) {
        const t = e.map((r) => r.getBytes());
        this.inputBufferList = t;
      }
      get template() {
        const { templateBuffer: e } = this, t = Je.decode(e), r = Re.trsTypeToV(t.type), n = Re.VM.get(r);
        if (!n) throw new Vl(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: r });
        return n.decode(e);
      }
      set template(e) {
        this.templateBuffer = e.getBytes();
      }
      toJSON() {
        return { inputs: this.inputs.map((t) => t.toJSON()), template: this.template.toJSON() };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        if (t !== e) {
          if (e.inputs) {
            const r = e.inputs, n = [];
            for (const s of r) if (s instanceof Y) n.push(s);
            else {
              const o = s.type, a = Mm.VM.get(o);
              if (!a) throw new Vl(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: o });
              n.push(a.fromObject(s));
            }
            t.inputs = n;
          }
          if (e.template) {
            const r = e.template;
            if (r instanceof Y) t.template = r;
            else {
              const n = r.type;
              if (n) {
                const s = Re.trsTypeToV(n), o = Re.VM.get(s);
                if (!o) throw new Vl(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: s });
                t.template = o.fromObject(r);
              }
            }
          }
        }
        return t;
      }
    };
    io.INC = 1;
    l([A.d(wu.INC++, "bytes", "repeated"), u("design:type", Array)], io.prototype, "inputBufferList", void 0);
    l([A.d(wu.INC++, "bytes"), u("design:type", Uint8Array)], io.prototype, "templateBuffer", void 0);
    io = wu = l([R.d("MacroModel")], io);
    let qp = class extends Y {
      toJSON() {
        return { macro: this.macro.toJSON() };
      }
    };
    l([A.d(1, io), u("design:type", io)], qp.prototype, "macro", void 0);
    qp = l([R.d("MacroAssetModel")], qp);
    let yy;
    let oo = yy = class extends Ve {
    };
    l([A.d(yy.INC++, qp), u("design:type", qp)], oo.prototype, "asset", void 0);
    oo = yy = l([R.d("MacroTransaction")], oo);
    const eT = (i) => typeof i === "object" && i !== null && typeof i.then === "function";
    const Yt = class {
      constructor() {
        this.is_resolved = false, this.is_rejected = false, this.is_finished = false, this.promise = new Promise((e, t) => {
          this.resolve = (r) => {
            try {
              eT(r) ? r.then(this.resolve, this.reject) : (this.is_resolved = true, this.is_finished = true, e(this.value = r), this._runThen(), this._innerFinallyArg = Object.freeze({ status: "resolved", result: this.value }), this._runFinally());
            } catch (n) {
              this.reject(n);
            }
          }, this.reject = (r) => {
            this.is_rejected = true, this.is_finished = true, t(this.reason = r), this._runCatch(), this._innerFinallyArg = Object.freeze({ status: "rejected", reason: this.reason }), this._runFinally();
          };
        });
      }
      onSuccess(e) {
        this.is_resolved ? this.__callInnerThen(e) : (this._innerThen || (this._innerThen = [])).push(e);
      }
      onError(e) {
        this.is_rejected ? this.__callInnerCatch(e) : (this._innerCatch || (this._innerCatch = [])).push(e);
      }
      onFinished(e) {
        this.is_finished ? this.__callInnerFinally(e) : (this._innerFinally || (this._innerFinally = [])).push(e);
      }
      _runFinally() {
        if (this._innerFinally) {
          for (const e of this._innerFinally) this.__callInnerFinally(e);
          this._innerFinally = void 0;
        }
      }
      __callInnerFinally(e) {
        queueMicrotask(async () => {
          try {
            await e(this._innerFinallyArg);
          } catch (t) {
            
          }
        });
      }
      _runThen() {
        if (this._innerThen) {
          for (const e of this._innerThen) this.__callInnerThen(e);
          this._innerThen = void 0;
        }
      }
      _runCatch() {
        if (this._innerCatch) {
          for (const e of this._innerCatch) this.__callInnerCatch(e);
          this._innerCatch = void 0;
        }
      }
      __callInnerThen(e) {
        queueMicrotask(async () => {
          try {
            await e(this.value);
          } catch (t) {
            
          }
        });
      }
      __callInnerCatch(e) {
        queueMicrotask(async () => {
          try {
            await e(this.value);
          } catch (t) {
            
          }
        });
      }
    };
    const tT = (i, e) => ["%c" + i, e];
    const ai = /* @__PURE__ */ Symbol("eventemitter.description");
    const vt = { head: tT, MIDNIGHTBLUE_BOLD_UNDERLINE: "color:midnightblue;text-decoration: underline;font-weight: bold;", DARKVIOLET_BOLD_UNDERLINE: "color:darkviolet;text-decoration: underline;font-weight: bold;" };
    function bA(i, e) {
      const t = Object.getOwnPropertyDescriptor(i, "name");
      t && t.configurable && Object.defineProperty(i, "name", { value: e, configurable: true });
    }
    const NA = Ss.getGlobalFlag("BFCHAIN_ENV", "development");
    NA.split(",").map((i) => i.trim());
    const Bf = /* @__PURE__ */ new Map();
    for (const i of NA.split(",")) {
      const [e, t] = i.split("=").map((s) => s.trim());
      let r = e, n = false;
      r.startsWith("- ") && (n = true, r = r.substr(2)), n ? Bf.delete(r) : Bf.set(r, t);
    }
    function Zp(i) {
      return Bf.has(i);
    }
    const Wr = Zp("eventemitter") && Zp("browser");
    const An = class {
      constructor() {
        this._e = /* @__PURE__ */ Object.create(null);
      }
      on(e, t, r = {}) {
        this._on(e, t, r.taskname, r.once);
      }
      _on(e, t, r, n) {
        const s = this._e;
        let o = s[e];
        o ? o.has(t) &&  : o = s[e] = /* @__PURE__ */ new Map(), r === void 0 && (r = xl(this.constructor)), o.set(t, { taskname: r, once: n });
      }
      once(e, t, r = {}) {
        this._on(e, t, r.taskname, true);
      }
      off(e, t) {
        return this._off(e, t);
      }
      _off(e, t) {
        const r = this._e[e];
        let n = true;
        return r ? t ? r.delete(t) && r.size === 0 && delete this._e[e] : (r.clear(), delete this._e[e]) : n = false, n;
      }
      get [ai]() {
        return "";
      }
      emit(e, ...t) {
        this._emit(e, t);
      }
      _emit(e, t) {
        const r = this._e[e];
        if (Wr && (console.group(...vt.head("%s EMIT [%s]", vt.MIDNIGHTBLUE_BOLD_UNDERLINE), this[ai] || this, e), console.log(...vt.head("%s ARGS:", vt.MIDNIGHTBLUE_BOLD_UNDERLINE), ...t)), r) for (const [n, s] of r.entries()) try {
          if (Wr) {
            const { taskname: a = n.name } = s;
            
          }
          const o = n(...t);
          o instanceof Promise && o.catch((a) => this._emitErrorHanlder(a, e, t));
        } catch (o) {
          this._emitErrorHanlder(o, e, t);
        } finally {
          s.once && r.delete(n);
        }
        Wr && ;
      }
      _emitErrorHanlder(e, t, r) {
        if (!this._hasEmitErrorHandlerSet) throw Wr && , e;
        for (const n of this._emitErrorHandlerSet) n(e, { eventname: t, args: r });
      }
      get _emitErrorHandlerSet() {
        return this._hasEmitErrorHandlerSet = true, /* @__PURE__ */ new Set();
      }
      onError(e, t) {
        typeof t === "string" && bA(e, t), this._emitErrorHandlerSet.has(e) && , this._emitErrorHandlerSet.add(e);
      }
      offError(e) {
        return !!this._hasEmitErrorHandlerSet && (e ? this._emitErrorHandlerSet.delete(e) : (this._emitErrorHandlerSet.clear(), true));
      }
      clear(e = {}) {
        this._e = /* @__PURE__ */ Object.create(null);
        const { ignoreCustomErrorHanlder: t } = e;
        !t && this._hasEmitErrorHandlerSet && this._emitErrorHandlerSet.clear();
      }
      get removeAllListeners() {
        return this.clear;
      }
      get addListener() {
        return this.on;
      }
      get removeListener() {
        return this.off;
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], An.prototype, "_emitErrorHandlerSet", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], An.prototype, "removeAllListeners", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], An.prototype, "addListener", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], An.prototype, "removeListener", null);
    const Lm = (i) => !(!i || !i.constructor) && typeof i.next === "function" && typeof i.return === "function" && typeof i.throw === "function" && typeof i[Symbol.asyncIterator] === "function" && i[Symbol.asyncIterator]() === i;
    const Hm = (i) => !!i && typeof i.next === "function" && typeof i.return === "function" && typeof i.throw === "function" && typeof i[Symbol.iterator] === "function" && i[Symbol.iterator]() === i;
    const ii = class {
      constructor() {
        this._e = /* @__PURE__ */ Object.create(null);
      }
      on(e, t, r = {}) {
        let n = this._e[e];
        n ? n.has(t) &&  : n = this._e[e] = /* @__PURE__ */ new Map(), r.taskname === void 0 && (r.taskname = xl(this.on)), n.set(t, r);
      }
      once(e, t, r) {
        return this.on(e, t, r ? new Proxy(r, { get: (n, s, o) => s === "once" || Reflect.get(n, s, o) }) : { once: true });
      }
      has(e, t) {
        const r = this._e[e];
        return !!r && (t ? r.has(t) : r.size > 0);
      }
      off(e, t) {
        const r = this._e[e];
        let n = false;
        return r && (n = r.delete(t)) && r.size === 0 && delete this._e[e], n;
      }
      get [ai]() {
        return "";
      }
      emit(e, t) {
        const r = this._e[e];
        if (r) {
          Wr && r.size && ;
          const n = r.entries(), s = (a) => {
            if (typeof a === "object") {
              if (Lm(a)) return (async () => {
                try {
                  const p = a[Symbol.asyncIterator]();
                  for (; ; ) {
                    const h = await p.next();
                    if (h.done) return h.value;
                  }
                } catch (p) {
                  this._emitErrorHanlder(p, e, t);
                }
              })();
              if (Hm(a)) {
                const p = a[Symbol.iterator]();
                try {
                  for (; ; ) {
                    const h = p.next();
                    if (h.done) return h.value;
                  }
                } catch (h) {
                  this._emitErrorHanlder(h, e, t);
                }
              }
            }
            return a;
          }, o = () => {
            const a = n.next();
            if (!a.done) {
              const [p, h] = a.value;
              try {
                Wr && ;
                const f = p(t, o);
                return f instanceof Promise ? f.then(s, (g) => this._emitErrorHanlder(g, e, t)) : s(f);
              } catch (f) {
                this._emitErrorHanlder(f, e, t);
              } finally {
                h.once && r.delete(p);
              }
            }
          };
          return o();
        }
      }
      async *emitToAsyncGenerator(e, t) {
        const r = this._e[e];
        if (r) {
          Wr && r.size && ;
          const n = r.entries(), s = async function* () {
            const o = n.next();
            if (!o.done) {
              const [a, p] = o.value;
              try {
                Wr && , yield;
                const h = await a(t, s);
                if (typeof h === "object") {
                  if (Lm(h)) return yield* h;
                  if (Hm(h)) return yield* h;
                }
                return h;
              } catch (h) {
                this._emitErrorHanlder(h, e, t);
              } finally {
                p.once && r.delete(a);
              }
            }
          }.bind(this);
          return yield* s();
        }
      }
      clear(e = {}) {
        this._e = /* @__PURE__ */ Object.create(null);
        const { ignoreCustomErrorHanlder: t } = e;
        !t && this._hasEmitErrorHandlerSet && this._emitErrorHandlerSet.clear();
      }
      get removeAllListeners() {
        return this.clear;
      }
      get addListener() {
        return this.on;
      }
      get removeListener() {
        return this.off;
      }
      _emitErrorHanlder(e, t, r) {
        if (!this._hasEmitErrorHandlerSet) throw Wr && , e;
        for (const n of this._emitErrorHandlerSet) n(e, { eventname: t, arg: r });
      }
      get _emitErrorHandlerSet() {
        return this._hasEmitErrorHandlerSet = true, /* @__PURE__ */ new Set();
      }
      onError(e, t) {
        typeof t === "string" && bA(e, t), this._emitErrorHandlerSet.has(e) && , this._emitErrorHandlerSet.add(e);
      }
      offError(e) {
        return !!this._hasEmitErrorHandlerSet && (e ? this._emitErrorHandlerSet.delete(e) : (this._emitErrorHandlerSet.clear(), true));
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ii.prototype, "removeAllListeners", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], ii.prototype, "addListener", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], ii.prototype, "removeListener", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], ii.prototype, "_emitErrorHandlerSet", null);
    const eh = class extends An {
      _emit(e, t) {
        if (this._hasBeforeTaskMap) {
          const r = this._beforeTasks[e];
          r && (delete this._beforeTasks[e], r.resolve(t));
        }
        if (this._hasCommonEmitHandlerMap) {
          Wr && this._commonEmitHandlerMap.size && ;
          for (const [r, n] of this._commonEmitHandlerMap) try {
            if (Wr) {
              const { taskname: o = r.name } = n;
              
            }
            const s = r({ eventname: e, args: t });
            s instanceof Promise && s.catch((o) => this._emitErrorHanlder(o, e, t));
          } catch (s) {
            this._emitErrorHanlder(s, e, t);
          } finally {
            n.once && this._commonEmitHandlerMap.delete(r);
          }
        }
        if (super._emit(e, t), this._hasAfterTaskMap) {
          const r = this._afterTasks[e];
          r && (delete this._afterTasks[e], r.resolve(t));
        }
      }
      clear(e = {}) {
        super.clear(e);
        const { ignoreCommonErrorHanlder: t, ignoreBeforeTask: r, ignoreAfterTask: n } = e;
        if (!t && this._hasCommonEmitHandlerMap && this._commonEmitHandlerMap.clear(), !r && this._hasBeforeTaskMap) {
          const s = new Error("Remove all listeners");
          for (const o in this._beforeTasks) this._beforeTasks[o].reject(s);
        }
        if (!n && this._hasAfterTaskMap) {
          const s = new Error("Remove all listeners");
          for (const o in this._afterTasks) this._afterTasks[o].reject(s);
        }
      }
      get _commonEmitHandlerMap() {
        return this._hasCommonEmitHandlerMap = true, /* @__PURE__ */ new Map();
      }
      onEmit(e, t = {}) {
        this._commonEmitHandlerMap.has(e) && , t.taskname === void 0 && (t.taskname = xl(this.onEmit)), this._commonEmitHandlerMap.set(e, t);
      }
      offEmit(e) {
        return !!this._hasCommonEmitHandlerMap && (e ? this._commonEmitHandlerMap.delete(e) : (this._commonEmitHandlerMap.clear(), true));
      }
      get _afterTasks() {
        return this._hasAfterTaskMap = true, /* @__PURE__ */ Object.create(null);
      }
      after(e) {
        let t = this._afterTasks[e];
        return t || (t = this._afterTasks[e] = new Yt()), t.promise;
      }
      abortAfter(e, t) {
        const r = this._afterTasks[e];
        return r && r.reject(t), r;
      }
      get _beforeTasks() {
        return this._hasBeforeTaskMap = true, /* @__PURE__ */ Object.create(null);
      }
      before(e) {
        let t = this._beforeTasks[e];
        return t || (t = this._beforeTasks[e] = new Yt()), t.promise;
      }
      abortBefore(e, t) {
        const r = this._beforeTasks[e];
        return r && r.reject(t), r;
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], eh.prototype, "_commonEmitHandlerMap", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], eh.prototype, "_afterTasks", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], eh.prototype, "_beforeTasks", null);
    const xA = class extends ii {
      emit(e, t) {
        if (this._hasCommonEmitHandlerMap) {
          if (Wr && this._commonEmitHandlerMap.size) {
            const r = this[ai] || this;
            
          }
          for (const [r, n] of this._commonEmitHandlerMap) try {
            if (Wr) {
              const { taskname: o = r.name } = n;
              
            }
            const s = r({ eventname: e, args: t });
            s instanceof Promise && s.catch((o) => this._emitErrorHanlder(o, e, t));
          } catch (s) {
            this._emitErrorHanlder(s, e, t);
          } finally {
            n.once && this._commonEmitHandlerMap.delete(r);
          }
        }
        return super.emit(e, t);
      }
      get _commonEmitHandlerMap() {
        return this._hasCommonEmitHandlerMap = true, /* @__PURE__ */ new Map();
      }
      onEmit(e, t = {}) {
        this._commonEmitHandlerMap.has(e) && , t.taskname === void 0 && (t.taskname = xl(this.onEmit)), this._commonEmitHandlerMap.set(e, t);
      }
      offEmit(e) {
        return !!this._hasCommonEmitHandlerMap && (e ? this._commonEmitHandlerMap.delete(e) : (this._commonEmitHandlerMap.clear(), true));
      }
      clear(e = {}) {
        super.clear(e);
        const { ignoreCommonErrorHanlder: t } = e;
        !t && this._hasCommonEmitHandlerMap && this._commonEmitHandlerMap.clear();
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xA.prototype, "_commonEmitHandlerMap", null);
    const Sr = class extends ii {
      constructor() {
        super(...arguments), this.list = [], this.min_next_index = 0, this.calcs = [], this._is_rejected = false, this._is_resolved = false, this._requestProcess = 0;
      }
      canPush(e) {
        return !(e < this.min_next_index || e in this.list || this.is_done);
      }
      push(e, t = this.min_next_index) {
        if (t < this.min_next_index) throw new RangeError(`push into wrong index:${t}, should be ${this.min_next_index}`);
        if (t in this.list || t in this.calcs) throw new TypeError(`index:${t} already have value`);
        for (this.list[t] = e; this.list[this.min_next_index]; ) this.min_next_index += 1;
        return this.emit("push", { item: e, index: t });
      }
      pushCalc(e, t = this.min_next_index) {
        if (t < this.min_next_index) throw new RangeError(`push into wrong index:${t}, should be ${this.min_next_index}`);
        if (t in this.list || t in this.calcs) throw new TypeError(`index:${t} already have value`);
        const r = () => {
          delete this.calcs[t];
          const n = this.list[t] = e();
          return this.emit("push", { item: n, index: t }), n;
        };
        for (this.calcs[t] = r; this.list[this.min_next_index]; ) this.min_next_index += 1;
        return this.emit("pushCalc", { calc: r, index: t });
      }
      get is_done() {
        return this._is_rejected || this._is_resolved;
      }
      _initTask() {
        let e = this._task;
        return e || (e = this._task = new Yt(), this._is_rejected ? e.reject(this._reason) : this._is_resolved ? e.resolve(this.list) : (this._requestProcess = 1 / 0, this.emit("requestAll", void 0))), e.promise;
      }
      async done() {
        let e;
        if (!this.is_done) {
          for (this._is_resolved = true, (e = this._task) == null ? void 0 : e.resolve(this.list); ; ) {
            const t = new Set(Object.keys(this.calcs));
            if (t.size === 0) break;
            await new Promise((r, n) => {
              const s = () => {
                this.off("push", o), this.off("error", a);
              }, o = (p) => {
                t.delete(p.index.toString()) && t.size === 0 && (r(), s());
              }, a = () => {
                n(), s();
              };
              this.on("push", o), this.once("error", a);
            });
          }
          return Object.freeze(this.list), this.emit("done", void 0);
        }
      }
      throw(e) {
        let t;
        if (!this.is_done) return this._is_rejected = true, (t = this._task) == null || t.reject(e), Object.freeze(this.list), this.emit("error", this._reason = e);
      }
      resolve() {
        return this.done();
      }
      reject(e) {
        return this.throw(e);
      }
      then(...e) {
        return this._initTask().then(...e);
      }
      catch(...e) {
        return this._initTask().catch(...e);
      }
      get requestProcess() {
        return this._requestProcess;
      }
      [Symbol.asyncIterator]() {
        const e = this, { list: t, calcs: r } = e;
        return { index: 0, return: () => (_f(e.done()), Promise.resolve({ done: true, value: void 0 })), async next() {
          const n = this.index;
          r[n] && _f(r[n]());
          const s = t[n];
          let o = { done: e.is_done, value: s };
          return n in t ? o.done = false : e.is_done || (o = await new Promise(async (a, p) => {
            const h = () => {
              e.off("error", f), e.off("push", d), e.off("pushCalc", y), e.off("done", g);
            }, f = (_, I) => (h(), p(_), I()), g = (_, I) => (h(), a({ done: true, value: s }), I()), d = ({ item: _, index: I }, S) => (n === I && (h(), a({ done: false, value: _ })), S()), y = ({ calc: _, index: I }, S) => (n === I && (h(), a({ done: false, value: _() })), S());
            e.on("error", f), e.on("done", g), e.on("push", d), e.on("pushCalc", y);
            try {
              await e.emit("requestItem", e._requestProcess = n);
            } catch (_) {
              e.emit("error", _);
            }
          })), this.index += 1, o;
        } };
      }
      toAsyncIterableIterator() {
        return rT(this);
      }
    };
    async function* rT(i) {
      yield* i;
    }
    l([De, u("design:type", Function), u("design:paramtypes", [Object, Object]), u("design:returntype", void 0)], Sr.prototype, "push", null), l([De, u("design:type", Function), u("design:paramtypes", [Function, Object]), u("design:returntype", void 0)], Sr.prototype, "pushCalc", null), l([De, u("design:type", Function), u("design:paramtypes", []), u("design:returntype", Promise)], Sr.prototype, "done", null), l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", void 0)], Sr.prototype, "throw", null), l([De, u("design:type", Function), u("design:paramtypes", []), u("design:returntype", void 0)], Sr.prototype, "resolve", null), l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", void 0)], Sr.prototype, "reject", null), l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", void 0)], Sr.prototype, "then", null), l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", void 0)], Sr.prototype, "catch", null);
    const tf = (i, e, t) => {
      let r = [new Yt()];
      const n = (a, p) => {
        let h = a[p];
        return h === void 0 && (h = a[p] = new Yt()), h;
      }, s = (a) => {
        if (r !== void 0) return n(r, a).promise;
      };
      let o = 0;
      (async () => {
        await s(o);
        for await (const a of i) {
          let p = t(a);
          if (p.async && (p = await p.value), p.filter) {
            if (p.multi) for (const h of p.maps) e.push(h);
            else e.push(p.map);
            await s(o);
          }
        }
        await e.done();
      })().catch(e.throw), e.on("done", (a, p) => (i.done(), p())), e.on("error", (a, p) => (i.throw(a), p())), e.on("requestItem", (a, p) => {
        r !== void 0 && (n(r, o).resolve(), o += 1), p();
      }), e.on("requestAll", (a, p) => {
        if (r !== void 0) {
          for (const h of r) h.is_resolved === false && h.resolve();
          r = void 0;
        }
        p();
      });
    };
    const ni = class {
      static InitCryptTable() {
        const i = new Array(1280);
        let e, t, r, n = 1048577, s = 0, o = 0;
        for (s = 0; s < 256; s++) for (o = s, e = 0; e < 5; e++, o += 256) n = (125 * n + 3) % 2796203, t = (65535 & n) << 16, n = (125 * n + 3) % 2796203, r = 65535 & n, i[o] = t | r;
        return i;
      }
      static hashString(i, e) {
        const { cryptTable: t, cryptTable_length: r } = ni;
        let n, s = 2146271213, o = 4008636142;
        for (let a = 0; a < i.length; a += 1) n = ((e << 8) + i.charCodeAt(a)) % r, s = t[n] ^ s + o, o = n + s + o + (o << 5) + 3;
        return s;
      }
      static inRangePosition(i) {
        const { hashRange: e } = ni;
        return (i - e.min) / e.dis % 1;
      }
      static hashToRandom(i, e, t = 0, r = 1, n) {
        const s = (ni.hashString(i, e) - ni.hashRange.min) / ni.hashRange.dis * (r - t) + t;
        return n ? Math.floor(s) : s;
      }
    };
    const rf = ni;
    rf.cryptTable = Object.freeze(ni.InitCryptTable()), rf.cryptTable_length = ni.cryptTable.length, rf.hashRange = Object.freeze({ min: -2147483648, max: 2147483647, dis: Math.pow(2, 32) });
    const nT = class extends wt {
      constructor(e) {
        super((t) => [], e);
      }
      add(e, t) {
        this.forceGet(e).push(t);
      }
      remove(e, t) {
        const r = this.get(e);
        if (r) {
          const n = r.indexOf(t);
          if (n !== -1) return r.splice(n, 1), true;
        }
        return false;
      }
    };
    const nf = class {
      constructor(e) {
        this.eventEmitter = e, this.BINDED_EVENTS_MAP = new nT();
      }
      on(e, t, r) {
        return this.eventEmitter.on(e, t, r), this.BINDED_EVENTS_MAP.add(e, t), this;
      }
      off(e, t) {
        return this.BINDED_EVENTS_MAP.remove(e, t) && this.eventEmitter.off(e, t), this;
      }
      emit(e, ...t) {
        return this.eventEmitter.emit(e, ...t), this;
      }
      once(e, t, r) {
        const n = (...s) => (this.BINDED_EVENTS_MAP.remove(e, n), t(...s));
        return this.BINDED_EVENTS_MAP.add(e, n), this.eventEmitter.once(e, t, r), this;
      }
      removeAllListeners() {
        for (const [e, t] of this.BINDED_EVENTS_MAP) for (const r of t) this.eventEmitter.off(e, r);
        return this.BINDED_EVENTS_MAP.clear(), this;
      }
      get clear() {
        return this.removeAllListeners;
      }
      get addListener() {
        return this.on;
      }
      get removeListener() {
        return this.off;
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], nf.prototype, "clear", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], nf.prototype, "addListener", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], nf.prototype, "removeListener", null);
    let vm;
    let Pf = class {
      constructor() {
        this._instanceParamWM = /* @__PURE__ */ new WeakMap();
      }
      getParam(i) {
        return this._instanceParamWM.get(i);
      }
      setParam(i, e) {
        this._instanceParamWM.set(i, e);
      }
    };
    Pf = l([J()], Pf);
    const sT = /"(?:\.|(\\")|[^""\n])*"|'(?:\.|(\\')|[^''\n])*'/g;
    let uh = class {
      constructor(i, e) {
        this.moduleMap = i, this.flagParamStack = e, this._applyedFlagMap = /* @__PURE__ */ new Map(), this._flagInfomationMap = /* @__PURE__ */ new Map();
      }
      strToBool_(i) {
        const e = i.toLowerCase();
        return e !== "disable" && e !== "disabled" && e !== "false" && (e === "enable" || e === "enabled" || e === "true" || e === "" || i);
      }
      _formatString(i) {
        return i.startsWith("'") && i.endsWith("'") || i.startsWith('"') && i.endsWith('"') ? i.slice(1, -1) : i;
      }
      parse(i) {
        const e = [], t = `_PLACE_${Math.random().toString(36).slice(2)}_HOLDER_`, r = i.replace(sT, (s) => (e.push(s), t)).split(/\s+/).filter((s) => !!s), n = /* @__PURE__ */ new Map();
        for (const s of r) {
          const o = s.indexOf("=");
          let a, p, h = "";
          if (o === -1) a = s;
          else {
            if (a = s.substr(0, o), a.includes(t)) throw new Error(`Flags format error: ${a.replace(t, e.shift() || t)} is invilde.`);
            h = s.substr(o + 1).replace(new RegExp(t, "g"), (g) => {
              const d = e.shift();
              if (!d) throw new Error();
              return d;
            });
          }
          const f = this._flagInfomationMap.get(s);
          if (f) switch (f.type) {
            case "boolean":
              p = !!this.strToBool_(h);
              break;
            case "number":
              const g = Number.parseFloat(h);
              p = Number.isNaN(g) ? void 0 : g;
              break;
            case "string":
              p = this._formatString(h);
          }
          else {
            if (p = this.strToBool_(h), typeof p === "string") {
              const g = parseFloat(p);
              g.toString() === p && (p = g);
            }
            typeof p === "string" && (p = this._formatString(p));
          }
          n.delete(a), n.set(a, p);
        }
        return n;
      }
      quote(i) {
        const e = [];
        for (let [t, r] of i) r === void 0 ? e.push(t) : (typeof r === "string" && (r = JSON.stringify(r)), e.push(`${t}=${r}`));
        return e.join(" ");
      }
      applyFlags(i) {
        i instanceof Map || (i = this.parse(i));
        for (const [e, t] of i) this.setFlagValue(e, t);
        return this._applyedFlagMap = i;
      }
      getFlagValue(i) {
        return this._applyedFlagMap.get(i);
      }
      setFlagValue(i, e) {
        const t = this._flagInfomationMap.get(i);
        return !!t && (e === false ? (t.onDisable instanceof Function && t.onDisable(), this._applyedFlagMap.delete(i)) : (t.onEnable instanceof Function && t.onEnable(e), this._applyedFlagMap.set(i, e)), true);
      }
      hasFlag(i) {
        return this._applyedFlagMap.has(i);
      }
      getApplyedFlags() {
        return this.quote(this._applyedFlagMap);
      }
      registerBooleanFlag(i, e, t) {
        if (this._flagInfomationMap.has(i)) throw new Error(`Duplicate registration boolean flag: ${i}.`);
        this._flagInfomationMap.set(i, { type: "boolean", onEnable: e, onDisable: t });
      }
      registerStringFlag(i, e, t) {
        if (this._flagInfomationMap.has(i)) throw new Error(`Duplicate registration string flag: ${i}.`);
        this._flagInfomationMap.set(i, { type: "string", onEnable: e, onDisable: t });
      }
      registerNumberFlag(i, e, t) {
        if (this._flagInfomationMap.has(i)) throw new Error(`Duplicate registration number flag: ${i}.`);
        this._flagInfomationMap.set(i, { type: "number", onEnable: e, onDisable: t });
      }
      registerInjectionFlag(i, e, t = "boolean") {
        if (this._flagInfomationMap.has(i)) throw new Error(`Duplicate registration injection flag: ${i}.`);
        this._flagInfomationMap.set(i, { type: t, onEnable: (r) => {
          const n = this.moduleMap, s = bt(e, n.installMask(new ze([[iT, r]])));
          this.flagParamStack.setParam(s, r);
        } });
      }
    };
    uh = l([J(), u("design:paramtypes", [typeof (vm = ze !== void 0 && ze) === "function" ? vm : Object, Pf])], uh);
    const iT = /* @__PURE__ */ Symbol("flag param in constructor");
    const oT = () => performance;
    let Pn = class {
      constructor() {
        this.platformInfo = Ss, this.performance = oT();
      }
      get platformName() {
        return Ss.platformName();
      }
      get isNodejs() {
        return fA;
      }
      get isWindows() {
        return LI;
      }
      get isCordova() {
        return gA;
      }
      get isWebView() {
        return Ol;
      }
      get isWebMainThread() {
        return ry;
      }
      get isWebWorker() {
        return dA;
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Pn.prototype, "platformName", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], Pn.prototype, "isNodejs", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], Pn.prototype, "isWindows", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], Pn.prototype, "isCordova", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], Pn.prototype, "isWebView", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], Pn.prototype, "isWebMainThread", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], Pn.prototype, "isWebWorker", null), Pn = l([J()], Pn);
    const Mf = /* @__PURE__ */ new WeakMap();
    function Ui(i, e, t) {
      let r, n = Mf.get(i);
      if (!n) {
        const s = { resolves: /* @__PURE__ */ new Set(), rejects: /* @__PURE__ */ new Set() }, o = () => {
          s.resolves.clear(), s.rejects.clear(), p.cbs = void 0;
        }, a = i.then((h) => {
          for (const f of s.resolves) queueMicrotask(async () => {
            try {
              await f(h);
            } catch (g) {
              
            }
          });
          o();
        }, async (h) => {
          for (const f of s.rejects) queueMicrotask(async () => {
            try {
              await f(h);
            } catch (g) {
              
            }
          });
          o();
        }), p = { cbs: s, promise: a };
        Mf.set(i, n = p);
      }
      return n.cbs ? (e && n.cbs.resolves.add(e), t && n.cbs.rejects.add(t), r = n.promise) : r = i.then(e, t), { thened: n, toPromise: r };
    }
    function th(i, e, t) {
      const r = Mf.get(i);
      return r && r.cbs && (e && r.cbs.resolves.delete(e), t && r.cbs.rejects.delete(t)), r;
    }
    const my = class _my {
      constructor(e) {
        this.rankList = [], this.thenedMap = /* @__PURE__ */ new Map(), this._cter = false, this.options = _my.mergeOptions(e);
      }
      static mergeOptions(e) {
        return Object.assign({ throwWhenNoRacer: false }, e);
      }
      resolve(e) {
        this.quota ? (this.quota.resolve(e), this.quota = void 0) : this.rankList.push({ type: 1, value: e });
      }
      reject(e) {
        this.quota ? (this.quota.reject(e), this.quota = void 0) : this.rankList.push({ type: 0, value: e });
      }
      addRacer(e) {
        const t = this.thenedMap.get(e);
        if (!t) {
          const r = (a) => {
            this.resolve(a), this.thenedMap.delete(e);
          }, n = (a) => {
            this.reject(a), this.thenedMap.delete(e);
          }, { thened: s, toPromise: o } = Ui(e, r, n);
          return s.cbs && this.thenedMap.set(e, { cbs: s.cbs, onfulfilled: r, onrejected: n, toPromise: o }), o;
        }
        return t.toPromise;
      }
      removeRacer(e) {
        const t = this.thenedMap.get(e);
        return !!t && (this._removeRacer(e, t), this._checkToEndRace(), true);
      }
      _removeRacer(e, t) {
        t.cbs.resolves.delete(t.onfulfilled), t.cbs.rejects.delete(t.onrejected), this.thenedMap.delete(e);
      }
      hasRacer(e) {
        return this.thenedMap.has(e);
      }
      get size() {
        return this.thenedMap.size;
      }
      _queneToCheck() {
      }
      _checkToEndRace() {
        this.options.throwWhenNoRacer && this._cter === false && this.thenedMap.size === 0 && (this._cter = true, queueMicrotask(() => {
          this.thenedMap.size === 0 && this.quota && this.quota.is_finished === false && this.quota.reject(new RangeError("no racer to race"));
        }));
      }
      static isNoRacerException(e) {
        return e instanceof RangeError && e.message === "no racer to race";
      }
      race(e) {
        const t = this.rankList.shift();
        if (!t) return e ? (this.quota ? this.quota !== e && this.quota.promise.then(e.resolve, e.reject) : this.quota = e, e.promise) : (this._checkToEndRace(), (this.quota || (this.quota = new Yt())).promise);
        if (t.type === 1) return t.value;
        throw t.value;
      }
      clear(e) {
        for (const t of this.thenedMap) this._removeRacer(t[0], t[1]);
        this.rankList.length = 0, this.quota && (this.quota.reject(e), this.quota = void 0);
      }
    };
    function OA(i) {
      const e = new Yt();
      let t = true;
      const r = [];
      for (const n of i) {
        if (typeof n !== "object" || n === null || typeof n.then !== "function") {
          t = false, e.resolve(n);
          break;
        }
        r.push(n);
      }
      if (t) if (r.length === 0) {}
      else {
        const n = new my();
        e.onFinished(() => n.clear());
        for (const s of r) n.addRacer(s);
        n.race(e);
      }
      return e.promise;
    }
    const Lf = /* @__PURE__ */ Symbol("then");
    const Hf = /* @__PURE__ */ Symbol("catch");
    const vf = class {
      constructor(e) {
        let t, r;
        const n = new Promise((a, p) => {
          t = a, r = p;
        });
        this.promise = Object.assign(n, { [Lf]: n.then, [Hf]: n.catch });
        let s = false;
        const o = () => {
          s || (e(t, r), s = true);
        };
        n.then = (a, p) => (o(), this.delayThen(a, p)), n.catch = (a) => (o(), this.delayCatch(a));
      }
      delayThen(e, t) {
        return this.promise[Lf](e, t);
      }
      delayCatch(e) {
        return this.promise[Hf](e);
      }
      get then() {
        return this.promise.then;
      }
      get catch() {
        return this.promise.catch;
      }
    };
    vf.THEN_SYMBOL = Lf, vf.CATCH_SYMBOL = Hf;
    const aT = class {
      constructor(e = 2) {
        this.maxParallelNum = e, this._runningTasks = [], this._waitingQuene = [];
      }
      addTaskExecutor(e) {
        const t = new Yt();
        return this._waitingQuene.push({ executor: e, po: t }), t.promise;
      }
      get isDone() {
        return this._runningTasks.length === 0 && this._waitingQuene.length === 0;
      }
      get hasTask() {
        return !this.isDone;
      }
      get isFull() {
        return this._runningTasks.length + this._waitingQuene.length >= this.maxParallelNum;
      }
      async *_startParallel() {
        for (; ; ) {
          const e = this._waitingQuene.shift();
          if (!e) break;
          try {
            const t = await e.executor();
            e.po.resolve(t), yield { asset: t };
          } catch (t) {
            yield { error: t }, e.po.reject(t);
          }
        }
      }
      async doAll(e) {
        const t = [];
        for await (const r of this.yieldResults(e)) t.push(r);
        return t;
      }
      async doRace(e) {
        for await (const t of this.yieldResults(e)) return t;
      }
      yieldResults(e) {
        return this._yielding || (this._yielding = this._yieldResults(e)), this._yielding;
      }
      async *_yieldResults(e = {}) {
        const t = [], r = () => this._startParallel(), n = this._runningTasks;
        for (; ; ) {
          for (; n.length < this.maxParallelNum && this._waitingQuene.length > 0; ) {
            const o = t.shift() || r(), a = o.next().then((h) => {
              if (!h.done) {
                t.push(o);
                const f = h.value;
                if (f) {
                  if (!("error" in f)) return { asset: f.asset, rm: p };
                  if (e.onError && e.onError(f.error), !e.ignoreError) throw f.error;
                }
              }
              p();
            });
            n.push(a);
            const p = () => {
              const h = n.indexOf(a);
              h !== -1 && n.splice(h, 1);
            };
          }
          if (n.length === 0) break;
          const s = await OA(n);
          s && (yield s.asset, s.rm());
        }
        this._yielding = void 0;
      }
    };
    const cT = class extends du {
      constructor(e, t) {
        super(e), this.silence = t, this.ABORT_ERROR_FLAG = true;
      }
    };
    const _y = class __y extends Yt {
      
      get is_done() {
        return this.is_resolved || this.is_rejected;
      }
      abort(e = "Abort") {
        this.is_done || (this.reject(this.abort_error = new cT(e)), this._hasAbortEvent && this._abortEvent.emit("abort", this.abort_error, this));
      }
      get _abortEvent() {
        return this._hasAbortEvent = true, new An();
      }
      onAbort(e) {
        this._abortEvent.on("abort", e);
      }
      follow(e) {
        return e.then(this.resolve).catch(this.reject), this.promise;
      }
      static fromPromise(e) {
        const t = new __y();
        return _f(e instanceof vf ? e.delayThen(t.resolve, t.reject) : e.then(t.resolve, t.reject)), t;
      }
      finally(e) {
        return this.promise.finally(e);
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], _y.prototype, "_abortEvent", null);
    const fh = /* @__PURE__ */ new WeakMap();
    const bs = (i, e) => {
      let t;
      i <= 0 && (i = 1);
      const r = new Promise((n) => t = setTimeout(() => {
        fh.delete(r), n();
      }, i)).then(e);
      return fh.set(r, t), r;
    };
    const CA = (i) => {
      const e = fh.get(i);
      e !== void 0 && (fh.delete(i), clearTimeout(e));
    };
    const RA = class {
      constructor() {
        this._task_list = [];
      }
      toPromise() {
        return Promise.all(this._task_list);
      }
      set next(e) {
        this._task_list.push(e);
      }
      tryToPromise() {
        return this._task_list.some((e) => e && typeof e.then === "function") ? Promise.all(this._task_list) : this._task_list;
      }
    };
    const $e = async (i) => {
      const e = new RA();
      try {
        await i(e);
      } catch (t) {
        e.next = Promise.reject(t);
      }
      return e.toPromise();
    };
    let rh;
    let km;
    const { info: pT } = yA("util", "TimeHelper");
    const lT = { TIME_SPEED: "TIME_SPEED" };
    let nh = rh = class {
      constructor(i, e = 1) {
        this.platformHelper = i, this.TIME_SPEED = e, this.clearTimeout = clearTimeout, this.clearInterval = clearInterval, this.time_offset_ms = 0, this.SYSTEM_START_TIME = this.platformHelper.performance.timeOrigin, typeof e === "number" && e > 0 || (this.TIME_SPEED = 1), pT("TIME SPPED \xD7 %d.", this.TIME_SPEED);
      }
      setTimeout(i, e) {
        return setTimeout(i, e / this.TIME_SPEED);
      }
      setInterval(i, e) {
        return setInterval(i, e / this.TIME_SPEED);
      }
      sleep(i, e) {
        return bs(i / this.TIME_SPEED, e);
      }
      get BLOCKCHAIN_SYSTEM_START_TIME() {
        return this.SYSTEM_START_TIME + this.time_offset_ms;
      }
      now(i = false) {
        const e = this.platformHelper.performance.now() + this.SYSTEM_START_TIME + this.time_offset_ms, t = Date.now() - e;
        t > 1 && (this.time_offset_ms += t);
        const r = this.SYSTEM_START_TIME + (this.platformHelper.performance.now() + this.time_offset_ms) * this.TIME_SPEED;
        return i ? parseInt(r.toString()) : r;
      }
      changeNowByDiff(i) {
        const { NOW_DIFF_SYMBOL: e } = rh, t = Reflect.get(Date, e);
        if (this.time_offset_ms += i - (t || 0), i !== 0) {
          if (t === void 0) {
            const r = Date.now, n = Date.now = () => r() + Reflect.get(Date, e);
            Reflect.set(n, "source", r);
          }
          Reflect.set(Date, e, i);
        } else {
          const r = Date.now, n = Reflect.get(r, "source");
          n !== void 0 && (Date.now = n, Reflect.deleteProperty(Date, e));
        }
      }
      changeNowByTime(i) {
        const { NOW_DIFF_SYMBOL: e } = rh, t = Reflect.get(Date, e) || 0, r = i - (Date.now() - t);
        return this.changeNowByDiff(r);
      }
      formatDate(i, e = "yyyy-MM-dd hh:mm:ss") {
        const t = i.getMonth() + 1, r = { "M+": t, "d+": i.getDate(), "h+": i.getHours(), "m+": i.getMinutes(), "s+": i.getSeconds(), "q+": Math.floor((i.getMonth() + 3) / 3), E: ["\u51AC", "\u6625", "\u590F", "\u79CB"][Math.floor(t % 12 / 3)], W: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"][i.getDay()], S: i.getMilliseconds() };
        let n = e;
        /(y+)/.test(n) && (n = n.replace(RegExp.$1, (i.getFullYear() + "").substr(4 - RegExp.$1.length)));
        for (const s in r) new RegExp("(" + s + ")").test(n) && (n = n.replace(RegExp.$1, RegExp.$1.length === 1 ? "" + r[s] : ("00" + r[s]).substr(("" + r[s]).length)));
        return n;
      }
      formatDateTime(i = this.now()) {
        return this.formatDate(new Date(i));
      }
      formatYMDHMS(i, e, t, r, n, s) {
        const o = (a, p = 2) => String(a).padStart(p, "0");
        return `${o(i, 4)}-${o(e)}-${o(t)} ${o(r)}:${o(n)}:${o(s)}`;
      }
    };
    nh.NOW_DIFF_SYMBOL = /* @__PURE__ */ Symbol("now-diff-ms"), nh = rh = l([J(), be(1, D(lT.TIME_SPEED, { optional: true })), u("design:paramtypes", [typeof (km = Pn !== void 0 && Pn) === "function" ? km : Object, Object])], nh);
    let Zo = class {
      get v4() {
        return "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      }
      get v6seg() {
        return "[a-fA-F\\d]{1,4}";
      }
      get v6() {
        const { v4: i, v6seg: e } = this;
        return `
    (
    (?:${e}:){7}(?:${e}|:)|                                // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
    (?:${e}:){6}(?:${i}|:${e}|:)|                         // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
    (?:${e}:){5}(?::${i}|(:${e}){1,2}|:)|                 // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
    (?:${e}:){4}(?:(:${e}){0,1}:${i}|(:${e}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
    (?:${e}:){3}(?:(:${e}){0,2}:${i}|(:${e}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
    (?:${e}:){2}(?:(:${e}){0,3}:${i}|(:${e}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
    (?:${e}:){1}(?:(:${e}){0,4}:${i}|(:${e}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
    (?::((?::${e}){0,5}:${i}|(?::${e}){1,7}|:))           // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
    )(%[0-9a-zA-Z]{1,})?                                           // %eth0            %1
    `.replace(/\/\/.*$/gm, "").replace(/(^\s+)|(\s+$)|\s+/g, "").replace(/\n/g, "");
      }
      isIp(i) {
        const { v4: e, v6: t } = this;
        return new RegExp(`(?:^${e}$)|(?:^${t}$)`).test(i);
      }
      isIpV4(i) {
        const { v4: e } = this;
        return new RegExp(`^${e}$`).test(i);
      }
      isIpV6(i) {
        const { v6: e } = this;
        return new RegExp(`^${e}$`).test(i);
      }
      ipv4ToUint32(i) {
        return i.split(".").reduce((e, t, r) => e + +t * Math.pow(256, 3 - r), 0);
      }
      uint32ToIpv4(i) {
        return `${i / 16777216 | 0}.${i % 16777216 / 65536 | 0}.${i % 65536 / 256 | 0}.${i % 256}`;
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Zo.prototype, "v4", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], Zo.prototype, "v6seg", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], Zo.prototype, "v6", null), Zo = l([J()], Zo);
    const wr = class extends rs.Buffer {
      static from(e, t, r) {
        return rs.Buffer.from(e, t, r);
      }
      static alloc(e, t, r) {
        return rs.Buffer.alloc(e, t, r);
      }
      static allocUnsafe(e) {
        return rs.Buffer.allocUnsafe(e);
      }
      static allocUnsafeSlow(e) {
        return rs.Buffer.allocUnsafeSlow(e);
      }
    };
    function kf(i) {
      return typeof i === "object" && i !== null && !(Symbol.iterator in i);
    }
    function Df(i) {
      return i.length === 1 ? i[0] : new Proxy(i[0], { get(e, t, r) {
        const n = i.filter((a) => Reflect.has(a, t));
        if (n.length === 0) return;
        if (n.length === 1) return Reflect.get(n[0], t);
        const s = n.map((a) => Reflect.get(a, t)), o = s.filter((a) => kf(a));
        return o.length === 0 ? s[s.length - 1] : Df(o);
      }, getOwnPropertyDescriptor(e, t) {
        const r = i.filter((a) => Reflect.has(a, t));
        if (r.length === 0) return;
        if (r.length === 1) return Object.getOwnPropertyDescriptor(r[0], t);
        const n = r.map((a) => ({ obj: a, value: Reflect.get(a, t) })), s = n.filter((a) => kf(a.value)), o = Object.getOwnPropertyDescriptor(n[n.length - 1].obj, t);
        return s.length === 0 ? o : { ...o, value: Df(n.map((a) => a.value)) };
      }, ownKeys() {
        const e = /* @__PURE__ */ new Set();
        for (const t of i) for (const r of Reflect.ownKeys(t)) e.add(r);
        return [...e];
      } });
    }
    function hT(...i) {
      const e = i.filter(kf);
      return e.length === 0 ? {} : Df(e);
    }
    const uT = () => ({ TextDecoder, TextEncoder });
    const fT = /* @__PURE__ */ new WeakMap();
    const { TextEncoder: gT, TextDecoder: dT } = uT();
    const yT = new gT();
    new dT("utf-8");
    const mT = new Uint8Array();
    function _T(i) {
      if (!i) return mT;
      const e = i.length <= 128 ? AT(i) : yT.encode(i);
      return fT.set(e, i), e;
    }
    function AT(i) {
      const e = [];
      let t, r;
      for (let n = 0; n < i.length; ++n) t = i.charCodeAt(n), t < 128 ? e[e.length] = t : t < 2048 ? (e[e.length] = t >> 6 | 192, e[e.length] = 63 & t | 128) : (64512 & t) == 55296 && (64512 & (r = i.charCodeAt(n + 1))) == 56320 ? (t = 65536 + ((1023 & t) << 10) + (1023 & r), ++n, e[e.length] = t >> 18 | 240, e[e.length] = t >> 12 & 63 | 128, e[e.length] = t >> 6 & 63 | 128, e[e.length] = 63 & t | 128) : (e[e.length] = t >> 12 | 224, e[e.length] = t >> 6 & 63 | 128, e[e.length] = 63 & t | 128);
      return new Uint8Array(e);
    }
    let BA;
    const mn = class _mn {
      constructor(e, t = (n) => n, r) {
        this.transformKey = t, this._afterDelete = r, this._set = new Set(e);
      }
      static from(e) {
        return new _mn(e.entries, e.transformKey, e.afterDelete);
      }
      tryAdd(e) {
        return this.add(this.transformKey(e));
      }
      tryDelete(e) {
        return this.delete(this.transformKey(e));
      }
      tryHas(e) {
        return this.has(this.transformKey(e));
      }
      get clear() {
        return this._set.clear.bind(this._set);
      }
      get delete() {
        const e = this._set.delete.bind(this._set), { _afterDelete: t } = this;
        return t ? (r) => !!e(r) && (t(r), true) : e;
      }
      get forEach() {
        return this._set.forEach.bind(this._set);
      }
      get has() {
        return this._set.has.bind(this._set);
      }
      get add() {
        return this._set.add.bind(this._set);
      }
      get size() {
        return this._set.size;
      }
      get [BA = Symbol.iterator]() {
        return this._set[Symbol.iterator].bind(this._set);
      }
      get entries() {
        return this._set.entries.bind(this._set);
      }
      get keys() {
        return this._set.keys.bind(this._set);
      }
      get values() {
        return this._set.values.bind(this._set);
      }
      get [Symbol.toStringTag]() {
        return "EasySet";
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], mn.prototype, "clear", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], mn.prototype, "delete", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], mn.prototype, "forEach", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], mn.prototype, "has", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], mn.prototype, "add", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], mn.prototype, BA, null), l([oe, u("design:type", Object), u("design:paramtypes", [])], mn.prototype, "entries", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], mn.prototype, "keys", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], mn.prototype, "values", null);
    const xc = class _xc {
      constructor(e, t = (n) => n, r) {
        this.transformKey = t, this._afterDelete = r, this._ws = new WeakSet(e);
      }
      static from(e) {
        return new _xc(e.entries, e.transformKey, e.afterDelete);
      }
      tryAdd(e) {
        return this.add(this.transformKey(e));
      }
      tryDelete(e) {
        return this.delete(this.transformKey(e));
      }
      tryHas(e) {
        return this.has(this.transformKey(e));
      }
      get delete() {
        const e = this._ws.delete.bind(this._ws), { _afterDelete: t } = this;
        return t ? (r) => !!e(r) && (t(r), true) : e;
      }
      get add() {
        return this._ws.add.bind(this._ws);
      }
      get has() {
        return this._ws.has.bind(this._ws);
      }
      get [Symbol.toStringTag]() {
        return "EasyWeakSet";
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xc.prototype, "delete", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], xc.prototype, "add", null), l([oe, u("design:type", Object), u("design:paramtypes", [])], xc.prototype, "has", null);
    const ET = typeof Promise === "function";
    const IT = typeof self === "object" ? self : global;
    const PA = typeof Symbol < "u";
    const Ff = typeof Map < "u";
    const $f = typeof Set < "u";
    const TT = typeof WeakMap < "u";
    const ST = typeof WeakSet < "u";
    const wT = typeof DataView < "u";
    const MA = PA && Symbol.iterator !== void 0;
    const Dm = PA && Symbol.toStringTag !== void 0;
    const bT = $f && typeof Set.prototype.entries === "function";
    const NT = Ff && typeof Map.prototype.entries === "function";
    const xT = bT && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries());
    const OT = NT && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries());
    const LA = MA && typeof Array.prototype[Symbol.iterator] === "function";
    const CT = LA && Object.getPrototypeOf([][Symbol.iterator]());
    const HA = MA && typeof String.prototype[Symbol.iterator] === "function";
    const RT = HA && Object.getPrototypeOf(""[Symbol.iterator]());
    function BT(i) {
      const e = typeof i;
      if (e !== "object") return e;
      if (i === null) return "null";
      if (i === IT) return "global";
      if (Array.isArray(i) && (Dm === false || !(Symbol.toStringTag in i))) return "Array";
      if (typeof window === "object" && window !== null) {
        if (typeof window.location === "object" && i === window.location) return "Location";
        if (typeof window.document === "object" && i === window.document) return "Document";
        if (typeof window.navigator === "object") {
          if (typeof window.navigator.mimeTypes === "object" && i === window.navigator.mimeTypes) return "MimeTypeArray";
          if (typeof window.navigator.plugins === "object" && i === window.navigator.plugins) return "PluginArray";
        }
        if ((typeof window.HTMLElement === "function" || typeof window.HTMLElement === "object") && i instanceof window.HTMLElement) {
          if (i.tagName === "BLOCKQUOTE") return "HTMLQuoteElement";
          if (i.tagName === "TD") return "HTMLTableDataCellElement";
          if (i.tagName === "TH") return "HTMLTableHeaderCellElement";
        }
      }
      const t = Dm && i[Symbol.toStringTag];
      if (typeof t === "string") return t;
      const r = Object.getPrototypeOf(i);
      return r === RegExp.prototype ? "RegExp" : r === Date.prototype ? "Date" : ET && r === Promise.prototype ? "Promise" : $f && r === Set.prototype ? "Set" : Ff && r === Map.prototype ? "Map" : ST && r === WeakSet.prototype ? "WeakSet" : TT && r === WeakMap.prototype ? "WeakMap" : wT && r === DataView.prototype ? "DataView" : Ff && r === OT ? "Map Iterator" : $f && r === xT ? "Set Iterator" : LA && r === CT ? "Array Iterator" : HA && r === RT ? "String Iterator" : r === null ? "Object" : Object.prototype.toString.call(i).slice(8, -1);
    }
    const vA = typeof Buffer < "u";
    vA && Buffer.from;
    const PT = vA ? function(i) {
      return Buffer.isBuffer(i);
    } : function(i) {
      return false;
    };
    function Fm(i) {
      return PT(i) ? "Buffer" : BT(i);
    }
    const kA = new class {
      get(i, e, t = Fm(i)) {
        switch (t) {
          case "Arguments":
          case "Array":
          case "Object":
            return i[e];
          case "Map":
            return i.get(e);
          case "Set":
            return e;
        }
      }
      set(i, e, t, r = Fm(i)) {
        switch (r) {
          case "Arguments":
          case "Array":
          case "Object":
            i[e] = t;
            break;
          case "Map":
            i.set(e, t);
            break;
          case "Set":
            i.add(t);
        }
        return i;
      }
    }();
    kA.get;
    kA.set;
    const MT = typeof globalThis < "u" && globalThis !== null && globalThis.Object === Object && globalThis;
    const LT = typeof global < "u" && global !== null && global.Object === Object && global;
    const HT = typeof self < "u" && self !== null && self.Object === Object && self;
    MT || LT || HT || Function("return this")();
    let Cl;
    const { ArgumentFormatException: $m } = ee("MODEL", "transactionModel");
    const vT = new ss((i) => new X_(i.inputs));
    let _i = Cl = class extends Y {
      get macroId() {
        return xe(this.macroIdBuffer);
      }
      set macroId(e) {
        this.macroIdBuffer = _e(e);
      }
      get inputMap() {
        return vT.forceGet(this);
      }
      get transaction() {
        const { transactionBuffer: e } = this, t = Je.decode(e), r = Re.trsTypeToV(t.type), n = Re.VM.get(r);
        if (!n) throw new $m(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: r });
        return n.decode(e);
      }
      set transaction(e) {
        this.transactionBuffer = e.getBytes();
      }
      toJSON() {
        return { macroId: this.macroId, inputs: this.inputs, transaction: this.transaction.toJSON() };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        if (t !== e && (e.macroId && (t.macroId = e.macroId), e.transaction)) {
          const r = e.transaction;
          if (r instanceof Y) t.transaction = r;
          else {
            const n = r.type;
            if (n) {
              const s = Re.trsTypeToV(n), o = Re.VM.get(s);
              if (!o) throw new $m(c.INVALID_TRANSACTION_BASE_TYPE, { type_base: s });
              t.transaction = o.fromObject(r);
            }
          }
        }
        return t;
      }
    };
    _i.INC = 1;
    l([A.d(Cl.INC++, "bytes"), u("design:type", Uint8Array)], _i.prototype, "macroIdBuffer", void 0);
    l([fr.d(Cl.INC++, "string", "string"), u("design:type", Object)], _i.prototype, "inputs", void 0);
    l([A.d(Cl.INC++, "bytes"), u("design:type", Uint8Array)], _i.prototype, "transactionBuffer", void 0);
    _i = Cl = l([R.d("MacroCallModel")], _i);
    let el = class extends Y {
      toJSON() {
        return { call: this.call.toJSON() };
      }
    };
    l([A.d(1, _i), u("design:type", _i)], el.prototype, "call", void 0);
    el = l([R.d("MacroCallAssetModel")], el);
    let Ay;
    let Oa = Ay = class extends Je {
      as(e, t) {
        const r = Re.MV.get(e), n = Re.trsTypeToV(this.type);
        if (r === n) if (t) {
          if (this.signature === t) return this;
        } else return this;
        const { transaction: s } = this.asset.call;
        return s.as(e, t);
      }
      getBlobSize(e = false) {
        let t = 0;
        const r = this.blobMap.values();
        for (const n of r) t += n[3];
        return e === false && (t += this.asset.call.transaction.getBlobSize(e)), t;
      }
    };
    l([A.d(Ay.INC++, el), u("design:type", el)], Oa.prototype, "asset", void 0);
    Oa = Ay = l([R.d("MacroCallTransaction")], Oa);
    Re.VM.set(v.REGISTER_CHAIN, Ia);
    Re.MV.set(Ia, v.REGISTER_CHAIN);
    Re.VM.set(v.MULTIPLE, Sa);
    Re.MV.set(Sa, v.MULTIPLE);
    Re.VM.set(v.PROMISE, no);
    Re.MV.set(no, v.PROMISE);
    Re.VM.set(v.PROMISE_RESOLVE, ba);
    Re.MV.set(ba, v.PROMISE_RESOLVE);
    Re.VM.set(v.MACRO, oo);
    Re.MV.set(oo, v.MACRO);
    Re.VM.set(v.MACRO_CALL, Oa);
    Re.MV.set(Oa, v.MACRO_CALL);
    let Po;
    let si;
    (function(i) {
      i[i.INDETERMINATE = 0] = "INDETERMINATE", i[i.DETERMINATE = 1] = "DETERMINATE", i[i.BUFFER = 2] = "BUFFER", i[i.QUERY = 3] = "QUERY";
    })(si || (si = {}));
    let Hr = Po = class extends Y {
      get loaded() {
        return this._loaded > this.total ? this.total : this._loaded;
      }
      set loaded(e) {
        this._loaded = e;
      }
      get buffer() {
        return this._buffer && this._buffer > this.total ? this.total : this._buffer;
      }
      set buffer(e) {
        this._buffer = e;
      }
      toJSON() {
        let e;
        const t = { type: this.type, mode: this.mode, loaded: this.loaded, buffer: this.buffer, total: this.total };
        return (e = this.buffer) !== null && e !== void 0 || (t.buffer = this.buffer), t;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return e.loaded && (t.loaded = e.loaded), e.buffer && (t.buffer = e.buffer), t;
      }
    };
    Hr.INC = 1;
    l([A.d(Po.INC++, "string"), u("design:type", String)], Hr.prototype, "type", void 0);
    l([A.d(Po.INC++, si), u("design:type", Number)], Hr.prototype, "mode", void 0);
    l([A.d(Po.INC++, "uint32"), u("design:type", Number)], Hr.prototype, "_loaded", void 0);
    l([A.d(Po.INC++, "uint32", "optional"), u("design:type", Number)], Hr.prototype, "_buffer", void 0);
    l([A.d(Po.INC++, "uint32"), u("design:type", Number)], Hr.prototype, "total", void 0);
    Hr = Po = l([R.d("ProgressEvent")], Hr);
    let Ey;
    let gh = Ey = class extends Hr {
      toJSON() {
        return Object.assign({ finishedDetails: this.finishedDetails.map((e) => e.toJSON()) }, super.toJSON());
      }
    };
    l([A.d(Ey.INC++, ia, "repeated"), u("design:type", Array)], gh.prototype, "finishedDetails", void 0);
    gh = Ey = l([R.d("TransactionsProgressEvent")], gh);
    let bu;
    let Ai = bu = class extends Hr {
      toJSON() {
        return Object.assign({ finishedDetails: this.finishedDetails.map((e) => e.toJSON()), processingDetails: this.processingDetails }, super.toJSON());
      }
    };
    l([A.d(bu.INC++, ia, "repeated"), u("design:type", Array)], Ai.prototype, "finishedDetails", void 0);
    l([fr.d(bu.INC++, "uint32", gh), u("design:type", Object)], Ai.prototype, "processingDetails", void 0);
    Ai = bu = l([R.d("BlocksProgressEvent")], Ai);
    let Iy;
    let vs = Iy = class extends Hr {
      toJSON() {
        return Object.assign({ currentBlockDetails: this.currentBlockDetails.toJSON() }, super.toJSON());
      }
    };
    l([A.d(Iy.INC++, Ai), u("design:type", Ai)], vs.prototype, "currentBlockDetails", void 0);
    vs = Iy = l([R.d("BlockchainRebuidingProgressEvent")], vs);
    let Ca = class extends Hr {
    };
    Ca = l([R.d("BlockchainPeerScanningProgressEvent")], Ca);
    let Ei = class extends Hr {
      toJSON() {
        const e = {};
        for (const r in this.applyDetails) e[r] = this.applyDetails[r].toJSON();
        const t = {};
        for (const r in this.syncDetails) t[r] = this.syncDetails[r].toJSON();
        return Object.assign({ applyDetails: e, syncDetails: t }, super.toJSON());
      }
    };
    l([fr.d(vs.INC++, "uint32", Ai), u("design:type", Object)], Ei.prototype, "applyDetails", void 0);
    l([fr.d(vs.INC++, "uint32", Ai), u("design:type", Object)], Ei.prototype, "syncDetails", void 0);
    Ei = l([R.d("BlockchainReplayBlockProgressEvent")], Ei);
    let Ra = class extends Hr {
    };
    Ra = l([R.d("BlockchainRollbackProgressEventModel")], Ra);
    let Ba = class extends Hr {
    };
    Ba = l([R.d("BlockchainGeneratingProgressEvent")], Ba);
    let Ne;
    (function(i) {
      i[i.error = 0] = "error", i[i.busy = 1] = "busy", i[i.success = 2] = "success", i[i.idempotentError = 3] = "idempotentError";
    })(Ne || (Ne = {}));
    let Qr;
    (function(i) {
      i[i.OFFLINE = 0] = "OFFLINE", i[i.FREE = 1] = "FREE", i[i.REBUIDING = 2] = "REBUIDING", i[i.PEER_SCANNING = 3] = "PEER_SCANNING", i[i.REPLAY_BLOCK = 4] = "REPLAY_BLOCK", i[i.GENERATING = 5] = "GENERATING", i[i.ROLLBACK = 6] = "ROLLBACK";
    })(Qr || (Qr = {}));
    let dh;
    (function(i) {
      i[i.Refuse = 0] = "Refuse", i[i.InBlock = 1] = "InBlock", i[i.InUnconfirmQuene = 2] = "InUnconfirmQuene";
    })(dh || (dh = {}));
    let Ce;
    (function(i) {
      i[i.FEE_LESS_THAN_WEB_FEE = 0] = "FEE_LESS_THAN_WEB_FEE", i[i.TRS_EXPRIED = 1] = "TRS_EXPRIED", i[i.TRANSACTION_IN_UNTREATEDTR = 2] = "TRANSACTION_IN_UNTREATEDTR", i[i.TRANSACTION_IN_TRS = 3] = "TRANSACTION_IN_TRS", i[i.TRANSACTION_BASE_TYPE_NOT_FOUND = 4] = "TRANSACTION_BASE_TYPE_NOT_FOUND", i[i.TRANSACTION_BASE_NOT_FOUND = 5] = "TRANSACTION_BASE_NOT_FOUND", i[i.CHAIN_ASSET_NOT_ENOUGH = 6] = "CHAIN_ASSET_NOT_ENOUGH", i[i.ASSET_NOT_ENOUGH = 7] = "ASSET_NOT_ENOUGH", i[i.TRANSACTION_SENDER_ASSET_FROZEN = 8] = "TRANSACTION_SENDER_ASSET_FROZEN", i[i.TRANSACTION_RECIPIENT_ASSET_FROZEN = 9] = "TRANSACTION_RECIPIENT_ASSET_FROZEN", i[i.TRANSACTION_FEE_NOT_ENOUGH = 10] = "TRANSACTION_FEE_NOT_ENOUGH", i[i.TRANSACTION_ASSET_DEBT = 11] = "TRANSACTION_ASSET_DEBT", i[i.LOCATION_NAME_NOT_EXIST = 12] = "LOCATION_NAME_NOT_EXIST", i[i.ACCOUNT_NOT_LNS_POSSESSOR = 13] = "ACCOUNT_NOT_LNS_POSSESSOR", i[i.DAPP_ALREADY_EXISTS = 14] = "DAPP_ALREADY_EXISTS", i[i.ASSETTYPE_ALREADY_EXIST = 15] = "ASSETTYPE_ALREADY_EXIST", i[i.CHAINNAME_ALREADY_EXIST = 16] = "CHAINNAME_ALREADY_EXIST", i[i.ASSET_ALREADY_EXIST = 17] = "ASSET_ALREADY_EXIST", i[i.LOCATION_NAME_ALREADY_EXIST = 18] = "LOCATION_NAME_ALREADY_EXIST", i[i.CAN_NOT_SET_FROZEN_ACCOUNT_AS_MANAGER = 19] = "CAN_NOT_SET_FROZEN_ACCOUNT_AS_MANAGER", i[i.CAN_NOT_SET_SAME_ACCOUNT_AS_MANAGER = 20] = "CAN_NOT_SET_SAME_ACCOUNT_AS_MANAGER", i[i.SET_LNS_MANAGER_PERMISSION_DENIED = 21] = "SET_LNS_MANAGER_PERMISSION_DENIED", i[i.SET_LNS_RECORD_VALUE_PERMISSION_DENIED = 22] = "SET_LNS_RECORD_VALUE_PERMISSION_DENIED", i[i.TRS_IN_FEATURE = 23] = "TRS_IN_FEATURE", i[i.TRUST_MAIN_ASSET_ONLY = 24] = "TRUST_MAIN_ASSET_ONLY", i[i.USE_MAIN_ASSET_PURCHASE_ONLY = 25] = "USE_MAIN_ASSET_PURCHASE_ONLY", i[i.ACCOUNT_REMAIN_EQUITY_NOT_ENOUGH = 26] = "ACCOUNT_REMAIN_EQUITY_NOT_ENOUGH", i[i.MIGRATE_MAIN_ASSET_ONLY = 27] = "MIGRATE_MAIN_ASSET_ONLY", i[i.ASSET_IS_ALREADY_MIGRATION = 28] = "ASSET_IS_ALREADY_MIGRATION", i[i.MAGIC_ALREADY_EXIST = 29] = "MAGIC_ALREADY_EXIST", i[i.ENTITY_FACTORY_ALREADY_EXIST = 30] = "ENTITY_FACTORY_ALREADY_EXIST", i[i.ENTITY_FACTORY_NOT_EXIST = 31] = "ENTITY_FACTORY_NOT_EXIST", i[i.ENTITY_ALREADY_EXIST = 32] = "ENTITY_ALREADY_EXIST", i[i.ENTITY_NOT_EXIST = 33] = "ENTITY_NOT_EXIST", i[i.ACCOUNT_NOT_ENTITY_POSSESSOR = 34] = "ACCOUNT_NOT_ENTITY_POSSESSOR", i[i.ACCOUNT_NOT_DAPPID_POSSESSOR = 35] = "ACCOUNT_NOT_DAPPID_POSSESSOR", i[i.ASSET_NOT_EXIST = 36] = "ASSET_NOT_EXIST", i[i.DAPPID_NOT_EXIST = 37] = "DAPPID_NOT_EXIST", i[i.CERTIFICATE_ALREADY_EXIST = 38] = "CERTIFICATE_ALREADY_EXIST", i[i.CERTIFICATE_NOT_EXIST = 39] = "CERTIFICATE_NOT_EXIST", i[i.ACCOUNT_NOT_CERTIFICATE_POSSESSOR = 40] = "ACCOUNT_NOT_CERTIFICATE_POSSESSOR";
    })(Ce || (Ce = {}));
    let Ie;
    (function(i) {
      i[i.REFUSE = 0] = "REFUSE", i[i.RESPONSE = 1] = "RESPONSE", i[i.QUERY_TRANSACTION = 2] = "QUERY_TRANSACTION", i[i.NEW_TRANSACTION = 4] = "NEW_TRANSACTION", i[i.QUERY_BLOCK = 8] = "QUERY_BLOCK", i[i.NEW_BLOCK = 16] = "NEW_BLOCK", i[i.GET_PEER_INFO = 32] = "GET_PEER_INFO", i[i.INDEX_TRANSACTION = 64] = "INDEX_TRANSACTION", i[i.DOWNLOAD_TRANSACTION = 128] = "DOWNLOAD_TRANSACTION", i[i.OPEN_BLOB = 256] = "OPEN_BLOB", i[i.READ_BLOB = 512] = "READ_BLOB", i[i.CLOSE_BLOB = 1024] = "CLOSE_BLOB", i[i.QUERY_TINDEX = 2048] = "QUERY_TINDEX", i[i.GET_TRANSACTIONINBLOCK = 4096] = "GET_TRANSACTIONINBLOCK", i[i.QUERY_TRANSACTION_RETURN = 3] = "QUERY_TRANSACTION_RETURN", i[i.NEW_TRANSACTION_RETURN = 5] = "NEW_TRANSACTION_RETURN", i[i.QUERY_BLOCK_RETURN = 9] = "QUERY_BLOCK_RETURN", i[i.NEW_BLOCK_RETURN = 17] = "NEW_BLOCK_RETURN", i[i.GET_PEER_INFO_RETURN = 33] = "GET_PEER_INFO_RETURN", i[i.INDEX_TRANSACTION_RETURN = 65] = "INDEX_TRANSACTION_RETURN", i[i.DOWNLOAD_TRANSACTION_RETURN = 129] = "DOWNLOAD_TRANSACTION_RETURN", i[i.OPEN_BLOB_RETURN = 257] = "OPEN_BLOB_RETURN", i[i.READ_BLOB_RETURN = 513] = "READ_BLOB_RETURN", i[i.CLOSE_BLOB_RETURN = 1025] = "CLOSE_BLOB_RETURN", i[i.QUERY_TINDEX_RETURN = 2049] = "QUERY_TINDEX_RETURN", i[i.GET_TRANSACTIONINBLOCK_RETURN = 4097] = "GET_TRANSACTIONINBLOCK_RETURN";
    })(Ie || (Ie = {}));
    let Uf;
    let Nu;
    let St = Uf = class extends Y {
      constructor() {
        super(...arguments), this._parsed_detail = false;
      }
      get detail() {
        if (!this._parsed_detail) {
          this._parsed_detail = true;
          try {
            this._detail = this.detailJSON ? JSON.parse(this.detailJSON) : {};
          } catch {
            this._detail = {};
          }
        }
        return this._detail;
      }
      set detail(e) {
        this.detailJSON = JSON.stringify(e), this._detail = e, this._parsed_detail = true;
      }
      static fromException(e) {
        const t = Uf.fromObject(e);
        return t.detail = e.detail, t;
      }
      toJSON() {
        return { message: this.message, detailJSON: this.detailJSON, PLATFORM: this.PLATFORM, CHANNEL: this.CHANNEL, BUSINESS: this.BUSINESS, MODULE: this.MODULE, FILE: this.FILE, CODE: this.CODE };
      }
    };
    l([A.d(1, "string"), u("design:type", String)], St.prototype, "message", void 0);
    l([A.d(2, "string", "required", ""), u("design:type", String)], St.prototype, "detailJSON", void 0);
    l([A.d(3, "string", "optional"), u("design:type", String)], St.prototype, "PLATFORM", void 0);
    l([A.d(4, "string", "optional"), u("design:type", String)], St.prototype, "CHANNEL", void 0);
    l([A.d(5, "string", "optional"), u("design:type", String)], St.prototype, "BUSINESS", void 0);
    l([A.d(6, "string", "optional"), u("design:type", String)], St.prototype, "MODULE", void 0);
    l([A.d(7, "string", "optional"), u("design:type", String)], St.prototype, "FILE", void 0);
    l([A.d(8, "string", "optional"), u("design:type", String)], St.prototype, "CODE", void 0);
    St = Uf = l([R.d("ExceptionMessage")], St);
    let er = Nu = class extends Y {
      toJSON() {
        const e = { status: this.status };
        return this.error && (e.error = this.error.toJSON()), e;
      }
    };
    er.INC = 1;
    l([A.d(Nu.INC++, Ne), u("design:type", Number)], er.prototype, "status", void 0);
    l([A.d(Nu.INC++, St, "optional"), u("design:type", St)], er.prototype, "error", void 0);
    er = Nu = l([R.d("CommonResponse")], er);
    let tr;
    let Ty;
    let Sy;
    let wy;
    let by;
    let Ny;
    let xy;
    let Mo;
    let Oy;
    let Cy;
    let it = tr = class extends Y {
      get signature() {
        return this.signatureBuffer && xe(this.signatureBuffer) || void 0;
      }
      set signature(e) {
        this.signatureBuffer = _e(e);
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.signature && (t.signature = e.signature), t;
      }
      toJSON() {
        return { type: this.type, types: this.types, signature: this.signature, senderId: this.senderId, recipientId: this.recipientId, dappid: this.dappid, lns: this.lns, storage: this.storage, blockSignature: this.blockSignature, minHeight: this.minHeight, maxHeight: this.maxHeight, trusteeId: this.trusteeId, purchaseDAppid: this.purchaseDAppid, range: this.range, offset: this.offset, limit: this.limit, address: this.address };
      }
    };
    it.INC = 1;
    l([A.d(tr.INC++, "string", "optional"), u("design:type", String)], it.prototype, "type", void 0);
    l([A.d(tr.INC++, "string", "repeated"), u("design:type", Array)], it.prototype, "types", void 0);
    l([A.d(tr.INC++, "bytes", "optional"), u("design:type", Uint8Array)], it.prototype, "signatureBuffer", void 0);
    l([A.d(tr.INC++, "string", "optional"), u("design:type", String)], it.prototype, "senderId", void 0);
    l([A.d(tr.INC++, "string", "optional"), u("design:type", String)], it.prototype, "recipientId", void 0);
    l([A.d(tr.INC++, "string", "optional"), u("design:type", String)], it.prototype, "dappid", void 0);
    l([A.d(tr.INC++, "string", "optional"), u("design:type", String)], it.prototype, "lns", void 0);
    l([A.d(tr.INC++, as, "optional"), u("design:type", as)], it.prototype, "storage", void 0);
    l([A.d(tr.INC++, "string", "optional"), u("design:type", String)], it.prototype, "blockSignature", void 0);
    l([A.d(tr.INC++, "uint32", "optional"), u("design:type", Number)], it.prototype, "minHeight", void 0);
    l([A.d(tr.INC++, "uint32", "optional"), u("design:type", Number)], it.prototype, "maxHeight", void 0);
    l([A.d(tr.INC++, "string", "optional"), u("design:type", String)], it.prototype, "trusteeId", void 0);
    l([A.d(tr.INC++, "string", "optional"), u("design:type", String)], it.prototype, "purchaseDAppid", void 0);
    l([A.d(tr.INC++, "uint32"), u("design:type", Number)], it.prototype, "offset", void 0);
    l([A.d(tr.INC++, "uint32", "optional"), u("design:type", Number)], it.prototype, "limit", void 0);
    l([A.d(tr.INC++, "string", "optional"), u("design:type", String)], it.prototype, "range", void 0);
    l([A.d(tr.INC++, "string", "optional"), u("design:type", String)], it.prototype, "address", void 0);
    it = tr = l([R.d("TransactionQueryOptions")], it);
    let qr = Ty = class extends Y {
      toJSON() {
        return { tIndex: this.tIndex };
      }
    };
    qr.INC = 1;
    l([A.d(Ty.INC++, "int32", "required", 1), u("design:type", Number)], qr.prototype, "tIndex", void 0);
    qr = Ty = l([R.d("TransactionSortOptions")], qr);
    let ao = class extends Y {
      toJSON() {
        return { query: this.query.toJSON(), sort: this.sort.toJSON() };
      }
    };
    l([A.d(1, it), u("design:type", it)], ao.prototype, "query", void 0);
    l([A.d(2, qr), u("design:type", qr)], ao.prototype, "sort", void 0);
    ao = l([R.d("QueryTransactionArg")], ao);
    let Pa = Sy = class extends er {
      toJSON() {
        return Object.assign({ transactions: this.transactions.map((e) => e.toJSON()) }, super.toJSON());
      }
    };
    l([A.d(Sy.INC++, qt, "repeated"), u("design:type", Array)], Pa.prototype, "transactions", void 0);
    Pa = Sy = l([R.d("QueryTransactionReturn")], Pa);
    let tl = class extends Y {
      toJSON() {
        return { query: this.query, sort: this.sort };
      }
    };
    l([A.d(1, it), u("design:type", it)], tl.prototype, "query", void 0);
    l([A.d(2, qr), u("design:type", qr)], tl.prototype, "sort", void 0);
    tl = l([R.d("QueryTindexArg")], tl);
    let Ma = wy = class extends er {
      toJSON() {
        return Object.assign({ tIndexes: this.tIndexes }, super.toJSON());
      }
    };
    l([A.d(wy.INC++, "uint32", "repeated"), u("design:type", Array)], Ma.prototype, "tIndexes", void 0);
    Ma = wy = l([R.d("QueryTindexReturn")], Ma);
    let co = by = class extends Y {
      static fromObject(e) {
        return super.fromObject(e);
      }
      toJSON() {
        return { tIndexRanges: this.tIndexRanges };
      }
    };
    co.INC = 1;
    l([A.d(by.INC++, "uint32", "repeated"), u("design:type", Array)], co.prototype, "tIndexRanges", void 0);
    co = by = l([R.d("TransactionInBlockGetOptions")], co);
    let rl = class extends Y {
      toJSON() {
        return { query: this.query };
      }
    };
    l([A.d(1, co), u("design:type", co)], rl.prototype, "query", void 0);
    rl = l([R.d("GetTransactionInBlockArg")], rl);
    let La = Ny = class extends er {
      toJSON() {
        return Object.assign({ transactionInBlocks: this.transactionInBlocks.map((e) => e.toJSON()) }, super.toJSON());
      }
    };
    l([A.d(Ny.INC++, qt, "repeated"), u("design:type", Array)], La.prototype, "transactionInBlocks", void 0);
    La = Ny = l([R.d("GetTransactionInBlockReturn")], La);
    let nl = xy = class extends Wi {
      static fromObject(e) {
        return super.fromObject(e);
      }
    };
    l([A.d(xy.INC++, "string", "optional"), u("design:type", String)], nl.prototype, "grabSecret", void 0);
    nl = xy = l([R.d("NewTransactionArg")], nl);
    let gs = Mo = class extends er {
      toJSON() {
        let e, t, r;
        const n = Object.assign({ newTrsStatus: this.newTrsStatus, minFee: this.minFee }, super.toJSON());
        return (e = this.refuseReason) !== null && e !== void 0 || (n.refuseReason = this.refuseReason), (t = this.errorCode) !== null && t !== void 0 || (n.errorCode = this.errorCode), (r = this.errorMessage) !== null && r !== void 0 || (n.errorMessage = this.errorMessage), n;
      }
    };
    l([A.d(Mo.INC++, dh, "required", dh.Refuse), u("design:type", Number)], gs.prototype, "newTrsStatus", void 0);
    l([A.d(Mo.INC++, "string", "required", "0"), u("design:type", String)], gs.prototype, "minFee", void 0);
    l([A.d(Mo.INC++, Ce, "optional"), u("design:type", Number)], gs.prototype, "refuseReason", void 0);
    l([A.d(Mo.INC++, "string", "optional"), u("design:type", String)], gs.prototype, "errorCode", void 0);
    l([A.d(Mo.INC++, "string", "optional"), u("design:type", String)], gs.prototype, "errorMessage", void 0);
    gs = Mo = l([R.d("NewTransactionReturn")], gs);
    let ds = class extends Y {
      toJSON() {
        const e = { height: this.height, tIndex: this.tIndex, length: this.length };
        return this.blockSignature && (e.blockSignature = this.blockSignature), e;
      }
    };
    l([A.d(1, "uint32"), u("design:type", Number)], ds.prototype, "height", void 0);
    l([A.d(2, "uint32"), u("design:type", Number)], ds.prototype, "tIndex", void 0);
    l([A.d(3, "uint32", "required", 1), u("design:type", Number)], ds.prototype, "length", void 0);
    l([A.d(4, "string"), u("design:type", String)], ds.prototype, "blockSignature", void 0);
    ds = l([R.d("TransactionIndexModel")], ds);
    let sl = class extends Y {
      toJSON() {
        return { query: this.query.toJSON(), sort: this.sort.toJSON() };
      }
    };
    l([A.d(1, it), u("design:type", it)], sl.prototype, "query", void 0);
    l([A.d(2, qr), u("design:type", qr)], sl.prototype, "sort", void 0);
    sl = l([R.d("IndexTransactionArg")], sl);
    let Ha = Oy = class extends er {
      toJSON() {
        return Object.assign({ tIndexes: this.tIndexes.map((e) => e.toJSON()) }, super.toJSON());
      }
    };
    l([A.d(Oy.INC++, ds, "repeated"), u("design:type", Array)], Ha.prototype, "tIndexes", void 0);
    Ha = Oy = l([R.d("IndexTransactionReturn")], Ha);
    let il = class extends Y {
      toJSON() {
        return { tIndexes: this.tIndexes.map((e) => e.toJSON()) };
      }
    };
    l([A.d(1, ds, "repeated"), u("design:type", Array)], il.prototype, "tIndexes", void 0);
    il = l([R.d("DownloadTransactionArg")], il);
    let va = Cy = class extends er {
      toJSON() {
        return Object.assign({ transactions: this.transactions.map((e) => e.toJSON()) }, super.toJSON());
      }
    };
    l([A.d(Cy.INC++, qt, "repeated"), u("design:type", Array)], va.prototype, "transactions", void 0);
    va = Cy = l([R.d("DownloadTransactionReturn")], va);
    let Rl;
    let Bl;
    let Ry;
    let Pl;
    let Ii = Rl = class extends Y {
      get hash() {
        return xe(this.hashBuffer);
      }
      set hash(e) {
        this.hashBuffer = _e(e);
      }
      toJSON() {
        return { algorithm: this.algorithm, hash: this.hash, downloadSize: this.downloadSize };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return e.hash && (t.hash = e.hash), t;
      }
    };
    Ii.INC = 1;
    l([A.d(Rl.INC++, "string"), u("design:type", String)], Ii.prototype, "algorithm", void 0);
    l([A.d(Rl.INC++, "bytes"), u("design:type", Uint8Array)], Ii.prototype, "hashBuffer", void 0);
    l([A.d(Rl.INC++, "int32"), u("design:type", Number)], Ii.prototype, "downloadSize", void 0);
    Ii = Rl = l([R.d("OpenBlobArgModel")], Ii);
    let Ti = Bl = class extends er {
      toJSON() {
        const e = super.toJSON();
        return e.descriptor = this.descriptor, e.contentType = this.contentType, e;
      }
      static fromObject(e) {
        return super.fromObject(e);
      }
    };
    l([A.d(Bl.INC++, "string", "optional"), u("design:type", String)], Ti.prototype, "descriptor", void 0);
    l([A.d(Bl.INC++, "string", "optional"), u("design:type", String)], Ti.prototype, "contentType", void 0);
    l([A.d(Bl.INC++, "uint32", "optional"), u("design:type", Number)], Ti.prototype, "size", void 0);
    Ti = Bl = l([R.d("OpenBlobReturn")], Ti);
    let ka = Ry = class extends Y {
      toJSON() {
        return { descriptor: this.descriptor };
      }
    };
    ka.INC = 1;
    l([A.d(Ry.INC++, "string"), u("design:type", String)], ka.prototype, "descriptor", void 0);
    ka = Ry = l([R.d("CloseBlobArg")], ka);
    let ol = class extends er {
    };
    ol = l([R.d("CloseBlobReturn")], ol);
    let ks = Pl = class extends Y {
      toJSON() {
        return { descriptor: this.descriptor, start: this.start, end: this.end };
      }
    };
    ks.INC = 1;
    l([A.d(Pl.INC++, "string"), u("design:type", String)], ks.prototype, "descriptor", void 0);
    l([A.d(Pl.INC++, "uint32"), u("design:type", Number)], ks.prototype, "start", void 0);
    l([A.d(Pl.INC++, "uint32"), u("design:type", Number)], ks.prototype, "end", void 0);
    ks = Pl = l([R.d("ReadBlobArg")], ks);
    let po = class extends er {
      get chunk() {
        return xe(this.chunkBuffer);
      }
      set chunk(e) {
        this.chunkBuffer = _e(e);
      }
      toJSON() {
        const e = super.toJSON();
        return e.chunk = this.chunk, e;
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return e.chunk && (t.chunk = e.chunk), t;
      }
    };
    po.INC = 1;
    l([A.d(ks.INC++, "bytes"), u("design:type", Uint8Array)], po.prototype, "chunkBuffer", void 0);
    po = l([R.d("ReadBlobReturn")], po);
    let By;
    let As;
    let lo = class extends Y {
      toJSON() {
        const e = super.toJSON();
        return this.signature && (e.signature = this.signature), this.height && (e.height = this.height), e;
      }
    };
    l([A.d(1, "string", "optional"), u("design:type", String)], lo.prototype, "signature", void 0);
    l([A.d(2, "uint32", "optional"), u("design:type", Number)], lo.prototype, "height", void 0);
    lo = l([R.d("BlockQueryOptions")], lo);
    let Da = class extends Y {
      toJSON() {
        return { query: this.query.toJSON() };
      }
    };
    l([A.d(1, lo), u("design:type", lo)], Da.prototype, "query", void 0);
    Da = l([R.d("QueryBlockArg")], Da);
    let Fa = By = class extends er {
      toJSON() {
        const e = super.toJSON();
        return this.someBlock && (e.someBlock = this.someBlock.toJSON()), e;
      }
    };
    l([A.d(By.INC++, mi, "optional"), u("design:type", mi)], Fa.prototype, "someBlock", void 0);
    Fa = By = l([R.d("QueryBlockReturn")], Fa);
    let Ur = As = class extends Y {
      get generatorPublicKey() {
        return xe(this.generatorPublicKeyBuffer);
      }
      set generatorPublicKey(e) {
        this.generatorPublicKeyBuffer = _e(e);
      }
      toJSON() {
        return { height: this.height, signature: this.signature, previousBlockSignature: this.previousBlockSignature, timestamp: this.timestamp, totalFee: this.totalFee, numberOfTransactions: this.numberOfTransactions, generatorPublicKey: this.generatorPublicKey, version: this.version };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.generatorPublicKey && (t.generatorPublicKey = e.generatorPublicKey), t;
      }
    };
    Ur.INC = 1;
    l([A.d(As.INC++, "uint32"), u("design:type", Number)], Ur.prototype, "height", void 0);
    l([A.d(As.INC++, "string"), u("design:type", String)], Ur.prototype, "signature", void 0);
    l([A.d(As.INC++, "string"), u("design:type", String)], Ur.prototype, "previousBlockSignature", void 0);
    l([A.d(As.INC++, "uint32"), u("design:type", Number)], Ur.prototype, "timestamp", void 0);
    l([A.d(As.INC++, "string"), u("design:type", String)], Ur.prototype, "totalFee", void 0);
    l([A.d(As.INC++, "uint32"), u("design:type", Number)], Ur.prototype, "numberOfTransactions", void 0);
    l([A.d(As.INC++, "bytes"), u("design:type", Uint8Array)], Ur.prototype, "generatorPublicKeyBuffer", void 0);
    l([A.d(As.INC++, "uint32"), u("design:type", Number)], Ur.prototype, "version", void 0);
    Ur = As = l([R.d("NewBlockArg")], Ur);
    let $a = class extends er {
    };
    $a = l([R.d("NewBlockReturn")], $a);
    let cn;
    let Pi;
    let zs;
    let Py;
    const Um = /* @__PURE__ */ new WeakMap();
    const sf = /* @__PURE__ */ new WeakMap();
    let al = class extends Y {
      toJSON() {
        return { uid: this.uid };
      }
    };
    l([A.d(1, "uint32", "optional"), u("design:type", Number)], al.prototype, "uid", void 0);
    al = l([R.d("GetPeerInfoArg")], al);
    let cl = class extends Y {
      get peerTime() {
        return this.peerTimeLong.toNumber();
      }
      set peerTime(e) {
        this.peerTimeLong = Sc.fromNumber(e, true);
      }
      toJSON() {
        return { peerTime: this.peerTime };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && e.peerTime !== void 0 && (t.peerTime = e.peerTime), t;
      }
    };
    l([A.d(1, "uint64"), u("design:type", Object)], cl.prototype, "peerTimeLong", void 0);
    cl = l([R.d("PeerConsensus")], cl);
    let ur = cn = class extends Y {
      get servicePeerInfo() {
        return { peerInfoDelay: this.peerInfoDelay, onlineUser: this.onlineUser, productivity: this.productivity, paidSourceChainMagic: this.paidSourceChainMagic, paidsourceChainName: this.paidsourceChainName, paidAssetType: this.paidAssetType, paidAmount: this.paidAmount, paidType: this.paidType, serviceNotesName: this.serviceNotesName, noteIP: this.noteIP, dappOnChainBuy: this.dappOnChainBuy };
      }
      set servicePeerInfo(e) {
        this.peerInfoDelay = e.peerInfoDelay, this.onlineUser = e.onlineUser, this.productivity = e.productivity, this.paidSourceChainMagic = e.paidSourceChainMagic, this.paidsourceChainName = e.paidsourceChainName, this.paidAssetType = e.paidAssetType, this.paidAmount = e.paidAmount, this.paidType = e.paidType, this.serviceNotesName = e.serviceNotesName, this.noteIP = e.noteIP, this.dappOnChainBuy = e.dappOnChainBuy;
      }
      toJSON() {
        return { peerInfoDelay: this.peerInfoDelay, onlineUser: this.onlineUser, productivity: this.productivity, paidSourceChainMagic: this.paidSourceChainMagic, paidsourceChainName: this.paidsourceChainName, paidAssetType: this.paidAssetType, paidAmount: this.paidAmount, paidType: this.paidType, serviceNotesName: this.serviceNotesName, noteIP: this.noteIP, dappOnChainBuy: this.dappOnChainBuy };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        return t !== e && (e.peerInfoDelay && (t.peerInfoDelay = e.peerInfoDelay), e.onlineUser && (t.onlineUser = e.onlineUser), e.productivity && (t.productivity = e.productivity), e.paidSourceChainMagic && (t.paidSourceChainMagic = e.paidSourceChainMagic), e.paidsourceChainName && (t.paidsourceChainName = e.paidsourceChainName), e.paidAmount && (t.paidAmount = e.paidAmount), e.paidType && (t.paidType = e.paidType), e.serviceNotesName && (t.serviceNotesName = e.serviceNotesName), e.noteIP && (t.noteIP = e.noteIP), e.dappOnChainBuy && (t.dappOnChainBuy = e.dappOnChainBuy)), t;
      }
    };
    ur.INC = 1;
    l([A.d(cn.INC++, "uint32"), u("design:type", Number)], ur.prototype, "peerInfoDelay", void 0);
    l([A.d(cn.INC++, "uint32"), u("design:type", Number)], ur.prototype, "onlineUser", void 0);
    l([A.d(cn.INC++, "uint32"), u("design:type", Number)], ur.prototype, "productivity", void 0);
    l([A.d(cn.INC++, "string"), u("design:type", String)], ur.prototype, "paidSourceChainMagic", void 0);
    l([A.d(cn.INC++, "string"), u("design:type", String)], ur.prototype, "paidsourceChainName", void 0);
    l([A.d(cn.INC++, "string"), u("design:type", String)], ur.prototype, "paidAssetType", void 0);
    l([A.d(cn.INC++, "string"), u("design:type", String)], ur.prototype, "paidAmount", void 0);
    l([A.d(cn.INC++, "string"), u("design:type", String)], ur.prototype, "paidType", void 0);
    l([A.d(cn.INC++, "string"), u("design:type", String)], ur.prototype, "serviceNotesName", void 0);
    l([A.d(cn.INC++, "string"), u("design:type", String)], ur.prototype, "noteIP", void 0);
    l([A.d(cn.INC++, "bool"), u("design:type", Boolean)], ur.prototype, "dappOnChainBuy", void 0);
    ur = cn = l([R.d("ServicePeerInfo")], ur);
    let jn = Pi = class extends Y {
      get progress() {
        const { status: e } = this;
        return e === Qr.REBUIDING ? { status: e, progressEvent: this.rebuildingProgressEvent } : e === Qr.PEER_SCANNING ? { status: e, progressEvent: this.peerScanningProgressEvent } : e === Qr.REPLAY_BLOCK ? { status: e, progressEvent: this.replayBlockProgressEvent } : e === Qr.GENERATING ? { status: e, progressEvent: this.generatingProgressEvent } : e === Qr.ROLLBACK ? { status: e, progressEvent: this.rollbackProgressEvent } : { status: e, progressEvent: void 0 };
      }
      get progressEvent() {
        return this._progressEvent;
      }
      set progressEvent(e) {
        e && (e instanceof vs ? this.rebuildingProgressEvent = e : e instanceof Ca ? this.peerScanningProgressEvent = e : e instanceof Ei ? this.replayBlockProgressEvent = e : e instanceof Ba ? this.generatingProgressEvent = e : e instanceof Ra && (this.rollbackProgressEvent = e));
      }
      get status() {
        return this._status;
      }
      set status(e) {
        e !== this._status && (this._status = e, this._clearProgressEvent(), e === Qr.REBUIDING ? this.rebuildingProgressEvent = vs.fromObject({ mode: si.DETERMINATE }) : e === Qr.PEER_SCANNING ? this.peerScanningProgressEvent = Ca.fromObject({ mode: si.BUFFER }) : e === Qr.REPLAY_BLOCK ? this.replayBlockProgressEvent = Ei.fromObject({ mode: si.BUFFER }) : e === Qr.GENERATING ? this.generatingProgressEvent = Ba.fromObject({ mode: si.QUERY }) : e === Qr.ROLLBACK && (this.rollbackProgressEvent = Ra.fromObject({ mode: si.BUFFER })));
      }
      _clearProgressEvent() {
        this.rebuildingProgressEvent = void 0, this.peerScanningProgressEvent = void 0, this.replayBlockProgressEvent = void 0, this.generatingProgressEvent = void 0, this.rollbackProgressEvent = void 0;
      }
      toJSON() {
        return this.progress;
      }
    };
    jn.INC = 1;
    l([A.d(Pi.INC++, vs, "optional"), u("design:type", vs)], jn.prototype, "rebuildingProgressEvent", void 0);
    l([A.d(Pi.INC++, Ca, "optional"), u("design:type", Ca)], jn.prototype, "peerScanningProgressEvent", void 0);
    l([A.d(Pi.INC++, Ei, "optional"), u("design:type", Ei)], jn.prototype, "replayBlockProgressEvent", void 0);
    l([A.d(Pi.INC++, Ba, "optional"), u("design:type", Ba)], jn.prototype, "generatingProgressEvent", void 0);
    l([A.d(Pi.INC++, Ra, "optional"), u("design:type", Ra)], jn.prototype, "rollbackProgressEvent", void 0);
    l([A.d(Pi.INC++, Qr), u("design:type", Number)], jn.prototype, "_status", void 0);
    jn = Pi = l([R.d("BlockchainStatus")], jn);
    let on = zs = class extends Y {
      constructor() {
        super(...arguments), this._parsed_serviceInfo = false;
      }
      get serviceInfo() {
        return !this._parsed_serviceInfo && typeof this.serviceInfoJSON === "string" && (this._parsed_serviceInfo = true, this._serviceInfo = JSON.parse(this.serviceInfoJSON)), this._serviceInfo;
      }
      set serviceInfo(e) {
        this.serviceInfoJSON = (this._serviceInfo = e) ? JSON.stringify(e) : void 0, this._parsed_serviceInfo = true;
      }
      get servicePeerInfo() {
        const { servicePeerInfoBufferList: e } = this;
        let t = Um.get(e);
        return t || (t = this.servicePeerInfoBufferList.map((r) => {
          const n = ur.decode(r);
          return sf.set(n, r), n;
        })), t;
      }
      set servicePeerInfo(e) {
        const t = e.map((r) => {
          let n = sf.get(r);
          return n || (n = ur.encode(r).finish(), sf.set(r, n)), n;
        });
        Um.set(t, e), this.servicePeerInfoBufferList = t;
      }
      toJSON() {
        return { uid: this.uid, height: this.height, blockchainStatus: this.blockchainStatus.toJSON(), serviceInfo: this.serviceInfo, servicePeerInfo: this.servicePeerInfo.map((e) => e.toJSON()), peerConsensus: this.peerConsensus.toJSON(), peerLinkCount: this.peerLinkCount };
      }
      static fromObject(e) {
        const t = super.fromObject(e);
        if (t !== e) {
          const r = [];
          if (e.servicePeerInfo) {
            const n = e.servicePeerInfo;
            for (const s of n) r[r.length] = ur.fromObject(s);
          }
          t.servicePeerInfo = r;
        }
        return t;
      }
    };
    on.INC = 1;
    l([A.d(zs.INC++, "uint32"), u("design:type", Number)], on.prototype, "uid", void 0);
    l([A.d(zs.INC++, "uint32"), u("design:type", Number)], on.prototype, "height", void 0);
    l([A.d(zs.INC++, jn), u("design:type", jn)], on.prototype, "blockchainStatus", void 0);
    l([A.d(zs.INC++, "string", "optional"), u("design:type", String)], on.prototype, "serviceInfoJSON", void 0);
    l([A.d(zs.INC++, "bytes", "repeated"), u("design:type", Array)], on.prototype, "servicePeerInfoBufferList", void 0);
    l([A.d(zs.INC++, cl), u("design:type", cl)], on.prototype, "peerConsensus", void 0);
    l([A.d(zs.INC++, "uint32"), u("design:type", Number)], on.prototype, "peerLinkCount", void 0);
    on = zs = l([R.d("PeerInfo")], on);
    let Ua = Py = class extends er {
      toJSON() {
        const e = super.toJSON();
        return this.peerInfo && (e.peerInfo = this.peerInfo.toJSON()), e;
      }
    };
    l([A.d(Py.INC++, on, "optional"), u("design:type", on)], Ua.prototype, "peerInfo", void 0);
    Ua = Py = l([R.d("GetPeerInfoReturn")], Ua);
    let js;
    let Zr = js = class extends Y {
    };
    Zr.INC = 1;
    l([A.d(js.INC++, "uint32"), u("design:type", Number)], Zr.prototype, "version", void 0);
    l([A.d(js.INC++, "uint32"), u("design:type", Number)], Zr.prototype, "req_id", void 0);
    l([A.d(js.INC++, Ie), u("design:type", Number)], Zr.prototype, "cmd", void 0);
    l([A.d(js.INC++, "bytes"), u("design:type", Uint8Array)], Zr.prototype, "binary", void 0);
    l([A.d(js.INC++, "uint32"), u("design:type", Number)], Zr.prototype, "lockTimespan", void 0);
    l([A.d(js.INC++, "uint32"), u("design:type", Number)], Zr.prototype, "refuseTimespan", void 0);
    l([A.d(js.INC++, "uint32"), u("design:type", Number)], Zr.prototype, "messageVersion", void 0);
    Zr = js = l([R.d("ChainChannelMessageModel")], Zr);
    let yh;
    (function(i) {
      i[i.TESTNET = 0] = "TESTNET", i[i.MAINNET = 1] = "MAINNET";
    })(yh || (yh = {}));
    let ne = class {
      constructor(e, t) {
        this.genesisBlock = e, this.business = t, this.events = new An(), this._hookBlockMap = /* @__PURE__ */ new Map(), this._hookBlockMap.set(e.version, e), this.hookedGenesisBlock = this.genesisBlock;
      }
      _applyHookGenesisBlock() {
        const e = [...this._hookBlockMap].toSorted((t, r) => t[0] - r[0]);
        this.hookedGenesisBlock = hT(this.genesisBlock, ...e.map((t) => ({ ...t[1], version: t[0] }))), $E(this), this.events.emit("hookGenesisBlockApply", this.toJSON());
      }
      setHookGenesisBlock(e, t) {
        this._hookBlockMap.set(e, t), this._applyHookGenesisBlock();
      }
      getHookGenesisBlock(e) {
        return this._hookBlockMap.get(e);
      }
      rollBackHookGenesisBlock(e) {
        this._hookBlockMap.delete(e) && this._applyHookGenesisBlock();
      }
      get version() {
        return this.hookedGenesisBlock.version;
      }
      get miniUnit() {
        return "1";
      }
      get netType() {
        return this.initials === "b" ? yh.MAINNET : yh.TESTNET;
      }
      get initials() {
        return this.bnid;
      }
      get genesisAccountPublicKey() {
        return this.hookedGenesisBlock.generatorPublicKey;
      }
      get chainName() {
        return this.hookedGenesisBlock.asset.genesisAsset.chainName;
      }
      get assetType() {
        return this.hookedGenesisBlock.asset.genesisAsset.assetType;
      }
      get magic() {
        return this.hookedGenesisBlock.asset.genesisAsset.magic;
      }
      get bnid() {
        return this.hookedGenesisBlock.asset.genesisAsset.bnid;
      }
      get beginEpochTime() {
        return this.hookedGenesisBlock.asset.genesisAsset.beginEpochTime;
      }
      get genesisLocationName() {
        return this.hookedGenesisBlock.asset.genesisAsset.genesisLocationName;
      }
      get genesisAmount() {
        return this.hookedGenesisBlock.asset.genesisAsset.genesisAmount;
      }
      get maxSupply() {
        return this.hookedGenesisBlock.asset.genesisAsset.maxSupply;
      }
      get minTransactionFeePerByte() {
        return this.hookedGenesisBlock.asset.genesisAsset.minTransactionFeePerByte;
      }
      get maxTransactionSize() {
        return this.hookedGenesisBlock.asset.genesisAsset.maxTransactionSize;
      }
      get maxTransactionBlobSize() {
        return this.hookedGenesisBlock.asset.genesisAsset.maxTransactionBlobSize;
      }
      get maxBlockSize() {
        return this.hookedGenesisBlock.asset.genesisAsset.maxBlockSize;
      }
      get maxBlockBlobSize() {
        return this.hookedGenesisBlock.asset.genesisAsset.maxBlockBlobSize;
      }
      get maxTPSPerBlock() {
        return this.hookedGenesisBlock.asset.genesisAsset.maxTPSPerBlock;
      }
      get consessusBeforeSyncBlockDiff() {
        return this.hookedGenesisBlock.asset.genesisAsset.consessusBeforeSyncBlockDiff;
      }
      get maxGrabTimesOfGiftAsset() {
        return this.hookedGenesisBlock.asset.genesisAsset.maxGrabTimesOfGiftAsset;
      }
      get issueAssetMinChainAsset() {
        return this.magic === "RRJJO" ? "100000000000" : this.hookedGenesisBlock.asset.genesisAsset.issueAssetMinChainAsset;
      }
      get maxMultipleOfAssetAndMainAsset() {
        return this.magic === "RRJJO" ? { numerator: "1000000", denominator: "1" } : this.hookedGenesisBlock.asset.genesisAsset.maxMultipleOfAssetAndMainAsset;
      }
      get issueEntityFactoryMinChainAsset() {
        return this.hookedGenesisBlock.asset.genesisAsset.issueEntityFactoryMinChainAsset;
      }
      get maxMultipleOfEntityAndMainAsset() {
        return this.hookedGenesisBlock.asset.genesisAsset.maxMultipleOfEntityAndMainAsset;
      }
      get registerChainMinChainAsset() {
        return this.hookedGenesisBlock.asset.genesisAsset.registerChainMinChainAsset;
      }
      get maxApplyAndConfirmedBlockHeightDiff() {
        return this.hookedGenesisBlock.asset.genesisAsset.maxApplyAndConfirmedBlockHeightDiff;
      }
      get blockPerRound() {
        return this.hookedGenesisBlock.asset.genesisAsset.blockPerRound;
      }
      get whetherToAllowGeneratorContinusElections() {
        return this.hookedGenesisBlock.asset.genesisAsset.whetherToAllowGeneratorContinusElections;
      }
      get forgeInterval() {
        return this.hookedGenesisBlock.asset.genesisAsset.forgeInterval;
      }
      get basicRewards() {
        return this.hookedGenesisBlock.asset.genesisAsset.basicRewards;
      }
      get ports() {
        return this.hookedGenesisBlock.asset.genesisAsset.ports;
      }
      get generatorPublicKey() {
        return this.hookedGenesisBlock.generatorPublicKey;
      }
      get signature() {
        return this.hookedGenesisBlock.signature;
      }
      get nextRoundGenerators() {
        return this.hookedGenesisBlock.asset.genesisAsset.nextRoundGenerators;
      }
      get blobFeeMultipleRatio() {
        return { numerator: BigInt(this.genesisAmount), denominator: BigInt(31456e11) };
      }
      toJSON() {
        return { version: this.version, miniUnit: this.miniUnit, chainName: this.chainName, assetType: this.assetType, magic: this.magic, bnid: this.bnid, beginEpochTime: this.beginEpochTime, genesisLocationName: this.genesisLocationName, genesisAmount: this.genesisAmount, maxSupply: this.maxSupply, minTransactionFeePerByte: this.minTransactionFeePerByte, maxTransactionSize: this.maxTransactionSize, maxTransactionBlobSize: this.maxTransactionBlobSize, maxBlockSize: this.maxBlockSize, maxBlockBlobSize: this.maxBlockBlobSize, maxTPSPerBlock: this.maxTPSPerBlock, consessusBeforeSyncBlockDiff: this.consessusBeforeSyncBlockDiff, maxGrabTimesOfGiftAsset: this.maxGrabTimesOfGiftAsset, issueAssetMinChainAsset: this.issueAssetMinChainAsset, maxMultipleOfAssetAndMainAsset: this.maxMultipleOfAssetAndMainAsset, issueEntityFactoryMinChainAsset: this.issueEntityFactoryMinChainAsset, maxMultipleOfEntityAndMainAsset: this.maxMultipleOfEntityAndMainAsset, registerChainMinChainAsset: this.registerChainMinChainAsset, maxApplyAndConfirmedBlockHeightDiff: this.maxApplyAndConfirmedBlockHeightDiff, blockPerRound: this.blockPerRound, whetherToAllowGeneratorContinusElections: this.whetherToAllowGeneratorContinusElections, forgeInterval: this.forgeInterval, basicRewards: this.basicRewards, ports: this.ports };
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "version", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "miniUnit", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "netType", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "genesisAccountPublicKey", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "chainName", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "assetType", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "magic", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "bnid", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "beginEpochTime", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "genesisLocationName", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "genesisAmount", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "maxSupply", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "minTransactionFeePerByte", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "maxTransactionSize", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "maxTransactionBlobSize", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "maxBlockSize", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "maxBlockBlobSize", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "maxTPSPerBlock", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "consessusBeforeSyncBlockDiff", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "maxGrabTimesOfGiftAsset", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "issueAssetMinChainAsset", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "maxMultipleOfAssetAndMainAsset", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "issueEntityFactoryMinChainAsset", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "maxMultipleOfEntityAndMainAsset", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "registerChainMinChainAsset", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "maxApplyAndConfirmedBlockHeightDiff", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "blockPerRound", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "whetherToAllowGeneratorContinusElections", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "forgeInterval", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "basicRewards", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "ports", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "generatorPublicKey", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "signature", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ne.prototype, "nextRoundGenerators", null);
    ne = l([J("config"), u("design:paramtypes", [Object, String])], ne);
    let xr = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      get clear() {
        return this._map.clear.bind(this._map);
      }
      get delete() {
        return this._map.delete.bind(this._map);
      }
      get forEach() {
        return this._map.forEach.bind(this._map);
      }
      get get() {
        return this._map.get.bind(this._map);
      }
      get has() {
        return this._map.has.bind(this._map);
      }
      get set() {
        return this._map.set.bind(this._map);
      }
      get size() {
        return this._map.size;
      }
      get [Symbol.iterator]() {
        return this._map[Symbol.iterator].bind(this._map);
      }
      get entries() {
        return this._map.entries.bind(this._map);
      }
      get keys() {
        return this._map.keys.bind(this._map);
      }
      get values() {
        return this._map.values.bind(this._map);
      }
      get [Symbol.toStringTag]() {
        return "EasyMap";
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xr.prototype, "delete", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xr.prototype, "forEach", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xr.prototype, "get", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xr.prototype, "has", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xr.prototype, "set", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xr.prototype, Symbol.iterator, null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xr.prototype, "entries", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xr.prototype, "keys", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], xr.prototype, "values", null);
    xr = l([J("configMap")], xr);
    const Ft = class extends nh {
      getTimestamp(e = this.now()) {
        return Math.floor((e - this.config.beginEpochTime) / 1e3);
      }
      getTimeByTimestamp(e) {
        return e * 1e3 + this.config.beginEpochTime;
      }
      get beginEpochTime() {
        return new Date(this.config.beginEpochTime);
      }
      getSlotNumberByTimestamp(e = this.getTimestamp()) {
        return Math.floor(e / this.config.forgeInterval);
      }
      getNextSlotNumberByTimestamp(e = this.getTimestamp()) {
        return this.getSlotNumberByTimestamp(e) + 1;
      }
      getTimestampBySlotNumber(e) {
        return e * this.config.forgeInterval;
      }
      formatTimestamp(e = this.getTimestamp()) {
        return this.formatDateTime(e * 1e3 + this.config.beginEpochTime);
      }
    };
    l([D(ne), u("design:type", ne)], Ft.prototype, "config", void 0);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Ft.prototype, "beginEpochTime", null);
    const { ArgumentIllegalException: kT } = ee("HELPER", "jsbiHelper");
    function dr(i) {
      try {
        if (typeof i === "string") {
          if (/^[0-9-]*$/.test(i) === false) throw new Error("QAQ");
          i = parseInt(i);
        } else if (typeof i === "number") i = Math.floor(i);
        else return i;
        return BigInt(i);
      } catch {
        throw new kT(c.PROP_IS_INVALID, { prop: `param ${i}`, target: "fraction" });
      }
    }
    let xt = class {
      multiplyFloor(e, t) {
        return this.multiplyFloorFraction(e, this.numberToFraction(t));
      }
      floorFraction(e) {
        const t = dr(e.numerator), r = dr(e.denominator);
        return t / r;
      }
      ceilFraction(e) {
        const t = dr(e.numerator), r = dr(e.denominator), n = t / r;
        return n * r === t ? n : n + BigInt(1);
      }
      multiplyFraction(e, t) {
        const r = BigInt(e.numerator), n = BigInt(e.denominator), s = BigInt(t.numerator), o = BigInt(t.denominator);
        return { numerator: r * s, denominator: n * o };
      }
      multiplyFractionAndFloor(e, t) {
        return this.floorFraction(this.multiplyFraction(e, t));
      }
      multiplyFractionAndCeil(e, t) {
        return this.ceilFraction(this.multiplyFraction(e, t));
      }
      multiplyFloorFraction(e, t) {
        const r = dr(e), n = BigInt(t.numerator), s = BigInt(t.denominator);
        return r * n / s;
      }
      multiplyFloorFractionString(e, t) {
        const r = dr(e), n = BigInt(t.numerator), s = BigInt(t.denominator);
        return r * n / s;
      }
      multiplyRound(e, t) {
        return this.multiplyRoundFraction(e, this.numberToFraction(t));
      }
      multiplyRoundFraction(e, t) {
        const r = this.multiplyFloorFraction(e, { numerator: BigInt(t.numerator) * BigInt(10), denominator: BigInt(t.denominator) }), n = r / BigInt(10);
        return r % BigInt(10) >= BigInt(5) ? n + BigInt(1) : n;
      }
      numberToFraction(e) {
        const r = e.toFixed(45).split("."), n = r.length > 1 ? r[1].length : 0, s = 1 + "0".repeat(n);
        return { numerator: r.join(""), denominator: s };
      }
      multiplyCeil(e, t) {
        return this.multiplyCeilFraction(e, this.numberToFraction(t));
      }
      multiplyCeilFraction(e, t) {
        const r = dr(e), n = BigInt(t.numerator), s = BigInt(t.denominator), o = r * n, a = o / s;
        return a * s === o ? a : a + BigInt(1);
      }
      divisionCeilFraction(e, t) {
        const r = dr(e), n = BigInt(t.numerator), s = BigInt(t.denominator), o = r * s, a = o / n;
        return a * n === o ? a : a + BigInt(1);
      }
      divisionFraction(e, t) {
        const r = BigInt(e.numerator), n = BigInt(e.denominator), s = BigInt(t.numerator), o = BigInt(t.denominator);
        return { numerator: r * o, denominator: n * s };
      }
      divisionFractionAndFloor(e, t) {
        return this.floorFraction(this.divisionFraction(e, t));
      }
      divisionFractionAndCeil(e, t) {
        return this.ceilFraction(this.divisionFraction(e, t));
      }
      compareFraction(e, t) {
        const r = dr(e.numerator), n = dr(e.denominator), s = dr(t.numerator), o = dr(t.denominator), a = r * o, p = s * n;
        return a === p ? 0 : a > p ? 1 : -1;
      }
      greatestCommonDivisor(e, t) {
        return t === BigInt(0) ? e : this.greatestCommonDivisor(t, e % t);
      }
      toFraction(e) {
        if (e.includes(".")) {
          const t = e.split(".");
          let r = BigInt(t[0] + t[1]), n = BigInt("1" + "0".repeat(t[1].length));
          const s = this.greatestCommonDivisor(r, n);
          return { numerator: (r / s).toString(), denominator: (n / s).toString() };
        } else return { numerator: e, denominator: "1" };
      }
      minusFraction(e, t) {
        const r = dr(e.numerator), n = dr(e.denominator), s = dr(t.numerator), o = dr(t.denominator), a = n * o, p = r * o - s * n, h = this.greatestCommonDivisor(p, a);
        return { numerator: (p / h).toString(), denominator: (a / h).toString() };
      }
    };
    xt = l([J()], xt);
    let Or = class {
      constructor(e, t, r) {
        this.cryptoHelper = e, this.keypairHelper = t, this.ed2curveHelper = r;
      }
      async detachedSign(e, t) {
        const r = await this.cryptoHelper.sha256(e);
        return this.keypairHelper.detached_sign(r, t);
      }
      async detachedVeriy(e, t, r) {
        const n = await this.cryptoHelper.sha256(e);
        return this.keypairHelper.detached_verify(n, t, r);
      }
      async signToString(e, t, r = "hex") {
        return (await this.detachedSign(e, t)).toString(r);
      }
      async asymmetricEncrypt(e, t, r) {
        const n = await this.ed2curveHelper.convertPublicKey(t);
        if (!n) throw new Error("decryptPK convertPublicKey fail");
        const s = await this.ed2curveHelper.convertSecretKey(r);
        return this.keypairHelper.box(e, n, s);
      }
      async asymmetricDecrypt(e, t, r, n = new Uint8Array(24)) {
        const s = await this.ed2curveHelper.convertPublicKey(t);
        if (!s) throw new Error("decryptPK convertPublicKey fail");
        const o = await this.ed2curveHelper.convertSecretKey(r);
        return await this.keypairHelper.open(e, n, s, o);
      }
    };
    Or = l([J("asymmetricHelper"), be(0, D("cryptoHelper")), be(1, D("keypairHelper")), be(2, D("ed2curveHelper")), u("design:paramtypes", [Object, Object, Object])], Or);
    let mh = class {
      calcParityBit(e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) t += e.charCodeAt(r);
        return t % 36;
      }
      shuffle(e) {
        let t = e.length;
        for (; t; ) {
          const r = Math.floor(Math.random() * t--);
          [e[r], e[t]] = [e[t], e[r]];
        }
        return e;
      }
      __getRandomString(e) {
        const t = [];
        for (let s = 0; s < 10; s++) t[t.length] = s;
        for (let s = 65; s < 91; s++) t[t.length] = String.fromCharCode(s);
        const r = this.shuffle(t);
        let n = "";
        for (let s = 0; s < e; s++) n += r[Math.floor(Math.random() * e)];
        return n;
      }
      __addParityBit(e) {
        const r = `P_${this.calcParityBit(e)}`;
        return e + Fi[r];
      }
      createMagic(e) {
        if (e) {
          if (typeof e !== "string") throw new Error(`Not a valid magic ${e}`);
          if (!new RegExp("^[A-Z0-9]{4}$").test(e)) throw new Error(`Not a valid magic ${e}`);
        } else e = this.__getRandomString(4);
        return this.__addParityBit(e);
      }
      createDAppId(e) {
        if (e) {
          if (typeof e !== "string") throw new Error(`Not a valid dappid ${e}`);
          if (!new RegExp("^[A-Z0-9]{7}$").test(e)) throw new Error(`Not a valid dappid ${e}`);
        } else e = this.__getRandomString(7);
        return this.__addParityBit(e);
      }
    };
    mh = l([J()], mh);
    const DT = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    const FT = class {
      constructor(e = DT) {
        this.ALPHABET = e, this.BASE = this.ALPHABET.length, this.ALPHABET_MAP = {}, this.LEADER = this.ALPHABET.charAt(0);
        for (let t = 0; t < e.length; t++) {
          const r = e.charAt(t);
          if (this.ALPHABET_MAP[r] !== void 0) throw new TypeError(r + " is ambiguous");
          this.ALPHABET_MAP[r] = t;
        }
      }
      encode(e) {
        if (e.length === 0) return "";
        const t = [0];
        for (let n = 0; n < e.length; ++n) {
          let s = e[n];
          for (let o = 0; o < t.length; ++o) s += t[o] << 8, t[o] = s % this.BASE, s = s / this.BASE | 0;
          for (; s > 0; ) t.push(s % this.BASE), s = s / this.BASE | 0;
        }
        let r = "";
        for (let n = 0; e[n] === 0 && n < e.length - 1; ++n) r += this.ALPHABET[0];
        for (let n = t.length - 1; n >= 0; --n) r += this.ALPHABET[t[n]];
        return r;
      }
      decodeUnsafe(e) {
        if (e.length === 0) return new Uint8Array();
        const t = [0];
        for (let r = 0; r < e.length; r++) {
          let n = this.ALPHABET_MAP[e[r]];
          if (n === void 0) return;
          let s = n;
          for (let o = 0; o < t.length; ++o) s += t[o] * this.BASE, t[o] = s & 255, s >>= 8;
          for (; s > 0; ) t.push(s & 255), s >>= 8;
        }
        for (let r = 0; e[r] === this.LEADER && r < e.length - 1; ++r) t.push(0);
        return new Uint8Array(t).toReversed();
      }
      decode(e) {
        const t = this.decodeUnsafe(e);
        if (t) return t;
        throw new Error("Non-base" + this.BASE + " character");
      }
    };
    const $T = new FT();
    let _h = class {
      constructor(e, t) {
        this.cryptoHelper = e, this.Buffer = t, this.bs58 = $T;
      }
      async sha256x2(e) {
        const t = await this.cryptoHelper.sha256(e);
        return this.cryptoHelper.sha256(t);
      }
      async encode(e) {
        return this.bs58.encode(this.Buffer.concat([e, await this.sha256x2(e)], e.length + 4));
      }
      async decodeRaw(e) {
        let t = e.slice(0, -4), r = e.slice(-4), n = await this.sha256x2(t);
        if (!(r[0] ^ n[0] | r[1] ^ n[1] | r[2] ^ n[2] | r[3] ^ n[3])) return this.Buffer.from(t);
      }
      async decodeUnsafe(e) {
        let t = await this.bs58.decodeUnsafe(e);
        if (t) return this.decodeRaw(t);
      }
      async decode(e) {
        let t = this.bs58.decode(e), r = await this.decodeRaw(t);
        if (!r) throw new Error("Invalid checksum");
        return r;
      }
    };
    _h = l([J(), be(0, D("cryptoHelper")), be(1, D("Buffer")), u("design:paramtypes", [Object, Object])], _h);
    const Vm = /* @__PURE__ */ new WeakMap();
    let me = class {
      constructor(e, t, r, n, s) {
        this.cryptoHelper = e, this.keypairHelperInterface = t, this.Buffer = r, this.base58Helper = n, this.config = s;
      }
      get _prefix() {
        return this.config.initials;
      }
      checkSecret(e) {
        if (/^\s|\s$/.test(e)) throw new SyntaxError("Main Secret cannot contain spaces at the beginning or end");
        if (/[\cA-\cZ]/.test(e)) throw new SyntaxError("Main Secret cannot contain Special Characters");
        return true;
      }
      async createSecretKeypair(e) {
        return await this.keypairHelperInterface.create(await this.cryptoHelper.sha256(_T(e)));
      }
      async getPublicKeyFromSecret(e) {
        return (await this.createSecretKeypair(e)).publicKey;
      }
      async getPublicKeyStringFromSecret(e, t = "hex") {
        return (await this.getPublicKeyFromSecret(e)).toString(t);
      }
      async getBinaryAddressFromPublicKey(e) {
        const t = Vm.get(e);
        if (t) return t;
        const r = await this.cryptoHelper.sha256(e), n = await this.cryptoHelper.ripemd160(r);
        return Vm.set(e, n), n;
      }
      async getAddressFromPublicKey(e, t = this._prefix) {
        return t + await this.base58Helper.encode(await this.getBinaryAddressFromPublicKey(e));
      }
      getAddressFromPublicKeyString(e, t) {
        return this.getAddressFromPublicKey(Z_(e), t);
      }
      async getAddressFromSecret(e, t) {
        return this.getAddressFromPublicKey(await this.getPublicKeyFromSecret(e), t);
      }
      async isAddress(e) {
        return typeof e !== "string" || /^[0-9]{1,20}$/g.test(e) ? false : !(e[0] !== this._prefix || !await this.base58Helper.decodeUnsafe(e.slice(1)));
      }
      async createSecondSecretKeypair(e, t) {
        return this.createSecretKeypair(`${e}-${t}`);
      }
      async getPublicKeyFromSecondSecret(e, t) {
        return (await this.createSecondSecretKeypair(e, t)).publicKey;
      }
      async getPublicKeyStringFromSecondSecret(e, t, r = "hex") {
        return (await this.getPublicKeyFromSecondSecret(e, t)).toString(r);
      }
      async checkSecondSecret(e, t, r) {
        return await this.getPublicKeyStringFromSecondSecret(e, t) === r;
      }
    };
    me = l([J(), be(0, D("cryptoHelper")), be(1, D("keypairHelper")), be(2, D("Buffer")), u("design:paramtypes", [Object, Object, Object, _h, ne])], me);
    let Be = class {
      constructor(e, t, r, n, s) {
        this.accountBaseHelper = e, this.configHelper = t, this.ipHelper = r, this.parityBitHelper = n, this.jsbiHelper = s, this.MAX_UINT_32_INTEGER = 2 ** 32, this.MAX_INT_32_INTEGER = 2 ** 31 - 1, this.MIN_INT_32_INTEGER = -(2 ** 31), this.isValidSecondPublicKey = this.isValidPublicKey, this.isValidAssetNumber = this.isStringNumber, this.isValidAccountEquity = this.isStringNumber, this.isValidBlockParticipation = this.isStringNumber, this.isValidEquityRate = this.isStringNumber, this.isValidAssetPrealnum = this.isStringNumber;
      }
      isIp(e) {
        return this.ipHelper.isIp(e);
      }
      isIpV4(e) {
        return this.ipHelper.isIpV4(e);
      }
      isIpV6(e) {
        return this.ipHelper.isIpV6(e);
      }
      isLongitude(e) {
        return /^[-+]((0(\.\d{1,10})?)|(([1,9](\d)?)(\.\d{1,10})?)|(1[0-7]\d{1}(\.\d{1,10})?)|(180(\.0{1,10})?))$/.test(e);
      }
      isLatitude(e) {
        return /^[-+]((0(\.\d{1,10})?)|([1,9](\.\d{1,10})?)|([1-8]\d?(\.\d{1,10})?)|(90(\.0{1,10})?))$/.test(e);
      }
      isDNS(e) {
        return /^(?=^.{3,255}$)[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$/.test(e);
      }
      isEmail(e) {
        return /^([A-Za-z0-9_\-.])+@([A-Za-z0-9_\-.])+\.([A-Za-z]{2,4})$/.test(e) ? ["qq.com", "163.com", "vip.163.com", "263.net", "yeah.net", "sohu.com", "sina.cn", "sina.com", "eyou.com", "gmail.com", "hotmail.com", "42du.cn"].includes(e.substring(e.indexOf("@") + 1)) : false;
      }
      async isValidLocationNameRecord(e) {
        if (!this.isObject(e)) return false;
        const { recordType: t, recordValue: r } = e;
        if (t === void 0 || r === void 0 || !this.isString(r)) return false;
        if (t === 0) return true;
        if (t === 1) return this.isIpV4(r);
        if (t === 2) return this.isIpV6(r);
        if (t === 3) {
          const n = r.split(",");
          return n.length !== 2 ? false : this.isLongitude(n[0]) && this.isLatitude(n[1]);
        }
        return t === 4 ? await this.accountBaseHelper.isAddress(r) : t === 5 ? this.isValidLocationName(r) : t === 6 ? this.isDNS(r) : t === 8 ? this.isEmail(r) : t === 7 ? this.isURL(r) : false;
      }
      async isValidRange(e, t) {
        if (e !== 0 && e !== 1 && e !== 2 && e !== 4 || !this.isArray(t)) return false;
        if (e === 0) {
          if (t.length !== 0) return false;
        } else {
          if (t.length === 0) return false;
          switch (e) {
            case 1:
              for (const r of t) if (!await this.accountBaseHelper.isAddress(r)) return false;
              break;
            case 2:
              for (const r of t) if (!this.isValidDAppId(r)) return false;
              break;
            case 4:
              for (const r of t) if (!this.isValidLocationName(r)) return false;
              break;
            default:
              return false;
          }
        }
        return true;
      }
      isValidCipherPublicKeys(e) {
        if (!this.isArray(e)) return false;
        for (const t of e) if (!this.isValidPublicKey(t)) return false;
        return true;
      }
      isValidAccountSignature(e) {
        if (!e || !this.isObject(e)) return false;
        const { publicKey: t, signature: r, secondPublicKey: n, signSignature: s } = e;
        return !(!(this.isValidPublicKey(t) && this.isValidSignature(r)) || n && !s || !n && s || n && s && !(this.isValidPublicKey(n) && this.isValidSignature(s)));
      }
      getVariableType(e) {
        return Object.prototype.toString.call(e);
      }
      isBoolean(e) {
        return typeof e === "boolean";
      }
      isNaturalNumber(e) {
        return Number.isInteger(e) && e >= 0;
      }
      isUint32(e) {
        return this.isNaturalNumber(e) && e < this.MAX_UINT_32_INTEGER;
      }
      isInt32(e) {
        return Number.isInteger(e) && e < this.MAX_INT_32_INTEGER && e > this.MIN_INT_32_INTEGER;
      }
      isNoEmptyUint8Array(e) {
        return e instanceof Uint8Array && e.length > 0;
      }
      isPositiveInteger(e) {
        return Number.isInteger(e) && e > 0;
      }
      isPositiveFloatMatchCondition(e, t) {
        let r = e;
        if (e && typeof e.denominator === "number" && typeof e.numerator === "number") {
          if (e.denominator === 0) return false;
          r = e.numerator / e.denominator;
        }
        return Number.isNaN(r) ? false : t(r);
      }
      isPositiveFloatContainZero(e) {
        return this.isPositiveFloatMatchCondition(e, (t) => t >= 0);
      }
      isPositiveFloatNotContainZero(e) {
        return this.isPositiveFloatMatchCondition(e, (t) => t > 0);
      }
      isPositiveBigFloatMatchCondition(e, t, r = 32) {
        if (!(e && typeof e.denominator === "string" && typeof e.numerator === "string")) return false;
        const { numerator: n, denominator: s } = e;
        return this.isStringNumber(n) === false || n.length > r || this.isPositiveStringNumber(s) === false || s.length > r ? false : t(e);
      }
      isPositiveBigFloatContainZero(e, t = 32) {
        return this.isPositiveBigFloatMatchCondition(e, (r) => this.jsbiHelper.compareFraction(r, { numerator: 0, denominator: 888 }) >= 0, t);
      }
      isPositiveBigFloatNotContainZero(e, t = 32) {
        return this.isPositiveBigFloatMatchCondition(e, (r) => this.jsbiHelper.compareFraction(r, { numerator: 0, denominator: 888 }) > 0, t);
      }
      isFraction(e) {
        if (typeof e !== "object" || e === null || !(e.numerator && e.denominator)) return false;
        try {
          const t = BigInt(e.denominator), r = BigInt(0);
          if (t === r) return false;
        } catch {
          return false;
        }
        return true;
      }
      isFiniteBigInt(e) {
        try {
          return BigInt(e), true;
        } catch {
          return false;
        }
      }
      isEmptyObject(e) {
        if (!this.isObject(e)) return false;
        let t;
        for (t in e) return false;
        return true;
      }
      isArrayEqual(e, t) {
        if (e.length !== t.length) return false;
        for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return false;
        return true;
      }
      isValidBufferSize(e, t) {
        if (e instanceof Uint8Array) return e.length === t;
        if (this.isString(e) && e.length === t * 2) for (let r = 0; r < e.length; r += 1) {
          let n = e[r];
          return n >= "0" && n <= "f";
        }
        return false;
      }
      isValidPublicKey(e) {
        return this.isValidBufferSize(e, 32);
      }
      isValidSecretKey(e) {
        return this.isValidBufferSize(e, 64);
      }
      isString(e) {
        return typeof e === "string";
      }
      isHexString(e) {
        return typeof e === "string" && /^[A-F0-9]+$/i.test(e);
      }
      isArray(e) {
        return this.getVariableType(e) === "[object Array]";
      }
      isObject(e) {
        return this.getVariableType(e) === "[object Object]";
      }
      isImage(e) {
        return this.isString(e);
      }
      isURL(e) {
        try {
          if (this.isString(e)) return new URL(e).hostname !== "";
        } catch {
        }
        return false;
      }
      isValidTransactionSignature(e) {
        return this.isValidSignature(e);
      }
      isValidBlockSignature(e) {
        return this.isValidSignature(e);
      }
      isValidSignature(e) {
        return this.isValidBufferSize(e, 64);
      }
      isValidAssetChangeHash(e) {
        return this.isValidBufferSize(e, 32);
      }
      isValidChainOnChainHash(e) {
        return this.isValidBufferSize(e, 32);
      }
      isValidUpperChainName(e) {
        return this.isString(e) ? /^[A-Z0-9]{5,20}$/.test(e) : false;
      }
      isValidChainName(e) {
        return this.isString(e) ? /^[a-z0-9]{5,20}$/.test(e) : false;
      }
      isValidAssetType(e) {
        return this.isString(e) ? /^[A-Z]{3,10}$/.test(e) : false;
      }
      isValidChainMagic(e) {
        if (!this.isString(e) || !/^[A-Z0-9]{5}$/.test(e)) return false;
        const t = e.slice(0, 4), r = e.slice(4), s = `P_${this.parityBitHelper.calcParityBit(t)}`;
        return Fi[s] === void 0 ? false : Fi[s].toString() === r;
      }
      isValidTransactionType(e) {
        if (!this.isString(e)) return false;
        const t = e.split("-");
        if (t.length !== 4 || !this.isValidAssetType(t[0]) || !this.isValidUpperChainName(t[1])) return false;
        const r = t[2];
        if (!(r === r.trim().toUpperCase() && r.length === 3)) return false;
        const n = t[3];
        return !!(/^[0-9]+$/.test(n) && n.length === 2);
      }
      isValidDAppId(e) {
        if (!this.isString(e) || !/^[A-Z0-9]{8}$/.test(e)) return false;
        const t = e.slice(0, 7), r = e.slice(7), s = `P_${this.parityBitHelper.calcParityBit(t)}`;
        return Fi[s] === void 0 ? false : Fi[s].toString() === r;
      }
      isMakeUpWithNumber(e) {
        return /^(([0-9])|([1-9](\d)+?))$/.test(e);
      }
      isStringNumber(e) {
        return this.isString(e) ? this.isMakeUpWithNumber(e) : false;
      }
      isPositiveStringNumber(e) {
        return this.isStringNumber(e) && BigInt(e) > BigInt(0);
      }
      isValidLocationName(e, t = this.configHelper.chainName) {
        if (!this.isString(e) || e.length > 512 || this.isStartWithOrEndWithPoint(e)) return false;
        const r = e.split("."), n = r.length;
        if (n < 2) return false;
        for (let s = 0; s < n; s++) {
          const o = r[s];
          if (o.length > 128) return false;
          if (s === n - 2) {
            if (!this.isLowerCaseLetter(o)) return false;
          } else if (s === n - 1) {
            if (o !== t) return false;
          } else if (o.length <= 2) {
            if (!this.isLowerCaseLetterOrNumber(o)) return false;
          } else if (!this.isLowerCaseLetterOrNumberOrUnderline(o)) return false;
        }
        return true;
      }
      isValidNumber(e) {
        const t = e.toString();
        return !(t.length > 1 && t.startsWith("0"));
      }
      isValidPort(e) {
        return !Number.isNaN(e) && this.isValidNumber(e) && e > 0 && e < 65536;
      }
      isValidChainPorts(e) {
        return this.isEmptyObject(e) ? false : this.isValidPort(e.port);
      }
      isUpperCaseString(e) {
        return this.isString(e) && e === e.trim().toUpperCase();
      }
      isLowerCaseString(e) {
        return this.isString(e) && e === e.trim().toLowerCase();
      }
      isScientificCounting(e) {
        return e.includes(".") || e.includes("e");
      }
      isLowerCaseLetter(e) {
        return this.isString(e) && /^[a-z]+$/.test(e);
      }
      isUpperCaseLetter(e) {
        return this.isString(e) && /^[A-Z]+$/.test(e);
      }
      isUpperCaseLetterOrNumber(e) {
        return this.isString(e) && /^[A-Z0-9]+$/.test(e);
      }
      isUpperCaseOrLowerCaseLetter(e) {
        return this.isString(e) && /^[A-Za-z]+$/.test(e);
      }
      isUpperCaseOrLowerCaseLetterOrNumber(e) {
        return this.isString(e) && /^[A-Za-z0-9]+$/.test(e);
      }
      isStartWithOrEndWithPoint(e) {
        return !/^[^.].*[^.]$/.test(e);
      }
      isLowerCaseLetterOrNumber(e) {
        return /^[a-z0-9]+$/.test(e);
      }
      isLowerCaseLetterOrNumberOrUnderline(e) {
        return /^[a-z0-9][a-z0-9_]*[a-z0-9]+$/.test(e);
      }
      isValidStakeId(e) {
        return this.isString(e) ? /^[a-z0-9]{1,30}$/.test(e) : false;
      }
      isValidFeeRate(e) {
        if (!e) return false;
        const t = e.senderPaidFeeRate, r = e.recipientPaidFeeRate;
        return !(!this.isPositiveFloatContainZero(t) || !this.isPositiveFloatContainZero(r) || !(t.denominator === 1 && r.denominator === 1) || !(t.numerator === 1 && r.numerator === 0 || t.numerator === 0 && r.numerator === 1));
      }
      isValidRate(e) {
        if (!e) return false;
        const t = e.prevWeight, r = e.nextWeight;
        try {
          const n = BigInt(t), s = BigInt(r);
          return n === BigInt(0) || s === BigInt(0) ? false : typeof r === typeof t;
        } catch {
          return false;
        }
      }
      isValidAssetExchangeWeightRatio(e) {
        if (!e) return false;
        const { toExchangeAssetWeight: t, beExchangeAssetWeight: r } = e;
        return !(!(this.isStringNumber(e.toExchangeAssetWeight) && this.isStringNumber(e.beExchangeAssetWeight)) || t === "0" || r === "0");
      }
      isValidEntityFactoryId(e) {
        return this.isString(e) ? /^[a-z0-9]{3,15}$/.test(e) : false;
      }
      isValidEntityId(e) {
        if (!this.isString(e)) return false;
        const t = e.split("_");
        if (t.length !== 2 && t.length !== 3) return false;
        const r = /^[a-z0-9]{3,30}$/;
        return t.length === 3 ? t[0] !== "m" || !this.isValidEntityFactoryId(t[1]) ? false : r.test(t[2]) : this.isValidEntityFactoryId(t[0]) ? r.test(t[1]) : false;
      }
      isValidTindexRanges(e) {
        const t = e.length;
        if (t === 0 || t % 2 !== 0 || !this.isNaturalNumber(e[0])) return false;
        for (let r = 1; r < t; r++) if (!this.isPositiveInteger(e[r])) return false;
        return true;
      }
      isValidCertificateId(e) {
        if (!this.isString(e) || e.length < 3 || e.length > 100 || e.includes(":") === false) return false;
        const t = e.split(":");
        return t.length !== 2 || this.isPositiveStringNumber(t[0]) === false ? false : /^[A-Za-z0-9\-_]*$/.test(t[1]);
      }
      isValidMacroInputName(e) {
        return this.isString(e) === false ? false : /^\S.{1,30}\S$/.test(e);
      }
    };
    Be = l([J(), u("design:paramtypes", [me, ne, Zo, mh, xt])], Be);
    const UT = /* @__PURE__ */ Symbol("bfchain-core:TransactionFilter");
    const VT = /* @__PURE__ */ Symbol("bfchain-core:AbortForbiddenTransaction");
    const { ArgumentFormatException: of, ArgumentIllegalException: Gm, NoFoundException: GT } = ee("HELPER", "transactionHelper");
    let Ee = class {
      constructor(e, t, r, n, s, o, a, p) {
        this.config = e, this.baseHelper = t, this.jsbiHelper = r, this.cryptoHelper = n, this.keypairHelper = s, this.Buffer = o, this.asymmetricHelper = a, this.accountBaseHelper = p, this.ALL_TRANSACTION_TYPES = [this.SIGNATURE, this.DAPP, this.DAPP_PURCHASING, this.REGISTER_CHAIN, this.MARK, this.ISSUE_ASSET, this.INCREASE_ASSET, this.DESTROY_ASSET, this.TRANSFER_ASSET, this.TO_EXCHANGE_ASSET, this.BE_EXCHANGE_ASSET, this.GIFT_ASSET, this.GRAB_ASSET, this.TRUST_ASSET, this.SIGN_FOR_ASSET, this.EMIGRATE_ASSET, this.IMMIGRATE_ASSET, this.LOCATION_NAME, this.SET_LNS_RECORD_VALUE, this.SET_LNS_MANAGER, this.ISSUE_ENTITY_FACTORY, this.ISSUE_ENTITY, this.DESTROY_ENTITY, this.ISSUE_ENTITY_MULTI, this.TRANSFER_ANY, this.GIFT_ANY, this.GRAB_ANY, this.TO_EXCHANGE_ANY, this.BE_EXCHANGE_ANY, this.TO_EXCHANGE_ANY_MULTI, this.BE_EXCHANGE_ANY_MULTI, this.TO_EXCHANGE_ANY_MULTI_ALL, this.BE_EXCHANGE_ANY_MULTI_ALL, this.ISSUE_CERTIFICATE, this.DESTROY_CERTIFICATE, this.MULTIPLE, this.PROMISE, this.PROMISE_RESOLVE, this.MACRO, this.MACRO_CALL], this.abortForbiddenTransaction = true;
      }
      get _ASSETTYPE() {
        return this.config.assetType;
      }
      get _CHAIN_NAME() {
        return this.config.chainName.toUpperCase();
      }
      parseType(e) {
        const t = e.indexOf("-"), r = e.indexOf("-", t + 1), n = e.substr(r + 1);
        return { assetType: e.substr(0, t), chainName: e.substring(t + 1, r), baseType: n };
      }
      resolveType(e) {
        return `${e.assetType}-${e.chainName}-${e.baseType}`;
      }
      getTypeName(e) {
        const { baseType: t } = this.parseType(e);
        return this.getTypeNameByBaseType(t);
      }
      getTypeNameByBaseType(e) {
        return Re.VK.get(e);
      }
      getTransactionType(e) {
        return `${this._ASSETTYPE}-${this._CHAIN_NAME}-${e}`;
      }
      isValidType(e) {
        return this.baseHelper.isValidTransactionType(e);
      }
      async generateSignature(e) {
        return gd(await this.cryptoHelper.sha256(e.getBytes(true, true)));
      }
      isValidTransactionSignature(e) {
        return this.baseHelper.isValidTransactionSignature(e);
      }
      get SIGNATURE() {
        return this.getTransactionType(v.SIGNATURE);
      }
      get DAPP() {
        return this.getTransactionType(v.DAPP);
      }
      get DAPP_PURCHASING() {
        return this.getTransactionType(v.DAPP_PURCHASING);
      }
      get REGISTER_CHAIN() {
        return this.getTransactionType(v.REGISTER_CHAIN);
      }
      get MARK() {
        return this.getTransactionType(v.MARK);
      }
      get ISSUE_ASSET() {
        return this.getTransactionType(v.ISSUE_ASSET);
      }
      get INCREASE_ASSET() {
        return this.getTransactionType(v.INCREASE_ASSET);
      }
      get DESTROY_ASSET() {
        return this.getTransactionType(v.DESTROY_ASSET);
      }
      get TRANSFER_ASSET() {
        return this.getTransactionType(v.TRANSFER_ASSET);
      }
      get GIFT_ASSET() {
        return this.getTransactionType(v.GIFT_ASSET);
      }
      get GRAB_ASSET() {
        return this.getTransactionType(v.GRAB_ASSET);
      }
      get TRUST_ASSET() {
        return this.getTransactionType(v.TRUST_ASSET);
      }
      get SIGN_FOR_ASSET() {
        return this.getTransactionType(v.SIGN_FOR_ASSET);
      }
      get EMIGRATE_ASSET() {
        return this.getTransactionType(v.EMIGRATE_ASSET);
      }
      get IMMIGRATE_ASSET() {
        return this.getTransactionType(v.IMMIGRATE_ASSET);
      }
      get TO_EXCHANGE_ASSET() {
        return this.getTransactionType(v.TO_EXCHANGE_ASSET);
      }
      get BE_EXCHANGE_ASSET() {
        return this.getTransactionType(v.BE_EXCHANGE_ASSET);
      }
      get STAKE_ASSET() {
        return this.getTransactionType(v.STAKE_ASSET);
      }
      get UNSTAKE_ASSET() {
        return this.getTransactionType(v.UNSTAKE_ASSET);
      }
      get LOCATION_NAME() {
        return this.getTransactionType(v.LOCATION_NAME);
      }
      get SET_LNS_RECORD_VALUE() {
        return this.getTransactionType(v.SET_LNS_RECORD_VALUE);
      }
      get SET_LNS_MANAGER() {
        return this.getTransactionType(v.SET_LNS_MANAGER);
      }
      get ISSUE_ENTITY_FACTORY() {
        return this.getTransactionType(v.ISSUE_ENTITY_FACTORY);
      }
      get ISSUE_ENTITY_FACTORY_V1() {
        return this.getTransactionType(v.ISSUE_ENTITY_FACTORY_V1);
      }
      get ISSUE_ENTITY() {
        return this.getTransactionType(v.ISSUE_ENTITY);
      }
      get DESTROY_ENTITY() {
        return this.getTransactionType(v.DESTROY_ENTITY);
      }
      get ISSUE_ENTITY_MULTI() {
        return this.getTransactionType(v.ISSUE_ENTITY_MULTI);
      }
      get TRANSFER_ANY() {
        return this.getTransactionType(v.TRANSFER_ANY);
      }
      get GIFT_ANY() {
        return this.getTransactionType(v.GIFT_ANY);
      }
      get GRAB_ANY() {
        return this.getTransactionType(v.GRAB_ANY);
      }
      get TO_EXCHANGE_ANY() {
        return this.getTransactionType(v.TO_EXCHANGE_ANY);
      }
      get BE_EXCHANGE_ANY() {
        return this.getTransactionType(v.BE_EXCHANGE_ANY);
      }
      get TO_EXCHANGE_ANY_MULTI() {
        return this.getTransactionType(v.TO_EXCHANGE_ANY_MULTI);
      }
      get BE_EXCHANGE_ANY_MULTI() {
        return this.getTransactionType(v.BE_EXCHANGE_ANY_MULTI);
      }
      get TO_EXCHANGE_ANY_MULTI_ALL() {
        return this.getTransactionType(v.TO_EXCHANGE_ANY_MULTI_ALL);
      }
      get BE_EXCHANGE_ANY_MULTI_ALL() {
        return this.getTransactionType(v.BE_EXCHANGE_ANY_MULTI_ALL);
      }
      get ISSUE_CERTIFICATE() {
        return this.getTransactionType(v.ISSUE_CERTIFICATE);
      }
      get DESTROY_CERTIFICATE() {
        return this.getTransactionType(v.DESTROY_CERTIFICATE);
      }
      get MULTIPLE() {
        return this.getTransactionType(v.MULTIPLE);
      }
      get PROMISE() {
        return this.getTransactionType(v.PROMISE);
      }
      get PROMISE_RESOLVE() {
        return this.getTransactionType(v.PROMISE_RESOLVE);
      }
      get MACRO() {
        return this.getTransactionType(v.MACRO);
      }
      get MACRO_CALL() {
        return this.getTransactionType(v.MACRO_CALL);
      }
      genesisGenerators(e = this.config) {
        const t = e.genesisBlock.transactionInfo.transactionInBlocks.filter((r) => r.transaction.type === this.ISSUE_ENTITY).map((r) => r.transaction.senderId);
        return [...new Set(t)];
      }
      async getGensisAcountAddress(e = this.config) {
        return this.accountBaseHelper.getAddressFromPublicKeyString(e.genesisAccountPublicKey);
      }
      async verifyTransactionSignature(e, t) {
        const r = t && t.taskLabel || "Transaction", { signSignatureBuffer: n, signatureBuffer: s, senderSecondPublicKeyBuffer: o, senderPublicKeyBuffer: a } = e, p = await this.cryptoHelper.sha256().update(e.getBytes(true, true)).digest();
        if (!await this.keypairHelper.detached_verify(p, s, a)) throw new of(c.INVALID_SIGNATURE, { taskLabel: r });
        if (o && o.length > 0 || n && n.length > 0) if (o && n) {
          const h = await this.cryptoHelper.sha256().update(e.getBytes(false, true)).digest();
          if (!await this.keypairHelper.detached_verify(h, n, o)) throw new of(c.INVALID_SIGNSIGNATURE, { taskLabel: r });
        } else throw new of(`Invalid ${r} miss signSignature or senderSecondPublicKey`);
      }
      verifyTransactionSize(e) {
        const { maxTransactionSize: t } = this.config, r = e.getBytes().length;
        if (r > t) throw new Gm(c.PROP_SHOULD_LTE_FIELD, { prop: `transaction size ${r}`, target: "transaction", field: t });
      }
      verifyTransactionBlobSize(e) {
        const { maxTransactionBlobSize: t } = this.config, r = e.getBlobSize(true);
        if (r > t) throw new Gm(c.PROP_SHOULD_LTE_FIELD, { prop: `transaction blob size ${r}`, target: "transaction", field: t });
      }
      __calcStandardMinFee(e) {
        const t = this.config.minTransactionFeePerByte;
        return e ? this.jsbiHelper.compareFraction(t, e) >= 0 ? t : e : t;
      }
      calcMinFeePerBytes(e, t, r = this.config.minTransactionFeePerByte) {
        let n = t, s = e;
        do {
          const o = this.jsbiHelper.multiplyCeilFraction(n, r).toString();
          if (o.length === s.length) return o;
          n += o.length - s.length, s = o;
        } while (true);
      }
      calcTransactionMinFeeByBytes(e, t, r) {
        return BigInt(this.calcMinFeePerBytes(e.fee, t || e.getBytes().length, this.__calcStandardMinFee(r)));
      }
      calcTransactionMinFeeByMaxBytes(e, t) {
        return this.jsbiHelper.multiplyCeilFraction(this.config.maxTransactionSize, this.__calcStandardMinFee(t)) * BigInt(e);
      }
      calcTransactionMinFeeByMulti(e, t, r, n) {
        const s = this.calcMinFeePerBytes(e.fee, r || e.getBytes().length, this.__calcStandardMinFee(n));
        return BigInt(s) * BigInt(t);
      }
      calcTransactionBlobFee(e, t) {
        const r = e.getBlobSize(true);
        if (r === 0) return BigInt(0);
        const n = this.calcMinFeePerBytes(e.fee, r, this.__calcStandardMinFee(t));
        return this.jsbiHelper.multiplyCeilFraction(BigInt(n), this.config.blobFeeMultipleRatio);
      }
      calcTransactionMinFee(e, t, r) {
        const n = e.type;
        if (n === this.GIFT_ASSET) {
          const s = e.asset.giftAsset.totalGrabableTimes + 1;
          return (this.calcTransactionMinFeeByMaxBytes(s, r) + this.calcTransactionBlobFee(e, r)).toString();
        }
        if (n === this.GIFT_ANY) {
          const s = e.asset.giftAny.totalGrabableTimes + 1;
          return (this.calcTransactionMinFeeByMaxBytes(s, r) + this.calcTransactionBlobFee(e, r)).toString();
        }
        if (n === this.TRUST_ASSET) {
          const s = e.asset.trustAsset.numberOfSignFor + 1;
          return (this.calcTransactionMinFeeByMaxBytes(s, r) + this.calcTransactionBlobFee(e, r)).toString();
        }
        return n === this.ISSUE_ENTITY_MULTI ? (this.calcTransactionMinFeeByMulti(e, e.asset.issueEntityMulti.entityStructList.length, void 0, r) + this.calcTransactionBlobFee(e, r)).toString() : n == this.TO_EXCHANGE_ANY_MULTI ? (this.calcTransactionMinFeeByMulti(e, e.asset.toExchangeAnyMulti.toExchangeAssets.length, void 0, r) + this.calcTransactionBlobFee(e, r)).toString() : n === this.BE_EXCHANGE_ANY_MULTI ? (this.calcTransactionMinFeeByMulti(e, e.asset.beExchangeAnyMulti.toExchangeAssets.length, void 0, r) + this.calcTransactionBlobFee(e, r)).toString() : n === this.GRAB_ASSET || n === this.GRAB_ANY || n === this.SIGN_FOR_ASSET ? this.calcTransactionBlobFee(e, r) : (this.calcTransactionMinFeeByBytes(e, t, r) + this.calcTransactionBlobFee(e, r)).toString();
      }
      calcTransactionFee(e, t = this.config.minTransactionFeePerByte) {
        return this.calcMinFeePerBytes(e.fee, e.getBytes().length, t);
      }
      hashCode(e) {
        let t = 0, r = 0;
        const n = e.length;
        for (; r < n; ) t = (t << 5) - t + e.charCodeAt(r++) << 0;
        return Math.abs(t);
      }
      async calcGrabRandomGiftAssetNumber(e, t, r, n, s, o) {
        const a = BigInt(s);
        if (o === 1) return a;
        const { jsbiHelper: p } = this, h = BigInt(0), f = BigInt(this.config.miniUnit), g = a / BigInt(o);
        if (g === h) return f;
        const d = BigInt(`0x${await this.cryptoHelper.md5().update(e).update(t).update(r).update(n).digest("hex")}`), y = p.multiplyFloorFractionString(s, { numerator: d, denominator: BigInt(2) ** BigInt(128) });
        if (y < f) return f;
        const _ = g * BigInt(2);
        if (y <= _) return y;
        let I = y % _;
        return y > _ * BigInt(2) && I <= g && (I += g), I;
      }
      async calcGrabRecipientRandomGiftAssetNumber(e, t, r, n, s, o) {
        const a = /* @__PURE__ */ new Map();
        let p = BigInt(0);
        for (const f of s) {
          const g = BigInt(`0x${(await this.cryptoHelper.md5().update(t).update(r).update(n).update(f).digest("hex")).substr(0, 16)}`);
          p = p + g, a.set(f, g);
        }
        const h = a.get(e);
        if (!h) throw new GT(c.NOT_EXIST, { prop: `grabId(${e})`, target: "giftTransactionRecipient" });
        return h * BigInt(o) / p;
      }
      calcGrabAverageGiftAssetNumber(e, t) {
        const r = BigInt(e), n = BigInt(this.config.miniUnit);
        if (t === 1) return r;
        const s = BigInt(0), o = r / BigInt(t);
        return o === s ? n : o;
      }
      async calcGrabGiftAssetNumber(e, t, r) {
        const n = t.asset.giftAsset;
        switch (n.giftDistributionRule) {
          case 0:
            return this.calcGrabAverageGiftAssetNumber(n.amount, n.totalGrabableTimes);
          case 1:
            return await this.calcGrabRandomGiftAssetNumber(e, r, t.signatureBuffer, t.senderId, n.amount, n.totalGrabableTimes);
          case 2:
            return await this.calcGrabRandomGiftAssetNumber(e, r, t.signatureBuffer, t.senderId, n.amount, n.totalGrabableTimes);
        }
      }
      async calcGrabbedAssetNumber(e, t, r, n, s, o, a) {
        switch (a) {
          case 0:
            return this.calcGrabAverageGiftAssetNumber(s, o);
          case 1:
            return await this.calcGrabRandomGiftAssetNumber(e, _e(t), _e(r), n, s, o);
          case 2:
            return this.calcGrabRandomGiftAssetNumber(e, _e(t), _e(r), n, s, o);
        }
      }
      async generateGrabAsset(e, t, r) {
        const n = await this.accountBaseHelper.createSecretKeypair(r.mainSecret), s = e.asset.giftAsset, { grabId: o = await this.accountBaseHelper.getAddressFromPublicKey(n.publicKey), grabSecret: a } = r, p = e.signatureBuffer;
        let h;
        a && (h = gt.fromObject({ signatureBuffer: await this.getCiphertextSignature({ secret: a, transactionSignatureBuffer: p, senderId: o }), publicKeyBuffer: n.publicKey }));
        const f = Dn.fromObject({ blockSignatureBuffer: t, transactionSignatureBuffer: p, giftAsset: s, ciphertextSignature: h });
        return f.amount = (await this.calcGrabGiftAssetNumber(o, e, t)).toString(), f;
      }
      async getCiphertextSignature(e) {
        return this.asymmetricHelper.detachedSign(await this.cryptoHelper.sha256().update(e.transactionSignatureBuffer).update(e.senderId).digest(), (await this.accountBaseHelper.createSecretKeypair(e.secret)).secretKey);
      }
      async verifyCiphertextSignature(e) {
        return this.asymmetricHelper.detachedVeriy(await this.cryptoHelper.sha256().update(e.transactionSignatureBuffer).update(e.senderId).digest(), e.ciphertextSignatureBuffer, e.secretPublicKey);
      }
      getTransactionMaxEffectiveHeight(e) {
        let t = e.effectiveBlockHeight;
        return (e instanceof ji || e instanceof Ji || e instanceof zi) && (t = Number.MAX_SAFE_INTEGER), t;
      }
      getTransactionMinEffectiveHeight(e) {
        let t = e.applyBlockHeight;
        if (e instanceof Ki) {
          const r = e.asset.giftAsset.beginUnfrozenBlockHeight;
          r && (t = r);
        } else if (e instanceof Yi) {
          const r = e.asset.giftAny.beginUnfrozenBlockHeight;
          r && (t = r);
        } else e instanceof zi && (t = e.asset.stakeAsset.beginUnstakeHeight);
        return t;
      }
      isTransactionInFilter(e) {
        return !(this.transactionFilter && !this.transactionFilter.includes(e));
      }
      calcTransactionQueryRange(e, t = this.config) {
        const r = e - t.maxApplyAndConfirmedBlockHeightDiff;
        return { startHeight: r <= 0 ? 1 : r, endHeight: e - 1 };
      }
      calcTransactionQueryRangeByApplyBlockHeight(e, t) {
        return { startHeight: e, endHeight: t - 1 };
      }
      getFactoryIdByEntityId(e) {
        const t = e.split("_");
        return t.length > 2 ? t[1] : t[0];
      }
      calcDestroyMainAssetsOfIsseuEntityFactory(e, t = this.config) {
        const r = this.jsbiHelper, n = r.divisionFraction({ numerator: e, denominator: "1" }, t.maxMultipleOfEntityAndMainAsset);
        return r.multiplyCeilFraction(eA, n).toString();
      }
      tIndexRangesToTindexes(e) {
        let t = e[0];
        const r = [t];
        for (let n = 1; n < e.length; n++) if (n % 2 === 1) for (let s = 0; s < e[n] - 1; s++) r[r.length] = ++t;
        else t += e[n] + 1, r[r.length] = t;
        return r;
      }
      tIndexRangesToStartAndEndTindex(e) {
        let t = e[0];
        const r = [t];
        t += e[1], r.push(t - 1);
        for (let n = 2; n < e.length; n += 2) t += e[n], r.push(t), t += e[n + 1], r.push(t - 1);
        return r;
      }
      getStakeSaveId(e, t) {
        return `${t}_${e}`;
      }
    };
    l([D(UT, { optional: true }), u("design:type", Array)], Ee.prototype, "transactionFilter", void 0);
    l([D(VT, { dynamics: true }), u("design:type", Object)], Ee.prototype, "abortForbiddenTransaction", void 0);
    Ee = l([J(), be(3, D("cryptoHelper")), be(4, D("keypairHelper")), be(5, D("Buffer")), u("design:paramtypes", [ne, Be, xt, Object, Object, Object, Or, me])], Ee);
    const { NoFoundException: KT, ArgumentIllegalException: af, RefuseException: Gl } = ee("helper", "blobHelper");
    let Si = class {
      constructor(e) {
        this.timeHelper = e;
      }
      support(e, t = "readwrite") {
        let r = true;
        return e === "SHA256" ? (t.includes("read") && (r = r && this.blobSha256Reader !== void 0), t.includes("write") && (r = r && this.blobSha256Writer !== void 0)) : r = false, r;
      }
      supportAlgorithms(e) {
        const t = /* @__PURE__ */ new Set();
        for (const r of ["SHA256"]) this.support(r, e) && t.add(r);
        return t;
      }
      async exists(e) {
        const { blobSha256Reader: t } = this;
        return !t || e.algorithm !== "SHA256" ? false : t.has(e.hash);
      }
      async open(e) {
        const { blobSha256Reader: t } = this;
        if (t === void 0) throw new KT(c.PARAM_LOST, { param: "blobSha256Reader" });
        const { hash: r, algorithm: n } = e;
        if (n !== "SHA256") throw new af(c.BLOB_ALGORITHM_IS_INVALID, { hash: r, algorithm: n });
        return await t.open(r);
      }
      async read(e) {
        const { blobSha256Reader: t } = this;
        if (t === void 0) throw new af(c.PARAM_LOST, { param: "blobSha256Reader" });
        return { chunkBuffer: await t.read(e.descriptor, e.start, e.end) };
      }
      async close(e) {
        const { blobSha256Reader: t } = this;
        if (t === void 0) throw new af(c.PARAM_LOST, { param: "blobSha256Reader" });
        return await t.close(e.descriptor);
      }
      requestStorage(e, t, r, n, s) {
        const { blobSha256Writer: o } = this;
        if (!o) throw new Gl(c.PARAM_LOST, { param: "blobSha256Writer" });
        return o.requestStorage(e, t, r, n, s);
      }
      saveChunk(e, t, r) {
        const { blobSha256Writer: n } = this;
        if (!n) throw new Gl(c.PARAM_LOST, { param: "blobSha256Writer" });
        return n.saveChunk(e, t, r);
      }
      saveAsBlob(e) {
        const { blobSha256Writer: t } = this;
        if (!t) throw new Gl(c.PARAM_LOST, { param: "blobSha256Writer" });
        return t.saveAsBlob(e);
      }
      changeBlobStrategy(e, t) {
        const { blobSha256Writer: r } = this;
        if (!r) throw new Gl(c.PARAM_LOST, { param: "blobSha256Writer" });
        return r.changeBlobStrategy(e, t);
      }
    };
    l([D("blobSha256Reader", { optional: true }), u("design:type", Object)], Si.prototype, "blobSha256Reader", void 0);
    l([D("blobSha256Writer", { optional: true }), u("design:type", Object)], Si.prototype, "blobSha256Writer", void 0);
    Si = l([J(), u("design:paramtypes", [Ft])], Si);
    const zT = class {
      constructor(e, t, r) {
        this.chainName = e, this.magic = t, this.assetType = r;
      }
    };
    const Km = /* @__PURE__ */ new Map();
    const zm = /* @__PURE__ */ new WeakSet();
    let ve = class {
      isChainAssetInfo(e) {
        return zm.has(e);
      }
      getAssetInfo(e, t, r) {
        const n = e + ":" + t + ":" + r;
        let s = Km.get(n);
        return s || (s = new zT(e, t, r), Object.freeze(s), Km.set(n, s), zm.add(s)), s;
      }
    };
    ve = l([J()], ve);
    let Vf;
    let Gf;
    ee("helper-block_base_statistics", "blockBaseStatisticsHelper");
    let Ds = Vf = class {
      constructor(e, t, r, n) {
        this.transactionHelper = e, this.chainAssetInfo = t, this.config = r, this.moduleMap = n, this._block_statistics_m = /* @__PURE__ */ new Map();
      }
      getConfig() {
        return this.tempConfig || this.config;
      }
      forceGetStatisticsInfoByBlock(e, t, r, n) {
        let s = this._block_statistics_m.get(e);
        return s || (s = bt(pl, new ze([[pl.SOURCE_DATA_SYMBOL, r]], this.moduleMap)), s.on("destroy", () => {
          this._block_statistics_m.delete(e);
        }), this._block_statistics_m.set(e, s)), s.ref(t), n && (this.tempConfig = n, s.on("destroy", () => {
          this._block_statistics_m.delete(e), this.tempConfig = void 0;
        })), s;
      }
      getStatisticsInfoByBlock(e) {
        return this._block_statistics_m.get(e);
      }
      _applyFee(e, t) {
        const { applyInfo: r, transaction: n } = e, { address: s, assetInfo: o } = r, a = BigInt(r.sourceAmount), { baseType: p } = this.transactionHelper.parseType(n.type), h = t.initAssetStatistic(o);
        h.total.changeAmount = (BigInt(h.total.changeAmount) + a).toString(), h.total.moveAmount = (BigInt(h.total.moveAmount) + a).toString(), h.total.changeCount += 1;
        const f = n.signature;
        t.subIdMap.has(f) || (h.total.transactionCount += 1, t.subIdMap.set(f, true));
        const g = t.initTypeStatistic(o, p);
        t.totalFee = t.totalFee + a, t.totalAsset = t.totalAsset + a, t.totalChainAsset = t.totalChainAsset + a, t.addTotalAccount(s), g.changeAmount = (BigInt(g.changeAmount) + a).toString(), g.changeCount += 1, g.moveAmount = (BigInt(g.moveAmount) + a).toString(), t.typeSubIdMap.has(f) || (g.transactionCount += 1, t.typeSubIdMap.set(f, true));
      }
      _applyAsset(e, t, r = false) {
        const { applyInfo: n, transaction: s } = e, { type: o } = s, a = BigInt(n.sourceAmount), { baseType: p } = this.transactionHelper.parseType(o), h = t.initAssetStatistic(n.assetInfo), f = t.initTypeStatistic(n.assetInfo, p);
        h.total.changeAmount = (BigInt(h.total.changeAmount) + a).toString(), h.total.changeCount += 1;
        const g = s.signature;
        if (t.subIdMap.has(g) || (h.total.transactionCount += 1, t.subIdMap.set(g, true)), f.changeAmount = (BigInt(f.changeAmount) + a).toString(), f.changeCount += 1, t.typeSubIdMap.has(g) || (f.transactionCount += 1, t.typeSubIdMap.set(g, true)), n.amount.startsWith("-") || r) {
          h.total.moveAmount = (BigInt(h.total.moveAmount) + a).toString(), t.totalAsset = t.totalAsset + a;
          const { assetInfo: d } = n, y = this.getConfig();
          d.assetType === y.assetType && d.magic === y.magic && (t.totalChainAsset = t.totalChainAsset + a), f.moveAmount = (BigInt(f.moveAmount) + a).toString();
        }
        t.addTotalAccount(n.address);
      }
      _applyCount(e, t) {
        const { transaction: r } = e, { baseType: n } = this.transactionHelper.parseType(r.type), s = t.numberOfTransactions;
        s[n] ? s[n]++ : s[n] = 1;
      }
      bindApplyTransactionEventEmiter(e, t) {
        const r = Vf.eventEmitterStatisticsWM.forceGet(e);
        if (!r.has(t)) return r.add(t), e.on("fee", (n, s) => (this._applyFee(n, t), s()), { taskname: "applyTransaction/blockStatistic/fee" }), e.on("feeFromUnfrozen", (n, s) => (this._applyFee(n, t), s()), { taskname: "applyTransaction/blockStatistic/feeFromUnfrozen" }), e.on("asset", (n, s) => (this._applyAsset(n, t), s()), { taskname: "applyTransaction/blockStatistic/asset" }), e.on("frozenAsset", (n, s) => (this._applyAsset(n, t), s()), { taskname: "applyTransaction/blockStatistic/frozenAsset" }), e.on("unfrozenAsset", (n, s) => (this._applyAsset(n, t, true), s()), { taskname: "applyTransaction/blockStatistic/unfrozenAsset" }), e.on("issueAsset", (n, s) => (this._applyAsset(n, t, true), s()), { taskname: "applyTransaction/blockStatistic/issueAsset" }), e.on("count", (n, s) => (this._applyCount(n, t), s())), true;
      }
    };
    Ds.eventEmitterStatisticsWM = new ss((i) => /* @__PURE__ */ new WeakSet());
    Ds = Vf = l([J("bfchain-core:BlockBaseStatistics"), u("design:paramtypes", [Ee, ve, ne, ze])], Ds);
    let pl = Gf = class extends An {
      constructor(e = nn.fromObject({}), t) {
        super(), this.source_data = e, this.chainAssetInfoHelper = t, this.subIdMap = /* @__PURE__ */ new Map(), this.typeSubIdMap = /* @__PURE__ */ new Map(), this._accountAddressSet = /* @__PURE__ */ new Set(), this._souce_data_totalAccount = this.source_data.totalAccount, this._reasonSet = /* @__PURE__ */ new Set();
      }
      get totalFee() {
        return this._totalFee || (this._totalFee = BigInt(this.source_data.totalFee));
      }
      set totalFee(e) {
        this._totalFee = e;
      }
      get totalAsset() {
        return this._totalAsset || (this._totalAsset = BigInt(this.source_data.totalAsset));
      }
      set totalAsset(e) {
        this._totalAsset = e;
      }
      get totalChainAsset() {
        return this._totalChainAsset || (this._totalChainAsset = BigInt(this.source_data.totalChainAsset));
      }
      set totalChainAsset(e) {
        this._totalChainAsset = e;
      }
      get numberOfTransactions() {
        return this._numberOfTransactions || (this._numberOfTransactions = this.source_data.numberOfTransactionsHashMap);
      }
      get totalAccount() {
        return this.source_data.totalAccount;
      }
      addTotalAccount(e) {
        return this._accountAddressSet.add(e), this.source_data.totalAccount = this._souce_data_totalAccount + this._accountAddressSet.size;
      }
      getAssetTypeTypeStatisticMap(e) {
        let t = this.source_data.magicAssetTypeTypeStatisticMap.get(e);
        return t || (t = Zi.fromObject({}), this.source_data.magicAssetTypeTypeStatisticMap.set(e, t)), t.assetTypeTypeStatisticMap;
      }
      __initAssetStatistic() {
        return qi.fromObject({ typeStatisticHashMap: {}, total: { changeAmount: "0", changeCount: 0, moveAmount: "0", transactionCount: 0 } });
      }
      getAssetStatistic(e) {
        const { magic: t, assetType: r } = e, n = this.getAssetTypeTypeStatisticMap(t);
        let s = n.get(r);
        return s || (s = this.__initAssetStatistic(), n.set(r, s)), s;
      }
      setAssetStatistic(e, t) {
        const { magic: r, assetType: n } = e;
        let o = this.source_data.magicAssetTypeTypeStatisticMap.get(r);
        return o || (o = Zi.fromObject({}), this.source_data.magicAssetTypeTypeStatisticMap.set(r, o)), o.assetTypeTypeStatisticMap.set(n, t), this;
      }
      initAssetStatistic(e) {
        const { magic: t, assetType: r } = e, n = this.getAssetTypeTypeStatisticMap(t);
        let s = n.get(r);
        return s || (s = this.__initAssetStatistic(), n.set(r, s)), s;
      }
      __initTypeStatistic() {
        return Kn.fromObject({ changeAmount: "0", changeCount: 0, moveAmount: "0", transactionCount: 0 });
      }
      getTypeStatistic(e, t) {
        let n = this.getAssetStatistic(e).typeStatisticMap.get(t);
        return n || (n = this.__initTypeStatistic()), n;
      }
      setTypeStatistic(e, t, r) {
        return this.getAssetStatistic(e).typeStatisticMap.set(t, r), this;
      }
      initTypeStatistic(e, t) {
        const r = this.getAssetStatistic(e);
        let n = r.typeStatisticMap.get(t);
        return n || (n = this.__initTypeStatistic(), r.typeStatisticMap.set(t, n)), n;
      }
      ref(e) {
        this._reasonSet.add(e);
      }
      unref(e) {
        this._reasonSet.delete(e), this._reasonSet.size === 0 && this.emit("destroy");
      }
      toModel() {
        return this._totalFee && (this.source_data.totalFee = this._totalFee.toString()), this._totalAsset && (this.source_data.totalAsset = this._totalAsset.toString()), this._totalChainAsset && (this.source_data.totalChainAsset = this._totalChainAsset.toString()), this.source_data.format();
      }
    };
    pl.SOURCE_DATA_SYMBOL = /* @__PURE__ */ Symbol("source-data");
    pl = Gf = l([J(), be(0, D(Gf.SOURCE_DATA_SYMBOL, { optional: true })), u("design:paramtypes", [Object, ve])], pl);
    const { ArgumentFormatException: Qs, NoFoundException: Li, ArgumentIllegalException: Qx, OutOfRangeException: jT, IllegalStateException: JT, ConsensusException: YT } = ee("HELPER", "blockHelper");
    let dt = class {
      constructor(e, t, r, n, s, o, a) {
        this.config = e, this.baseHelper = t, this.accountBaseHelper = r, this.jsbiHelper = n, this.cryptoHelper = s, this.keypairHelper = o, this.Buffer = a, this._BTC_BLOCK_WM = /* @__PURE__ */ new WeakMap(), this._BLOCK_BTC_WM = /* @__PURE__ */ new WeakMap();
      }
      async generateSignature(e) {
        return gd(await this.cryptoHelper.sha256(e.getBytes(true, true)));
      }
      isValidSignature(e) {
        return this.baseHelper.isValidSignature(e);
      }
      async verifyBlockSignature(e, t) {
        const r = t && t.taskLabel || "Block", { Buffer: n } = this, { generatorPublicKeyBuffer: s, signatureBuffer: o, generatorSecondPublicKeyBuffer: a, signSignatureBuffer: p } = e, h = await this.cryptoHelper.sha256(e.getBytes(true, true, true));
        if (!await this.keypairHelper.detached_verify(h, o, s)) throw new Qs(c.INVALID_SIGNATURE, { taskLabel: r });
        if (a && a.length > 0 || p && p.length > 0) if (a && p) {
          const f = await this.cryptoHelper.sha256().update(e.getBytes(false, true, true)).digest();
          if (!this.keypairHelper.detached_verify(f, n.from(p), n.from(a))) throw new Qs(c.INVALID_SIGNSIGNATURE, { taskLabel: r });
        } else throw new Qs(`Invalid ${r} miss signSignature or senderSecondPublicKey`);
      }
      verifyBlockVersion(e, t = this.config) {
        if (e.version > t.version) throw new YT(c.NOT_MATCH, { to_compare_prop: `block version ${e.version}`, be_compare_prop: `blockChain version ${t.version}`, to_target: "block", be_target: "config" });
      }
      parseTypeByHeight(e) {
        return e === 1 ? Kt.GENESIS : e % this.config.blockPerRound === 0 ? Kt.ROUNDEND : Kt.COMMON;
      }
      calcRoundByHeight(e) {
        return Math.ceil(e / this.config.blockPerRound);
      }
      calcBlockNumberToRoundEnd(e) {
        return this.config.blockPerRound - (e % this.config.blockPerRound || this.config.blockPerRound);
      }
      calcRoundStartHeight(e) {
        return (e - 1) * this.config.blockPerRound + 1;
      }
      calcRoundEndHeight(e) {
        return e * this.config.blockPerRound;
      }
      calcRoundStartHeightByHeight(e) {
        const t = this.calcRoundByHeight(e);
        return this.calcRoundStartHeight(t);
      }
      calcRoundEndHeightByHeight(e) {
        const t = this.calcRoundByHeight(e);
        return this.calcRoundEndHeight(t);
      }
      calcBlockChainRoundByHeight(e) {
        return this.calcRoundByHeight(e + 1);
      }
      isRoundLastBlock(e) {
        return e % this.config.blockPerRound === 0;
      }
      isRoundChange(e, t) {
        return this.calcRoundByHeight(e) === this.calcRoundByHeight(t);
      }
      async forceGetBlockByHeight(e, t = this.blockGetterHelper) {
        if (!t) throw new Li(c.NOT_EXIST, { prop: "blockGetterHelper", target: "moduleStroge" });
        const r = await t.getBlockByHeight(e);
        if (!r) throw new Qs(c.NOT_EXIST, { prop: `height:${e}`, target: "blocks" });
        return r;
      }
      async forceGetBlockBySignature(e, t = this.blockGetterHelper) {
        if (!t) throw new Li(c.NOT_EXIST, { prop: "blockGetterHelper", target: "moduleStroge" });
        const r = await t.getBlockBySignature(e);
        if (!r) throw new Qs(c.NOT_EXIST, { prop: `signature: ${e}`, target: "blockChain" });
        return r;
      }
      async forceGetBlockListByHeightRange(e, t, r = this.blockGetterHelper) {
        const n = [];
        if (e > t) throw new jT(c.OUT_OF_RANGE, { variable: "min and max", message: `min: ${e} max: ${t}` });
        for (let s = e; s <= t; s++) n[n.length] = await this.forceGetBlockByHeight(s, r);
        return n;
      }
      async forceGetBlockGeneratorAddressByHeight(e, t = this.blockGetterHelper) {
        if (!t) throw new Li(c.NOT_EXIST, { prop: "blockGetterHelper", target: "moduleStroge" });
        const r = typeof t.getBlockGeneratorPublicKeyBufferByHeight === "function" ? await t.getBlockGeneratorPublicKeyBufferByHeight(e) : (await this.forceGetBlockByHeight(e, t)).generatorPublicKeyBuffer;
        if (!r) throw new Qs(c.NOT_EXIST, { prop: `height:${e}`, target: "generatorPublicKey" });
        return this.accountBaseHelper.getAddressFromPublicKey(r);
      }
      async forceGetBlockSignatureBufferByHeight(e, t = this.blockGetterHelper) {
        if (!t) throw new Li(c.NOT_EXIST, { prop: "blockGetterHelper", target: "moduleStroge" });
        const r = typeof t.getBlockSignatureByHeight === "function" ? await t.getBlockSignatureByHeight(e) : (await this.forceGetBlockByHeight(e, t)).signatureBuffer;
        if (!r) throw new Qs(c.NOT_EXIST, { prop: `height:${e}`, target: "generatorPublicKey" });
        return r;
      }
      async forceGetBlockSignatureByHeight(e, t = this.blockGetterHelper) {
        return xe(await this.forceGetBlockSignatureBufferByHeight(e, t));
      }
      async getLastBlock(e = this.blockGetterHelper) {
        if (!e) throw new Li(c.NOT_EXIST, { prop: "blockGetterHelper", target: "moduleStroge" });
        return e.getLastBlock();
      }
      async getBlocksByRange(e, t, r = this.blockGetterHelper) {
        if (!r) throw new Li(c.NOT_EXIST, { prop: "blockGetterHelper", target: "moduleStroge" });
        if (!("getBlockByHeight" in r)) return r.getBlocksByRange(e, t);
        if ("getBlockByHeight" in r) {
          const n = [];
          for (let s = e; s < t; s++) {
            const o = await r.getBlockByHeight(s);
            if (!o) break;
            n.push(o);
          }
          return n;
        }
        throw new JT(c.FAILED_TO_GET_BLOCKS_BY_RANGE, { minHeight: e, maxHeight: t });
      }
      async getCurrentGenerateBlock(e = this.blockGetterHelper) {
        if (e && e.getCurrentGenerateBlock) return e.getCurrentGenerateBlock();
      }
      async getCurrentReplayingBlockInfo(e = this.blockGetterHelper) {
        if (e && e.getCurrentReplayingBlockInfo) return e.getCurrentReplayingBlockInfo();
      }
      async getCurrentProcessingBlockPlotChecker(e = this.blockGetterHelper) {
        const t = await this.getCurrentGenerateBlock();
        if (t) return this.parseNewBlockToPlotChecker(t);
        const r = await this.getCurrentReplayingBlockInfo(e);
        if (r) return this.parseBlockToPlotChecker(r.replayingBlock || r.currentBlock);
      }
      parseBlockToPlotChecker(e) {
        let t = this._BLOCK_BTC_WM.get(e);
        return t || (t = { height: e.height, timestamp: e.timestamp, numberOfTransactions: e.numberOfTransactions, get totalFee() {
          return Object.defineProperty(this, "totalFee", { value: BigInt(e.totalFee) }), this.totalFee;
        }, signature: e.signature, previousBlockSignature: e.previousBlockSignature }, this._BLOCK_BTC_WM.set(e, t), this._BTC_BLOCK_WM.set(t, e)), t;
      }
      getBlockFromPlotChecker(e) {
        return this._BTC_BLOCK_WM.get(e);
      }
      parseNewBlockToPlotChecker(e) {
        return { height: e.height, timestamp: e.timestamp, numberOfTransactions: e.numberOfTransactions, get totalFee() {
          return Object.defineProperty(this, "totalFee", { value: BigInt(e.totalFee) }), this.totalFee;
        }, signature: "signature" in e ? e.signature : "ff".repeat(64), previousBlockSignature: e.previousBlockSignature };
      }
      parseBlockPlotCheckerListToPlotChecker(e) {
        const t = e[0], r = e[e.length - 1];
        return { height: r.height, timestamp: r.timestamp, get numberOfTransactions() {
          return Object.defineProperty(this, "numberOfTransactions", { value: e.reduce((s, o) => s + o.numberOfTransactions, 0) }), this.numberOfTransactions;
        }, get totalFee() {
          return Object.defineProperty(this, "totalFee", { value: e.reduce((s, o) => s + o.totalFee, BigInt(0)) }), this.totalFee;
        }, get signature() {
          return Object.defineProperty(this, "signature", { value: e.reduce((s, o) => s + o.signature, "") }), this.signature;
        }, previousBlockSignature: t.previousBlockSignature };
      }
      async forceGetBlockGeneratorAddressByRound(e, t = this.blockGetterHelper) {
        if (!t) throw new Li(c.NOT_EXIST, { prop: "blockGetterHelper", target: "moduleStroge" });
        const r = (e - 1) * this.config.blockPerRound + 1, n = e * this.config.blockPerRound, s = [];
        for (let o = r; o <= n; o++) {
          const a = typeof t.getBlockGeneratorPublicKeyBufferByHeight === "function" ? await t.getBlockGeneratorPublicKeyBufferByHeight(o) : (await this.forceGetBlockByHeight(o, t)).generatorPublicKeyBuffer;
          if (!a) throw new Qs(c.NOT_EXIST, { prop: `height:${o}`, target: "generatorPublicKey" });
          const p = await this.accountBaseHelper.getAddressFromPublicKey(a);
          s.includes(p) || s.push(p);
        }
        return s;
      }
      async calcAssetChangeHash(e, t = "utf-8") {
        const r = [];
        for (const s in e) {
          const o = e[s];
          for (const a in o) {
            const p = o[a];
            for (const h in p) r.push(`${s}-${a}-${h}-${p[h]}`);
          }
        }
        if (r.toSorted((s, o) => s > o ? 1 : -1), r.length === 0) return;
        const n = this.cryptoHelper.sha256();
        for (const s of r) n.update(wr.from(s, t));
        return (await n.digest()).toString("hex");
      }
      async calcChainOnChainHash(e, t) {
        let r = (this.calcRoundByHeight(e) - 1) * this.config.blockPerRound;
        r = r === 0 ? 1 : r;
        const n = this.cryptoHelper.sha256();
        if (r !== 1) {
          const s = await this.forceGetBlockByHeight(r, t);
          n.update(s.asset.roundLastAsset.chainOnChainBuffer);
        }
        for (let s = r; s < e; s++) {
          const o = await this.forceGetBlockSignatureBufferByHeight(s, t);
          n.update(o);
        }
        return (await n.digest()).toString("hex");
      }
      nextRoundGeneratorsCompareFn(e, t) {
        return t.numberOfForgeEntities > e.numberOfForgeEntities ? 1 : t.numberOfForgeEntities < e.numberOfForgeEntities ? -1 : t.producedblocks > e.producedblocks ? 1 : t.producedblocks < e.producedblocks ? -1 : e.publicKey > t.publicKey ? 1 : e.publicKey === t.publicKey ? 0 : -1;
      }
      sortInRankAccountInfoList(e) {
        return e.toSorted(this.nextRoundGeneratorsCompareFn);
      }
      calcForginAndHoldingRewards(e, t, r, n) {
        const s = BigInt(e.reward), o = { forgingRewards: BigInt(e.totalFee) + s, holdingRewardsList: [], circulations: BigInt(0) };
        let a = s;
        if (s > BigInt(0)) {
          if (t > BigInt(0) && r > 0) {
            const p = BigInt(r), h = [];
            for (const f of n) {
              const g = t * BigInt(f.numberOfShareEntities) / p;
              g > BigInt(0) && (a = a + g, h.push({ address: f.address, rewards: g }));
            }
            o.holdingRewardsList = h;
          }
          o.circulations = a;
        }
        return o;
      }
    };
    l([D("blockGetterHelper", { optional: true }), u("design:type", Object)], dt.prototype, "blockGetterHelper", void 0);
    dt = l([J(), be(4, D("cryptoHelper")), be(5, D("keypairHelper")), be(6, D("Buffer")), u("design:paramtypes", [ne, Be, me, xt, Object, Object, Object])], dt);
    const Qn = class _Qn {
      constructor(e) {
        this._map = new Map(e);
      }
      get(e) {
        return this._map.get(e);
      }
      has(e) {
        return this._map.has(e);
      }
      set(e, t) {
        return this._map.set(e, t);
      }
      [Symbol.iterator]() {
        return this._map.entries();
      }
      entries() {
        return this._map[Symbol.iterator];
      }
      static fromPrefix(e, t) {
        const r = new _Qn();
        for (const [n, s] of t) r.set(e + n, s);
        return r;
      }
      mergeWithPrefix(e, t) {
        for (const [r, n] of t) this.set(e + r, n);
        return this;
      }
    };
    const Xe = "/";
    const En = "utf-8";
    const { ArgumentIllegalException: Wn } = ee("HELPER", "transactionHelper");
    let Kf = class {
      constructor() {
        this.version = "1";
      }
      checkEncodeArgs(e) {
        if (!e) throw new Wn(c.PROP_IS_REQUIRE, { prop: `chainInfo ${e}`, target: "encodeArgs" });
        const { chainName: t, magic: r, genesisBlockSignature: n } = e;
        if (!t) throw new Wn(c.PROP_IS_REQUIRE, { prop: `chainName ${t}`, target: "encodeArgs" });
        if (typeof t !== "string") throw new Wn(c.PROP_IS_INVALID, { prop: `chainName ${t}`, target: "encodeArgs" });
        if (!r) throw new Wn(c.PROP_IS_REQUIRE, { prop: `magic ${r}`, target: "encodeArgs" });
        if (typeof r !== "string") throw new Wn(c.PROP_IS_INVALID, { prop: `magic ${r}`, target: "encodeArgs" });
        if (!n) throw new Wn(c.PROP_IS_REQUIRE, { prop: `genesisBlockSignature ${n}`, target: "encodeArgs" });
        if (typeof n !== "string") throw new Wn(c.PROP_IS_INVALID, { prop: `genesisBlockSignature ${n}`, target: "encodeArgs" });
      }
      checkDecodeArgs(e) {
        if (!e) throw new Wn(c.PROP_IS_REQUIRE, { prop: `fromChainId ${e}`, target: "decodeArgs" });
        if (typeof e !== "string") throw new Wn(c.PROP_IS_INVALID, { prop: `fromChainId ${e}`, target: "decodeArgs" });
        if (e.split(Xe).length !== 4) throw new Wn(c.PROP_IS_INVALID, { prop: `fromChainId ${e}`, target: "decodeArgs" });
      }
      encode(e, t = false) {
        return t || this.checkEncodeArgs(e), `${this.version}${Xe}${e.magic}${Xe}${e.chainName}${Xe}${e.genesisBlockSignature}`;
      }
      decode(e, t = false) {
        t || this.checkDecodeArgs(e);
        const r = e.split(Xe);
        return { magic: r[1], chainName: r[2], genesisBlockSignature: r[3] };
      }
    };
    Kf = l([J()], Kf);
    function QT(i = "fromChainId") {
      const e = new Kf();
      return new Qn([[`${i}/${e.version}`, e]]);
    }
    const { ArgumentIllegalException: Xn } = ee("HELPER", "transactionHelper");
    let zf = class {
      constructor() {
        this.version = "1";
      }
      checkEncodeArgs(e) {
        if (!e) throw new Xn(c.PROP_IS_REQUIRE, { prop: `chainInfo ${e}`, target: "encodeArgs" });
        const { chainName: t, magic: r, genesisBlockSignature: n } = e;
        if (!t) throw new Xn(c.PROP_IS_REQUIRE, { prop: `chainName ${t}`, target: "encodeArgs" });
        if (typeof t !== "string") throw new Xn(c.PROP_IS_INVALID, { prop: `chainName ${t}`, target: "encodeArgs" });
        if (!r) throw new Xn(c.PROP_IS_REQUIRE, { prop: `magic ${r}`, target: "encodeArgs" });
        if (typeof r !== "string") throw new Xn(c.PROP_IS_INVALID, { prop: `magic ${r}`, target: "encodeArgs" });
        if (!n) throw new Xn(c.PROP_IS_REQUIRE, { prop: `genesisBlockSignature ${n}`, target: "encodeArgs" });
        if (typeof n !== "string") throw new Xn(c.PROP_IS_INVALID, { prop: `genesisBlockSignature ${n}`, target: "encodeArgs" });
      }
      checkDecodeArgs(e) {
        if (!e) throw new Xn(c.PROP_IS_REQUIRE, { prop: `toChainId ${e}`, target: "decodeArgs" });
        if (typeof e !== "string") throw new Xn(c.PROP_IS_INVALID, { prop: `toChainId ${e}`, target: "decodeArgs" });
        if (e.split(Xe).length !== 4) throw new Xn(c.PROP_IS_INVALID, { prop: `toChainId ${e}`, target: "decodeArgs" });
      }
      encode(e, t = false) {
        return t || this.checkEncodeArgs(e), `${this.version}${Xe}${e.magic}${Xe}${e.chainName}${Xe}${e.genesisBlockSignature}`;
      }
      decode(e, t = false) {
        t || this.checkDecodeArgs(e);
        const r = e.split(Xe);
        return { magic: r[1], chainName: r[2], genesisBlockSignature: r[3] };
      }
    };
    zf = l([J()], zf);
    function WT(i = "toChainId") {
      const e = new zf();
      return new Qn([[`${i}/${e.version}`, e]]);
    }
    const { ArgumentIllegalException: ac } = ee("HELPER", "transactionHelper");
    let jf = class {
      constructor() {
        this.version = "1";
      }
      checkEncodeArgs(e) {
        if (!e) throw new ac(c.PROP_IS_REQUIRE, { prop: `address ${e}`, target: "encodeArgs" });
        if (typeof e !== "string") throw new ac(c.PROP_IS_INVALID, { prop: `address ${e}`, target: "encodeArgs" });
      }
      checkDecodeArgs(e) {
        if (!e) throw new ac(c.PROP_IS_REQUIRE, { prop: `fromId ${e}`, target: "decodeArgs" });
        if (typeof e !== "string") throw new ac(c.PROP_IS_INVALID, { prop: `fromId ${e}`, target: "decodeArgs" });
        if (e.split(Xe).length !== 2) throw new ac(c.PROP_IS_INVALID, { prop: `fromId ${e}`, target: "decodeArgs" });
      }
      encode(e, t = false) {
        return t || this.checkEncodeArgs(e), `${this.version}${Xe}${e}`;
      }
      decode(e, t = false) {
        return t || this.checkDecodeArgs(e), e.split(Xe)[1];
      }
    };
    jf = l([J()], jf);
    function XT(i = "fromId") {
      const e = new jf();
      return new Qn([[`${i}/${e.version}`, e]]);
    }
    const { ArgumentIllegalException: cc } = ee("HELPER", "transactionHelper");
    let Jf = class {
      constructor() {
        this.version = "1";
      }
      checkEncodeArgs(e) {
        if (!e) throw new cc(c.PROP_IS_REQUIRE, { prop: `address ${e}`, target: "encodeArgs" });
        if (typeof e !== "string") throw new cc(c.PROP_IS_INVALID, { prop: `address ${e}`, target: "encodeArgs" });
      }
      checkDecodeArgs(e) {
        if (!e) throw new cc(c.PROP_IS_REQUIRE, { prop: `toId ${e}`, target: "decodeArgs" });
        if (typeof e !== "string") throw new cc(c.PROP_IS_INVALID, { prop: `toId ${e}`, target: "decodeArgs" });
        if (e.split(Xe).length !== 2) throw new cc(c.PROP_IS_INVALID, { prop: `toId ${e}`, target: "decodeArgs" });
      }
      encode(e, t = false) {
        return t || this.checkEncodeArgs(e), `${this.version}${Xe}${e}`;
      }
      decode(e, t = false) {
        return t || this.checkDecodeArgs(e), e.split(Xe)[1];
      }
    };
    Jf = l([J()], Jf);
    function qT(i = "toId") {
      const e = new Jf();
      return new Qn([[`${i}/${e.version}`, e]]);
    }
    const { ArgumentIllegalException: $o } = ee("HELPER", "transactionHelper");
    let Yf = class {
      constructor() {
        this.version = "1";
      }
      checkEncodeArgs(e) {
        if (!e) throw new $o(c.PROP_IS_REQUIRE, { prop: `assetInfo ${e}`, target: "encodeArgs" });
        const { parentAssetType: t, assetType: r } = e;
        if (t !== G.DAPP && t !== G.LOCATION_NAME && t !== G.ENTITY && t !== G.ASSETS) throw new $o(c.PROP_IS_INVALID, { prop: `parentAssetType ${t}`, target: "encodeArgs" });
        if (typeof r !== "string") throw new $o(c.PROP_IS_INVALID, { prop: `assetType ${r}`, target: "encodeArgs" });
      }
      checkDecodeArgs(e) {
        if (!e) throw new $o(c.PROP_IS_REQUIRE, { prop: `assetId ${e}`, target: "decodeArgs" });
        if (typeof e !== "string") throw new $o(c.PROP_IS_INVALID, { prop: `assetId ${e}`, target: "decodeArgs" });
        if (e.split(Xe).length !== 3) throw new $o(c.PROP_IS_INVALID, { prop: `assetId ${e}`, target: "decodeArgs" });
      }
      encode(e, t = false) {
        return t || this.checkEncodeArgs(e), `${this.version}${Xe}${e.parentAssetType}${Xe}${e.assetType}`;
      }
      decode(e, t = false) {
        t || this.checkDecodeArgs(e);
        const r = e.split(Xe);
        return { parentAssetType: Number(r[1]), assetType: r[2] };
      }
    };
    Yf = l([J()], Yf);
    function ZT(i = "assetId") {
      const e = new Yf();
      return new Qn([[`${i}/${e.version}`, e]]);
    }
    const { ArgumentIllegalException: yr } = ee("HELPER", "transactionHelper");
    let Qf = class {
      constructor() {
        this.version = "1";
      }
      checkEncodeArgs(e) {
        const { publicKey: t, signature: r, secondPublicKey: n, signSignature: s } = e;
        if (!t) throw new yr(c.PROP_IS_REQUIRE, { prop: `publicKey ${t}`, target: "encodeArgs" });
        if (typeof t !== "string") throw new yr(c.PROP_IS_INVALID, { prop: `publicKey ${t}`, target: "encodeArgs" });
        if (!r) throw new yr(c.PROP_IS_REQUIRE, { prop: `signature ${r}`, target: "encodeArgs" });
        if (typeof r !== "string") throw new yr(c.PROP_IS_INVALID, { prop: `signature ${r}`, target: "encodeArgs" });
        if (n) {
          if (!n) throw new yr(c.PROP_IS_REQUIRE, { prop: `secondPublicKey ${n}`, target: "encodeArgs" });
          if (typeof n !== "string") throw new yr(c.PROP_IS_INVALID, { prop: `secondPublicKey ${n}`, target: "encodeArgs" });
          if (!s) throw new yr(c.PROP_IS_REQUIRE, { prop: `signSignature ${s}`, target: "encodeArgs" });
          if (typeof s !== "string") throw new yr(c.PROP_IS_INVALID, { prop: `signSignature ${s}`, target: "encodeArgs" });
        } else if (s) throw new yr(c.SHOULD_NOT_EXIST, { prop: `signSignature ${s}`, target: "encodeArgs" });
      }
      checkDecodeArgs(e) {
        if (!e) throw new yr(c.PROP_IS_REQUIRE, { prop: `signature ${e}`, target: "decodeArgs" });
        if (typeof e !== "string") throw new yr(c.PROP_IS_INVALID, { prop: `signature ${e}`, target: "decodeArgs" });
        const t = e.split("/");
        if (t.length !== 2 && t.length !== 3) throw new yr(c.PROP_IS_INVALID, { prop: `signature ${e}`, target: "decodeArgs" });
        if (t[1].split("-").length !== 2) throw new yr(c.PROP_IS_INVALID, { prop: `signature ${e}`, target: "decodeArgs" });
        if (t[2] && t[2].split("-").length !== 2) throw new yr(c.PROP_IS_INVALID, { prop: `signature ${e}`, target: "decodeArgs" });
      }
      encode(e, t = false) {
        t || this.checkEncodeArgs(e);
        let r = `${this.version}${Xe}${e.publicKey}-${e.signature}`;
        return e.secondPublicKey && e.signSignature && (r += `${Xe}${e.secondPublicKey}-${e.signSignature}`), r;
      }
      decode(e, t = false) {
        t || this.checkDecodeArgs(e);
        const r = e.split(Xe), n = r[1].split("-"), s = { publicKey: n[0], signature: n[1] };
        if (r[2]) {
          const o = r[2].split("-");
          s.secondPublicKey = o[0], s.signSignature = o[1];
        }
        return s;
      }
      splitSignature(e) {
        return e.split("/")[0];
      }
      splitSignSignature(e) {
        return e.split("/").slice(0, 2).join(Xe);
      }
      async generateSignature(e, t, r) {
        const { secret: n, secondSecret: s, migrateCertificate: o } = e;
        o.signature = this.version;
        const a = await t.createSecretKeypair(n), p = xe(a.publicKey), h = await r.detachedSign(wr.from(JSON.stringify({ body: o.body, signature: o.signature }), En), a.secretKey);
        if (o.signature += `/${p}-${xe(h)}`, s) {
          const f = await t.createSecondSecretKeypair(n, s), g = xe(f.publicKey), d = await r.detachedSign(wr.from(JSON.stringify({ body: o.body, signature: o.signature }), En), f.secretKey);
          o.signature += `/${g}-${xe(d)}`;
        }
        return o;
      }
      async verifySignature(e, t, r) {
        const n = r && r.taskLabel || "MigrateCertificate", s = e.signature, o = this.decode(s);
        if (!await t.detachedVeriy(wr.from(JSON.stringify({ body: e.body, signature: this.splitSignature(s) }), En), _e(o.signature), _e(o.publicKey))) throw new yr(c.INVALID_SIGNATURE, { taskLabel: n });
        if (o.secondPublicKey && o.signSignature && !await t.detachedVeriy(wr.from(JSON.stringify({ body: e.body, signature: this.splitSignSignature(s) }), En), _e(o.signSignature), _e(o.secondPublicKey))) throw new yr(c.INVALID_SIGNSIGNATURE, { taskLabel: n });
      }
    };
    Qf = l([J()], Qf);
    function e0(i = "signature") {
      const e = new Qf();
      return new Qn([[`${i}/${e.version}`, e]]);
    }
    const { ArgumentIllegalException: mr } = ee("HELPER", "transactionHelper");
    let Wf = class {
      constructor() {
        this.version = "1";
      }
      checkEncodeArgs(e) {
        const { publicKey: t, signature: r, secondPublicKey: n, signSignature: s } = e;
        if (!t) throw new mr(c.PROP_IS_REQUIRE, { prop: `publicKey ${t}`, target: "encodeArgs" });
        if (typeof t !== "string") throw new mr(c.PROP_IS_INVALID, { prop: `publicKey ${t}`, target: "encodeArgs" });
        if (!r) throw new mr(c.PROP_IS_REQUIRE, { prop: `signature ${r}`, target: "encodeArgs" });
        if (typeof r !== "string") throw new mr(c.PROP_IS_INVALID, { prop: `signature ${r}`, target: "encodeArgs" });
        if (n) {
          if (!n) throw new mr(c.PROP_IS_REQUIRE, { prop: `secondPublicKey ${n}`, target: "encodeArgs" });
          if (typeof n !== "string") throw new mr(c.PROP_IS_INVALID, { prop: `secondPublicKey ${n}`, target: "encodeArgs" });
          if (!s) throw new mr(c.PROP_IS_REQUIRE, { prop: `signSignature ${s}`, target: "encodeArgs" });
          if (typeof s !== "string") throw new mr(c.PROP_IS_INVALID, { prop: `signSignature ${s}`, target: "encodeArgs" });
        } else if (s) throw new mr(c.SHOULD_NOT_EXIST, { prop: `signSignature ${s}`, target: "encodeArgs" });
      }
      checkDecodeArgs(e) {
        if (!e) throw new mr(c.PROP_IS_REQUIRE, { prop: `fromAuthSignature ${e}`, target: "decodeArgs" });
        if (typeof e !== "string") throw new mr(c.PROP_IS_INVALID, { prop: `fromAuthSignature ${e}`, target: "decodeArgs" });
        const t = e.split("/");
        if (t.length !== 2 && t.length !== 3) throw new mr(c.PROP_IS_INVALID, { prop: `fromAuthSignature ${e}`, target: "decodeArgs" });
        if (t[1].split("-").length !== 2) throw new mr(c.PROP_IS_INVALID, { prop: `fromAuthSignature ${e}`, target: "decodeArgs" });
        if (t[2] && t[2].split("-").length !== 2) throw new mr(c.PROP_IS_INVALID, { prop: `fromAuthSignature ${e}`, target: "decodeArgs" });
      }
      encode(e, t = false) {
        t || this.checkEncodeArgs(e);
        let r = `${this.version}${Xe}${e.publicKey}-${e.signature}`;
        return e.secondPublicKey && e.signSignature && (r += `${Xe}${e.secondPublicKey}-${e.signSignature}`), r;
      }
      decode(e, t = false) {
        t || this.checkDecodeArgs(e);
        const r = e.split(Xe), n = r[1].split("-"), s = { publicKey: n[0], signature: n[1] };
        if (r[2]) {
          const o = r[2].split("-");
          s.secondPublicKey = o[0], s.signSignature = o[1];
        }
        return s;
      }
      splitSignature(e) {
        return e.split("/")[0];
      }
      splitSignSignature(e) {
        return e.split("/").slice(0, 2).join(Xe);
      }
      async generateSignature(e, t, r) {
        const { authSecret: n, authSecondSecret: s, migrateCertificate: o } = e;
        o.fromAuthSignature = this.version;
        const a = await t.createSecretKeypair(n), p = xe(a.publicKey), h = await r.detachedSign(wr.from(JSON.stringify({ body: o.body, signature: o.signature, fromAuthSignature: o.fromAuthSignature }), En), a.secretKey);
        if (o.fromAuthSignature += `/${p}-${xe(h)}`, s) {
          const f = await t.createSecondSecretKeypair(n, s), g = xe(f.publicKey), d = await r.detachedSign(wr.from(JSON.stringify({ body: o.body, signature: o.signature, fromAuthSignature: o.fromAuthSignature }), En), f.secretKey);
          o.fromAuthSignature += `/${g}-${xe(d)}`;
        }
        return o;
      }
      async verifySignature(e, t, r) {
        const n = r && r.taskLabel || "MigrateCertificate", s = e.fromAuthSignature, o = this.decode(s);
        if (!await t.detachedVeriy(wr.from(JSON.stringify({ body: e.body, signature: e.signature, fromAuthSignature: this.splitSignature(s) }), En), _e(o.signature), _e(o.publicKey))) throw new mr(c.INVALID_FROMAUTHSIGNATURE, { taskLabel: n });
        if (o.secondPublicKey && o.signSignature && !await t.detachedVeriy(wr.from(JSON.stringify({ body: e.body, signature: e.signature, fromAuthSignature: this.splitSignSignature(s) }), En), _e(o.signSignature), _e(o.secondPublicKey))) throw new mr(c.INVALID_FROMAUTHSIGNSIGNATURE, { taskLabel: n });
      }
    };
    Wf = l([J()], Wf);
    function t0(i = "fromAuthSignature") {
      const e = new Wf();
      return new Qn([[`${i}/${e.version}`, e]]);
    }
    const { ArgumentIllegalException: _r } = ee("HELPER", "transactionHelper");
    let Xf = class {
      constructor() {
        this.version = "1";
      }
      checkEncodeArgs(e) {
        const { publicKey: t, signature: r, secondPublicKey: n, signSignature: s } = e;
        if (!t) throw new _r(c.PROP_IS_REQUIRE, { prop: `publicKey ${t}`, target: "encodeArgs" });
        if (typeof t !== "string") throw new _r(c.PROP_IS_INVALID, { prop: `publicKey ${t}`, target: "encodeArgs" });
        if (!r) throw new _r(c.PROP_IS_REQUIRE, { prop: `signature ${r}`, target: "encodeArgs" });
        if (typeof r !== "string") throw new _r(c.PROP_IS_INVALID, { prop: `signature ${r}`, target: "encodeArgs" });
        if (n) {
          if (!n) throw new _r(c.PROP_IS_REQUIRE, { prop: `secondPublicKey ${n}`, target: "encodeArgs" });
          if (typeof n !== "string") throw new _r(c.PROP_IS_INVALID, { prop: `secondPublicKey ${n}`, target: "encodeArgs" });
          if (!s) throw new _r(c.PROP_IS_REQUIRE, { prop: `signSignature ${s}`, target: "encodeArgs" });
          if (typeof s !== "string") throw new _r(c.PROP_IS_INVALID, { prop: `signSignature ${s}`, target: "encodeArgs" });
        } else if (s) throw new _r(c.SHOULD_NOT_EXIST, { prop: `signSignature ${s}`, target: "encodeArgs" });
      }
      checkDecodeArgs(e, t) {
        if (!e) throw new _r(c.PROP_IS_REQUIRE, { prop: `toAuthSignature ${e}`, target: "decodeArgs" });
        if (typeof e !== "string") throw new _r(c.PROP_IS_INVALID, { prop: `toAuthSignature ${e}`, target: "decodeArgs" });
        const r = e.split("/");
        if (r.length !== 2 && r.length !== 3) throw new _r(c.PROP_IS_INVALID, { prop: `toAuthSignature ${e}`, target: "decodeArgs" });
        if (r[1].split("-").length !== 2) throw new _r(c.PROP_IS_INVALID, { prop: `toAuthSignature ${e}`, target: "decodeArgs" });
        if (r[2] && r[2].split("-").length !== 2) throw new _r(c.PROP_IS_INVALID, { prop: `toAuthSignature ${e}`, target: "decodeArgs" });
      }
      encode(e, t = false) {
        t || this.checkEncodeArgs(e);
        let r = `${this.version}${Xe}${e.publicKey}-${e.signature}`;
        return e.secondPublicKey && e.signSignature && (r += `${Xe}${e.secondPublicKey}-${e.signSignature}`), r;
      }
      decode(e, t = false) {
        t || this.checkDecodeArgs(e);
        const r = e.split(Xe), n = r[1].split("-"), s = { publicKey: n[0], signature: n[1] };
        if (r[2]) {
          const o = r[2].split("-");
          s.secondPublicKey = o[0], s.signSignature = o[1];
        }
        return s;
      }
      splitSignature(e) {
        return e.split("/")[0];
      }
      splitSignSignature(e) {
        return e.split("/").slice(0, 2).join(Xe);
      }
      async generateSignature(e, t, r) {
        const { authSecret: n, authSecondSecret: s, migrateCertificate: o } = e;
        o.toAuthSignature = this.version;
        const a = await t.createSecretKeypair(n), p = xe(a.publicKey), h = await r.detachedSign(wr.from(JSON.stringify({ body: o.body, signature: o.signature, fromAuthSignature: o.fromAuthSignature, toAuthSignature: o.toAuthSignature }), En), a.secretKey);
        if (o.toAuthSignature += `/${p}-${xe(h)}`, s) {
          const f = await t.createSecondSecretKeypair(n, s), g = xe(f.publicKey), d = await r.detachedSign(wr.from(JSON.stringify({ body: o.body, signature: o.signature, fromAuthSignature: o.fromAuthSignature, toAuthSignature: o.toAuthSignature }), En), f.secretKey);
          o.toAuthSignature += `/${g}-${xe(d)}`;
        }
        return o;
      }
      async verifySignature(e, t, r) {
        const n = r && r.taskLabel || "MigrateCertificate", s = e.toAuthSignature, o = this.decode(s);
        if (!await t.detachedVeriy(wr.from(JSON.stringify({ body: e.body, signature: e.signature, fromAuthSignature: e.fromAuthSignature, toAuthSignature: this.splitSignature(s) }), En), _e(o.signature), _e(o.publicKey))) throw new _r(c.INVALID_TOAUTHSIGNATURE, { taskLabel: n });
        if (o.secondPublicKey && o.signSignature && !await t.detachedVeriy(wr.from(JSON.stringify({ body: e.body, signature: e.signature, fromAuthSignature: e.fromAuthSignature, toAuthSignature: this.splitSignSignature(s) }), En), _e(o.signSignature), _e(o.secondPublicKey))) throw new _r(c.INVALID_TOAUTHSIGNSIGNATURE, { taskLabel: n });
      }
    };
    Xf = l([J()], Xf);
    function r0(i = "toAuthSignature") {
      const e = new Xf();
      return new Qn([[`${i}/${e.version}`, e]]);
    }
    function n0(i = 1) {
      return new Qn().mergeWithPrefix(`${i}/`, QT()).mergeWithPrefix(`${i}/`, WT()).mergeWithPrefix(`${i}/`, XT()).mergeWithPrefix(`${i}/`, qT()).mergeWithPrefix(`${i}/`, ZT()).mergeWithPrefix(`${i}/`, e0()).mergeWithPrefix(`${i}/`, t0()).mergeWithPrefix(`${i}/`, r0());
    }
    const cr = n0();
    let Ah = class {
      constructor(e) {
        this.config = e, this.fieldConverter = cr, this._init(), this._check();
      }
      get fromChainId() {
        return this.__fromChainId;
      }
      get toChainId() {
        return this.__toChainId;
      }
      get fromId() {
        return this.__fromId;
      }
      get toId() {
        return this.__toId;
      }
      get assetId() {
        return this.__assetId;
      }
      get signature() {
        return this.__signature;
      }
      get fromAuthSignature() {
        return this.__fromAuthSignature;
      }
      get toAuthSignature() {
        return this.__toAuthSignature;
      }
      getUUID(e) {
        return this.signature.decode(e.fromAuthSignature, true).signature;
      }
      _init() {
        if (!this.config) {
          this.__fromChainId = cr.get("1/fromChainId/1"), this.__toChainId = cr.get("1/toChainId/1"), this.__fromId = cr.get("1/fromId/1"), this.__toId = cr.get("1/toId/1"), this.__assetId = cr.get("1/assetId/1"), this.__signature = cr.get("1/signature/1"), this.__fromAuthSignature = cr.get("1/fromAuthSignature/1"), this.__toAuthSignature = cr.get("1/toAuthSignature/1");
          return;
        }
        const { fromChainIdVersion: e, toChainIdVersion: t, fromIdVersion: r, toIdVersion: n, assetIdVersion: s, signatureVersion: o, fromAuthSignatureVersion: a, toAuthSignatureVersion: p } = this.config;
        this.__fromChainId = cr.get(`1/fromChainId/${e}`), this.__toChainId = cr.get(`1/toChainId/${t}`), this.__fromId = cr.get(`1/fromId/${r}`), this.__toId = cr.get(`1/toId/${n}`), this.__assetId = cr.get(`1/assetId/${s}`), this.__signature = cr.get(`1/signature/${o}`), this.__fromAuthSignature = cr.get(`1/fromAuthSignature/${a || o}`), this.__toAuthSignature = cr.get(`1/toAuthSignature/${p || a || o}`);
      }
      _check() {
        if (this.config) {
          if (!this.__fromChainId) throw new SyntaxError(`unknown fromChainId version ${this.config.fromChainIdVersion}`);
          if (!this.__toChainId) throw new SyntaxError(`unknown toChainId version ${this.config.toChainIdVersion}`);
          if (!this.__fromId) throw new SyntaxError(`unknown fromId version ${this.config.fromIdVersion}`);
          if (!this.__toId) throw new SyntaxError(`unknown toId version ${this.config.toIdVersion}`);
          if (!this.__assetId) throw new SyntaxError(`unknown assetId version ${this.config.assetIdVersion}`);
          if (!this.__signature) throw new SyntaxError(`unknown signature version ${this.config.signatureVersion}`);
          if (!this.__fromAuthSignature) throw new SyntaxError(`unknown fromAuthSignature version ${this.config.fromAuthSignatureVersion}`);
          if (!this.__toAuthSignature) throw new SyntaxError(`unknown toAuthSignature version ${this.config.toAuthSignatureVersion}`);
        }
      }
    };
    Ah = l([J(), u("design:paramtypes", [Object])], Ah);
    const { ArgumentIllegalException: jm } = ee("HELPER", "transactionHelper");
    function Ws(i) {
      return i.split("/", 1)[0];
    }
    function xn(i) {
      if (!i) return new Ah();
      const { body: e, signature: t, fromAuthSignature: r, toAuthSignature: n } = i;
      if (!e) throw new jm(c.PROP_IS_REQUIRE, { prop: "json.body" });
      if (!t) throw new jm(c.PROP_IS_REQUIRE, { prop: "json.signature" });
      const { fromChainId: s, toChainId: o, fromId: a, toId: p, assetId: h } = e, f = Ws(s), g = Ws(o), d = Ws(a), y = Ws(p), _ = Ws(h), I = Ws(t), S = { fromChainIdVersion: f, toChainIdVersion: g, fromIdVersion: d, toIdVersion: y, assetIdVersion: _, signatureVersion: I };
      return r && (S.fromAuthSignatureVersion = Ws(r)), n && (S.toAuthSignatureVersion = Ws(n)), new Ah(S);
    }
    let qf = class {
      constructor() {
        this.__version = "0.0.1";
      }
      get version() {
        return this.__version;
      }
      set version(e) {
        this.__version = e;
      }
    };
    qf = l([J()], qf);
    const { ArgumentIllegalException: rr } = ee("HELPER", "transactionHelper");
    let Fs = class {
      constructor(e, t, r, n, s, o, a) {
        this.baseHelper = e, this.configHelper = t, this.chainTimeHelper = r, this.asymmetricHelper = n, this.accountBaseHelper = s, this.transactionHelper = o, this.config = a;
      }
      __checkVersion(e) {
        if (!e) throw new rr(c.PROP_IS_REQUIRE, { prop: "version", target: "migrateCertificate" });
        if (typeof e !== "string") throw new rr(c.PROP_IS_INVALID, { prop: "version", target: "migrateCertificate" });
      }
      __checkTimestamp(e) {
        if (!e) throw new rr(c.PROP_IS_REQUIRE, { prop: "timestamp", target: "migrateCertificate" });
        if (!this.baseHelper.isPositiveInteger(e)) throw new rr(c.PROP_IS_INVALID, { prop: "timestamp", target: "migrateCertificate" });
      }
      __checkAssets(e) {
        if (!e) throw new rr(c.PROP_IS_REQUIRE, { prop: "assets", target: "migrateCertificate" });
        if (!this.baseHelper.isValidAssetNumber(e)) throw new rr(c.PROP_IS_INVALID, { prop: "assets", target: "migrateCertificate" });
        if (e === "0") throw new rr(c.PROP_SHOULD_GT_FIELD, { prop: "assets", fueld: "0", target: "migrateCertificate" });
      }
      getMigrateCertificateConverter(e) {
        return xn(e);
      }
      formatMigrateCertificate(e) {
        const { body: t, signature: r, fromAuthSignature: n, toAuthSignature: s } = e;
        return { body: { version: t.version, timestamp: t.timestamp, fromChainId: t.fromChainId, toChainId: t.toChainId, fromId: t.fromId, toId: t.toId, assetId: t.assetId, assetPrealnum: t.assetPrealnum }, signature: r || "", fromAuthSignature: n || "", toAuthSignature: s || "" };
      }
      combineMigrateCertificateBody(e, t = this.configHelper) {
        const r = xn(), { senderId: n, recipientId: s, toChainInfo: o, assetInfo: a, assetPrealnum: p } = e;
        return { body: { version: t.version.toString(), timestamp: this.chainTimeHelper.now(true), fromChainId: r.fromChainId.encode({ magic: t.magic, chainName: t.chainName, genesisBlockSignature: t.signature }, true), toChainId: r.toChainId.encode(o), fromId: r.fromId.encode(n, true), toId: r.toId.encode(s, true), assetId: r.assetId.encode(a, true), assetPrealnum: p }, signature: r.signature.version };
      }
      combineMigrateCertificateSignature(e, t) {
        const r = xn(e), { signature: n, fromAuthSignature: s, toAuthSignature: o } = t;
        return n && (e.signature = r.signature.encode(n)), s && (e.fromAuthSignature = r.fromAuthSignature.encode(s)), o && (e.toAuthSignature = r.toAuthSignature.encode(o)), e;
      }
      async generateMigrateCertificate(e, t = this.configHelper) {
        const { senderSecret: r, senderSecondSecret: n, recipientId: s, toChainInfo: o, assetInfo: a, assetPrealnum: p } = e, h = xn();
        this.__checkAssets(p);
        const f = this.accountBaseHelper, g = await f.createSecretKeypair(r), d = await f.getAddressFromPublicKey(g.publicKey);
        let y = { body: { version: this.config.version, timestamp: this.chainTimeHelper.now(true), fromChainId: h.fromChainId.encode({ magic: t.magic, chainName: t.chainName, genesisBlockSignature: t.signature }, true), toChainId: h.toChainId.encode(o), fromId: h.fromId.encode(d, true), toId: h.toId.encode(s, true), assetId: h.assetId.encode(a, true), assetPrealnum: p }, signature: "", fromAuthSignature: "", toAuthSignature: "" };
        return r && (y = await h.signature.generateSignature({ secret: r, secondSecret: n, migrateCertificate: y }, f, this.asymmetricHelper)), y;
      }
      parseMigrateCertificateToJson(e) {
        const { body: t, signature: r, fromAuthSignature: n, toAuthSignature: s } = e, o = xn(e);
        return { body: { version: t.version, senderId: o.fromId.decode(t.fromId), recipientId: o.toId.decode(t.toId), timestamp: t.timestamp, fromChain: o.fromChainId.decode(t.fromChainId), toChain: o.toChainId.decode(t.toChainId), asset: o.assetId.decode(t.assetId), assetPrealnum: t.assetPrealnum }, signature: o.signature.decode(r), fromAuthSignature: n && n.includes("/") ? o.fromAuthSignature.decode(n) : void 0, toAuthSignature: s && s.includes("/") ? o.toAuthSignature.decode(s) : void 0 };
      }
      async fromAuthSignMigrateCertificate(e) {
        return xn(e.migrateCertificate).fromAuthSignature.generateSignature(e, this.accountBaseHelper, this.asymmetricHelper);
      }
      async toAuthSignMigrateCertificate(e) {
        return xn(e.migrateCertificate).toAuthSignature.generateSignature(e, this.accountBaseHelper, this.asymmetricHelper);
      }
      async verifyMigrateCertificateSignature(e, t) {
        return xn(e).signature.verifySignature(e, this.asymmetricHelper, t);
      }
      async verifyMigrateCertificateFromAuthSignature(e, t) {
        return xn(e).fromAuthSignature.verifySignature(e, this.asymmetricHelper, t);
      }
      async verifyMigrateCertificateToAuthSignature(e, t) {
        return xn(e).toAuthSignature.verifySignature(e, this.asymmetricHelper, t);
      }
      async __checkAuthAccount(e, t, r) {
        const n = await this.accountBaseHelper.getAddressFromPublicKeyString(r.publicKey), s = t.genesisGenerators, o = await this.accountBaseHelper.getAddressFromPublicKeyString(t.generatorPublicKey);
        if (s.push(o), !s.includes(n)) throw new rr(c.NOT_MATCH, { to_compare_prop: `${e} auth signature address ${n}`, be_compare_prop: "genesis generator address", to_target: "migrateCertificate", be_target: "fromChain" });
      }
      async checkChainInfo(e, t, r, n) {
        if (t.magic !== r.magic) throw new rr(c.SHOULD_BE, { to_compare_prop: `${e}.magic ${t.magic}`, to_target: "migrateCertificate", be_compare_prop: r.magic });
        if (t.chainName !== r.chainName) throw new rr(c.SHOULD_BE, { to_compare_prop: `${e}.chainName ${t.chainName}`, to_target: "migrateCertificate", be_compare_prop: r.chainName });
        if (t.genesisBlockSignature !== t.genesisBlockSignature) throw new rr(c.SHOULD_BE, { to_compare_prop: `${e}.genesisBlockSignature ${t.genesisBlockSignature}`, to_target: "migrateCertificate", be_compare_prop: t.genesisBlockSignature });
        n && await this.__checkAuthAccount(e, r, n);
      }
      async verifyMigrateCertificate(e, t) {
        const r = { target: "migrateCertificate" }, n = xn(e), { forceCheckFromChainInfo: s, fromChainBaseConfig: o, forceCheckFromAuthSignature: a, forceCheckToChainInfo: p, toChainBaseConfig: h, forceCheckToAuthSignature: f } = t, { body: g, signature: d, fromAuthSignature: y, toAuthSignature: _ } = e;
        this.__checkVersion(g.version), this.__checkTimestamp(g.timestamp), n.fromChainId.checkDecodeArgs(g.fromChainId), n.toChainId.checkDecodeArgs(g.toChainId), n.fromId.checkDecodeArgs(g.fromId), n.toId.checkDecodeArgs(g.toId), n.assetId.checkDecodeArgs(g.assetId), this.__checkAssets(g.assetPrealnum), n.signature.checkDecodeArgs(d);
        const I = this.baseHelper, S = n.signature.decode(d, true);
        if (!I.isValidAccountSignature(S)) throw new rr(c.PROP_IS_INVALID, { prop: `signature ${d}`, ...r });
        if (await n.signature.verifySignature(e, this.asymmetricHelper), s) {
          if (!o) throw new rr(c.PROP_IS_REQUIRE, { prop: "fromChainBaseConfig", target: "options" });
          const w = n.fromChainId.decode(g.fromChainId);
          if (await this.checkChainInfo("fromChain", w, o), y && y.includes(Xe)) {
            n.fromAuthSignature.checkDecodeArgs(y);
            const N = n.fromAuthSignature.decode(y, true);
            if (!I.isValidAccountSignature(N)) throw new rr(c.PROP_IS_INVALID, { prop: `fromAuthSignature ${y}`, ...r });
            await this.__checkAuthAccount("fromChain", o, N);
          }
        }
        if (a) {
          if (!y) throw new rr(c.PROP_IS_REQUIRE, { prop: "fromAuthSignature", ...r });
          await this.verifyMigrateCertificateFromAuthSignature(e);
        }
        if (p) {
          if (!h) throw new rr(c.PROP_IS_REQUIRE, { prop: "toChainBaseConfig", target: "options" });
          const w = n.toChainId.decode(g.toChainId);
          if (await this.checkChainInfo("toChain", w, h), _ && _.includes(Xe)) {
            n.toAuthSignature.checkDecodeArgs(_);
            const N = n.toAuthSignature.decode(_, true);
            if (!I.isValidAccountSignature(N)) throw new rr(c.PROP_IS_INVALID, { prop: `toAuthSignature ${_}`, ...r });
            await this.__checkAuthAccount("toChain", h, N);
          }
        }
        if (f) {
          if (!_) throw new rr(c.PROP_IS_REQUIRE, { prop: "toAuthSignature", ...r });
          await this.verifyMigrateCertificateToAuthSignature(e);
        }
        return n;
      }
    };
    Fs = l([J(), u("design:paramtypes", [Be, ne, Ft, Or, me, Ee, qf])], Fs);
    let Zf = class {
      constructor() {
        this.__version = "0.0.1";
      }
      get version() {
        return this.__version;
      }
      set version(e) {
        this.__version = e;
      }
    };
    Zf = l([J()], Zf);
    const Kl = "utf-8";
    const { ArgumentIllegalException: Gr } = ee("HELPER", "RegisterChainCertificateHelper");
    let Eh = class {
      constructor(e, t, r, n, s) {
        this.baseHelper = e, this.chainTimeHelper = t, this.asymmetricHelper = r, this.accountBaseHelper = n, this.config = s;
      }
      __checkVersion(e) {
        if (!e) throw new Gr(c.PROP_IS_REQUIRE, { prop: "version", target: "registerChainCertificate" });
        if (typeof e !== "string") throw new Gr(c.PROP_IS_INVALID, { prop: "version", target: "registerChainCertificate" });
      }
      __checkTimestamp(e) {
        if (!e) throw new Gr(c.PROP_IS_REQUIRE, { prop: "timestamp", target: "registerChainCertificate" });
        if (!this.baseHelper.isPositiveInteger(e)) throw new Gr(c.PROP_IS_INVALID, { prop: "timestamp", target: "registerChainCertificate" });
      }
      __checkPublicKey(e) {
        if (!e) throw new Gr(c.PROP_IS_REQUIRE, { prop: "publicKey", target: "registerChainCertificate" });
        if (!this.baseHelper.isValidPublicKey(e)) throw new Gr(c.PROP_IS_INVALID, { prop: "publicKey", target: "registerChainCertificate" });
      }
      __checkSignature(e) {
        if (!e) throw new Gr(c.PROP_IS_REQUIRE, { prop: "signature", target: "registerChainCertificate" });
        if (!this.baseHelper.isValidSignature(e)) throw new Gr(c.PROP_IS_INVALID, { prop: "signature", target: "registerChainCertificate" });
      }
      async generateRegisterChainCertificate(e) {
        const { generatorSecret: t, generatorSecondSecret: r, genesisBlockInfo: n, version: s, timestamp: o } = e, a = this.accountBaseHelper, p = await a.createSecretKeypair(t), h = xe(p.publicKey);
        let f;
        const g = { body: { version: s || this.config.version, timestamp: o === void 0 ? this.chainTimeHelper.now(true) : o, genesisBlockInfo: { genesisAccount: { address: await a.getAddressFromPublicKey(p.publicKey), publicKey: h }, ...n } }, publicKey: h };
        r && (f = await a.createSecretKeypair(t), g.secondPublicKey = xe(f.publicKey));
        const d = await this.asymmetricHelper.detachedSign(Buffer.from(JSON.stringify(g), Kl), p.secretKey), y = { ...g, signature: xe(d) };
        if (f) {
          const _ = await this.asymmetricHelper.detachedSign(Buffer.from(JSON.stringify(g), Kl), f.secretKey);
          y.signSignature = xe(_);
        }
        return y;
      }
      async verifyRegisterChainCertificateSignature(e, t) {
        const r = t && t.taskLabel || "RegisterChainCertificate", { body: n, publicKey: s, signature: o, secondPublicKey: a, signSignature: p } = e;
        if (!await this.asymmetricHelper.detachedVeriy(Buffer.from(JSON.stringify({ body: n, publicKey: s }), Kl), _e(o), _e(s))) throw new Gr(c.INVALID_SIGNATURE, { taskLabel: r });
        if (a && p && !await this.asymmetricHelper.detachedVeriy(Buffer.from(JSON.stringify({ body: n, publicKey: s, secondPublicKey: a, signature: o }), Kl), _e(p), _e(a))) throw new Gr(c.INVALID_SIGNSIGNATURE, { taskLabel: r });
      }
      async verifyRegisterChainCertificate(e) {
        const { body: t, publicKey: r, signature: n, secondPublicKey: s, signSignature: o } = e;
        if (r !== t.genesisBlockInfo.genesisAccount.publicKey) throw new Gr(c.NOT_MATCH, { to_compare_prop: `publicKey ${r}`, be_compare_prop: `generatorPublicKey ${t.genesisBlockInfo.genesisAccount.publicKey}`, to_target: "registerChainCertificate", be_target: "registerChainCertificate.body.genesisBlockInfo" });
        if (this.__checkVersion(t.version), this.__checkTimestamp(t.timestamp), this.__checkPublicKey(r), this.__checkSignature(n), s && o) this.__checkPublicKey(s), this.__checkSignature(o);
        else {
          if (s) throw new Gr(c.SHOULD_NOT_EXIST, { prop: `secondPublicKey ${s}`, target: "registerChainCertificate" });
          if (o) throw new Gr(c.SHOULD_NOT_EXIST, { prop: `signSignature ${o}`, target: "registerChainCertificate" });
        }
        return await this.verifyRegisterChainCertificateSignature(e), true;
      }
      encode(e) {
        return JSON.stringify(e);
      }
      decode(e) {
        return JSON.parse(e);
      }
    };
    Eh = l([J(), u("design:paramtypes", [Be, Ft, Or, me, Zf])], Eh);
    const { ArgumentIllegalException: Te } = ee("CONTROLLER", "_txbase");
    const Ge = class {
      async fromJSON(e, t) {
        const r = this.init(e, e.asset);
        return t && t.verify && await this.verify(r, t.config), r;
      }
      verifyKeypair(e) {
        if (!e) throw new Te(c.PARAM_LOST, { param: "keypair" });
        const t = { target: "keypair" };
        if (!e.publicKey) throw new Te(c.PROP_IS_REQUIRE, { prop: "publicKey", ...t });
        if (!e.secretKey) throw new Te(c.PROP_IS_REQUIRE, { param: "secretKey", ...t });
      }
      verifySecondKeypair(e) {
        if (!e) throw new Te(c.PARAM_LOST, { param: "keypair" });
        const t = { target: "keypair" };
        if (!e.publicKey) throw new Te(c.PROP_IS_REQUIRE, { prop: "publicKey", ...t });
        if (!e.secretKey) throw new Te(c.PROP_IS_REQUIRE, { param: "secretKey", ...t });
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        if (!e) throw new Te(c.PARAM_LOST, { param: "body" });
        if (!t) throw new Te(c.PARAM_LOST, { param: "asset" });
        const n = { target: "body" }, { baseHelper: s, accountBaseHelper: o } = this;
        if (!s.isPositiveInteger(e.version)) throw new Te(c.PROP_IS_REQUIRE, { prop: "version", ...n });
        if (!e.type) throw new Te(c.PROP_IS_REQUIRE, { prop: "type", ...n });
        if (!s.isValidTransactionType(e.type)) throw new Te(c.PROP_IS_INVALID, { prop: "type", type: "transaction type", ...n });
        if (!e.senderId) throw new Te(c.PROP_IS_REQUIRE, { prop: "senderId", ...n });
        if (!await o.isAddress(e.senderId)) throw new Te(c.PROP_IS_INVALID, { prop: `senderId ${e.senderId}`, type: "account address", ...n });
        if (!e.senderPublicKey) throw new Te(c.PROP_IS_REQUIRE, { prop: "senderPublicKey", ...n });
        if (!s.isValidPublicKey(e.senderPublicKey)) throw new Te(c.PROP_IS_INVALID, { prop: `senderPublicKey ${e.senderPublicKey}`, type: "account publicKey", ...n });
        const a = await o.getAddressFromPublicKeyString(e.senderPublicKey);
        if (e.senderId !== a) throw new Te(c.NOT_MATCH, { to_compare_prop: `senderId ${e.senderId}`, be_compare_prop: `publicKey => address ${a}`, to_target: "senderPublicKey", be_target: "body", ...n });
        if (e.senderSecondPublicKey && !s.isValidPublicKey(e.senderSecondPublicKey)) throw new Te(c.PROP_IS_INVALID, { prop: `senderSecondPublicKey ${e.senderSecondPublicKey}`, type: "account publicKey", ...n });
        if (e.recipientId !== void 0 && !await o.isAddress(e.recipientId)) throw new Te(c.PROP_IS_INVALID, { prop: `recipientId ${e.recipientId}`, type: "account address", ...n });
        const { range: p } = e;
        if (p.length > 0) {
          const _ = new Set(p);
          if (p.length !== _.size) throw new Te(c.SHOULD_NOT_DUPLICATE, { prop: "range", ...n });
        }
        if (!await this.baseHelper.isValidRange(e.rangeType, p)) throw new Te(c.PROP_IS_INVALID, { prop: `range ${e.rangeType}`, type: "transaction range", ...n });
        if (!s.isNaturalNumber(e.timestamp)) throw new Te(c.PROP_IS_INVALID, { prop: `timestamp ${e.timestamp}`, type: "natural number", ...n });
        const h = e.applyBlockHeight;
        if (!s.isPositiveInteger(h)) throw new Te(c.PROP_IS_INVALID, { prop: `applyBlockHeight ${h}`, type: "positive integer", ...n });
        const f = e.effectiveBlockHeight;
        if (!s.isPositiveInteger(f)) throw new Te(c.PROP_IS_INVALID, { prop: `effectiveBlockHeight ${f}`, type: "positive integer", ...n });
        if (f < h) throw new Te(c.PROP_SHOULD_GTE_FIELD, { prop: `effectiveBlockHeight ${f}`, field: h, ...n });
        const { maxApplyAndConfirmedBlockHeightDiff: g } = r, d = h + g;
        if (f > d) throw new Te(c.PROP_SHOULD_LTE_FIELD, { prop: `effectiveBlockHeight ${f}`, field: d, ...n });
        if (this.checkTrsBaseFee(e.fee, n), !e.fromMagic) throw new Te(c.PROP_IS_REQUIRE, { prop: "fromMagic", ...n });
        if (!s.isValidChainMagic(e.fromMagic)) throw new Te(c.PROP_IS_INVALID, { prop: `fromMagic ${e.fromMagic}`, type: "chain magic", ...n });
        if (!e.toMagic) throw new Te(c.PROP_IS_REQUIRE, { prop: "toMagic", ...n });
        if (!s.isValidChainMagic(e.toMagic)) throw new Te(c.PROP_IS_INVALID, { prop: `toMagic ${e.toMagic}`, type: "chain magic", ...n });
        if (e.sourceIP !== void 0 && !s.isIp(e.sourceIP)) throw new Te(c.PROP_IS_INVALID, { prop: `sourceIP ${e.sourceIP}`, type: "ip", ...n });
        if (e.dappid !== void 0 && !s.isValidDAppId(e.dappid)) throw new Te(c.PROP_IS_INVALID, { prop: `dappid ${e.dappid}`, type: "dappid", ...n });
        if (e.lns !== void 0 && !s.isValidLocationName(e.lns, r.chainName)) throw new Te(c.PROP_IS_INVALID, { prop: `lns ${e.lns}`, type: "location name", ...n });
        const y = e.remark;
        if (!y) throw new Te(c.PROP_IS_REQUIRE, { prop: "remark", ...n });
        if (s.getVariableType(y) !== "[object Object]") throw new Te(c.PROP_IS_INVALID, { prop: "remark", ...n });
        for (const _ in y) if (!s.isString(y[_])) throw new Te(c.PROP_IS_INVALID, { prop: "remark", ...n });
      }
      async verifyBaseInfo(e, t = this.configHelper) {
        if (!e) throw new Te(c.PARAM_LOST, { param: "transaction" });
        await this.verifyTransactionBody(e, e.asset, t);
        const r = { target: "transaction" }, { baseHelper: n } = this;
        if (!e.signature) throw new Te(c.PROP_IS_REQUIRE, { prop: "signature", ...r });
        if (!n.isValidSignature(e.signature)) throw new Te(c.PROP_IS_INVALID, { prop: `signature ${e.signature}`, type: "signature", ...r });
        if (e.signSignature && !n.isValidSignature(e.signSignature)) throw new Te(c.PROP_IS_INVALID, { prop: `signSignature ${e.signSignature}`, type: "signature", ...r });
      }
      async verifySignature(e) {
        await this.transactionHelper.verifyTransactionSignature(e);
      }
      verifyTransactionSize(e) {
        this.transactionHelper.verifyTransactionSize(e);
      }
      verifyTransactionBlobSize(e) {
        this.transactionHelper.verifyTransactionBlobSize(e);
      }
      async verify(e, t = this.configHelper) {
        await this.verifyBaseInfo(e, t), this.verifyTransactionSize(e), this.verifyTransactionBlobSize(e), await this.verifySignature(e);
      }
      checkAssetAmount(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        const { baseHelper: n } = this;
        if (!n.isValidAssetNumber(e)) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, type: "asset number", ...r });
        const s = BigInt(0), o = BigInt(e);
        if (s >= o) throw new Te(c.PROP_SHOULD_GT_FIELD, { prop: `${t} ${e}`, field: "0", ...r });
      }
      checkAssetPrealnum(e, t, r) {
        this.checkBaseAssetPrealnum(r, t, e), this.isAssetPrealnumGtZero(e, t, r);
      }
      checkBaseAssetPrealnum(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        const { baseHelper: n } = this;
        if (!n.isValidAssetNumber(e)) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, type: "asset prealnum", ...r });
        const s = BigInt(0), o = BigInt(e);
        if (s > o) throw new Te(c.PROP_SHOULD_GTE_FIELD, { prop: `${t} ${e}`, field: "0", ...r });
      }
      isAssetPrealnumGtZero(e, t, r) {
        if (e === "0") throw new Te(c.PROP_SHOULD_GT_FIELD, { prop: `${t} ${e}`, field: "0", ...r });
      }
      checkTrsBaseFee(e, t) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: "fee", ...t });
        const { baseHelper: r } = this;
        if (!r.isValidAssetNumber(e)) throw new Te(c.PROP_IS_INVALID, { prop: `fee ${e}`, type: "asset number", ...t });
        const n = BigInt(e);
        if (BigInt("0") > n) throw new Te(c.PROP_SHOULD_GTE_FIELD, { prop: `fee ${e}`, field: "0", ...t });
      }
      emptyRangeType(e, t) {
        if (e.rangeType !== 0) throw new Te(c.SHOULD_BE, { to_compare_prop: `rangeType ${e.rangeType}`, to_target: "body", be_compare_prop: "RANGE_TYPE.EMPTY", ...t });
      }
      checkChainName(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        if (!this.baseHelper.isValidChainName(e)) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, type: "chain name", ...r });
      }
      checkChainMagic(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        if (!this.baseHelper.isValidChainMagic(e)) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, type: "chain magic", ...r });
      }
      checkParentAssetType(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        if (!G[e]) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, ...r });
      }
      checkAsset(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        if (!this.baseHelper.isValidAssetType(e)) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, ...r });
      }
      checkDAppId(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        if (!this.baseHelper.isValidDAppId(e)) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, ...r });
      }
      checkLocationName(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        if (!this.baseHelper.isValidLocationName(e)) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, ...r });
      }
      checkEntityFactoryId(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        if (!this.baseHelper.isValidEntityFactoryId(e)) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, ...r });
      }
      checkEntityId(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        if (!this.baseHelper.isValidEntityId(e)) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, ...r });
      }
      checkCertificateId(e, t, r) {
        if (!e) throw new Te(c.PROP_IS_REQUIRE, { prop: t, ...r });
        if (!this.baseHelper.isValidCertificateId(e)) throw new Te(c.PROP_IS_INVALID, { prop: `${t} ${e}`, ...r });
      }
      checkAssetType(e, t, r, n) {
        if (e === G.ASSETS) {
          this.checkAsset(t, r, n);
          return;
        }
        if (e === G.DAPP) {
          this.checkDAppId(t, r, n);
          return;
        }
        if (e === G.LOCATION_NAME) {
          this.checkLocationName(t, r, n);
          return;
        }
        if (e === G.ENTITY) {
          this.checkEntityId(t, r, n);
          return;
        }
        if (e === G.CERTIFICATE) {
          this.checkCertificateId(t, r, n);
          return;
        }
        throw new Te(c.PROP_IS_INVALID, { prop: `parentAssetType ${e}`, ...n });
      }
      async checkTaxInformation(e, t) {
        if (!t) throw new Te(c.PROP_IS_REQUIRE, { prop: "taxInformation", ...e });
        const { taxCollector: r, taxAssetPrealnum: n } = t;
        if (!r) throw new Te(c.PROP_IS_REQUIRE, { prop: "taxInformation.taxCollector", ...e });
        if (!await this.accountBaseHelper.isAddress(r)) throw new Te(c.PROP_IS_INVALID, { prop: `taxInformation.taxCollector ${r}`, ...e });
        if (!n) throw new Te(c.PROP_IS_REQUIRE, { prop: "taxInformation.taxAssetPrealnum", ...e });
        if (!this.baseHelper.isValidAssetPrealnum(n)) throw new Te(c.PROP_IS_INVALID, { prop: `taxInformation.taxAssetPrealnum ${n}`, ...e });
      }
      async applyTransaction(e, t, r = this.configHelper) {
        const n = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
        return $e((s) => {
          s.next = t.emit("fee", { type: "fee", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: n, amount: "-" + e.fee, sourceAmount: e.fee } }), s.next = t.emit("count", { type: "count", transaction: e });
        });
      }
      beginDealTransaction(e, t) {
        return t.emit("beginDealTransaction", { type: "beginDealTransaction", transaction: e, applyInfo: void 0 });
      }
      endDealTransaction(e, t) {
        return t.emit("endDealTransaction", { transactionInBlock: e });
      }
      _applyTransactionEmitAsset(e, t, r, n) {
        return $e((s) => {
          s.next = e.emit("asset", { type: "asset", transaction: t, applyInfo: { address: n.senderId, publicKeyBuffer: n.senderPublicKeyBuffer, assetInfo: n.assetInfo, amount: "-" + r, sourceAmount: r } }), n.recipientId && (s.next = e.emit("asset", { type: "asset", transaction: t, applyInfo: { address: n.recipientId, publicKeyBuffer: n.recipientPublicKeyBuffer, assetInfo: n.assetInfo, amount: r, sourceAmount: r } }));
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        return "0";
      }
    };
    const { ArgumentIllegalException: Hi } = ee("CONTROLLER", "SignatureTransactionFactory");
    let Ih = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (e.recipientId) throw new Hi(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Hi(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Hi(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.storage) throw new Hi(c.SHOULD_NOT_EXIST, { prop: "storage", ...n });
        const o = t.signature;
        if (!o) throw new Hi(c.PARAM_LOST, { param: "signature" });
        const a = { ...n, target: "signatureAsset" }, p = o.publicKey;
        if (!p) throw new Hi(c.PROP_IS_REQUIRE, { prop: "publicKey", ...a });
        if (!s.isValidSecondPublicKey(p)) throw new Hi(c.PROP_IS_INVALID, { prop: `publicKey ${p}`, type: "account second publicKey", ...a });
      }
      init(e, t) {
        return dp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r), n.next = t.emit("setSecondPublicKey", { type: "setSecondPublicKey", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, secondPublicKeyBuffer: e.asset.signature.publicKeyBuffer } });
        });
      }
    };
    Ih = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], Ih);
    const { ArgumentIllegalException: pr } = ee("CONTROLLER", "DAppTransactionFactory");
    let ll = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), !e.recipientId) throw new pr(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new pr(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new pr(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new pr(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const s = e.storage;
        if (s.key !== "dappid") throw new pr(c.SHOULD_BE, { to_compare_prop: `storage.key ${s.key}`, to_target: "storage", be_compare_prop: "dappid", ...n });
        const o = t.dapp;
        if (this.verifyDAppAsset(o, r), s.value !== o.dappid) throw new pr(c.NOT_MATCH, { to_compare_prop: `storage.value ${s.value}`, be_compare_prop: `dappid ${o.dappid}`, to_target: "storage", be_target: "dapp", ...n });
      }
      verifyDAppAsset(e, t = this.configHelper) {
        const { baseHelper: r } = this, n = { target: "body" };
        if (!e) throw new pr(c.PARAM_LOST, { param: "dapp", ...n });
        const s = { ...n, target: "dappAsset" }, { dappid: o, sourceChainMagic: a, sourceChainName: p, type: h, purchaseAsset: f } = e;
        if (!o) throw new pr(c.PROP_IS_REQUIRE, { prop: "dappid", ...s });
        if (!r.isString(o)) throw new pr(c.PROP_IS_INVALID, { prop: `dappid ${o}`, type: "string", ...s });
        if (o.length !== 8) throw new pr(c.PROP_LENGTH_SHOULD_EQ_FIELD, { prop: `dappid ${o}`, fileds: 8, ...s });
        if (!r.isUpperCaseLetterOrNumber(o)) throw new pr(c.PROP_IS_INVALID, { prop: `dappid ${o}`, type: "uppercase or number", ...s });
        if (this.checkChainName(p, "sourceChainName", s), p !== t.chainName) throw new pr(c.SHOULD_BE, { to_compare_prop: `sourceChainName ${p}`, to_target: "body", be_compare_prop: "local chain name", ...n });
        if (this.checkChainMagic(a, "sourceChainMagic", s), a !== t.magic) throw new pr(c.SHOULD_BE, { to_compare_prop: `sourceChainMagic ${a}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (h !== 1 && h !== 0) throw new pr(c.NOT_MATCH, { to_compare_prop: `type ${h}`, be_compare_prop: "dappType", to_target: "dapp", be_target: "DAPP_TYPE", ...s });
        if (h === 0) {
          if (!f) throw new pr(c.PROP_IS_REQUIRE, { prop: "purchaseAsset", ...s });
          if (!r.isValidAssetNumber(f)) throw new pr(c.PROP_IS_INVALID, { prop: "purchaseAsset", type: "asset number", ...s });
          this.checkAssetAmount(f, "purchaseAsset", s);
        } else if (h === 1 && f) throw new pr(c.SHOULD_NOT_EXIST, { prop: "purchaseAsset", ...s });
      }
      init(e, t) {
        return yp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { sourceChainName: s, sourceChainMagic: o, dappid: a, type: p, purchaseAsset: h } = e.asset.dapp;
          n.next = t.emit("issueDAppid", { type: "issueDAppid", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, sourceChainName: s, sourceChainMagic: o, dappid: a, possessorAddress: e.recipientId, type: p, purchaseAsset: h, status: 0 } });
        });
      }
    };
    ll = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], ll);
    const { ArgumentIllegalException: Xs } = ee("CONTROLLER", "DAppPurchasingTransactionFactory");
    let eg = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.dappTransactionFactory = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), !e.recipientId) throw new Xs(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Xs(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Xs(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Xs(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const o = e.storage;
        if (o.key !== "dappid") throw new Xs(c.SHOULD_BE, { to_compare_prop: `storage.key ${o.key}`, to_target: "storage", be_compare_prop: "dappid", ...n });
        const a = t.dappPurchasing;
        if (!a) throw new Xs(c.PARAM_LOST, { param: "dappPurchasing" });
        const p = { ...n, target: "dappPurchasingAsset" }, { dappAsset: h } = a;
        if (this.dappTransactionFactory.verifyDAppAsset(h), o.value !== h.dappid) throw new Xs(c.NOT_MATCH, { to_compare_prop: `storage.value ${o.value}`, be_compare_prop: `dappid ${h.dappid}`, to_target: "storage", be_target: "dapp", ...p });
        if (h.type !== 0) throw new Xs(c.SHOULD_NOT_BE, { to_compare_prop: `type ${h.type}`, to_target: "dappAsset", be_compare_prop: 0, ...p });
      }
      init(e, t) {
        return mp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { chainName: s, magic: o, assetType: a } = r, { purchaseAsset: p } = e.asset.dappPurchasing.dappAsset, h = this.chainAssetInfoHelper.getAssetInfo(s, o, a);
          n.next = this._applyTransactionEmitAsset(t, e, p, { senderId: e.senderId, senderPublicKeyBuffer: e.senderPublicKeyBuffer, recipientId: e.recipientId, assetInfo: h });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, purchaseAsset: n } = e.asset.dappPurchasing.dappAsset;
        return t.magic === r && t.assetType === this.configHelper.assetType && n || "0";
      }
    };
    eg = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, ll])], eg);
    const { ArgumentIllegalException: Rr } = ee("CONTROLLER", "MarkTransactionFactory");
    let tg = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.dappTransactionFactory = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new Rr(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Rr(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Rr(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.dappid) throw new Rr(c.PROP_IS_REQUIRE, { prop: "dappid", ...n });
        if (!e.storage) throw new Rr(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "dappid") throw new Rr(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "dappid", ...n });
        const p = t.mark;
        if (!p) throw new Rr(c.PARAM_LOST, { param: "mark" });
        const h = { ...n, target: "markAsset" }, f = p.dapp;
        if (this.dappTransactionFactory.verifyDAppAsset(f), e.dappid !== f.dappid) throw new Rr(c.NOT_MATCH, { to_compare_prop: `dappid ${a.value}`, be_compare_prop: `dappid ${f.dappid}`, to_target: "body", be_target: "mark", ...n });
        if (a.value !== f.dappid) throw new Rr(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `dappid ${f.dappid}`, to_target: "storage", be_target: "mark", ...n });
        const g = p.content;
        if (!g) throw new Rr(c.PROP_IS_REQUIRE, { prop: "content", ...h });
        if (!s.isString(g)) throw new Rr(c.PROP_IS_INVALID, { prop: `content ${g}`, type: "string", ...h });
        if (g.length > 1024) throw new Rr(c.OVER_LENGTH, { prop: `content ${g}`, limit: 1024, ...h });
        const d = p.action;
        if (!d) throw new Rr(c.PROP_IS_REQUIRE, { prop: "action", ...h });
        if (!s.isString(d)) throw new Rr(c.PROP_IS_INVALID, { prop: `action ${d}`, type: "string", ...h });
        const y = d.length;
        if (y < 1 || y > 10) throw new Rr(c.NOT_IN_EXPECTED_RANGE, { prop: `action ${d}`, min: 1, max: 10, ...h });
      }
      init(e, t) {
        return _p.fromObject({ ...e, asset: t });
      }
    };
    tg = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, ll])], tg);
    const { ArgumentIllegalException: Ar } = ee("CONTROLLER", "IssueAssetTransactionFactory");
    let rg = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this, o = e.recipientId;
        if (!e.recipientId) throw new Ar(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.senderId === o) throw new Ar(c.SHOULD_NOT_BE, { to_compare_prop: `senderId ${e.senderId}`, to_target: "body", be_compare_prop: `recipientId ${o}`, ...n });
        if (e.fromMagic !== r.magic) throw new Ar(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Ar(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Ar(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "assetType") throw new Ar(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "assetType", ...n });
        const p = t.issueAsset;
        if (!p) throw new Ar(c.PARAM_LOST, { param: "issueAsset" });
        const h = { ...n, target: "issueAssetAsset" }, { sourceChainName: f, sourceChainMagic: g, assetType: d, expectedIssuedAssets: y } = p;
        if (this.checkChainName(f, "sourceChainName", h), f !== r.chainName) throw new Ar(c.SHOULD_BE, { to_compare_prop: `sourceChainName ${f}`, to_target: "body", be_compare_prop: "local chain name", ...n });
        if (this.checkChainMagic(g, "sourceChainMagic", h), g !== r.magic) throw new Ar(c.SHOULD_BE, { to_compare_prop: `sourceChainMagic ${g}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!d) throw new Ar(c.PROP_IS_REQUIRE, { prop: "assetType", ...h });
        if (!s.isUpperCaseLetter(d)) throw new Ar(c.PROP_IS_INVALID, { prop: `assetType ${d}`, type: "uppercase", ...h });
        const _ = d.length;
        if (_ < 3 || _ > 10) throw new Ar(c.NOT_IN_EXPECTED_RANGE, { prop: `assetType ${d}`, type: "string length", min: 3, max: 10, ...h });
        if (a.value !== d) throw new Ar(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `assetType ${d}`, to_target: "storage", be_target: "issueAsset", ...n });
        if (!y) throw new Ar(c.PROP_IS_REQUIRE, { prop: "expectedIssuedAssets", ...h });
        if (!s.isValidAssetNumber(y)) throw new Ar(c.PROP_IS_INVALID, { prop: `expectedIssuedAssets ${y}`, type: "asset number", ...h });
        if (BigInt(y) < BigInt(0)) throw new Ar(c.PROP_SHOULD_GT_FIELD, { prop: "expectedIssuedAssets", field: "0", ...h });
      }
      init(e, t) {
        return Ap.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, recipientId: o, senderPublicKeyBuffer: a } = e, { sourceChainName: p, sourceChainMagic: h, assetType: f, expectedIssuedAssets: g } = e.asset.issueAsset;
          n.next = t.emit("frozenAccount", { type: "frozenAccount", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, accountStatus: 16 } });
          const d = this.chainAssetInfoHelper.getAssetInfo(p, h, f);
          n.next = t.emit("issueAsset", { type: "issueAsset", transaction: e, applyInfo: { address: s, genesisAddress: o, publicKeyBuffer: a, sourceChainName: p, assetInfo: d, amount: g, sourceAmount: g } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, expectedIssuedAssets: s } = e.asset.issueAsset;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    rg = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], rg);
    const { ArgumentIllegalException: Er } = ee("CONTROLLER", "IncreaseAssetTransactionFactory");
    let ng = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new Er(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Er(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Er(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Er(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const o = e.storage;
        if (o.key !== "assetType") throw new Er(c.SHOULD_BE, { to_compare_prop: `storage.key ${o.key}`, to_target: "storage", be_compare_prop: "assetType", ...n });
        const a = t.increaseAsset;
        if (!a) throw new Er(c.PARAM_LOST, { param: "increaseAsset" });
        const p = { ...n, target: "increaseAssetAsset" }, { applyAddress: h, sourceChainName: f, sourceChainMagic: g, assetType: d, increasedAssetPrealnum: y, frozenMainAssetPrealnum: _ } = a;
        if (!await this.accountBaseHelper.isAddress(h)) throw new Er(c.PROP_IS_INVALID, { prop: `applyAddress ${h}`, type: "account address", ...n, target: "increaseAsset" });
        if (this.checkChainName(f, "sourceChainName", p), f !== r.chainName) throw new Er(c.SHOULD_BE, { to_compare_prop: `sourceChainName ${f}`, to_target: "body", be_compare_prop: "local chain name", ...n });
        if (this.checkChainMagic(g, "sourceChainMagic", p), g !== r.magic) throw new Er(c.SHOULD_BE, { to_compare_prop: `sourceChainMagic ${g}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (this.checkAssetType(G.ASSETS, d, "assetType", p), d === r.assetType) throw new Er(c.SHOULD_NOT_BE, { to_compare_prop: `assetType ${d}`, to_target: "body", be_compare_prop: "local chain assetType", ...n });
        if (o.value !== d) throw new Er(c.NOT_MATCH, { to_compare_prop: `storage.value ${o.value}`, be_compare_prop: `assetType ${d}`, to_target: "storage", be_target: "increaseAsset", ...n });
        if (!y) throw new Er(c.PROP_IS_REQUIRE, { prop: "increasedAssetPrealnum", ...p });
        if (!s.isValidAssetNumber(y)) throw new Er(c.PROP_IS_INVALID, { prop: `increasedAssetPrealnum ${y}`, type: "asset number", ...p });
        if (BigInt(y) <= BigInt(0)) throw new Er(c.PROP_SHOULD_GT_FIELD, { prop: "increasedAssetPrealnum", field: "0", ...p });
        if (!_) throw new Er(c.PROP_IS_REQUIRE, { prop: "frozenMainAssetPrealnum", ...p });
        if (!s.isValidAssetNumber(_)) throw new Er(c.PROP_IS_INVALID, { prop: `frozenMainAssetPrealnum ${_}`, type: "asset number", ...p });
      }
      init(e, t) {
        return Ep.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, recipientId: o, senderPublicKeyBuffer: a } = e, { applyAddress: p, sourceChainName: h, sourceChainMagic: f, assetType: g, increasedAssetPrealnum: d, frozenMainAssetPrealnum: y } = e.asset.increaseAsset, _ = this.chainAssetInfoHelper.getAssetInfo(h, f, g);
          n.next = t.emit("increaseAsset", { type: "increaseAsset", transaction: e, applyInfo: { address: s, recipientId: o, applyAddress: p, publicKeyBuffer: a, sourceChainName: h, assetInfo: _, amount: d, sourceAmount: d, frozenMainAssetPrealnum: y } });
          const I = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
          n.next = this._applyTransactionEmitAsset(t, e, y, { senderId: e.senderId, senderPublicKeyBuffer: e.senderPublicKeyBuffer, recipientId: p, assetInfo: I });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, increasedAssetPrealnum: s } = e.asset.increaseAsset;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    ng = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], ng);
    const { ArgumentIllegalException: Uo } = ee("CONTROLLER", "TransferTransactionFactory");
    let Th = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async commonVerifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const s = e.recipientId;
        if (!s) throw new Uo(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.senderId === s) throw new Uo(c.SHOULD_NOT_BE, { to_compare_prop: `senderId ${e.senderId}`, to_target: "body", be_compare_prop: `recipientId ${s}`, ...n });
        if (e.fromMagic !== r.magic) throw new Uo(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Uo(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Uo(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const o = e.storage;
        if (o.key !== "assetType") throw new Uo(c.SHOULD_BE, { to_compare_prop: `storage.key ${o.key}`, to_target: "storage", be_compare_prop: "assetType", ...n });
        return o;
      }
    };
    Th = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], Th);
    const { ArgumentIllegalException: Jm } = ee("CONTROLLER", "TransferAssetTransactionFactory");
    let Sh = class extends Th {
      async verifyTransactionBody(e, t, r = this.configHelper) {
        const n = { target: "transferAssetAsset" }, s = await super.commonVerifyTransactionBody(e, t, r), o = t.transferAsset;
        if (!o) throw new Jm(c.PARAM_LOST, { param: "transferAsset" });
        const { sourceChainMagic: a, sourceChainName: p, assetType: h, amount: f } = o;
        if (a === this.configHelper.magic && (this.checkChainName(p, "sourceChainName", n), this.checkChainMagic(a, "sourceChainMagic", n), this.checkAsset(h, "assetType", n)), s.value !== h) throw new Jm(c.NOT_MATCH, { to_compare_prop: `storage.value ${s.value}`, be_compare_prop: `assetType ${h}`, to_target: "storage", be_target: "transferAsset" });
        this.checkAssetAmount(f, "amount", n);
      }
      init(e, t) {
        return Ip.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { amount: s, assetType: o, sourceChainMagic: a, sourceChainName: p } = e.asset.transferAsset, h = this.chainAssetInfoHelper.getAssetInfo(p, a, o);
          n.next = this._applyTransactionEmitAsset(t, e, s, { senderId: e.senderId, senderPublicKeyBuffer: e.senderPublicKeyBuffer, recipientId: e.recipientId, assetInfo: h });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, amount: s } = e.asset.transferAsset;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    Sh = l([J()], Sh);
    const { ArgumentIllegalException: Vo } = ee("CONTROLLER", "TransferAnyTransactionFactory");
    let wh = class extends Th {
      async verifyTransactionBody(e, t, r = this.configHelper) {
        const n = await super.commonVerifyTransactionBody(e, t, r), s = { target: "transferAnyAsset" };
        if (n.key !== "assetType") throw new Vo(c.SHOULD_BE, { to_compare_prop: `storage.key ${n.key}`, to_target: "storage", be_compare_prop: "assetType", ...s });
        const o = t.transferAny;
        if (!o) throw new Vo(c.PARAM_LOST, { param: "transferAny" });
        const { sourceChainMagic: a, sourceChainName: p, parentAssetType: h, assetType: f, taxInformation: g } = o;
        if (a === this.configHelper.magic && (this.checkChainName(p, "sourceChainName", s), this.checkChainMagic(a, "sourceChainMagic", s), this.checkAssetType(h, f, "assetType", s)), n.value !== f) throw new Vo(c.NOT_MATCH, { to_compare_prop: `storage.value ${n.value}`, be_compare_prop: `assetType ${f}`, to_target: "storage", be_target: "transferAny", ...s });
        if (this.checkAssetAmount(o.amount, "amount", s), h !== G.ASSETS && o.amount !== "1") throw new Vo(c.SHOULD_BE, { to_compare_prop: `amount ${o.amount}`, to_target: "transferAny", be_compare_prop: "1" });
        if (h === G.ENTITY) await this.checkTaxInformation(s, g);
        else if (g) throw new Vo(c.SHOULD_NOT_EXIST, { prop: "taxInformation", ...s });
      }
      init(e, t) {
        return Hp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, senderPublicKeyBuffer: o, recipientId: a, asset: p } = e, { amount: h, assetType: f, sourceChainMagic: g, sourceChainName: d, parentAssetType: y, taxInformation: _ } = p.transferAny;
          if (y === G.ASSETS) {
            const I = this.chainAssetInfoHelper.getAssetInfo(d, g, f);
            n.next = this._applyTransactionEmitAsset(t, e, h, { senderId: s, senderPublicKeyBuffer: o, recipientId: a, assetInfo: I });
          } else if (y === G.DAPP) n.next = t.emit("changeDAppidPossessor", { type: "changeDAppidPossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, possessorAddress: a, sourceChainName: d, sourceChainMagic: g, dappid: f } });
          else if (y === G.LOCATION_NAME) n.next = t.emit("changeLocationNamePossessor", { type: "changeLocationNamePossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, possessorAddress: a, sourceChainName: d, sourceChainMagic: g, name: f } });
          else if (y === G.ENTITY && _) {
            n.next = t.emit("changeEntityPossessor", { type: "changeEntityPossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, possessorAddress: a, sourceChainName: d, sourceChainMagic: g, entityId: f } }), n.next = t.emit("payTax", { type: "payTax", transaction: e, applyInfo: { sourceChainName: d, sourceChainMagic: g, parentAssetType: y, assetType: f, taxInformation: _.toJSON() } });
            const I = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
            n.next = this._applyTransactionEmitAsset(t, e, _.taxAssetPrealnum, { senderId: s, senderPublicKeyBuffer: o, recipientId: _.taxCollector, assetInfo: I });
          } else if (y === G.CERTIFICATE) n.next = t.emit("changeCertificatePossessor", { type: "changeCertificatePossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, possessorAddress: a, sourceChainName: d, sourceChainMagic: g, certificateId: f } });
          else throw new Vo(c.PROP_IS_INVALID, { prop: `parentAssetType ${y}`, target: "transaction.asset.transferAsset" });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, amount: s } = e.asset.transferAny;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    wh = l([J()], wh);
    const { ArgumentIllegalException: On } = ee("CONTROLLER", "DestroyAssetTransactionFactory");
    let bh = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const s = e.recipientId;
        if (!s) throw new On(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.senderId === s) throw new On(c.SHOULD_NOT_BE, { to_compare_prop: `senderId ${e.senderId}`, to_target: "body", be_compare_prop: `recipientId ${s}`, ...n });
        if (e.fromMagic !== r.magic) throw new On(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new On(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new On(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const o = e.storage;
        if (o.key !== "assetType") throw new On(c.SHOULD_BE, { to_compare_prop: `storage.key ${o.key}`, to_target: "storage", be_compare_prop: "assetType", ...n });
        const a = t.destroyAsset;
        if (!a) throw new On(c.PARAM_LOST, { param: "destroyAsset" });
        const p = { ...n, target: "destroyAssetAsset" }, { sourceChainMagic: h, sourceChainName: f, assetType: g } = a;
        if (f !== r.chainName) throw new On(c.SHOULD_BE, { to_compare_prop: "sourceChainName", to_target: "body", be_compare_prop: "local chain name", ...p });
        if (h !== r.magic) throw new On(c.SHOULD_BE, { to_compare_prop: "sourceChainMagic", to_target: "body", be_compare_prop: "local chain magic", ...p });
        if (this.checkAsset(g, "assetType", p), g === r.assetType) throw new On(c.SHOULD_NOT_BE, { to_compare_prop: "assetType", to_target: "destroyAsset", be_compare_prop: r.assetType, ...p });
        if (o.value !== g) throw new On(c.NOT_MATCH, { to_compare_prop: `storage.value ${o.value}`, be_compare_prop: `assetType ${g}`, to_target: "storage", be_target: "destroyAsset", ...n });
        this.checkAssetAmount(a.amount, "amount", p);
      }
      init(e, t) {
        return Tp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, senderPublicKeyBuffer: o, recipientId: a } = e, { amount: p, assetType: h, sourceChainMagic: f, sourceChainName: g } = e.asset.destroyAsset, d = this.chainAssetInfoHelper.getAssetInfo(g, f, h);
          n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, assetInfo: d, amount: `-${p}`, sourceAmount: p } }), n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: a, publicKeyBuffer: o, assetInfo: d, amount: p, sourceAmount: p } }), n.next = t.emit("destroyAsset", { type: "destroyAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: e.senderPublicKeyBuffer, assetsApplyAddress: a, assetInfo: d, amount: p, sourceAmount: p } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, amount: s } = e.asset.destroyAsset;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    bh = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], bh);
    const { ArgumentIllegalException: Kr } = ee("CONTROLLER", "ToExchangeAssetTransactionFactory");
    let Nh = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (e.recipientId) throw new Kr(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Kr(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Kr(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        const s = t.toExchangeAsset;
        if (this.verifyToExchangeAsset(s, r), s.toExchangeNumber === "0") throw new Kr(c.PROP_SHOULD_GT_FIELD, { prop: "toExchangeNumber", field: "0", target: "toExchangeAsset" });
        if (e.storage) throw new Kr(c.SHOULD_NOT_EXIST, { prop: "storage", ...n });
      }
      verifyToExchangeAsset(e, t = this.configHelper) {
        const { baseHelper: r } = this;
        if (!e) throw new Kr(c.PARAM_LOST, { param: "toExchangeAsset" });
        const n = { target: "toExchangeAssetAsset" }, s = e.cipherPublicKeys, o = new Set(s);
        if (s.length !== o.size) throw new Kr(c.SHOULD_NOT_DUPLICATE, { prop: "cipherPublicKeys", ...n });
        if (!r.isValidCipherPublicKeys(s)) throw new Kr(c.PROP_IS_INVALID, { prop: "cipherPublicKeys", ...n });
        if (e.toExchangeSource === this.configHelper.magic && (this.checkChainName(e.toExchangeChainName, "toExchangeChainName", n), this.checkChainMagic(e.toExchangeSource, "toExchangeSource", n), this.checkAsset(e.toExchangeAsset, "toExchangeAsset", n)), e.beExchangeSource === this.configHelper.magic && (this.checkChainName(e.beExchangeChainName, "beExchangeChainName", n), this.checkChainMagic(e.beExchangeSource, "beExchangeSource", n), this.checkAsset(e.beExchangeAsset, "beExchangeAsset", n)), !e.toExchangeNumber) throw new Kr(c.PROP_IS_REQUIRE, { prop: "toExchangeNumber", ...n });
        if (!r.isValidAssetNumber(e.toExchangeNumber)) throw new Kr(c.PROP_IS_INVALID, { prop: "toExchangeNumber", type: "asset number", ...n });
        if (e.toExchangeNumber === "0") throw new Kr(c.PROP_SHOULD_GT_FIELD, { prop: "toExchangeNumber", field: "0", ...n });
        if (!r.isValidRate(e.exchangeRate)) throw new Kr(c.PROP_IS_INVALID, { prop: `exchangeRate ${JSON.stringify(e.exchangeRate)}`, type: "rate", ...n });
        if (e.toExchangeAsset === e.beExchangeAsset) throw new Kr(c.SHOULD_NOT_BE, { to_compare_prop: `toExchangeAsset ${e.toExchangeAsset}`, to_target: "toExchangeAsset", be_compare_prop: e.beExchangeAsset });
      }
      init(e, t) {
        return la.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { toExchangeChainName: s, toExchangeSource: o, toExchangeAsset: a, toExchangeNumber: p } = e.asset.toExchangeAsset, h = this.chainAssetInfoHelper.getAssetInfo(s, o, a);
          n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: h, amount: `-${p}`, sourceAmount: p, maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), frozenId: e.signature, frozenReason: ht.EXCHANGE } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { magic: r, assetType: n } = t, { toExchangeSource: s, toExchangeAsset: o, toExchangeNumber: a } = e.asset.toExchangeAsset;
        return r === s && n === o ? a : "0";
      }
    };
    Nh = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], Nh);
    const { ArgumentIllegalException: Jt } = ee("CONTROLLER", "BeExchangeAssetTransactionFactory");
    let sg = class extends Ge {
      constructor(e, t, r, n, s, o, a) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.jsbiHelper = o, this.toExchangeAssetTransactionFactory = a;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s, jsbiHelper: o } = this;
        if (!e.recipientId) throw new Jt(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Jt(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Jt(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Jt(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const p = e.storage;
        if (p.key !== "transactionSignature") throw new Jt(c.SHOULD_BE, { to_compare_prop: `storage.key ${p.key}`, to_target: "storage", be_compare_prop: "transactionSignature", ...n });
        const h = t.beExchangeAsset;
        if (!h) throw new Jt(c.PARAM_LOST, { param: "beExchangeAsset" });
        const f = { ...n, target: "beExchangeAsset" }, { transactionSignature: g } = h;
        if (!g) throw new Jt(c.PROP_IS_REQUIRE, { prop: "transactionSignature", ...f });
        if (!s.isValidSignature(g)) throw new Jt(c.PROP_IS_INVALID, { prop: `transactionSignature ${g}`, type: "transaction signature", ...f });
        if (p.value !== g) throw new Jt(c.NOT_MATCH, { to_compare_prop: `storage.value ${p.value}`, be_compare_prop: `transactionSignature ${g}`, to_target: "storage", be_target: "beExchangeAsset", ...n });
        const { toExchangeNumber: d, beExchangeNumber: y } = h;
        if (!d) throw new Jt(c.PROP_IS_REQUIRE, { prop: "toExchangeNumber", ...f });
        if (!s.isValidAssetNumber(d)) throw new Jt(c.PROP_IS_INVALID, { prop: "toExchangeNumber", type: "asset number", ...f });
        if (!y) throw new Jt(c.PROP_IS_REQUIRE, { prop: "beExchangeNumber", ...f });
        if (!s.isValidAssetNumber(y)) throw new Jt(c.PROP_IS_INVALID, { prop: "beExchangeNumber", type: "asset number", ...f });
        const { exchangeAsset: _, ciphertextSignature: I } = h;
        if (this.toExchangeAssetTransactionFactory.verifyToExchangeAsset(_), BigInt(d) > BigInt(_.toExchangeNumber)) throw new Jt(c.PROP_SHOULD_LTE_FIELD, { prop: `toExchangeNumber ${d}`, field: _.toExchangeNumber, ...f });
        if (!s.isValidRate(_.exchangeRate)) throw new Jt(c.PROP_IS_INVALID, { prop: `exchangeRate ${_.exchangeRate}`, type: "rate", ...f });
        const { cipherPublicKeys: S } = _;
        if (S.length > 0) {
          if (!I) throw new Jt(c.NOT_EXIST, { prop: `ciphertextSignature ${I}`, ...f });
          if (!s.isValidAccountSignature(I)) throw new Jt(c.PROP_IS_INVALID, { prop: `ciphertextSignature ${I}`, ...f });
          const { signature: w, publicKey: N } = I;
          if (!S.includes(N)) throw new Jt(c.NOT_MATCH, { to_compare_prop: `publicKey ${N}`, be_compare_prop: "cipherPublicKeys", to_target: "ciphertextSignature", be_target: "cipherPublicKeys", ...f });
          if (!await this.transactionHelper.verifyCiphertextSignature({ secretPublicKey: _e(N), ciphertextSignatureBuffer: _e(w), transactionSignatureBuffer: _e(g), senderId: e.senderId })) throw new Jt(c.PROP_IS_INVALID, { prop: `ciphertextSignature ${w}`, type: "signature", ...f });
        } else if (I) throw new Jt(c.SHOULD_NOT_EXIST, { prop: `ciphertextSignature ${I}`, ...f });
      }
      init(e, t) {
        return xp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { exchangeAsset: s, toExchangeNumber: o, beExchangeNumber: a } = e.asset.beExchangeAsset, { toExchangeChainName: p, toExchangeSource: h, toExchangeAsset: f, beExchangeChainName: g, beExchangeSource: d, beExchangeAsset: y } = s, _ = this.chainAssetInfoHelper.getAssetInfo(g, d, y);
          n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: _, amount: `-${a}`, sourceAmount: a } });
          const I = e.recipientId;
          n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: I, assetInfo: _, amount: a, sourceAmount: a } });
          const S = this.chainAssetInfoHelper.getAssetInfo(p, h, f);
          n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: S, amount: o, sourceAmount: o, recipientId: I, frozenId: e.asset.beExchangeAsset.transactionSignature, frozenReason: ht.EXCHANGE } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { magic: r, assetType: n } = t, { exchangeAsset: s, toExchangeNumber: o, beExchangeNumber: a } = e.asset.beExchangeAsset, { toExchangeSource: p, beExchangeSource: h, toExchangeAsset: f, beExchangeAsset: g } = s;
        return r === p && n === f ? o : r === h && n === g ? a : "0";
      }
    };
    sg = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, xt, Nh])], sg);
    const { ArgumentIllegalException: Go } = ee("CONTROLLER", "GiftTransactionFactory");
    let xh = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.jsbiHelper = o;
      }
      async commonVerifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (e.recipientId) throw new Go(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Go(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Go(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Go(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const s = e.storage;
        if (s.key !== "assetType") throw new Go(c.SHOULD_BE, { to_compare_prop: `storage.key ${s.key}`, to_target: "storage", be_compare_prop: "assetType", ...n });
        return s;
      }
      checkTransactionFee(e, t, r = this.configHelper) {
        const { maxTransactionSize: n, minTransactionFeePerByte: s } = r, o = n * (t + 1), a = { numerator: BigInt(e), denominator: o };
        if (this.jsbiHelper.compareFraction(a, s) < 0) {
          const h = this.jsbiHelper.multiplyCeilFraction(a.denominator, s).toString();
          throw new Go(c.TRANSACTION_FEE_NOT_ENOUGH, { errorId: Ce.TRANSACTION_FEE_NOT_ENOUGH, minFee: h.toString(), target: "body" });
        }
      }
    };
    xh = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, xt])], xh);
    const { ArgumentIllegalException: qn } = ee("CONTROLLER", "GiftAssetTransactionFactory");
    let Oh = class extends xh {
      async verifyTransactionBody(e, t, r = this.configHelper) {
        const n = await this.commonVerifyTransactionBody(e, t, r), s = t.giftAsset;
        if (this.verifyGiftAsset(s, r), s.giftDistributionRule === 2 && e.rangeType !== 1) throw new qn(c.SHOULD_BE, { to_compare_prop: `rangeType ${e.rangeType}`, to_target: "body", be_compare_prop: 1 });
        if (s.beginUnfrozenBlockHeight && s.beginUnfrozenBlockHeight >= e.effectiveBlockHeight) throw new qn(c.PROP_SHOULD_LT_FIELD, { prop: `beginUnfrozenBlockHeight ${s.beginUnfrozenBlockHeight}`, field: e.effectiveBlockHeight, target: "giftAsset" });
        if (n.value !== s.assetType) throw new qn(c.NOT_MATCH, { to_compare_prop: `storage.value ${n.value}`, be_compare_prop: `assetType ${s.assetType}`, to_target: "storage", be_target: "giftAsset" });
        this.checkTransactionFee(e.fee, s.totalGrabableTimes, r);
      }
      verifyGiftAsset(e, t = this.configHelper) {
        const { baseHelper: r } = this;
        if (!e) throw new qn(c.PARAM_LOST, { param: "giftAsset" });
        const n = { target: "giftAssetAsset" }, s = e.cipherPublicKeys, o = new Set(s);
        if (s.length !== o.size) throw new qn(c.SHOULD_NOT_DUPLICATE, { prop: "cipherPublicKeys", ...n });
        if (!r.isValidCipherPublicKeys(s)) throw new qn(c.PROP_IS_INVALID, { prop: "cipherPublicKeys", type: "cipher publicKeys", ...n });
        const { sourceChainMagic: a, sourceChainName: p, assetType: h, amount: f, giftDistributionRule: g, totalGrabableTimes: d, beginUnfrozenBlockHeight: y } = e;
        if (a === this.configHelper.magic && (this.checkChainName(p, "sourceChainName", n), this.checkChainMagic(a, "sourceChainMagic", n), this.checkAsset(h, "assetType", n)), !r.isPositiveInteger(d)) throw new qn(c.PROP_IS_INVALID, { prop: `totalGrabableTimes ${d}`, type: "positive integer", ...n });
        if (d > t.maxGrabTimesOfGiftAsset) throw new qn(c.PROP_SHOULD_LTE_FIELD, { prop: `totalGrabableTimes ${d}`, field: t.maxGrabTimesOfGiftAsset, ...n });
        if (y !== void 0 && !r.isPositiveInteger(y)) throw new qn(c.PROP_IS_INVALID, { prop: `beginUnfrozenBlockHeight ${y}`, type: "positive integer", ...n });
        if (g !== 1 && g !== 0 && g !== 2) throw new qn(c.PROP_IS_INVALID, { prop: `giftDistributionRule ${g}`, type: "enum of GIFT_DISTRIBUTION_RULE", ...n });
        this.checkAssetAmount(f, "amount", n);
      }
      init(e, t) {
        return Ki.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { chainAssetInfoHelper: s } = this, { amount: o, assetType: a, sourceChainMagic: p, sourceChainName: h, totalGrabableTimes: f } = e.asset.giftAsset, g = s.getAssetInfo(h, p, a), d = this.transactionHelper.getTransactionMinEffectiveHeight(e), y = this.transactionHelper.getTransactionMaxEffectiveHeight(e);
          n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: g, amount: `-${o}`, sourceAmount: o, minEffectiveHeight: d, maxEffectiveHeight: y, totalUnfrozenTimes: f, frozenId: e.signature, frozenReason: ht.GIFT } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, amount: s } = e.asset.giftAsset;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    Oh = l([J()], Oh);
    const { ArgumentIllegalException: Ir } = ee("CONTROLLER", "GiftAnyTransactionFactory");
    let hl = class extends xh {
      async verifyTransactionBody(e, t, r = this.configHelper) {
        const n = await this.commonVerifyTransactionBody(e, t, r), s = t.giftAny;
        if (await this.verifyGiftAny(s, r), s.giftDistributionRule === 2 && e.rangeType !== 1) throw new Ir(c.SHOULD_BE, { to_compare_prop: `rangeType ${e.rangeType}`, to_target: "body", be_compare_prop: 1 });
        if (s.beginUnfrozenBlockHeight && s.beginUnfrozenBlockHeight >= e.effectiveBlockHeight) throw new Ir(c.PROP_SHOULD_LT_FIELD, { prop: `beginUnfrozenBlockHeight ${s.beginUnfrozenBlockHeight}`, field: e.effectiveBlockHeight, target: "giftAsset" });
        if (n.value !== s.assetType) throw new Ir(c.NOT_MATCH, { to_compare_prop: `storage.value ${n.value}`, be_compare_prop: `assetType ${s.assetType}`, to_target: "storage", be_target: "giftAsset" });
        this.checkTransactionFee(e.fee, s.totalGrabableTimes, r);
      }
      async verifyGiftAny(e, t = this.configHelper) {
        const { baseHelper: r } = this;
        if (!e) throw new Ir(c.PARAM_LOST, { param: "giftAny" });
        const n = { target: "giftAnyAsset" }, s = e.cipherPublicKeys, o = new Set(s);
        if (s.length !== o.size) throw new Ir(c.SHOULD_NOT_DUPLICATE, { prop: "cipherPublicKeys", ...n });
        if (!r.isValidCipherPublicKeys(e.cipherPublicKeys)) throw new Ir(c.PROP_IS_INVALID, { prop: "cipherPublicKeys", ...n });
        const { sourceChainMagic: a, sourceChainName: p, parentAssetType: h, assetType: f, amount: g, giftDistributionRule: d, totalGrabableTimes: y, beginUnfrozenBlockHeight: _, taxInformation: I } = e;
        if (a === this.configHelper.magic && (this.checkChainName(p, "sourceChainName", n), this.checkChainMagic(a, "sourceChainMagic", n), this.checkAssetType(h, f, "assetType", n)), !r.isPositiveInteger(y)) throw new Ir(c.PROP_IS_INVALID, { prop: `totalGrabableTimes ${y}`, type: "positive integer", ...n });
        if (y > t.maxGrabTimesOfGiftAsset) throw new Ir(c.PROP_SHOULD_LTE_FIELD, { prop: `totalGrabableTimes ${y}`, field: t.maxGrabTimesOfGiftAsset, ...n });
        if (_ !== void 0 && !r.isPositiveInteger(_)) throw new Ir(c.PROP_IS_INVALID, { prop: `beginUnfrozenBlockHeight ${e.beginUnfrozenBlockHeight}`, type: "positive integer", ...n });
        if (this.checkAssetAmount(g, "amount", n), h === G.ASSETS) {
          if (d === void 0) throw new Ir(c.PROP_IS_REQUIRE, { prop: "giftDistributionRule", ...n });
          if (d !== 1 && d !== 0 && d !== 2) throw new Ir(c.PROP_IS_INVALID, { prop: `giftDistributionRule ${d}`, type: "enum of GIFT_DISTRIBUTION_RULE", ...n });
        } else {
          if (y !== 1) throw new Ir(c.SHOULD_BE, { to_compare_prop: `totalGrabableTimes ${y}`, to_target: "giftAny", be_compare_prop: 1 });
          if (g !== "1") throw new Ir(c.SHOULD_BE, { to_compare_prop: `amount ${g}`, to_target: "giftAny", be_compare_prop: "1" });
          if (d !== void 0) throw new Ir(c.SHOULD_NOT_EXIST, { prop: "giftDistributionRule", target: "giftAny" });
        }
        if (h === G.ENTITY) await this.checkTaxInformation(n, I);
        else if (I) throw new Ir(c.SHOULD_NOT_EXIST, { prop: "taxInformation", ...n });
      }
      init(e, t) {
        return Yi.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { chainAssetInfoHelper: s } = this, { senderId: o, senderPublicKeyBuffer: a, signature: p, asset: h } = e, { taxInformation: f, amount: g, assetType: d, parentAssetType: y, sourceChainMagic: _, sourceChainName: I, totalGrabableTimes: S } = h.giftAny, w = this.transactionHelper.getTransactionMinEffectiveHeight(e), N = this.transactionHelper.getTransactionMaxEffectiveHeight(e);
          if (y === G.ASSETS) {
            const B = s.getAssetInfo(I, _, d);
            n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: o, publicKeyBuffer: a, assetInfo: B, amount: `-${g}`, sourceAmount: g, minEffectiveHeight: w, maxEffectiveHeight: N, totalUnfrozenTimes: S, frozenId: p, frozenReason: ht.GIFT } });
          } else if (y === G.DAPP) n.next = t.emit("frozenDAppid", { type: "frozenDAppid", transaction: e, applyInfo: { address: o, sourceChainName: I, sourceChainMagic: _, dappid: d, minEffectiveHeight: w, maxEffectiveHeight: N, status: 17, frozenId: p } });
          else if (y === G.LOCATION_NAME) n.next = t.emit("frozenLocationName", { type: "frozenLocationName", transaction: e, applyInfo: { address: o, sourceChainName: I, sourceChainMagic: _, name: d, minEffectiveHeight: w, maxEffectiveHeight: N, status: 17, frozenId: p } });
          else if (y === G.ENTITY && f) {
            n.next = t.emit("frozenEntity", { type: "frozenEntity", transaction: e, applyInfo: { address: o, sourceChainName: I, sourceChainMagic: _, entityId: d, minEffectiveHeight: w, maxEffectiveHeight: N, status: 17, frozenId: p } }), n.next = t.emit("payTax", { type: "payTax", transaction: e, applyInfo: { sourceChainName: I, sourceChainMagic: _, parentAssetType: y, assetType: d, taxInformation: f.toJSON() } });
            const { taxAssetPrealnum: B } = f;
            if (B !== "0") {
              const O = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
              n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: o, publicKeyBuffer: a, assetInfo: O, amount: `-${B}`, sourceAmount: B, maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), frozenId: p, frozenReason: ht.GIFT } });
            }
          } else if (y === G.CERTIFICATE) n.next = t.emit("frozenCertificate", { type: "frozenCertificate", transaction: e, applyInfo: { address: o, sourceChainName: I, sourceChainMagic: _, certificateId: d, minEffectiveHeight: w, maxEffectiveHeight: N, status: 17, frozenId: p } });
          else throw new Ir(c.PROP_IS_INVALID, { prop: `parentAssetType ${y}`, target: "transaction.asset.giftAny" });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, amount: s } = e.asset.giftAny;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    hl = l([J()], hl);
    const { ArgumentIllegalException: Tr } = ee("CONTROLLER", "GrabAssetTransactionFactory");
    let ig = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.__giftAssetTransactionFactory = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new Tr(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Tr(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Tr(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Tr(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "transactionSignature") throw new Tr(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "transactionSignature", ...n });
        const p = t.grabAsset;
        if (!p) throw new Tr(c.PARAM_LOST, { param: "grabAsset" });
        const h = { ...n, target: "grabAssetAsset" }, { blockSignature: f, transactionSignature: g } = p;
        if (!f) throw new Tr(c.PROP_IS_REQUIRE, { prop: "blockSignature", ...h });
        if (!s.isValidSignature(f)) throw new Tr(c.PROP_IS_INVALID, { prop: `blockSignature ${f}`, type: "block signature", ...h });
        if (!g) throw new Tr(c.PROP_IS_REQUIRE, { prop: "transactionSignature", ...h });
        if (!s.isValidSignature(g)) throw new Tr(c.PROP_IS_INVALID, { prop: `transactionSignature ${g}`, type: "transaction signature", ...h });
        if (a.value !== g) throw new Tr(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `transactionSignature ${g}`, to_target: "storage", be_target: "grabAsset", ...n });
        this.checkAssetAmount(p.amount, "amount", h);
        const { giftAsset: d, ciphertextSignature: y } = p;
        this.__giftAssetTransactionFactory.verifyGiftAsset(d);
        const { cipherPublicKeys: _ } = d;
        if (_.length > 0) {
          if (!y) throw new Tr(c.NOT_EXIST, { prop: `ciphertextSignature ${y}`, ...h });
          if (!s.isValidAccountSignature(y)) throw new Tr(c.NOT_EXIST, { prop: `ciphertextSignature ${y}`, ...h });
          const { publicKey: I, signature: S } = y;
          if (!_.includes(I)) throw new Tr(c.NOT_MATCH, { to_compare_prop: `publicKey ${I}`, be_compare_prop: "cipherPublicKeys", to_target: "ciphertextSignature", be_target: "cipherPublicKeys", ...h });
          if (!await this.transactionHelper.verifyCiphertextSignature({ secretPublicKey: _e(I), ciphertextSignatureBuffer: _e(S), transactionSignatureBuffer: _e(g), senderId: e.senderId })) throw new Tr(c.PROP_IS_INVALID, { prop: `ciphertextSignature ${S}`, type: "signature", ...h });
        } else if (y) throw new Tr(c.SHOULD_NOT_EXIST, { prop: `ciphertextSignature ${y}`, type: "grabAsset", ...h });
      }
      init(e, t) {
        return Sp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          const { chainAssetInfoHelper: s } = this, { grabAsset: o } = e.asset, { amount: a, transactionSignature: p } = o, { assetType: h, sourceChainMagic: f, sourceChainName: g } = o.giftAsset, d = e.recipientId, y = s.getAssetInfo(g, f, h);
          n.next = super.applyTransaction(e, t, r), n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: y, amount: a, sourceAmount: a, recipientId: d, frozenId: p, frozenReason: ht.GIFT } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { amount: r, giftAsset: n } = e.asset.grabAsset, { sourceChainMagic: s, assetType: o } = n;
        return t.magic === s && t.assetType === o ? r : "0";
      }
    };
    ig = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, Oh])], ig);
    const { ArgumentIllegalException: lr } = ee("CONTROLLER", "GrabAnyTransactionFactory");
    let Ch = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.__giftAnyTransactionFactory = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new lr(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new lr(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new lr(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new lr(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "transactionSignature") throw new lr(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "transactionSignature", ...n });
        const p = t.grabAny;
        if (!p) throw new lr(c.PARAM_LOST, { param: "grabAny" });
        const h = { ...n, target: "grabAnyAsset" }, { blockSignature: f, transactionSignature: g } = p;
        if (!f) throw new lr(c.PROP_IS_REQUIRE, { prop: "blockSignature", ...h });
        if (!s.isValidSignature(f)) throw new lr(c.PROP_IS_INVALID, { prop: `blockSignature ${f}`, type: "block signature", ...h });
        if (!g) throw new lr(c.PROP_IS_REQUIRE, { prop: "transactionSignature", ...h });
        if (!s.isValidSignature(g)) throw new lr(c.PROP_IS_INVALID, { prop: `transactionSignature ${g}`, type: "transaction signature", ...h });
        if (a.value !== g) throw new lr(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `transactionSignature ${g}`, to_target: "storage", be_target: "grabAsset", ...n });
        this.checkAssetAmount(p.amount, "amount", h);
        const { giftAny: d, ciphertextSignature: y } = p;
        await this.__giftAnyTransactionFactory.verifyGiftAny(d);
        const { cipherPublicKeys: _ } = d;
        if (_.length > 0) {
          if (!y) throw new lr(c.NOT_EXIST, { prop: `ciphertextSignature ${y}`, ...h });
          if (!s.isValidAccountSignature(y)) throw new lr(c.NOT_EXIST, { prop: `ciphertextSignature ${y}`, ...h });
          const { publicKey: I, signature: S } = y;
          if (!_.includes(I)) throw new lr(c.NOT_MATCH, { to_compare_prop: `publicKey ${I}`, be_compare_prop: "cipherPublicKeys", to_target: "ciphertextSignature", be_target: "cipherPublicKeys", ...h });
          if (!await this.transactionHelper.verifyCiphertextSignature({ secretPublicKey: _e(I), ciphertextSignatureBuffer: _e(S), transactionSignatureBuffer: _e(g), senderId: e.senderId })) throw new lr(c.PROP_IS_INVALID, { prop: `ciphertextSignature ${S}`, type: "signature", ...h });
        } else if (y) throw new lr(c.SHOULD_NOT_EXIST, { prop: `ciphertextSignature ${y}`, type: "grabAsset", ...h });
      }
      init(e, t) {
        return vp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          const { chainAssetInfoHelper: s } = this, { senderId: o, recipientId: a, senderPublicKeyBuffer: p, asset: h } = e, { amount: f, giftAny: g, transactionSignature: d } = h.grabAny, { assetType: y, parentAssetType: _, sourceChainMagic: I, sourceChainName: S } = g, w = s.getAssetInfo(S, I, y);
          if (n.next = super.applyTransaction(e, t, r), _ === G.ASSETS) n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: o, publicKeyBuffer: p, assetInfo: w, amount: f, sourceAmount: f, recipientId: a, frozenId: d, frozenReason: ht.GIFT } });
          else if (_ === G.DAPP) n.next = t.emit("unfrozenDAppid", { type: "unfrozenDAppid", transaction: e, applyInfo: { address: o, publicKeyBuffer: p, possessorAddress: o, sourceChainName: S, sourceChainMagic: I, dappid: y, status: 0, frozenId: d } });
          else if (_ === G.LOCATION_NAME) n.next = t.emit("unfrozenLocationName", { type: "unfrozenLocationName", transaction: e, applyInfo: { address: o, publicKeyBuffer: p, possessorAddress: o, sourceChainName: S, sourceChainMagic: I, name: y, status: 0, frozenId: d } });
          else if (_ === G.ENTITY) {
            if (n.next = t.emit("unfrozenEntity", { type: "unfrozenEntity", transaction: e, applyInfo: { address: o, publicKeyBuffer: p, possessorAddress: o, sourceChainName: S, sourceChainMagic: I, entityId: y, status: 0, frozenId: d } }), g.taxInformation) {
              const { taxCollector: N, taxAssetPrealnum: B } = g.taxInformation, O = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
              B === "0" ? n.next = this._applyTransactionEmitAsset(t, e, B, { senderId: o, senderPublicKeyBuffer: p, recipientId: N, assetInfo: O }) : n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: N, publicKeyBuffer: p, assetInfo: O, amount: B, sourceAmount: B, recipientId: a, frozenId: d, frozenReason: ht.GIFT } });
            }
          } else if (_ === G.CERTIFICATE) n.next = t.emit("unfrozenCertificate", { type: "unfrozenCertificate", transaction: e, applyInfo: { address: o, publicKeyBuffer: p, possessorAddress: o, sourceChainName: S, sourceChainMagic: I, certificateId: y, status: 0, frozenId: d } });
          else throw new lr(c.PROP_IS_INVALID, { prop: `parentAssetType ${_}`, target: "transaction.asset.grabAny.giftAny" });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { amount: r, giftAny: n } = e.asset.grabAny, { sourceChainMagic: s, assetType: o } = n;
        return t.magic === s && t.assetType === o ? r : "0";
      }
    };
    Ch = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, hl])], Ch);
    const { ArgumentIllegalException: nr } = ee("CONTROLLER", "TrustAssetTransactionFactory");
    let Rh = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { senderId: s, recipientId: o } = e;
        if (!o) throw new nr(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (s === o) throw new nr(c.SHOULD_NOT_BE, { to_compare_prop: `senderId ${s}`, to_target: "body", be_compare_prop: `recipientId ${o}`, ...n });
        if (e.fromMagic !== r.magic) throw new nr(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new nr(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new nr(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "assetType") throw new nr(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "assetType", ...n });
        const p = t.trustAsset;
        await this.verifyTrustAsset(p, s, o);
        const h = p.trustees;
        if (!h.includes(s)) throw new nr(c.SHOULD_INCLUDE, { prop: "trustees", value: `senderId ${s}`, ...n, target: "trustAsset" });
        if (!h.includes(o)) throw new nr(c.SHOULD_INCLUDE, { prop: "trustee", value: `recipientId ${o}`, ...n, target: "trustAsset" });
        if (a.value !== p.assetType) throw new nr(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `assetType ${p.assetType}`, to_target: "storage", be_target: "trustAsset", ...n });
      }
      async verifyTrustAsset(e, t, r) {
        const { baseHelper: n, accountBaseHelper: s } = this;
        if (!e) throw new nr(c.PARAM_LOST, { param: "trustAsset" });
        const o = { target: "trustAssetAsset" }, { trustees: a, numberOfSignFor: p, sourceChainName: h, sourceChainMagic: f } = e;
        if (!n.isArray(a)) throw new nr(c.PROP_IS_INVALID, { prop: "trustees", type: "string array", ...o, target: "trustAsset" });
        if (a.length < 0) throw new nr(c.PROP_IS_REQUIRE, { prop: `trustees length ${a.length}`, ...o });
        for (const d of a) if (!await s.isAddress(d)) throw new nr(c.PROP_IS_INVALID, { prop: `trustee ${d}`, type: "account address", target: "trustees" });
        const g = [.../* @__PURE__ */ new Set([...a, t, r])];
        if (a.length !== g.length) throw new nr(c.SHOULD_NOT_DUPLICATE, { prop: "trustee", ...o });
        if (!n.isPositiveInteger(p)) throw new nr(c.PROP_IS_INVALID, { prop: `numberOfSignFor ${p}`, type: "positive integer", ...o });
        if (p > g.length) throw new nr(c.PROP_SHOULD_LTE_FIELD, { prop: `numberOfSignFor ${p}`, field: g.length, ...o, target: "trustAsset" });
        if (p < 1) throw new nr(c.PROP_SHOULD_GTE_FIELD, { prop: `numberOfSignFor ${p}`, field: 1, ...o, target: "trustAsset" });
        if (f === this.configHelper.magic && (this.checkChainName(h, "sourceChainName", o), this.checkChainMagic(f, "sourceChainMagic", o), this.checkAsset(e.assetType, "assetType", o)), this.checkAssetAmount(e.amount, "amount", o), e.amount === "0") throw new nr(c.PROP_SHOULD_GT_FIELD, { prop: `amount ${e.amount}`, fueld: "0", ...o });
      }
      init(e, t) {
        return pa.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { amount: s, assetType: o, sourceChainMagic: a, sourceChainName: p, numberOfSignFor: h } = e.asset.trustAsset, f = this.chainAssetInfoHelper.getAssetInfo(p, a, o);
          n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: f, amount: `-${s}`, sourceAmount: s, maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), totalUnfrozenTimes: h, frozenId: e.signature, frozenReason: ht.TRUST } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, amount: s } = e.asset.trustAsset;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    Rh = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], Rh);
    const { ArgumentIllegalException: Br } = ee("CONTROLLER", "signForAssetTransactionFactory");
    let og = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.trustAssetTransactionFactory = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s, accountBaseHelper: o, transactionHelper: a } = this, p = e.recipientId;
        if (!p) throw new Br(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        const h = e.senderId;
        if (e.fromMagic !== r.magic) throw new Br(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Br(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Br(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const f = e.storage;
        if (f.key !== "transactionSignature") throw new Br(c.SHOULD_BE, { to_compare_prop: `storage.key ${f.key}`, to_target: "storage", be_compare_prop: "transactionSignature", ...n });
        const g = { ...n, target: "signForAssetAsset" }, d = t.signForAsset;
        if (!d) throw new Br(c.PARAM_LOST, { param: "signForAsset" });
        const { trustAsset: y, trustSenderId: _, trustRecipientId: I, transactionSignature: S } = d;
        if (!S) throw new Br(c.PROP_IS_REQUIRE, { prop: "transactionSignature", ...g });
        if (!s.isValidSignature(S)) throw new Br(c.PROP_IS_INVALID, { prop: `transactionSignature ${S}`, type: "transaction signature", ...g });
        if (f.value !== S) throw new Br(c.NOT_MATCH, { to_compare_prop: `storage.value ${f.value}`, be_compare_prop: `transactionSignature ${S}`, to_target: "storage", be_target: "signForAsset", ...n });
        if (!_) throw new Br(c.PROP_IS_REQUIRE, { prop: "trustSenderId", ...g });
        if (!await o.isAddress(_)) throw new Br(c.PROP_IS_INVALID, { prop: `trustSenderId ${_}`, type: "account address", ...n, target: "trustAsset" });
        if (!I) throw new Br(c.PROP_IS_REQUIRE, { prop: "trustRecipientId", ...g });
        if (!await o.isAddress(I)) throw new Br(c.PROP_IS_INVALID, { prop: `trustRecipientId ${I}`, type: "account address", ...g });
        if (p !== I) throw new Br(c.SHOULD_BE, { to_compare_prop: `recipientId ${p}`, to_target: "body", be_compare_prop: `trustRecipientId ${I}`, ...g });
        await this.trustAssetTransactionFactory.verifyTrustAsset(y, _, I);
        const { trustees: w } = y;
        if (![.../* @__PURE__ */ new Set([...w, _, I])].includes(h)) throw new Br(c.PERMISSION_DENIED, { operationName: `sign for asset ${S}`, ...g });
      }
      init(e, t) {
        return wp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { transactionSignature: s, trustSenderId: o, trustRecipientId: a, trustAsset: p } = e.asset.signForAsset, h = this.chainAssetInfoHelper.getAssetInfo(p.sourceChainName, p.sourceChainMagic, p.assetType);
          n.next = t.emit("signForAsset", { type: "signForAsset", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: h, frozenAddress: o, recipientId: a, frozenId: s, frozenReason: ht.TRUST } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, amount: s } = e.asset.signForAsset.trustAsset;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    og = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, Rh])], og);
    const { ArgumentIllegalException: zr } = ee("CONTROLLER", "EmigrateAssetTransactionFactory");
    let ag = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.baseHelper = e, this.configHelper = t, this.accountBaseHelper = r, this.transactionHelper = n, this.chainAssetInfoHelper = s, this.migrateCertificateHelper = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), !e.recipientId) throw new zr(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new zr(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic === r.magic) throw new zr(c.SHOULD_NOT_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new zr(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const s = e.storage;
        if (s.key !== "assetType") throw new zr(c.SHOULD_BE, { to_compare_prop: `key ${s.key}`, to_target: "storage", be_compare_prop: "assetType", ...n });
        const o = t.emigrateAsset;
        if (!o) throw new zr(c.PARAM_LOST, { param: "emigrateAsset" });
        if (!o.migrateCertificate) throw new zr(c.PROP_IS_REQUIRE, { prop: "migrateCertificate", target: "emigrateAsset" });
        let a;
        try {
          a = JSON.parse(o.migrateCertificate);
        } catch {
          throw new zr(c.PROP_IS_INVALID, { prop: "migrateCertificate", target: "emigrateAsset" });
        }
        const p = await this.migrateCertificateHelper.verifyMigrateCertificate(a, { forceCheckFromChainInfo: true, fromChainBaseConfig: { chainName: r.chainName, magic: r.magic, generatorPublicKey: r.generatorPublicKey, genesisBlockSignature: r.signature, genesisGenerators: this.transactionHelper.genesisGenerators(r) }, forceCheckFromAuthSignature: true });
        if (a.toAuthSignature) throw new zr(c.SHOULD_NOT_EXIST, { prop: "toAuthSignature", ...n, target: "aemigrateAsset.migrateCertificate" });
        const { toChainId: h, fromId: f, toId: g, assetId: d } = a.body, y = p.fromId.decode(f);
        if (e.senderId !== y) throw new zr(c.NOT_MATCH, { to_compare_prop: `senderId ${e.senderId}`, be_compare_prop: `fromId ${y}`, to_target: "body", be_target: "migrateCertificate", ...n });
        const _ = p.toId.decode(g);
        if (e.recipientId !== _) throw new zr(c.NOT_MATCH, { to_compare_prop: `recipientId ${e.recipientId}`, be_compare_prop: `toId ${_}`, to_target: "body", be_target: "migrateCertificate", ...n });
        const I = p.toChainId.decode(h);
        if (e.toMagic !== I.magic) throw new zr(c.NOT_MATCH, { to_compare_prop: `toMagic ${e.toMagic}`, be_compare_prop: `toChainId ${I.magic}`, to_target: "body", be_target: "migrateCertificate", ...n });
        const S = p.assetId.decode(d);
        if (s.value !== S.assetType) throw new zr(c.NOT_MATCH, { to_compare_prop: `value ${s.value}`, be_compare_prop: `assetTypeId ${S.assetType}`, to_target: "storage", be_target: "migrateCertificateBody", ...n });
      }
      init(e, t) {
        return bp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, senderPublicKeyBuffer: o } = e;
          n.next = t.emit("frozenAccount", { type: "frozenAccount", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, accountStatus: 17 } });
        });
      }
    };
    ag = l([J(), u("design:paramtypes", [Be, ne, me, Ee, ve, Fs])], ag);
    const { ArgumentIllegalException: jr } = ee("CONTROLLER", "ImmigrateAssetTransactionFactory");
    let cg = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.baseHelper = e, this.configHelper = t, this.accountBaseHelper = r, this.transactionHelper = n, this.chainAssetInfoHelper = s, this.migrateCertificateHelper = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), !e.recipientId) throw new jr(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic === r.magic) throw new jr(c.SHOULD_NOT_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new jr(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new jr(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const s = e.storage;
        if (s.key !== "assetType") throw new jr(c.SHOULD_BE, { to_compare_prop: `key ${s.key}`, to_target: "storage", be_compare_prop: "assetType", ...n });
        const o = t.immigrateAsset;
        if (!o) throw new jr(c.PARAM_LOST, { param: "immigrateAsset" });
        const a = { ...n, target: "immigrateAsset" };
        if (!o.migrateCertificate) throw new jr(c.PROP_IS_REQUIRE, { prop: "migrateCertificate", ...a });
        let p;
        try {
          p = JSON.parse(o.migrateCertificate);
        } catch {
          throw new jr(c.PROP_IS_INVALID, { prop: "migrateCertificate", ...a });
        }
        const h = await this.migrateCertificateHelper.verifyMigrateCertificate(p, { forceCheckToChainInfo: true, toChainBaseConfig: { chainName: r.chainName, magic: r.magic, generatorPublicKey: r.generatorPublicKey, genesisBlockSignature: r.signature, genesisGenerators: this.transactionHelper.genesisGenerators(r) }, forceCheckToAuthSignature: true, forceCheckFromAuthSignature: true }), { fromChainId: f, toId: g, assetId: d } = p.body, y = h.toId.decode(g, true);
        if (e.recipientId !== y) throw new jr(c.NOT_MATCH, { to_compare_prop: `recipientId ${e.recipientId}`, be_compare_prop: `toId ${y}`, to_target: "body", be_target: "migrateCertificate", ...n });
        const _ = h.fromChainId.decode(f, true);
        if (e.fromMagic !== _.magic) throw new jr(c.NOT_MATCH, { to_compare_prop: `fromMagic ${e.fromMagic}`, be_compare_prop: `fromChainId ${_.magic}`, to_target: "body", be_target: "migrateCertificate", ...n });
        const I = h.assetId.decode(d, true);
        if (s.value !== I.assetType) throw new jr(c.NOT_MATCH, { to_compare_prop: `value ${s.value}`, be_compare_prop: `asset ${JSON.stringify(I)}`, to_target: "storage", be_target: "migrateCertificate", ...n });
      }
      init(e, t) {
        return Np.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          let s;
          try {
            s = JSON.parse(e.asset.immigrateAsset.migrateCertificate);
          } catch {
            throw new jr(c.PROP_IS_INVALID, { prop: "migrateCertificate", target: "transaction.asset.immigrateAsset" });
          }
          const o = this.migrateCertificateHelper.getMigrateCertificateConverter(s), { fromChainId: a, assetId: p, assetPrealnum: h } = s.body, f = o.fromChainId.decode(a), g = o.assetId.decode(p), { parentAssetType: d, assetType: y } = g;
          if (d === G.ASSETS) {
            const _ = this.chainAssetInfoHelper.getAssetInfo(f.chainName, f.magic, y);
            n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: e.recipientId, assetInfo: _, amount: h, sourceAmount: h } });
          } else throw new Error("\u76EE\u524D\u53EA\u652F\u6301\u6743\u76CA");
          n.next = t.emit("migrateCertificate", { type: "migrateCertificate", transaction: e, applyInfo: { migrateCertificateId: o.getUUID(s), assetInfo: { chainName: f.chainName, magic: f.magic, assetType: y }, assets: h, migrateIdBuffer: e.signatureBuffer } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        let r;
        try {
          r = JSON.parse(e.asset.immigrateAsset.migrateCertificate);
        } catch {
          throw new jr(c.PROP_IS_INVALID, { prop: "migrateCertificate", target: "transaction.asset.immigrateAsset" });
        }
        const n = this.migrateCertificateHelper.getMigrateCertificateConverter(r), { fromChainId: s, assetId: o, assetPrealnum: a } = r.body, p = n.fromChainId.decode(s), h = n.assetId.decode(o);
        return t.magic === p.magic && t.assetType === h.assetType ? a : "0";
      }
    };
    cg = l([J(), u("design:paramtypes", [Be, ne, me, Ee, ve, Fs])], cg);
    const { ArgumentIllegalException: Cn } = ee("CONTROLLER", "StakeAssetTransactionFactory");
    let Bh = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), e.recipientId) throw new Cn(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Cn(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Cn(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Cn(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const s = e.storage;
        if (s.key !== "stakeId") throw new Cn(c.SHOULD_BE, { to_compare_prop: `storage.key ${s.key}`, to_target: "storage", be_compare_prop: "stakeId", ...n });
        const o = t.stakeAsset;
        if (!o) throw new Cn(c.PARAM_LOST, { param: "stakeAsset" });
        const a = { target: "stakeAssetAsset" }, { baseHelper: p } = this, { stakeId: h, sourceChainName: f, sourceChainMagic: g, assetType: d, assetPrealnum: y, beginUnstakeHeight: _ } = o;
        if (p.isValidStakeId(h) === false) throw new Cn(c.PROP_IS_INVALID, { prop: `stakeId ${h}`, ...a });
        if (g === this.configHelper.magic && (this.checkChainName(f, "sourceChainName", a), this.checkChainMagic(g, "sourceChainMagic", a), this.checkAsset(d, "assetType", a)), this.checkAssetAmount(y, "assetPrealnum", a), y === "0") throw new Cn(c.PROP_SHOULD_GT_FIELD, { prop: `assetPrealnum ${y}`, fueld: "0", ...a });
        if (p.isPositiveInteger(_) === false) throw new Cn(c.PROP_IS_INVALID, { prop: `beginUnstakeHeight ${_}`, ...a });
        if (o.beginUnstakeHeight < e.applyBlockHeight) throw new Cn(c.PROP_SHOULD_GT_FIELD, { prop: `beginUnstakeHeight ${o.beginUnstakeHeight}`, field: e.applyBlockHeight, target: "stakeAssetAsset" });
        if (s.value !== o.stakeId) throw new Cn(c.NOT_MATCH, { to_compare_prop: `storage.value ${s.value}`, be_compare_prop: `stakeId ${o.stakeId}`, to_target: "storage", be_target: "stakeAsset", ...n });
      }
      init(e, t) {
        return zi.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, senderPublicKeyBuffer: o } = e, { stakeId: a, assetType: p, sourceChainName: h, sourceChainMagic: f, assetPrealnum: g, beginUnstakeHeight: d } = e.asset.stakeAsset, y = this.chainAssetInfoHelper.getAssetInfo(h, f, p);
          n.next = t.emit("stakeAsset", { type: "stakeAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, assetInfo: y, amount: `-${g}`, sourceAmount: g, beginUnstakeHeight: d, stakeId: a } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, assetPrealnum: s } = e.asset.stakeAsset;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    Bh = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], Bh);
    const { ArgumentIllegalException: Zn } = ee("CONTROLLER", "UnstakeAssetTransactionFactory");
    let pg = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.stakeAssetTransactionFactory = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s, accountBaseHelper: o } = this;
        if (e.recipientId) throw new Zn(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Zn(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Zn(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Zn(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "stakeId") throw new Zn(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "stakeId", ...n });
        const p = t.unstakeAsset;
        if (!p) throw new Zn(c.PARAM_LOST, { param: "unstakeAsset" });
        const h = { target: "unstakeAssetAsset" }, { stakeId: f, sourceChainName: g, sourceChainMagic: d, assetType: y, assetPrealnum: _ } = p;
        if (s.isValidStakeId(f) === false) throw new Zn(c.PROP_IS_INVALID, { prop: `stakeId ${f}`, ...h });
        if (d === this.configHelper.magic && (this.checkChainName(g, "sourceChainName", h), this.checkChainMagic(d, "sourceChainMagic", h), this.checkAsset(y, "assetType", h)), this.checkAssetAmount(_, "assetPrealnum", h), _ === "0") throw new Zn(c.PROP_SHOULD_GT_FIELD, { prop: `assetPrealnum ${_}`, fueld: "0", ...h });
        if (a.value !== f) throw new Zn(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `stakeId ${f}`, to_target: "storage", be_target: "unstakeAsset", ...n });
        if (this.checkAssetAmount(_, "assetPrealnum", h), _ === "0") throw new Zn(c.PROP_SHOULD_GT_FIELD, { prop: `assetPrealnum ${_}`, fueld: "0", ...h });
      }
      init(e, t) {
        return Op.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s } = e, { stakeId: o, sourceChainName: a, sourceChainMagic: p, assetType: h, assetPrealnum: f } = e.asset.unstakeAsset, g = this.chainAssetInfoHelper.getAssetInfo(a, p, h);
          n.next = t.emit("unstakeAsset", { type: "unstakeAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: g, amount: f, sourceAmount: f, stakeId: o } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, assetType: n, assetPrealnum: s } = e.asset.unstakeAsset;
        return t.magic === r && t.assetType === n ? s : "0";
      }
    };
    pg = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, Bh])], pg);
    const { ArgumentIllegalException: Vt } = ee("CONTROLLER", "LocationNameTransactionFactory");
    let lg = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new Vt(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Vt(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Vt(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Vt(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const o = e.storage;
        if (o.key !== "name") throw new Vt(c.SHOULD_BE, { to_compare_prop: `storage.key ${o.key}`, to_target: "storage", be_compare_prop: "name", ...n });
        const a = t.locationName;
        if (!a) throw new Vt(c.PARAM_LOST, { param: "locationName" });
        const p = { ...n, target: "locationName" }, h = a.name;
        if (!h) throw new Vt(c.PROP_IS_REQUIRE, { prop: "name", ...p });
        if (!s.isString(h)) throw new Vt(c.PROP_IS_INVALID, { prop: `name ${h}`, type: "string", ...p });
        if (h.length > 512) throw new Vt(c.OVER_LENGTH, { prop: `name ${h}`, limit: 512, ...p });
        if (s.isStartWithOrEndWithPoint(h)) throw new Vt(c.SHOULD_NOT_START_WITH_OR_END_WITH, { prop: `name ${h}`, field: ".", ...p });
        const g = h.split("."), d = g.length;
        if (d < 2) throw new Vt(c.PROP_IS_INVALID, { prop: `name ${h}`, ...p });
        for (let S = 0; S < d; S++) {
          const w = g[S];
          if (w.length > 128) throw new Vt(c.OVER_LENGTH, { prop: `name ${w}`, limit: 128, ...p });
          if (S === d - 2) {
            if (!s.isLowerCaseLetter(w)) throw new Vt(c.PROP_IS_INVALID, { prop: `name ${w}`, type: "lowercase", ...p });
          } else if (S === d - 1) {
            if (w !== r.chainName) throw new Vt(c.SHOULD_BE, { to_compare_prop: "root location name", to_target: `name ${w}`, be_compare_prop: r.chainName, ...p });
          } else if (w.length <= 2) {
            if (!s.isLowerCaseLetterOrNumber(w)) throw new Vt(c.PROP_IS_INVALID, { prop: `name ${w}`, type: "lowercase letter or number", ...p });
          } else if (!s.isLowerCaseLetterOrNumberOrUnderline(w)) throw new Vt(c.PROP_IS_INVALID, { prop: `name ${w}`, type: "lowercase letter or number or underline", ...p });
        }
        if (o.value !== h) throw new Vt(c.NOT_MATCH, { to_compare_prop: `storage.value ${o.value}`, be_compare_prop: `name ${h}`, to_target: "storage", be_target: "locationName", ...n });
        const { sourceChainName: y, sourceChainMagic: _, operationType: I } = a;
        if (this.checkChainName(y, "sourceChainName", p), y !== r.chainName) throw new Vt(c.SHOULD_BE, { to_compare_prop: `sourceChainName ${y}`, to_target: "body", be_compare_prop: "local chain name", ...n });
        if (this.checkChainMagic(_, "sourceChainMagic", p), _ !== r.magic) throw new Vt(c.SHOULD_BE, { to_compare_prop: `sourceChainMagic ${_}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (I !== 0 && I !== 1) throw new Vt(c.NOT_MATCH, { to_compare_prop: `operationType ${I}`, be_compare_prop: "locationNameType", to_target: "locationName", be_target: "LOCATION_NAME_OPERATION_TYPE", ...p });
        if (I === 1 && e.senderId !== e.recipientId) throw new Vt(c.SHOULD_BE, { to_compare_prop: `recipientId ${e.recipientId}`, to_target: "transaction", be_compare_prop: e.senderId, ...n });
      }
      init(e, t) {
        return Cp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, recipientId: o } = e, { name: a, sourceChainMagic: p, sourceChainName: h, operationType: f } = e.asset.locationName;
          f === 0 ? n.next = t.emit("registerLocationName", { type: "registerLocationName", transaction: e, applyInfo: { address: s, name: a, sourceChainMagic: p, sourceChainName: h, possessorAddress: o, status: 0 } }) : n.next = t.emit("cancelLocationName", { type: "cancelLocationName", transaction: e, applyInfo: { address: s, sourceChainName: h, sourceChainMagic: p, name: a, status: 255 } });
        });
      }
    };
    lg = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], lg);
    const { ArgumentIllegalException: Es } = ee("CONTROLLER", "SetLnsManagerTransactionFactory");
    let hg = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new Es(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Es(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Es(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Es(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "name") throw new Es(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "name", ...n });
        const p = t.lnsManager;
        if (!p) throw new Es(c.PARAM_LOST, { param: "lnsManager" });
        const h = { ...n, target: "lnsManagerAsset" }, f = p.name;
        if (!f) throw new Es(c.PROP_IS_REQUIRE, { prop: "name", ...h });
        if (!s.isValidLocationName(f)) throw new Es(c.PROP_IS_INVALID, { prop: `name ${f}`, type: "location name", ...h });
        if (a.value !== f) throw new Es(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `name ${f}`, to_target: "storage", be_target: "lnsManager", ...n });
        const { sourceChainName: g, sourceChainMagic: d } = p;
        this.checkChainName(g, "sourceChainName", h), this.checkChainMagic(d, "sourceChainMagic", h);
      }
      init(e, t) {
        return Rp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { name: s, sourceChainMagic: o, sourceChainName: a } = e.asset.lnsManager;
          n.next = t.emit("setLnsManager", { type: "setLnsManager", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, sourceChainName: a, sourceChainMagic: o, name: s, manager: e.recipientId } });
        });
      }
    };
    hg = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], hg);
    const { ArgumentIllegalException: nt } = ee("CONTROLLER", "SetLnsRecordValueTransactionFactory");
    let ug = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (e.recipientId) throw new nt(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new nt(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new nt(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new nt(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const o = e.storage;
        if (o.key !== "name") throw new nt(c.SHOULD_BE, { to_compare_prop: `storage.key ${o.key}`, to_target: "storage", be_compare_prop: "name", ...n });
        const a = t.lnsRecordValue;
        if (!a) throw new nt(c.PARAM_LOST, { param: "lnsRecordValue" });
        const p = { ...n, target: "lnsRecordValueAsset" }, h = a.name;
        if (!h) throw new nt(c.PROP_IS_REQUIRE, { prop: "name", ...p });
        if (!s.isValidLocationName(h)) throw new nt(c.PROP_IS_INVALID, { prop: `name ${h}`, type: "location name", ...p });
        if (o.value !== h) throw new nt(c.NOT_MATCH, { to_compare_prop: `storage.value ${o.value}`, be_compare_prop: `name ${h}`, to_target: "storage", be_target: "lnsRecordValue", ...n });
        const { sourceChainName: f, sourceChainMagic: g } = a;
        switch (this.checkChainName(f, "sourceChainName", p), this.checkChainMagic(g, "sourceChainMagic", p), a.operationType) {
          case 0:
            if (!a.addRecord) throw new nt(c.PROP_IS_REQUIRE, { prop: "addRecord", ...p });
            if (a.deleteRecord) throw new nt(c.SHOULD_NOT_EXIST, { prop: "deleteRecord", ...p });
            await this.checkLocationNameRecord(a.addRecord);
            break;
          case 1:
            if (a.addRecord) throw new nt(c.SHOULD_NOT_EXIST, { prop: "addRecord", ...p });
            if (!a.deleteRecord) throw new nt(c.PROP_IS_REQUIRE, { prop: "deleteRecord", ...p });
            await this.checkLocationNameRecord(a.deleteRecord);
            break;
          case 2:
            if (!a.addRecord) throw new nt(c.PROP_IS_REQUIRE, { prop: "addRecord", ...p });
            if (!a.deleteRecord) throw new nt(c.PROP_IS_REQUIRE, { prop: "deleteRecord", ...p });
            await this.checkLocationNameRecord(a.addRecord), await this.checkLocationNameRecord(a.deleteRecord);
            break;
          default:
            throw new nt(c.PROP_IS_INVALID, { prop: "operationType", type: "location name operation type", ...p });
        }
      }
      async checkLocationNameRecord(e) {
        const { baseHelper: t, accountBaseHelper: r } = this;
        if (!e) throw new nt(c.PARAM_LOST, { param: "record" });
        const n = { target: "lnsRecordValue" }, { recordType: s, recordValue: o } = e;
        if (!t.isString(o)) throw new nt(c.NOT_A_STRING, { prop: "recordValue", value: o, ...n });
        if (s === 1) {
          if (!t.isIpV4(o)) throw new nt(c.NOT_A_IPV4, { prop: "recordValue", value: o, ...n });
        } else if (s === 2) {
          if (!t.isIpV6(o)) throw new nt(c.NOT_A_IPV6, { prop: "recordValue", value: o, ...n });
        } else if (s === 3) {
          const a = o.split(",");
          if (a.length !== 2) throw new nt(c.NOT_A_LONGITUDE_LATITUDE, { prop: "recordValue", value: o, ...n });
          if (!t.isLongitude(a[0])) throw new nt(c.NOT_A_LONGITUDE, { prop: "recordValue", value: o, ...n });
          if (!t.isLatitude(a[1])) throw new nt(c.NOT_A_LATITUDE, { prop: "recordValue", value: o, ...n });
        } else if (s === 4) {
          if (!await r.isAddress(o)) throw new nt(c.NOT_A_ADDRESS, { prop: "recordValue", value: o, ...n });
        } else if (s === 5) {
          if (!t.isValidLocationName(o)) throw new nt(c.NOT_A_LOCATION_NAME, { prop: "recordValue", value: o, ...n });
        } else if (s === 6) {
          if (!t.isDNS(o)) throw new nt(c.NOT_A_DNS, { prop: "recordValue", value: o, ...n });
        } else if (s === 8) {
          if (!t.isEmail(o)) throw new nt(c.NOT_A_EMAIL, { prop: "recordValue", value: o, ...n });
        } else if (s === 7) {
          if (!t.isURL(o)) throw new nt(c.NOT_A_URL, { prop: "recordValue", value: o, ...n });
        } else if (s !== 0) throw new nt(c.NOT_EXIST, { prop: "recordType", ...n });
      }
      init(e, t) {
        return Bp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { name: s, sourceChainMagic: o, sourceChainName: a, operationType: p, addRecord: h, deleteRecord: f } = e.asset.lnsRecordValue;
          n.next = t.emit("setLnsRecordValue", { type: "setLnsRecordValue", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, sourceChainMagic: o, sourceChainName: a, name: s, operationType: p, addRecord: h, deleteRecord: f } });
        });
      }
    };
    ug = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], ug);
    const { ArgumentIllegalException: Wt } = ee("CONTROLLER", "IssueEntityFactoryTransactionFactory");
    let ho = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.jsbiHelper = o;
      }
      async commonVerifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), !e.recipientId) throw new Wt(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Wt(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Wt(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Wt(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const o = e.storage;
        if (o.key !== "factoryId") throw new Wt(c.SHOULD_BE, { to_compare_prop: `storage.key ${o.key}`, to_target: "storage", be_compare_prop: "factoryId", ...n });
        const a = t.issueEntityFactory;
        if (this.verifyIssueEntityFactoryAsset(a, r), o.value !== a.factoryId) throw new Wt(c.NOT_MATCH, { to_compare_prop: `storage.value ${o.value}`, be_compare_prop: `factoryId ${a.factoryId}`, to_target: "storage", be_target: "dapp", ...n });
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        if (await this.commonVerifyTransactionBody(e, t, r), e.senderId === e.recipientId) throw new Wt(c.SHOULD_NOT_BE, { to_compare_prop: `senderId ${e.senderId}`, to_target: "body", be_compare_prop: `recipientId ${e.recipientId}`, target: "body" });
      }
      verifyIssueEntityFactoryAsset(e, t = this.configHelper) {
        const { baseHelper: r } = this, n = { target: "body" };
        if (!e) throw new Wt(c.PARAM_LOST, { param: "issueEntityFactory", ...n });
        const s = { ...n, target: "issueEntityFactory" }, { sourceChainMagic: o, sourceChainName: a, factoryId: p, entityPrealnum: h, entityFrozenAssetPrealnum: f, purchaseAssetPrealnum: g } = e;
        if (a !== t.chainName) throw new Wt(c.SHOULD_BE, { to_compare_prop: `sourceChainName ${a}`, to_target: "body", be_compare_prop: "local chain name", ...n });
        if (o !== t.magic) throw new Wt(c.SHOULD_BE, { to_compare_prop: `sourceChainMagic ${o}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!p) throw new Wt(c.PROP_IS_REQUIRE, { prop: "factoryId", ...s });
        if (!r.isString(p)) throw new Wt(c.PROP_IS_INVALID, { prop: `factoryId ${p}`, type: "string", ...s });
        const d = p.length;
        if (d < 3 || d > 15) throw new Wt(c.NOT_IN_EXPECTED_RANGE, { prop: `factoryId ${p}`, type: "string length", min: 3, max: 15, ...s });
        if (!r.isLowerCaseLetterOrNumber(p)) throw new Wt(c.PROP_IS_INVALID, { prop: `factoryId ${p}`, type: "lowercase letter or number", ...s });
        if (!r.isPositiveStringNumber(h)) throw new Wt(c.PROP_IS_INVALID, { prop: `entityPrealnum ${h}`, type: "positive integer", IssueEntityFactoryAsset_Exception_Detail: s });
        if (!f) throw new Wt(c.PROP_IS_REQUIRE, { prop: "entityFrozenAssetPrealnum", ...s });
        if (!r.isValidAssetPrealnum(f)) throw new Wt(c.PROP_IS_INVALID, { prop: `entityFrozenAssetPrealnum ${f}`, type: "string number", ...s });
        if (!g) throw new Wt(c.PROP_IS_REQUIRE, { prop: "purchaseAssetPrealnum", ...s });
        if (!r.isValidAssetPrealnum(g)) throw new Wt(c.PROP_IS_INVALID, { prop: `purchaseAssetPrealnum ${g}`, type: "string number", ...s });
      }
      init(e, t) {
        return Pp.fromObject({ ...e, asset: t });
      }
      async applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { sourceChainName: s, sourceChainMagic: o, factoryId: a, entityPrealnum: p, entityFrozenAssetPrealnum: h, purchaseAssetPrealnum: f } = e.asset.issueEntityFactory;
          n.next = t.emit("frozenAccount", { type: "frozenAccount", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, accountStatus: 16 } }), n.next = t.emit("issueEntityFactoryByFrozen", { type: "issueEntityFactoryByFrozen", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, sourceChainName: s, sourceChainMagic: o, factoryId: a, entityPrealnum: p, entityFrozenAssetPrealnum: h, possessorAddress: e.recipientId, purchaseAssetPrealnum: f, status: 0 } });
        });
      }
    };
    ho = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, xt])], ho);
    let Ph = class extends ho {
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await this.commonVerifyTransactionBody(e, t, r);
      }
      init(e, t) {
        return Mp.fromObject({ ...e, asset: t });
      }
      async applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          const { senderId: s, recipientId: o, senderPublicKeyBuffer: a, fee: p } = e, h = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
          n.next = t.emit("fee", { type: "fee", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: h, amount: "-" + e.fee, sourceAmount: e.fee } }), n.next = t.emit("count", { type: "count", transaction: e });
          const { sourceChainName: f, sourceChainMagic: g, factoryId: d, entityPrealnum: y, entityFrozenAssetPrealnum: _, purchaseAssetPrealnum: I } = e.asset.issueEntityFactory, S = this.transactionHelper.calcDestroyMainAssetsOfIsseuEntityFactory(y, r);
          n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, assetInfo: h, amount: "-" + S, sourceAmount: S } }), n.next = t.emit("destroyMainAsset", { type: "destroyMainAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, assetInfo: h, amount: "-" + S, sourceAmount: S } }), n.next = t.emit("issueEntityFactoryByDestroy", { type: "issueEntityFactoryByDestroy", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, sourceChainName: f, sourceChainMagic: g, factoryId: d, entityPrealnum: y, entityFrozenAssetPrealnum: _, possessorAddress: e.recipientId, purchaseAssetPrealnum: I, status: 0 } });
        });
      }
    };
    Ph = l([J()], Ph);
    const { ArgumentIllegalException: Xt } = ee("CONTROLLER", "IssueEntityTransactionFactory");
    let Mh = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.issueEntityFactoryTransactionFactory = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new Xt(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Xt(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Xt(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Xt(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "entityId") throw new Xt(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "entityId", ...n });
        const p = t.issueEntity;
        if (!p) throw new Xt(c.PARAM_LOST, { param: "issueEntity" });
        const h = { ...n, target: "issueEntityAsset" }, { sourceChainName: f, sourceChainMagic: g, entityId: d, taxAssetPrealnum: y, entityFactoryPossessor: _, entityFactory: I } = p;
        if (f !== r.chainName) throw new Xt(c.SHOULD_BE, { to_compare_prop: `sourceChainName ${f}`, to_target: "body", be_compare_prop: "local chain name", ...n });
        if (g !== r.magic) throw new Xt(c.SHOULD_BE, { to_compare_prop: `sourceChainMagic ${f}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!_) throw new Xt(c.PROP_IS_REQUIRE, { prop: "entityFactoryPossessor", ...n });
        if (!await this.accountBaseHelper.isAddress(_)) throw new Xt(c.PROP_IS_INVALID, { prop: `entityFactoryPossessor ${_}`, type: "account address", ...n, target: "issueEntity" });
        if (!d) throw new Xt(c.PROP_IS_REQUIRE, { prop: "entityId", ...h });
        const S = d.split("_");
        if (S.length !== 2) throw new Xt(c.PROP_IS_INVALID, { prop: `entityId ${d}`, ...h });
        if (!s.isValidEntityFactoryId(S[0])) throw new Xt(c.PROP_IS_INVALID, { prop: `factoryId ${S[0]}`, ...h });
        const w = S[1].length;
        if (w < 3 || w > 30) throw new Xt(c.NOT_IN_EXPECTED_RANGE, { prop: `entityId ${S[1]}`, type: "string length", min: 3, max: 30, ...h });
        if (!s.isLowerCaseLetterOrNumber(S[1])) throw new Xt(c.PROP_IS_INVALID, { prop: `entityId ${S[1]}`, type: "lowercase or number", ...h });
        if (!y) throw new Xt(c.PROP_IS_REQUIRE, { prop: "taxAssetPrealnum", ...h });
        if (!this.baseHelper.isValidAssetPrealnum(y)) throw new Xt(c.PROP_IS_INVALID, { prop: `taxAssetPrealnum ${y}`, ...h });
        if (a.value !== d) throw new Xt(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `entityId ${d}`, to_target: "storage", be_target: "issueEntityAsset", ...n });
        if (this.issueEntityFactoryTransactionFactory.verifyIssueEntityFactoryAsset(I), S[0] !== I.factoryId) throw new Xt(c.NOT_MATCH, { to_compare_prop: `factoryId ${S[0]}`, be_compare_prop: `factoryId ${I.factoryId}`, to_target: "entityId", be_target: "entityFactory", ...n });
      }
      init(e, t) {
        return ji.fromObject({ ...e, asset: t });
      }
      async applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          const { senderId: s, recipientId: o, senderPublicKeyBuffer: a, signature: p } = e, { sourceChainName: h, sourceChainMagic: f, entityId: g, taxAssetPrealnum: d, entityFactoryPossessor: y, entityFactory: _, taxAssetRecipientId: I } = e.asset.issueEntity, { factoryId: S, entityFrozenAssetPrealnum: w, purchaseAssetPrealnum: N } = _, B = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
          n.next = t.emit("fee", { type: "fee", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: B, amount: "-" + e.fee, sourceAmount: e.fee } }), n.next = t.emit("count", { type: "count", transaction: e }), n.next = t.emit("issueEntity", { type: "issueEntity", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, sourceChainName: h, sourceChainMagic: f, factoryId: S, entityId: g, taxAssetPrealnum: d, possessorAddress: o, entityFactoryPossessorAddress: y, entityFrozenAssetPrealnum: w, issueId: p, status: 0, taxAssetRecipientId: I || s } }), w !== "0" && (n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, assetInfo: B, amount: `-${w}`, sourceAmount: w, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), totalUnfrozenTimes: 1, frozenId: p, frozenReason: ht.ENTITY } })), n.next = this._applyTransactionEmitAsset(t, e, N, { senderId: s, senderPublicKeyBuffer: a, recipientId: y, assetInfo: B });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, entityFrozenAssetPrealnum: n, purchaseAssetPrealnum: s } = e.asset.issueEntity.entityFactory;
        return t.magic === r && t.assetType === this.configHelper.assetType ? (BigInt(n) + BigInt(s)).toString() : "0";
      }
    };
    Mh = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, ho])], Mh);
    const { ArgumentIllegalException: sr } = ee("CONTROLLER", "DestroyEntityTransactionFactory");
    let fg = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.issueEntityFactoryTransactionFactory = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), !e.recipientId) throw new sr(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new sr(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new sr(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new sr(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const s = e.storage;
        if (s.key !== "entityId") throw new sr(c.SHOULD_BE, { to_compare_prop: `storage.key ${s.key}`, to_target: "storage", be_compare_prop: "entityId", ...n });
        const o = t.destroyEntity;
        if (!o) throw new sr(c.PARAM_LOST, { param: "destroyEntity" });
        const a = { ...n, target: "destroyAssetAsset" }, { sourceChainMagic: p, sourceChainName: h, entityId: f, entityFactoryApplicant: g, entityFactoryPossessor: d, entityFactory: y, transactionSignature: _ } = o;
        if (h !== r.chainName) throw new sr(c.SHOULD_BE, { to_compare_prop: "sourceChainName", to_target: "body", be_compare_prop: "local chain name", ...a });
        if (p !== r.magic) throw new sr(c.SHOULD_BE, { to_compare_prop: "sourceChainMagic", to_target: "body", be_compare_prop: "local chain magic", ...a });
        const I = this.baseHelper;
        if (!f) throw new sr(c.PROP_IS_REQUIRE, { prop: "entityId", ...a });
        if (!I.isValidEntityId(f)) throw new sr(c.PROP_IS_INVALID, { prop: `entityId ${f}`, type: "entityId", ...a });
        if (s.value !== f) throw new sr(c.NOT_MATCH, { to_compare_prop: `storage.value ${s.value}`, be_compare_prop: `entityId ${f}`, to_target: "storage", be_target: "destroyEntity", ...n });
        if (!d) throw new sr(c.PROP_IS_REQUIRE, { prop: "entityFactoryPossessor", ...n });
        if (!await this.accountBaseHelper.isAddress(d)) throw new sr(c.PROP_IS_INVALID, { prop: `entityFactoryPossessor ${d}`, type: "account address", ...n, target: "destroyEntity" });
        if (!g) throw new sr(c.PROP_IS_REQUIRE, { prop: "entityFactoryApplicant", ...n });
        if (!await this.accountBaseHelper.isAddress(g)) throw new sr(c.PROP_IS_INVALID, { prop: `entityFactoryApplicant ${g}`, type: "account address", ...n, target: "destroyEntity" });
        this.issueEntityFactoryTransactionFactory.verifyIssueEntityFactoryAsset(y);
        const S = this.transactionHelper.getFactoryIdByEntityId(f);
        if (S !== y.factoryId) throw new sr(c.NOT_MATCH, { to_compare_prop: `factoryId ${S}`, be_compare_prop: `factoryId ${y.factoryId}`, to_target: "entityId", be_target: "entityFactory", ...n });
        if (!_) throw new sr(c.PROP_IS_REQUIRE, { prop: "transactionSignature", ...a });
        if (!I.isValidTransactionSignature(_)) throw new sr(c.PROP_IS_INVALID, { prop: `transactionSignature ${_}`, type: "transaction signature", ...a });
      }
      init(e, t) {
        return Lp.fromObject({ ...e, asset: t });
      }
      async applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, senderPublicKeyBuffer: o, recipientId: a } = e, { sourceChainMagic: p, sourceChainName: h, entityId: f, entityFactoryApplicant: g, entityFactoryPossessor: d, entityFactory: y, transactionSignature: _ } = e.asset.destroyEntity;
          n.next = t.emit("destroyEntity", { type: "destroyEntity", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, sourceChainMagic: p, sourceChainName: h, entityId: f, entityFactoryApplicantAddress: g, entityFactoryPossessorAddress: d, entityFactory: y.toJSON(), frozenId: _, status: 255 } });
          const I = y.entityFrozenAssetPrealnum;
          if (I !== "0") {
            const S = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
            n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: e.senderId, publicKeyBuffer: e.senderPublicKeyBuffer, assetInfo: S, amount: I, sourceAmount: I, recipientId: a, frozenId: _, frozenReason: ht.ENTITY } });
          }
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { sourceChainMagic: r, entityFactory: n } = e.asset.destroyEntity;
        return t.magic === r && t.assetType === this.configHelper.assetType ? n.entityFrozenAssetPrealnum : "0";
      }
    };
    fg = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, ho])], fg);
    const { ArgumentIllegalException: mt } = ee("CONTROLLER", "ToExchangeAnyTransactionFactory");
    let ul = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (e.recipientId) throw new mt(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new mt(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new mt(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic" });
        const s = t.toExchangeAny;
        if (await this.verifyToExchangeAny(s, r), s.toExchangeAssetPrealnum === "0") throw new mt(c.PROP_SHOULD_GT_FIELD, { prop: "toExchangeAssetPrealnum", field: "0", target: "toExchangeAny" });
        if (e.storage) throw new mt(c.SHOULD_NOT_EXIST, { prop: "storage", ...n });
      }
      async verifyToExchangeAny(e, t = this.configHelper) {
        const { baseHelper: r } = this;
        if (!e) throw new mt(c.PARAM_LOST, { param: "toExchangeAny" });
        const n = { target: "toExchangeAnyAsset" }, s = e.cipherPublicKeys, o = new Set(s);
        if (s.length !== o.size) throw new mt(c.SHOULD_NOT_DUPLICATE, { prop: "cipherPublicKeys", ...n });
        if (!r.isValidCipherPublicKeys(s)) throw new mt(c.PROP_IS_INVALID, { prop: "cipherPublicKeys", ...n });
        const { toExchangeParentAssetType: a, toExchangeAssetType: p, beExchangeParentAssetType: h, beExchangeAssetType: f } = e;
        this.checkParentAssetType(a, "toExchangeParentAssetType", n), this.checkParentAssetType(h, "beExchangeParentAssetType", n), e.toExchangeSource === this.configHelper.magic && (this.checkChainName(e.toExchangeChainName, "toExchangeChainName", n), this.checkChainMagic(e.toExchangeSource, "toExchangeSource", n), this.checkAssetType(a, p, "toExchangeAssetType", n)), e.beExchangeSource === this.configHelper.magic && (this.checkChainName(e.beExchangeChainName, "beExchangeChainName", n), this.checkChainMagic(e.beExchangeSource, "beExchangeSource", n), this.checkAssetType(h, f, "beExchangeAssetType", n));
        const { toExchangeAssetPrealnum: g, beExchangeAssetPrealnum: d, assetExchangeWeightRatio: y, taxInformation: _ } = e;
        if (!g) throw new mt(c.PROP_IS_REQUIRE, { prop: "toExchangeAssetPrealnum", ...n });
        if (!r.isValidAssetNumber(g)) throw new mt(c.PROP_IS_INVALID, { prop: "toExchangeAssetPrealnum", ...n });
        if (a === G.ASSETS) if (h === G.ASSETS) {
          if (d) throw new mt(c.SHOULD_NOT_EXIST, { prop: "beExchangeAssetPrealnum", ...n });
          if (!y) throw new mt(c.PROP_IS_REQUIRE, { prop: "assetExchangeWeightRatio", ...n });
          if (!r.isValidAssetExchangeWeightRatio(y)) throw new mt(c.PROP_IS_INVALID, { prop: `assetExchangeWeightRatio ${JSON.stringify(y)}`, ...n });
        } else {
          if (!d) throw new mt(c.PROP_IS_REQUIRE, { prop: "beExchangeAssetPrealnum", ...n });
          if (d !== "1") throw new mt(c.SHOULD_BE, { to_compare_prop: `beExchangeAssetPrealnum ${d}`, to_target: "toExchangeAnyAsset", be_compare_prop: "1" });
          if (y) throw new mt(c.SHOULD_NOT_EXIST, { prop: "assetExchangeWeightRatio", ...n });
        }
        else {
          if (g !== "1") throw new mt(c.SHOULD_BE, { to_compare_prop: `toExchangeAssetPrealnum ${g}`, to_target: "toExchangeAnyAsset", be_compare_prop: "1", ...n });
          if (!d) throw new mt(c.PROP_IS_REQUIRE, { prop: "beExchangeAssetPrealnum", ...n });
          if (y) throw new mt(c.SHOULD_NOT_EXIST, { prop: "assetExchangeWeightRatio", ...n });
          if (!r.isValidAssetNumber(d)) throw new mt(c.PROP_IS_INVALID, { prop: "beExchangeAssetPrealnum", ...n });
          if (h === G.ASSETS) {
            if (d === "0") throw new mt(c.PROP_SHOULD_GT_FIELD, { prop: "beExchangeAssetPrealnum", field: "0", ...n });
          } else if (d !== "1") throw new mt(c.SHOULD_BE, { to_compare_prop: `beExchangeAssetPrealnum ${d}`, to_target: "toExchangeAnyAsset", be_compare_prop: "1" });
        }
        if (p === f) throw new mt(c.SHOULD_NOT_BE, { to_compare_prop: `toExchangeAssetType ${p}`, to_target: "toExchangeAny", be_compare_prop: f });
        if (a === G.ENTITY) await this.checkTaxInformation(n, _);
        else if (_) throw new mt(c.SHOULD_NOT_EXIST, { prop: "taxInformation", ...n });
      }
      init(e, t) {
        return ha.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, senderPublicKeyBuffer: o, signature: a } = e, { toExchangeChainName: p, toExchangeSource: h, toExchangeParentAssetType: f, toExchangeAssetType: g, toExchangeAssetPrealnum: d, taxInformation: y } = e.asset.toExchangeAny;
          if (f === G.ASSETS) {
            const _ = this.chainAssetInfoHelper.getAssetInfo(p, h, g);
            n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, assetInfo: _, amount: `-${d}`, sourceAmount: d, maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), frozenId: a, frozenReason: ht.EXCHANGE } });
          } else if (f === G.DAPP) n.next = t.emit("frozenDAppid", { type: "frozenDAppid", transaction: e, applyInfo: { address: s, sourceChainName: p, sourceChainMagic: h, dappid: g, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } });
          else if (f === G.LOCATION_NAME) n.next = t.emit("frozenLocationName", { type: "frozenLocationName", transaction: e, applyInfo: { address: s, sourceChainName: p, sourceChainMagic: h, name: g, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } });
          else if (f === G.ENTITY) {
            if (n.next = t.emit("frozenEntity", { type: "frozenEntity", transaction: e, applyInfo: { address: s, sourceChainName: p, sourceChainMagic: h, entityId: g, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } }), y) {
              n.next = t.emit("payTax", { type: "payTax", transaction: e, applyInfo: { sourceChainName: p, sourceChainMagic: h, parentAssetType: f, assetType: g, taxInformation: y.toJSON() } });
              const { taxAssetPrealnum: _ } = y;
              if (_ !== "0") {
                const I = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
                n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, assetInfo: I, amount: `-${_}`, sourceAmount: _, maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), frozenId: a, frozenReason: ht.EXCHANGE } });
              }
            }
          } else if (f === G.CERTIFICATE) n.next = t.emit("frozenCertificate", { type: "frozenCertificate", transaction: e, applyInfo: { address: s, sourceChainName: p, sourceChainMagic: h, certificateId: g, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } });
          else throw new mt(c.PROP_IS_INVALID, { prop: `toExchangeParentAssetType ${f}`, target: "transaction.asset.toExchangeAny" });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { magic: r, assetType: n } = t, { toExchangeSource: s, toExchangeAssetType: o, toExchangeAssetPrealnum: a } = e.asset.toExchangeAny;
        return r === s && n === o ? a : "0";
      }
    };
    ul = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], ul);
    const { ArgumentIllegalException: Pt } = ee("CONTROLLER", "BeExchangeAnyTransactionFactory");
    let Lh = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.toExchangeAnyTransactionFactory = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new Pt(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Pt(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Pt(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Pt(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "transactionSignature") throw new Pt(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "transactionSignature", ...n });
        const p = t.beExchangeAny;
        if (!p) throw new Pt(c.PARAM_LOST, { param: "beExchangeAny" });
        const h = { ...n, target: "beExchangeAny" }, { transactionSignature: f } = p;
        if (!f) throw new Pt(c.PROP_IS_REQUIRE, { prop: "transactionSignature", ...h });
        if (!s.isValidSignature(f)) throw new Pt(c.PROP_IS_INVALID, { prop: `transactionSignature ${f}`, type: "transaction signature", ...h });
        if (a.value !== f) throw new Pt(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `transactionSignature ${f}`, to_target: "storage", be_target: "beExchangeAny", ...n });
        const { toExchangeAssetPrealnum: g, beExchangeAssetPrealnum: d } = p;
        if (!g) throw new Pt(c.PROP_IS_REQUIRE, { prop: "toExchangeAssetPrealnum", ...h });
        if (!s.isValidAssetNumber(g)) throw new Pt(c.PROP_IS_INVALID, { prop: "toExchangeAssetPrealnum", type: "asset prealnum", ...h });
        if (!d) throw new Pt(c.PROP_IS_REQUIRE, { prop: "beExchangeAssetPrealnum", ...h });
        if (!s.isValidAssetNumber(d)) throw new Pt(c.PROP_IS_INVALID, { prop: "beExchangeAssetPrealnum", type: "asset prealnum", ...h });
        const { exchangeAny: y, ciphertextSignature: _ } = p;
        await this.toExchangeAnyTransactionFactory.verifyToExchangeAny(y);
        const { beExchangeParentAssetType: I } = y;
        if (BigInt(g) > BigInt(y.toExchangeAssetPrealnum)) throw new Pt(c.PROP_SHOULD_LTE_FIELD, { prop: `toExchangeAssetPrealnum ${g}`, field: y.toExchangeAssetPrealnum, ...h });
        if (I === G.ENTITY) await this.checkTaxInformation(h, p.taxInformation);
        else if (p.taxInformation) throw new Pt(c.SHOULD_NOT_EXIST, { prop: "taxInformation", ...h });
        const { cipherPublicKeys: S } = y;
        if (S.length > 0) {
          if (!_) throw new Pt(c.NOT_EXIST, { prop: `ciphertextSignature ${_}`, ...h });
          if (!s.isValidAccountSignature(_)) throw new Pt(c.PROP_IS_INVALID, { prop: `ciphertextSignature ${_}`, ...h });
          const { signature: w, publicKey: N } = _;
          if (!S.includes(N)) throw new Pt(c.NOT_MATCH, { to_compare_prop: `publicKey ${N}`, be_compare_prop: "cipherPublicKeys", to_target: "ciphertextSignature", be_target: "cipherPublicKeys", ...h });
          if (!await this.transactionHelper.verifyCiphertextSignature({ secretPublicKey: _e(N), ciphertextSignatureBuffer: _e(w), transactionSignatureBuffer: _e(f), senderId: e.senderId })) throw new Pt(c.PROP_IS_INVALID, { prop: `ciphertextSignature ${w}`, type: "signature", ...h });
        } else if (_) throw new Pt(c.SHOULD_NOT_EXIST, { prop: `ciphertextSignature ${_}`, ...h });
      }
      init(e, t) {
        return kp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, recipientId: o, senderPublicKeyBuffer: a } = e, { exchangeAny: p, toExchangeAssetPrealnum: h, beExchangeAssetPrealnum: f, taxInformation: g, transactionSignature: d } = e.asset.beExchangeAny, { toExchangeChainName: y, toExchangeSource: _, toExchangeParentAssetType: I, toExchangeAssetType: S, beExchangeChainName: w, beExchangeSource: N, beExchangeParentAssetType: B, beExchangeAssetType: O } = p;
          if (I === G.ASSETS) {
            const P = this.chainAssetInfoHelper.getAssetInfo(y, _, S);
            n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, assetInfo: P, amount: h, sourceAmount: h, recipientId: o, frozenId: d, frozenReason: ht.EXCHANGE } });
          } else {
            let P = s;
            if (h === "0" && (P = o), I === G.DAPP) n.next = t.emit("unfrozenDAppid", { type: "unfrozenDAppid", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: P, sourceChainName: y, sourceChainMagic: _, dappid: S, status: 0, frozenId: d } });
            else if (I === G.LOCATION_NAME) n.next = t.emit("unfrozenLocationName", { type: "unfrozenLocationName", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: P, sourceChainName: y, sourceChainMagic: _, name: S, status: 0, frozenId: d } });
            else if (I === G.ENTITY) {
              if (n.next = t.emit("unfrozenEntity", { type: "unfrozenEntity", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: P, sourceChainName: y, sourceChainMagic: _, entityId: S, status: 0, frozenId: d } }), p.taxInformation) {
                const { taxCollector: C, taxAssetPrealnum: V } = p.taxInformation, F = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
                V === "0" ? n.next = this._applyTransactionEmitAsset(t, e, V, { senderId: s, senderPublicKeyBuffer: a, recipientId: C, assetInfo: F }) : n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: C, publicKeyBuffer: a, assetInfo: F, amount: V, sourceAmount: V, frozenId: d, recipientId: o, frozenReason: ht.EXCHANGE } });
              }
            } else if (I === G.CERTIFICATE) n.next = t.emit("unfrozenCertificate", { type: "unfrozenCertificate", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: P, sourceChainName: y, sourceChainMagic: _, certificateId: S, status: 0, frozenId: d } });
            else throw new Pt(c.PROP_IS_INVALID, { prop: `toExchangeParentAssetType ${I}`, target: "transaction.asset.beExchangeAny.exchangeAny" });
          }
          if (B === G.ENTITY && g && (n.next = t.emit("payTax", { type: "payTax", transaction: e, applyInfo: { sourceChainName: w, sourceChainMagic: N, parentAssetType: B, assetType: O, taxInformation: g.toJSON() } })), f === "0") {
            if (g) {
              const P = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
              n.next = this._applyTransactionEmitAsset(t, e, "0", { senderId: s, senderPublicKeyBuffer: a, recipientId: g.taxCollector, assetInfo: P });
            }
            return;
          }
          if (B === G.ASSETS) {
            const P = this.chainAssetInfoHelper.getAssetInfo(w, N, O);
            n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, assetInfo: P, amount: `-${f}`, sourceAmount: f } }), n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: o, assetInfo: P, amount: f, sourceAmount: f } });
          } else if (B === G.DAPP) n.next = t.emit("changeDAppidPossessor", { type: "changeDAppidPossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: w, sourceChainMagic: N, dappid: O } });
          else if (B === G.LOCATION_NAME) n.next = t.emit("changeLocationNamePossessor", { type: "changeLocationNamePossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: w, sourceChainMagic: N, name: O } });
          else if (B === G.ENTITY) {
            if (n.next = t.emit("changeEntityPossessor", { type: "changeEntityPossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: w, sourceChainMagic: N, entityId: O } }), g) {
              const P = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
              n.next = this._applyTransactionEmitAsset(t, e, g.taxAssetPrealnum, { senderId: s, senderPublicKeyBuffer: a, recipientId: g.taxCollector, assetInfo: P });
            }
          } else if (B === G.CERTIFICATE) n.next = t.emit("changeCertificatePossessor", { type: "changeCertificatePossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: w, sourceChainMagic: N, certificateId: O } });
          else throw new Pt(c.PROP_IS_INVALID, { prop: `beExchangeParentAssetType ${B}`, target: "transaction.asset.beExchangeAny.exchangeAny" });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { magic: r, assetType: n } = t, { exchangeAny: s, toExchangeAssetPrealnum: o, beExchangeAssetPrealnum: a } = e.asset.beExchangeAny, { toExchangeSource: p, beExchangeSource: h, toExchangeAssetType: f, beExchangeAssetType: g } = s;
        return r === p && n === f ? o : r === h && n === g ? a : "0";
      }
    };
    Lh = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, ul])], Lh);
    const { ArgumentIllegalException: Mt } = ee("CONTROLLER", "IssueEntityMultiTransactionV1");
    let Hh = class extends Ge {
      constructor(e, t, r, n, s, o, a) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.jsbiHelper = o, this.issueEntityFactoryTransactionFactory = a;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new Mt(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Mt(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Mt(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Mt(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "factoryId") throw new Mt(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "factoryId", ...n });
        const p = t.issueEntityMulti;
        if (!p) throw new Mt(c.PARAM_LOST, { param: "issueEntityMulti" });
        const h = { ...n, target: "issueEntityMultiAsset" }, { sourceChainName: f, sourceChainMagic: g, entityStructList: d, entityFactoryPossessor: y, entityFactory: _ } = p;
        if (this.issueEntityFactoryTransactionFactory.verifyIssueEntityFactoryAsset(_), f !== r.chainName) throw new Mt(c.SHOULD_BE, { to_compare_prop: `sourceChainName ${f}`, to_target: "body", be_compare_prop: "local chain name", ...n });
        if (g !== r.magic) throw new Mt(c.SHOULD_BE, { to_compare_prop: `sourceChainMagic ${f}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!y) throw new Mt(c.PROP_IS_REQUIRE, { prop: "entityFactoryPossessor", ...n });
        if (!await this.accountBaseHelper.isAddress(y)) throw new Mt(c.PROP_IS_INVALID, { prop: `entityFactoryPossessor ${y}`, type: "account address", ...n, target: "issueEntityMulti" });
        const I = d.length;
        if (!(s.isArray(d) && I > 0)) throw new Mt(c.PROP_IS_INVALID, { prop: `entityStructList ${JSON.stringify(d)}`, ...n, target: "issueEntityMulti" });
        const S = _.factoryId, w = /* @__PURE__ */ new Set();
        for (const { entityId: N, taxAssetPrealnum: B } of d) {
          if (!N) throw new Mt(c.PROP_IS_REQUIRE, { prop: "entityId", ...h });
          w.add(N);
          const O = N.split("_");
          if (O.length !== 3) throw new Mt(c.PROP_IS_INVALID, { prop: `entityId ${N}`, target: "issueEntityMulti.entityStructList" });
          if (O[0] !== "m") throw new Mt(c.SHOULD_BE, { to_compare_prop: `entityId first item ${O[0]}`, be_compare_prop: "m", to_target: "issueEntityMulti.entityStructList" });
          if (!s.isValidEntityFactoryId(O[1])) throw new Mt(c.PROP_IS_INVALID, { prop: `factoryId ${O[0]}`, target: "issueEntityMulti.entityStructList" });
          if (O[1] !== S) throw new Mt(c.NOT_MATCH, { to_compare_prop: `factoryId ${O[1]}`, be_compare_prop: `factoryId ${S}`, to_target: "entityId", be_target: "entityFactory", ...n });
          const P = O[2].length;
          if (P < 3 || P > 30) throw new Mt(c.NOT_IN_EXPECTED_RANGE, { prop: `entityId ${O[2]}`, min: 3, max: 30, target: "issueEntityMulti.entityStructList" });
          if (!s.isLowerCaseLetterOrNumber(O[2])) throw new Mt(c.PROP_IS_INVALID, { prop: `entityId ${O[2]}`, target: "issueEntityMulti.entityStructList" });
          if (!B) throw new Mt(c.PROP_IS_REQUIRE, { prop: "taxAssetPrealnum", target: "issueEntityMulti.entityStructList" });
          if (!this.baseHelper.isValidAssetPrealnum(B)) throw new Mt(c.PROP_IS_INVALID, { prop: `taxAssetPrealnum ${B}`, target: `issueEntityMulti.entityStructList ${N}` });
        }
        if (w.size < I) throw new Mt(c.SHOULD_NOT_DUPLICATE, { prop: `entityStructList ${JSON.stringify(d)}`, target: "issueEntityMulti" });
        if (a.value !== S) throw new Mt(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `factoryId ${S}`, to_target: "storage", be_target: "issueEntityMultiAsset", ...n });
      }
      init(e, t) {
        return Ji.fromObject({ ...e, asset: t });
      }
      async applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          const { senderId: s, recipientId: o, senderPublicKeyBuffer: a, signature: p, fee: h } = e, { sourceChainName: f, sourceChainMagic: g, entityStructList: d, entityFactoryPossessor: y, entityFactory: _ } = e.asset.issueEntityMulti, { factoryId: I, entityFrozenAssetPrealnum: S, purchaseAssetPrealnum: w } = _;
          n.next = super.applyTransaction(e, t, r), n.next = t.emit("issueEntityMulti", { type: "issueEntityMulti", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, sourceChainName: f, sourceChainMagic: g, factoryId: I, entityStructList: d.map((O) => ({ ...O, taxAssetRecipientId: O.taxAssetRecipientId || s })), possessorAddress: o, entityFactoryPossessorAddress: y, entityFrozenAssetPrealnum: S, issueId: p, status: 0 } });
          const N = d.length, B = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
          if (S !== "0") {
            const O = (BigInt(S) * BigInt(N)).toString();
            n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, assetInfo: B, amount: `-${O}`, sourceAmount: O, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), totalUnfrozenTimes: N, frozenId: p, frozenReason: ht.ENTITY } });
          }
          n.next = this._applyTransactionEmitAsset(t, e, (BigInt(w) * BigInt(N)).toString(), { senderId: s, senderPublicKeyBuffer: a, recipientId: y, assetInfo: B });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { entityStructList: r, entityFactory: n } = e.asset.issueEntityMulti, { sourceChainMagic: s, entityFrozenAssetPrealnum: o, purchaseAssetPrealnum: a } = n;
        if (t.magic === s && t.assetType === this.configHelper.assetType) {
          const p = r.length;
          return (BigInt(o) * BigInt(p) + BigInt(a) * BigInt(p)).toString();
        }
        return "0";
      }
    };
    Hh = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, xt, ho])], Hh);
    const { ArgumentIllegalException: ot } = ee("CONTROLLER", "ToExchangeAnyMultiTransactionFactory");
    let vh = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.Buffer = e, this.accountBaseHelper = t, this.transactionHelper = r, this.baseHelper = n, this.configHelper = s, this.chainAssetInfoHelper = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (e.recipientId) throw new ot(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new ot(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new ot(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        const s = t.toExchangeAnyMulti;
        if (!s) throw new ot(c.PARAM_LOST, { param: "toExchangeAnyMulti", ...n });
        const o = s.cipherPublicKeys, a = new Set(o);
        if (o.length !== a.size) throw new ot(c.SHOULD_NOT_DUPLICATE, { prop: "cipherPublicKeys", target: "toExchangeAnyMulti" });
        if (!this.baseHelper.isValidCipherPublicKeys(o)) throw new ot(c.PROP_IS_INVALID, { prop: "toExchangeAnyMulti.cipherPublicKeys", target: "toExchangeAnyMulti" });
        const { toExchangeAssets: p, beExchangeAsset: h } = s, f = await this.verifyToExchangeAnyMulti("toExchangeAnyMulti", p, h, r);
        for (const d of p) if (d.toExchangeAssetPrealnum === "0") throw new ot(c.PROP_SHOULD_GT_FIELD, { prop: "toExchangeAssetPrealnum", field: "0", target: "toExchangeAnyMulti.toExchangeAssets.toExchangeAsset" });
        const g = h.beExchangeAssetPrealnum;
        if (f) {
          if (h.beExchangeParentAssetType !== G.ASSETS) {
            if (g !== "1") throw new ot(c.SHOULD_BE, { to_compare_prop: `beExchangeAssetPrealnum ${g}`, to_target: "toExchangeAnyMulti.beExchangeAsset", be_compare_prop: "1" });
          } else if (g === "0") throw new ot(c.PROP_SHOULD_GT_FIELD, { prop: `beExchangeAssetPrealnum ${g}`, target: "toExchangeAnyMulti.beExchangeAsset", field: "0" });
        } else if (g) throw new ot(c.SHOULD_NOT_EXIST, { prop: "beExchangeAssetPrealnum", target: "toExchangeAnyMulti.beExchangeAsset" });
        if (e.storage) throw new ot(c.SHOULD_NOT_EXIST, { prop: "storage", ...n });
      }
      async verifyToExchangeAnyMulti(e, t, r, n = this.configHelper) {
        const { baseHelper: s } = this;
        if (!t) throw new ot(c.PARAM_LOST, { param: `${e}.toExchangeAssets` });
        if (!r) throw new ot(c.PARAM_LOST, { param: `${e}.beExchangeAsset` });
        if (t.length <= 0) throw new ot(c.PROP_LENGTH_SHOULD_GT_FIELD, { prop: "toExchangeAssets", target: e, field: 0 });
        const { beExchangeChainName: o, beExchangeSource: a, beExchangeParentAssetType: p, beExchangeAssetType: h, beExchangeAssetPrealnum: f } = r, g = { target: `${e}.beExchangeAsset` }, d = this.configHelper.magic;
        this.checkParentAssetType(p, "beExchangeParentAssetType", g), a === d && (this.checkChainName(o, "beExchangeChainName", g), this.checkChainMagic(a, "beExchangeSource", g), this.checkAssetType(p, h, "beExchangeAssetType", g));
        let y = false, _ = /* @__PURE__ */ new Set();
        const I = { target: `${e}.toExchangeAssets.toExchangeAsset` };
        for (const S of t) {
          const { toExchangeChainName: w, toExchangeSource: N, toExchangeParentAssetType: B, toExchangeAssetType: O, toExchangeAssetPrealnum: P, assetExchangeWeightRatio: C, taxInformation: V } = S;
          if (_.has(O)) throw new ot(c.SHOULD_NOT_DUPLICATE, { prop: `toExchangeAssets ${JSON.stringify(t)}`, target: e });
          if (_.add(O), this.checkParentAssetType(B, "toExchangeParentAssetType", I), N === d && (this.checkChainName(w, "toExchangeChainName", I), this.checkChainMagic(N, "toExchangeSource", I), this.checkAssetType(B, O, "toExchangeAssetType", I)), !P) throw new ot(c.PROP_IS_REQUIRE, { prop: "toExchangeAssetPrealnum", ...I });
          if (!s.isValidAssetNumber(P)) throw new ot(c.PROP_IS_INVALID, { prop: "toExchangeAssetPrealnum", ...I });
          if (B === G.ENTITY) await this.checkTaxInformation(I, V);
          else if (V) throw new ot(c.SHOULD_NOT_EXIST, { prop: "taxInformation", ...I });
          if (B !== G.ASSETS) {
            if (y = true, P !== "1") throw new ot(c.SHOULD_BE, { to_compare_prop: `toExchangeAssetPrealnum ${P}`, to_target: "toExchangeAnyMulti.toExchangeAssets", be_compare_prop: "1" });
            if (C) throw new ot(c.SHOULD_NOT_EXIST, { prop: "assetExchangeWeightRatio", ...I });
          } else if (p === G.ASSETS) {
            if (!C) throw new ot(c.PROP_IS_REQUIRE, { prop: "assetExchangeWeightRatio", ...I });
            if (!s.isValidAssetExchangeWeightRatio(C)) throw new ot(c.PROP_IS_INVALID, { prop: `assetExchangeWeightRatio ${C}`, ...I });
          } else {
            if (C) throw new ot(c.SHOULD_NOT_EXIST, { prop: "assetExchangeWeightRatio", ...I });
            y = true;
          }
        }
        if (_.has(h)) throw new ot(c.SHOULD_NOT_BE, { to_compare_prop: `beExchangeAssetType ${h}`, to_target: "toExchangeAsset", be_compare_prop: h });
        if (y) {
          if (!f) throw new ot(c.PROP_IS_REQUIRE, { prop: "beExchangeAssetPrealnum", ...g });
          if (!s.isValidAssetNumber(f)) throw new ot(c.PROP_IS_INVALID, { prop: "beExchangeAssetPrealnum", ...g });
        }
        if (p === G.ENTITY) await this.checkTaxInformation(g, r.taxInformation);
        else if (r.taxInformation) throw new ot(c.SHOULD_NOT_EXIST, { prop: "taxInformation", target: `${e}.toExchangeAssets.beExchangeAsset` });
        return y;
      }
      init(e, t) {
        return ua.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, senderPublicKeyBuffer: o, signature: a } = e, { toExchangeAssets: p, beExchangeAsset: h } = e.asset.toExchangeAnyMulti;
          let f = BigInt(0);
          for (const g of p) {
            const { toExchangeSource: d, toExchangeChainName: y, toExchangeParentAssetType: _, toExchangeAssetType: I, toExchangeAssetPrealnum: S, taxInformation: w } = g;
            if (_ === G.ASSETS) {
              const N = this.chainAssetInfoHelper.getAssetInfo(y, d, I);
              n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, assetInfo: N, amount: `-${S}`, sourceAmount: S, maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), frozenId: a, frozenReason: ht.EXCHANGE } });
            } else if (_ === G.DAPP) n.next = t.emit("frozenDAppid", { type: "frozenDAppid", transaction: e, applyInfo: { address: s, sourceChainName: y, sourceChainMagic: d, dappid: I, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } });
            else if (_ === G.LOCATION_NAME) n.next = t.emit("frozenLocationName", { type: "frozenLocationName", transaction: e, applyInfo: { address: s, sourceChainName: y, sourceChainMagic: d, name: I, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } });
            else if (_ === G.ENTITY) {
              if (n.next = t.emit("frozenEntity", { type: "frozenEntity", transaction: e, applyInfo: { address: s, sourceChainName: y, sourceChainMagic: d, entityId: I, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } }), w) {
                n.next = t.emit("payTax", { type: "payTax", transaction: e, applyInfo: { sourceChainName: y, sourceChainMagic: d, parentAssetType: _, assetType: I, taxInformation: w.toJSON() } });
                const { taxAssetPrealnum: N } = w;
                N !== "0" && (f += BigInt(w.taxAssetPrealnum));
              }
            } else if (_ === G.CERTIFICATE) n.next = t.emit("frozenCertificate", { type: "frozenCertificate", transaction: e, applyInfo: { address: s, sourceChainName: y, sourceChainMagic: d, certificateId: I, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } });
            else throw new ot(c.PROP_IS_INVALID, { prop: `toExchangeParentAssetType ${_}`, target: "transaction.asset.toExchangeAnyMulti" });
          }
          if (f !== BigInt(0)) {
            const g = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
            n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, assetInfo: g, amount: `-${f.toString()}`, sourceAmount: f.toString(), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), frozenId: a + this.Buffer.from("_entity").toString("hex"), frozenReason: ht.EXCHANGE } });
          }
          h.taxInformation && (n.next = t.emit("payTax", { type: "payTax", transaction: e, applyInfo: { sourceChainName: h.beExchangeChainName, sourceChainMagic: h.beExchangeSource, parentAssetType: h.beExchangeParentAssetType, assetType: h.beExchangeAssetType, taxInformation: h.taxInformation.toJSON() } }));
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { magic: r, assetType: n } = t, s = e.asset.toExchangeAnyMulti.toExchangeAssets;
        for (const o of s) {
          const { toExchangeSource: a, toExchangeAssetType: p, toExchangeAssetPrealnum: h } = o;
          if (r === a && n === p) return h;
        }
        return "0";
      }
    };
    vh = l([J(), be(0, D("Buffer")), u("design:paramtypes", [Object, me, Ee, Be, ne, ve])], vh);
    const { ArgumentIllegalException: st } = ee("CONTROLLER", "BeExchangeAnyMultiTransactionFactory");
    let kh = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.Buffer = e, this.accountBaseHelper = t, this.transactionHelper = r, this.baseHelper = n, this.configHelper = s, this.chainAssetInfoHelper = o;
      }
      async verifyToExchangeAnyMulti(e, t, r, n = this.configHelper) {
        const { baseHelper: s } = this;
        if (!t) throw new st(c.PARAM_LOST, { param: `${e}.toExchangeAssets` });
        if (!r) throw new st(c.PARAM_LOST, { param: `${e}.beExchangeAsset` });
        if (t.length <= 0) throw new st(c.PROP_LENGTH_SHOULD_GT_FIELD, { prop: "toExchangeAssets", target: e, field: 0 });
        const { beExchangeChainName: o, beExchangeSource: a, beExchangeParentAssetType: p, beExchangeAssetType: h, beExchangeAssetPrealnum: f } = r, g = { target: `${e}.beExchangeAsset` }, d = this.configHelper.magic;
        this.checkParentAssetType(p, "beExchangeParentAssetType", g), a === d && (this.checkChainName(o, "beExchangeChainName", g), this.checkChainMagic(a, "beExchangeSource", g), this.checkAssetType(p, h, "beExchangeAssetType", g));
        let y = false, _ = /* @__PURE__ */ new Set();
        const I = { target: `${e}.toExchangeAssets.toExchangeAsset` };
        for (const S of t) {
          const { toExchangeChainName: w, toExchangeSource: N, toExchangeParentAssetType: B, toExchangeAssetType: O, toExchangeAssetPrealnum: P, assetExchangeWeightRatio: C, taxInformation: V } = S;
          if (_.has(O)) throw new st(c.SHOULD_NOT_DUPLICATE, { prop: `toExchangeAssets ${JSON.stringify(t)}`, target: e });
          if (_.add(O), this.checkParentAssetType(B, "toExchangeParentAssetType", I), N === d && (this.checkChainName(w, "toExchangeChainName", I), this.checkChainMagic(N, "toExchangeSource", I), this.checkAssetType(B, O, "toExchangeAssetType", I)), !P) throw new st(c.PROP_IS_REQUIRE, { prop: "toExchangeAssetPrealnum", ...I });
          if (!s.isValidAssetNumber(P)) throw new st(c.PROP_IS_INVALID, { prop: "toExchangeAssetPrealnum", ...I });
          if (B === G.ENTITY) await this.checkTaxInformation(I, V);
          else if (V) throw new st(c.SHOULD_NOT_EXIST, { prop: "taxInformation", ...I });
          if (B !== G.ASSETS) {
            if (y = true, C) throw new st(c.SHOULD_NOT_EXIST, { prop: "assetExchangeWeightRatio", ...I });
            if (p !== G.ASSETS && h === O) throw new st(c.SHOULD_NOT_BE, { to_compare_prop: `beExchangeAssetType ${h}`, to_target: "toExchangeAnyMulti.beExchangeAsset", be_compare_prop: O });
          } else if (p === G.ASSETS) {
            if (!C) throw new st(c.PROP_IS_REQUIRE, { prop: "assetExchangeWeightRatio", ...I });
            if (!s.isValidAssetExchangeWeightRatio(C)) throw new st(c.PROP_IS_INVALID, { prop: `assetExchangeWeightRatio ${C}`, ...I });
          } else {
            if (C) throw new st(c.SHOULD_NOT_EXIST, { prop: "assetExchangeWeightRatio", ...I });
            y = true;
          }
        }
        if (y) {
          if (!f) throw new st(c.PROP_IS_REQUIRE, { prop: "beExchangeAssetPrealnum", ...g });
          if (!s.isValidAssetNumber(f)) throw new st(c.PROP_IS_INVALID, { prop: "beExchangeAssetPrealnum", ...g });
        }
        return y;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new st(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new st(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new st(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new st(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "transactionSignature") throw new st(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "transactionSignature", ...n });
        const p = t.beExchangeAnyMulti;
        if (!p) throw new st(c.PARAM_LOST, { param: "beExchangeAnyMulti" });
        const h = { ...n, target: "beExchangeAnyMulti" }, { transactionSignature: f } = p;
        if (!f) throw new st(c.PROP_IS_REQUIRE, { prop: "transactionSignature", ...h });
        if (!s.isValidSignature(f)) throw new st(c.PROP_IS_INVALID, { prop: `transactionSignature ${f}`, type: "transaction signature", ...h });
        if (a.value !== f) throw new st(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `transactionSignature ${f}`, to_target: "storage", be_target: "beExchangeAnyMulti", ...n });
        const { toExchangeAssets: g, beExchangeAsset: d, ciphertextSignature: y } = p;
        await this.verifyToExchangeAnyMulti("beExchangeAnyMulti", g, d, r);
        const { beExchangeParentAssetType: _, beExchangeAssetPrealnum: I, taxInformation: S } = d;
        if (!I) throw new st(c.PROP_IS_REQUIRE, { prop: "beExchangeAsset.beExchangeAssetPrealnum", ...h });
        if (_ === G.ENTITY) await this.checkTaxInformation(h, S);
        else if (S) throw new st(c.SHOULD_NOT_EXIST, { prop: "beExchangeAsset.taxInformation", ...h });
        if (y) {
          if (!s.isValidAccountSignature(y)) throw new st(c.PROP_IS_INVALID, { prop: `ciphertextSignature ${y}`, ...h });
          const { signature: w, publicKey: N } = y;
          if (!await this.transactionHelper.verifyCiphertextSignature({ secretPublicKey: _e(N), ciphertextSignatureBuffer: _e(w), transactionSignatureBuffer: _e(f), senderId: e.senderId })) throw new st(c.PROP_IS_INVALID, { prop: `ciphertextSignature ${w}`, type: "signature", ...h });
        }
      }
      init(e, t) {
        return Dp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, recipientId: o, senderPublicKeyBuffer: a } = e, { toExchangeAssets: p, beExchangeAsset: h, transactionSignature: f } = e.asset.beExchangeAnyMulti, { beExchangeChainName: g, beExchangeSource: d, beExchangeParentAssetType: y, beExchangeAssetType: _, beExchangeAssetPrealnum: I } = h;
          let S = 0;
          for (const w of p) {
            const { toExchangeSource: N, toExchangeChainName: B, toExchangeParentAssetType: O, toExchangeAssetType: P, toExchangeAssetPrealnum: C, taxInformation: V } = w;
            if (O === G.ASSETS) {
              const F = this.chainAssetInfoHelper.getAssetInfo(B, N, P);
              n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, assetInfo: F, amount: C, sourceAmount: C, frozenId: f, recipientId: o, frozenReason: ht.EXCHANGE } }), S++;
            } else {
              let F = s;
              if (C === "0" && (F = o), O === G.DAPP) n.next = t.emit("unfrozenDAppid", { type: "unfrozenDAppid", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: F, sourceChainName: B, sourceChainMagic: N, dappid: P, status: 0, frozenId: f } }), S++;
              else if (O === G.LOCATION_NAME) n.next = t.emit("unfrozenLocationName", { type: "unfrozenLocationName", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: F, sourceChainName: B, sourceChainMagic: N, name: P, status: 0, frozenId: f } }), S++;
              else if (O === G.ENTITY) {
                if (n.next = t.emit("unfrozenEntity", { type: "unfrozenEntity", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: F, sourceChainName: B, sourceChainMagic: N, entityId: P, status: 0, frozenId: f } }), S++, V) {
                  const { taxCollector: K, taxAssetPrealnum: L } = V, H = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
                  L === "0" ? n.next = this._applyTransactionEmitAsset(t, e, L, { senderId: s, senderPublicKeyBuffer: a, recipientId: K, assetInfo: H }) : n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: K, assetInfo: H, amount: L, sourceAmount: L, recipientId: o, frozenId: f + this.Buffer.from("_entity").toString("hex"), frozenReason: ht.EXCHANGE } });
                }
              } else if (O === G.CERTIFICATE) n.next = t.emit("unfrozenCertificate", { type: "unfrozenCertificate", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: F, sourceChainName: B, sourceChainMagic: N, certificateId: P, status: 0, frozenId: f } });
              else throw new st(c.PROP_IS_INVALID, { prop: `toExchangeParentAssetType ${O}`, target: "transaction.asset.beExchangeAnyMulti.toExchangeAsset" });
            }
          }
          if (y === G.ENTITY && h.taxInformation && (n.next = t.emit("payTax", { type: "payTax", transaction: e, applyInfo: { sourceChainName: g, sourceChainMagic: d, parentAssetType: y, assetType: _, taxInformation: h.taxInformation.toJSON() } })), I === "0") {
            if (h.taxInformation) {
              const w = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
              n.next = this._applyTransactionEmitAsset(t, e, "0", { senderId: s, senderPublicKeyBuffer: a, recipientId: h.taxInformation.taxCollector, assetInfo: w });
            }
            return;
          }
          if (y === G.ASSETS) {
            const w = this.chainAssetInfoHelper.getAssetInfo(g, d, _), N = (BigInt(I) * BigInt(S)).toString();
            n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, assetInfo: w, amount: `-${N}`, sourceAmount: N } }), n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: o, assetInfo: w, amount: N, sourceAmount: N } });
          } else if (y === G.DAPP) n.next = t.emit("changeDAppidPossessor", { type: "changeDAppidPossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: g, sourceChainMagic: d, dappid: _ } });
          else if (y === G.LOCATION_NAME) n.next = t.emit("changeLocationNamePossessor", { type: "changeLocationNamePossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: g, sourceChainMagic: d, name: _ } });
          else if (y === G.ENTITY) {
            if (n.next = t.emit("changeEntityPossessor", { type: "changeEntityPossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: g, sourceChainMagic: d, entityId: _ } }), h.taxInformation) {
              const w = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
              n.next = this._applyTransactionEmitAsset(t, e, h.taxInformation.taxAssetPrealnum, { senderId: s, senderPublicKeyBuffer: a, recipientId: h.taxInformation.taxCollector, assetInfo: w });
            }
          } else if (y === G.CERTIFICATE) n.next = t.emit("changeCertificatePossessor", { type: "changeCertificatePossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: g, sourceChainMagic: d, certificateId: _ } });
          else throw new st(c.PROP_IS_INVALID, { prop: `beExchangeParentAssetType ${y}`, target: "transaction.asset.beExchangeAnyMulti.beExchangeAsset" });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { magic: r, assetType: n } = t, { toExchangeAssets: s, beExchangeAsset: o } = e.asset.beExchangeAnyMulti;
        for (const a of s) {
          const { toExchangeSource: p, toExchangeAssetType: h, toExchangeAssetPrealnum: f } = a;
          if (r === p && n === h) return f;
        }
        return r === o.beExchangeSource && n === o.beExchangeAssetType ? o.beExchangeAssetPrealnum : "0";
      }
    };
    kh = l([J(), be(0, D("Buffer")), u("design:paramtypes", [Object, me, Ee, Be, ne, ve])], kh);
    const { ArgumentIllegalException: _t } = ee("CONTROLLER", "ToExchangeAnyMultiAllTransactionFactory");
    let Dh = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.Buffer = e, this.accountBaseHelper = t, this.transactionHelper = r, this.baseHelper = n, this.configHelper = s, this.chainAssetInfoHelper = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (e.recipientId) throw new _t(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new _t(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new _t(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        const s = t.toExchangeAnyMultiAll;
        if (!s) throw new _t(c.PARAM_LOST, { param: "toExchangeAnyMultiAll", ...n });
        const o = s.cipherPublicKeys, a = new Set(o);
        if (o.length !== a.size) throw new _t(c.SHOULD_NOT_DUPLICATE, { prop: "cipherPublicKeys", target: "toExchangeAnyMultiAll" });
        if (!this.baseHelper.isValidCipherPublicKeys(o)) throw new _t(c.PROP_IS_INVALID, { prop: "cipherPublicKeys", target: "toExchangeAnyMultiAll" });
        const { toExchangeAssets: p, beExchangeAssets: h } = s;
        await this.verifyExchangeAnyMultiAll("toExchangeAnyMultiAll", p, h, r);
        for (const { beExchangeParentAssetType: f, beExchangeAssetPrealnum: g } of h) if (f === G.ASSETS) {
          if (g === "0") throw new _t(c.PROP_SHOULD_GT_FIELD, { prop: "beExchangeAssetPrealnum", field: "0", target: "toExchangeAnyMultiAll.beExchangeAssets.beExchangeAsset" });
        } else if (g !== "1") throw new _t(c.SHOULD_BE, { to_compare_prop: `beExchangeAssetPrealnum ${g}`, to_target: "toExchangeAnyMultiAll.beExchangeAssets.beExchangeAsset", be_compare_prop: "1" });
        if (e.storage) throw new _t(c.SHOULD_NOT_EXIST, { prop: "storage", ...n });
      }
      async verifyExchangeAnyMultiAll(e, t, r, n = this.configHelper) {
        const { baseHelper: s } = this;
        if (!t) throw new _t(c.PARAM_LOST, { param: `${e}.toExchangeAssets` });
        if (!r) throw new _t(c.PARAM_LOST, { param: `${e}.beExchangeAssets` });
        if (t.length <= 0) throw new _t(c.PROP_LENGTH_SHOULD_GT_FIELD, { prop: "toExchangeAssets", target: e, field: 0 });
        if (r.length <= 0) throw new _t(c.PROP_LENGTH_SHOULD_GT_FIELD, { prop: "beExchangeAssets", target: e, field: 0 });
        const o = this.configHelper.magic, a = /* @__PURE__ */ new Set(), p = { target: `${e}.toExchangeAssets.toExchangeAsset` };
        for (const g of t) {
          const { toExchangeChainName: d, toExchangeSource: y, toExchangeParentAssetType: _, toExchangeAssetType: I, toExchangeAssetPrealnum: S, taxInformation: w } = g, N = `${y}-${I}`;
          if (a.has(N)) throw new _t(c.SHOULD_NOT_DUPLICATE, { prop: `toExchangeAssets.toExchangeAsset ${JSON.stringify(g)}`, target: e });
          if (a.add(N), this.checkParentAssetType(_, "toExchangeParentAssetType", p), y === o && (this.checkChainName(d, "toExchangeChainName", p), this.checkChainMagic(y, "toExchangeSource", p), this.checkAssetType(_, I, "toExchangeAssetType", p)), !S) throw new _t(c.PROP_IS_REQUIRE, { prop: "toExchangeAssetPrealnum", ...p });
          if (!s.isValidAssetNumber(S)) throw new _t(c.PROP_IS_INVALID, { prop: "toExchangeAssetPrealnum", ...p });
          if (_ === G.ENTITY) await this.checkTaxInformation(p, w);
          else if (w) throw new _t(c.SHOULD_NOT_EXIST, { prop: "taxInformation", ...p });
          if (_ === G.ASSETS) {
            if (S === "0") throw new _t(c.PROP_SHOULD_GT_FIELD, { prop: "toExchangeAssetPrealnum", field: "0", target: `${e}.toExchangeAssets.toExchangeAsset` });
          } else if (S !== "1") throw new _t(c.SHOULD_BE, { to_compare_prop: `toExchangeAssetPrealnum ${S}`, to_target: `${e}.toExchangeAssets.toExchangeAsset`, be_compare_prop: "1" });
        }
        const h = { target: `${e}.beExchangeAssets.beExchangeAsset` }, f = /* @__PURE__ */ new Set();
        for (const g of r) {
          const { beExchangeChainName: d, beExchangeSource: y, beExchangeParentAssetType: _, beExchangeAssetType: I, beExchangeAssetPrealnum: S, taxInformation: w } = g, N = `${y}-${I}`;
          if (a.has(N)) throw new _t(c.SHOULD_NOT_BE, { to_compare_prop: `beExchangeAssetType ${I}`, to_target: "toExchangeAnyMultiAll.beExchangeAssets", be_compare_prop: I });
          if (f.has(N)) throw new _t(c.SHOULD_NOT_DUPLICATE, { prop: `beExchangeAssets.beExchangeAsset ${JSON.stringify(g)}`, target: e });
          if (f.add(N), this.checkParentAssetType(_, "beExchangeParentAssetType", h), y === o && (this.checkChainName(d, "beExchangeChainName", h), this.checkChainMagic(y, "beExchangeSource", h), this.checkAssetType(_, I, "beExchangeAssetType", h)), !S) throw new _t(c.PROP_IS_REQUIRE, { prop: "beExchangeAssetPrealnum", ...h });
          if (!s.isValidAssetNumber(S)) throw new _t(c.PROP_IS_INVALID, { prop: "beExchangeAssetPrealnum", ...h });
          if (_ === G.ENTITY) await this.checkTaxInformation(h, w);
          else if (w) throw new _t(c.SHOULD_NOT_EXIST, { prop: "taxInformation", target: `${e}.beExchangeAssets.beExchangeAsset` });
        }
      }
      init(e, t) {
        return fa.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, senderPublicKeyBuffer: o, signature: a } = e, { toExchangeAssets: p, beExchangeAssets: h } = e.asset.toExchangeAnyMultiAll;
          let f = BigInt(0);
          for (const g of p) {
            const { toExchangeSource: d, toExchangeChainName: y, toExchangeParentAssetType: _, toExchangeAssetType: I, toExchangeAssetPrealnum: S, taxInformation: w } = g;
            if (_ === G.ASSETS) {
              const N = this.chainAssetInfoHelper.getAssetInfo(y, d, I);
              n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, assetInfo: N, amount: `-${S}`, sourceAmount: S, maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), frozenId: a, frozenReason: ht.EXCHANGE } });
            } else if (_ === G.DAPP) n.next = t.emit("frozenDAppid", { type: "frozenDAppid", transaction: e, applyInfo: { address: s, sourceChainName: y, sourceChainMagic: d, dappid: I, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } });
            else if (_ === G.LOCATION_NAME) n.next = t.emit("frozenLocationName", { type: "frozenLocationName", transaction: e, applyInfo: { address: s, sourceChainName: y, sourceChainMagic: d, name: I, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } });
            else if (_ === G.ENTITY) {
              if (n.next = t.emit("frozenEntity", { type: "frozenEntity", transaction: e, applyInfo: { address: s, sourceChainName: y, sourceChainMagic: d, entityId: I, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } }), w) {
                n.next = t.emit("payTax", { type: "payTax", transaction: e, applyInfo: { sourceChainName: y, sourceChainMagic: d, parentAssetType: _, assetType: I, taxInformation: w.toJSON() } });
                const { taxAssetPrealnum: N } = w;
                N !== "0" && (f += BigInt(w.taxAssetPrealnum));
              }
            } else if (_ === G.CERTIFICATE) n.next = t.emit("frozenCertificate", { type: "frozenCertificate", transaction: e, applyInfo: { address: s, sourceChainName: y, sourceChainMagic: d, certificateId: I, minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), status: 17, frozenId: a } });
            else throw new _t(c.PROP_IS_INVALID, { prop: `toExchangeParentAssetType ${_}`, target: "toExchangeAnyMultiAll.toExchangeAssets.toExchangeAsset" });
          }
          if (f !== BigInt(0)) {
            const g = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
            n.next = t.emit("frozenAsset", { type: "frozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, assetInfo: g, amount: `-${f.toString()}`, sourceAmount: f.toString(), maxEffectiveHeight: this.transactionHelper.getTransactionMaxEffectiveHeight(e), minEffectiveHeight: this.transactionHelper.getTransactionMinEffectiveHeight(e), frozenId: a + this.Buffer.from("_entity").toString("hex"), frozenReason: ht.EXCHANGE } });
          }
          for (const g of h) g.taxInformation && (n.next = t.emit("payTax", { type: "payTax", transaction: e, applyInfo: { sourceChainName: g.beExchangeChainName, sourceChainMagic: g.beExchangeSource, parentAssetType: g.beExchangeParentAssetType, assetType: g.beExchangeAssetType, taxInformation: g.taxInformation.toJSON() } }));
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { magic: r, assetType: n } = t, s = e.asset.toExchangeAnyMultiAll.toExchangeAssets;
        for (const o of s) {
          const { toExchangeSource: a, toExchangeAssetType: p, toExchangeAssetPrealnum: h } = o;
          if (r === a && n === p) return h;
        }
        return "0";
      }
    };
    Dh = l([J(), be(0, D("Buffer")), u("design:paramtypes", [Object, me, Ee, Be, ne, ve])], Dh);
    const { ArgumentIllegalException: Jr } = ee("CONTROLLER", "BeExchangeAnyMultiAllTransactionFactory");
    let gg = class extends Ge {
      constructor(e, t, r, n, s, o, a) {
        super(), this.Buffer = e, this.accountBaseHelper = t, this.transactionHelper = r, this.baseHelper = n, this.configHelper = s, this.chainAssetInfoHelper = o, this.toExchangeAnyMultiAllTransactionFactory = a;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (!e.recipientId) throw new Jr(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Jr(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Jr(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new Jr(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const a = e.storage;
        if (a.key !== "transactionSignature") throw new Jr(c.SHOULD_BE, { to_compare_prop: `storage.key ${a.key}`, to_target: "storage", be_compare_prop: "transactionSignature", ...n });
        const p = t.beExchangeAnyMultiAll;
        if (!p) throw new Jr(c.PARAM_LOST, { param: "beExchangeAnyMultiAll" });
        const h = { ...n, target: "beExchangeAnyMultiAll" }, { transactionSignature: f } = p;
        if (!f) throw new Jr(c.PROP_IS_REQUIRE, { prop: "transactionSignature", ...h });
        if (!s.isValidSignature(f)) throw new Jr(c.PROP_IS_INVALID, { prop: `transactionSignature ${f}`, type: "transaction signature", ...h });
        if (a.value !== f) throw new Jr(c.NOT_MATCH, { to_compare_prop: `storage.value ${a.value}`, be_compare_prop: `transactionSignature ${f}`, to_target: "storage", be_target: "beExchangeAnyMultiAll", ...n });
        const { toExchangeAssets: g, beExchangeAssets: d, ciphertextSignature: y } = p;
        if (await this.toExchangeAnyMultiAllTransactionFactory.verifyExchangeAnyMultiAll("beExchangeAnyMultiAll", g, d, r), y) {
          if (!s.isValidAccountSignature(y)) throw new Jr(c.PROP_IS_INVALID, { prop: `ciphertextSignature ${y}`, ...h });
          const { signature: _, publicKey: I } = y;
          if (!await this.transactionHelper.verifyCiphertextSignature({ secretPublicKey: _e(I), ciphertextSignatureBuffer: _e(_), transactionSignatureBuffer: _e(f), senderId: e.senderId })) throw new Jr(c.PROP_IS_INVALID, { prop: `ciphertextSignature ${_}`, type: "signature", ...h });
        }
      }
      init(e, t) {
        return Fp.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, recipientId: o, senderPublicKeyBuffer: a } = e, { toExchangeAssets: p, beExchangeAssets: h, transactionSignature: f } = e.asset.beExchangeAnyMultiAll;
          for (const g of p) {
            const { toExchangeSource: d, toExchangeChainName: y, toExchangeParentAssetType: _, toExchangeAssetType: I, toExchangeAssetPrealnum: S, taxInformation: w } = g;
            if (_ === G.ASSETS) {
              const N = this.chainAssetInfoHelper.getAssetInfo(y, d, I);
              n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, assetInfo: N, amount: S, sourceAmount: S, frozenId: f, recipientId: o, frozenReason: ht.EXCHANGE } });
            } else {
              const N = s;
              if (_ === G.DAPP) n.next = t.emit("unfrozenDAppid", { type: "unfrozenDAppid", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: N, sourceChainName: y, sourceChainMagic: d, dappid: I, status: 0, frozenId: f } });
              else if (_ === G.LOCATION_NAME) n.next = t.emit("unfrozenLocationName", { type: "unfrozenLocationName", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: N, sourceChainName: y, sourceChainMagic: d, name: I, status: 0, frozenId: f } });
              else if (_ === G.ENTITY) {
                if (n.next = t.emit("unfrozenEntity", { type: "unfrozenEntity", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: N, sourceChainName: y, sourceChainMagic: d, entityId: I, status: 0, frozenId: f } }), w) {
                  const { taxCollector: B, taxAssetPrealnum: O } = w, P = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
                  O === "0" ? n.next = this._applyTransactionEmitAsset(t, e, O, { senderId: s, senderPublicKeyBuffer: a, recipientId: B, assetInfo: P }) : n.next = t.emit("unfrozenAsset", { type: "unfrozenAsset", transaction: e, applyInfo: { address: B, assetInfo: P, amount: O, sourceAmount: O, recipientId: o, frozenId: f + this.Buffer.from("_entity").toString("hex"), frozenReason: ht.EXCHANGE } });
                }
              } else if (_ === G.CERTIFICATE) n.next = t.emit("unfrozenCertificate", { type: "unfrozenCertificate", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: N, sourceChainName: y, sourceChainMagic: d, certificateId: I, status: 0, frozenId: f } });
              else throw new Jr(c.PROP_IS_INVALID, { prop: `toExchangeParentAssetType ${_}`, target: "beExchangeAnyMultiAll.toExchangeAssets.toExchangeAsset" });
            }
          }
          for (const g of h) {
            const { beExchangeChainName: d, beExchangeSource: y, beExchangeParentAssetType: _, beExchangeAssetType: I, beExchangeAssetPrealnum: S, taxInformation: w } = g;
            if (_ === G.ENTITY && g.taxInformation && (n.next = t.emit("payTax", { type: "payTax", transaction: e, applyInfo: { sourceChainName: d, sourceChainMagic: y, parentAssetType: _, assetType: I, taxInformation: g.taxInformation.toJSON() } })), S === "0") {
              if (g.taxInformation) {
                const N = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
                n.next = this._applyTransactionEmitAsset(t, e, "0", { senderId: s, senderPublicKeyBuffer: a, recipientId: g.taxInformation.taxCollector, assetInfo: N });
              }
              continue;
            }
            if (_ === G.ASSETS) {
              const N = this.chainAssetInfoHelper.getAssetInfo(d, y, I), B = S;
              n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, assetInfo: N, amount: `-${B}`, sourceAmount: B } }), n.next = t.emit("asset", { type: "asset", transaction: e, applyInfo: { address: o, assetInfo: N, amount: B, sourceAmount: B } });
            } else if (_ === G.DAPP) n.next = t.emit("changeDAppidPossessor", { type: "changeDAppidPossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: d, sourceChainMagic: y, dappid: I } });
            else if (_ === G.LOCATION_NAME) n.next = t.emit("changeLocationNamePossessor", { type: "changeLocationNamePossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: d, sourceChainMagic: y, name: I } });
            else if (_ === G.ENTITY) {
              if (n.next = t.emit("changeEntityPossessor", { type: "changeEntityPossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: d, sourceChainMagic: y, entityId: I } }), w) {
                const N = this.chainAssetInfoHelper.getAssetInfo(r.chainName, r.magic, r.assetType);
                n.next = this._applyTransactionEmitAsset(t, e, w.taxAssetPrealnum, { senderId: s, senderPublicKeyBuffer: a, recipientId: w.taxCollector, assetInfo: N });
              }
            } else if (_ === G.CERTIFICATE) n.next = t.emit("changeCertificatePossessor", { type: "changeCertificatePossessor", transaction: e, applyInfo: { address: s, publicKeyBuffer: a, possessorAddress: o, sourceChainName: d, sourceChainMagic: y, certificateId: I } });
            else throw new Jr(c.PROP_IS_INVALID, { prop: `beExchangeParentAssetType ${_}`, target: "beExchangeAnyMultiAll.beExchangeAssets.beExchangeAsset" });
          }
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        const { magic: r, assetType: n } = t, { toExchangeAssets: s, beExchangeAssets: o } = e.asset.beExchangeAnyMultiAll;
        for (const a of s) {
          const { toExchangeSource: p, toExchangeAssetType: h, toExchangeAssetPrealnum: f } = a;
          if (r === p && n === h) return f;
        }
        for (const a of o) if (r === a.beExchangeSource && n === a.beExchangeAssetType) return a.beExchangeAssetPrealnum;
        return "0";
      }
    };
    gg = l([J(), be(0, D("Buffer")), u("design:paramtypes", [Object, me, Ee, Be, ne, ve, Dh])], gg);
    const { ArgumentIllegalException: un } = ee("CONTROLLER", "IssueCertificateTransactionFactory");
    let dg = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        this.emptyRangeType(e, n);
        const { baseHelper: s } = this;
        if (e.recipientId, !e.recipientId) throw new un(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new un(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new un(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new un(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const o = e.storage;
        if (o.key !== "certificateId") throw new un(c.SHOULD_BE, { to_compare_prop: `storage.key ${o.key}`, to_target: "storage", be_compare_prop: "certificateId", ...n });
        const a = t.issueCertificate;
        if (!a) throw new un(c.PARAM_LOST, { param: "issueCertificate" });
        const p = { ...n, target: "issueCertificateAsset" }, { sourceChainMagic: h, sourceChainName: f, certificateId: g, type: d } = a;
        if (this.checkChainName(f, "sourceChainName", p), f !== r.chainName) throw new un(c.SHOULD_BE, { to_compare_prop: `sourceChainName ${f}`, to_target: "body", be_compare_prop: "local chain name", ...n });
        if (this.checkChainMagic(h, "sourceChainMagic", p), h !== r.magic) throw new un(c.SHOULD_BE, { to_compare_prop: `sourceChainMagic ${f}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!g) throw new un(c.PROP_IS_REQUIRE, { prop: "certificateId", ...p });
        if (!s.isValidCertificateId(g)) throw new un(c.PROP_IS_INVALID, { prop: `certificateId ${g}`, ...p });
        if (d !== 0 && d !== 1 && d !== 2) throw new un(c.NOT_MATCH, { to_compare_prop: `type ${d}`, be_compare_prop: "type", to_target: "dapp", be_target: "CERTIFICATE_TYPE" });
        if (o.value !== g) throw new un(c.NOT_MATCH, { to_compare_prop: `storage.value ${o.value}`, be_compare_prop: `certificateId ${g}`, to_target: "storage", be_target: "issueCertificate", ...n });
      }
      init(e, t) {
        return $p.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, recipientId: o, senderPublicKeyBuffer: a } = e, { sourceChainName: p, sourceChainMagic: h, certificateId: f, type: g } = e.asset.issueCertificate;
          n.next = t.emit("issueCertificate", { type: "issueCertificate", transaction: e, applyInfo: { address: s, possessorAddress: o, publicKeyBuffer: a, sourceChainName: p, sourceChainMagic: h, certificateId: f, type: g, status: 0, issueId: e.signature } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        return "0";
      }
    };
    dg = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], dg);
    const { ArgumentIllegalException: es } = ee("CONTROLLER", "DestroyCertificateTransactionFactory");
    let yg = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), !e.recipientId) throw new es(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new es(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new es(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new es(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const o = e.storage;
        if (o.key !== "certificateId") throw new es(c.SHOULD_BE, { to_compare_prop: `storage.key ${o.key}`, to_target: "storage", be_compare_prop: "certificateId", ...n });
        const a = t.destroyCertificate;
        if (!a) throw new es(c.PARAM_LOST, { param: "destroyCertificate" });
        const p = { ...n, target: "destroyCertificateAsset" }, { sourceChainMagic: h, sourceChainName: f, certificateId: g, type: d } = a;
        if (f !== r.chainName) throw new es(c.SHOULD_BE, { to_compare_prop: "sourceChainName", to_target: "body", be_compare_prop: "local chain name", ...p });
        if (h !== r.magic) throw new es(c.SHOULD_BE, { to_compare_prop: "sourceChainMagic", to_target: "body", be_compare_prop: "local chain magic", ...p });
        if (!this.baseHelper.isValidCertificateId(g)) throw new es(c.PROP_IS_INVALID, { prop: `certificateId ${g}`, ...p });
        if (o.value !== g) throw new es(c.NOT_MATCH, { to_compare_prop: `storage.value ${o.value}`, be_compare_prop: `certificateId ${g}`, to_target: "storage", be_target: "destroyCertificate" });
      }
      init(e, t) {
        return Up.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { senderId: s, senderPublicKeyBuffer: o, recipientId: a } = e, { sourceChainMagic: p, sourceChainName: h, certificateId: f, type: g } = e.asset.destroyCertificate;
          n.next = t.emit("destroyCertificate", { type: "destroyCertificate", transaction: e, applyInfo: { address: s, possessorAddress: a, publicKeyBuffer: o, sourceChainName: h, sourceChainMagic: p, certificateId: f, status: 255 } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        return "0";
      }
    };
    yg = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], yg);
    const { ArgumentFormatException: pc, OutOfRangeException: QO, ConsensusException: Ym, warn: Qm } = ee("CONTROLLER", "transaction");
    let $t = class {
      constructor(e, t, r, n, s, o, a) {
        this.transactionHelper = e, this.accountBaseHelper = t, this.asymmetricHelper = r, this.keypairHelper = n, this.Buffer = s, this.config = o, this.moduleMap = a, this._txFactoryCache = /* @__PURE__ */ new Map(), this.fromJSON = this.recombineTransaction;
      }
      getTransactionFactory(e) {
        let t = this._txFactoryCache.get(e);
        return t || (t = bt(e, this.moduleMap), this._txFactoryCache.set(e, t)), t;
      }
      getTransactionFactoryFromType(e) {
        const { baseType: t } = this.transactionHelper.parseType(e);
        return this.getTransactionFactoryFromBaseType(t);
      }
      getTransactionFactoryFromBaseType(e) {
        const t = Mr.VF.get(e);
        if (!t) throw new pc(c.INVALID_BASE_TYPE, { base_type: e });
        return this.getTransactionFactory(t);
      }
      canCreateTransaction(e) {
        return this.transactionHelper.isTransactionInFilter(e);
      }
      get abortForbiddenTransaction() {
        return this.transactionHelper.abortForbiddenTransaction;
      }
      async createTransactionWithoutSignature(e, t, r, n = this.config) {
        const s = t.type || this.getTransactionTypeFromTransactionFactoryConstructor(e);
        if (!this.canCreateTransaction(s)) {
          const h = Re.VK.get(Re.trsTypeToV(s)), f = new Ym(c.DISABLED_CREATE_TRANSACTION, { trsName: h });
          if (this.abortForbiddenTransaction) throw f;
          Qm(f);
        }
        const o = this.getTransactionFactory(e);
        await o.verifyTransactionBody(t, r, n);
        const a = { version: t.version, type: t.type || this.getTransactionTypeFromTransactionFactoryConstructor(e), senderId: t.senderId, senderPublicKey: t.senderPublicKey, senderSecondPublicKey: t.senderSecondPublicKey, recipientId: t.recipientId || void 0, rangeType: t.rangeType, range: t.range, timestamp: t.timestamp, fee: t.fee, remark: t.remark, dappid: t.dappid || void 0, lns: t.lns || void 0, sourceIP: t.sourceIP || void 0, fromMagic: t.fromMagic, toMagic: t.toMagic, applyBlockHeight: t.applyBlockHeight, effectiveBlockHeight: t.effectiveBlockHeight, storage: t.storage };
        return o.init(a, r);
      }
      async createTransaction(e, t, r, n, s, o = this.config) {
        const a = t.type || this.getTransactionTypeFromTransactionFactoryConstructor(e);
        if (!this.canCreateTransaction(a)) {
          const g = Re.VK.get(Re.trsTypeToV(a)), d = new Ym(c.DISABLED_CREATE_TRANSACTION, { trsName: g });
          if (this.abortForbiddenTransaction) throw d;
          Qm(d);
        }
        const p = this.getTransactionFactory(e);
        p.verifyKeypair(n), s && p.verifySecondKeypair(s), await p.verifyTransactionBody(t, r, o);
        const h = { version: t.version, type: t.type || this.getTransactionTypeFromTransactionFactoryConstructor(e), senderId: t.senderId, senderPublicKey: t.senderPublicKey, senderSecondPublicKey: t.senderSecondPublicKey, recipientId: t.recipientId || void 0, rangeType: t.rangeType, range: t.range, timestamp: t.timestamp, fee: t.fee, remark: t.remark, dappid: t.dappid || void 0, lns: t.lns || void 0, sourceIP: t.sourceIP || void 0, fromMagic: t.fromMagic, toMagic: t.toMagic, applyBlockHeight: t.applyBlockHeight, effectiveBlockHeight: t.effectiveBlockHeight, storage: t.storage }, f = p.init(h, r);
        return f.signatureBuffer = await this.asymmetricHelper.detachedSign(f.getBytes(true, true), n.secretKey), s && (f.signSignatureBuffer = await this.asymmetricHelper.detachedSign(f.getBytes(false, true), s.secretKey)), this.transactionHelper.verifyTransactionSize(f), this.transactionHelper.verifyTransactionBlobSize(f), f;
      }
      async recombineTransaction(e) {
        return await this.getTransactionFactoryFromType(e.type).fromJSON(e);
      }
      recombineTransactionInBlock(e) {
        return qt.fromObject(e);
      }
      parseBytesToTransaction(e) {
        return Je.decode(e);
      }
      parseBytesToSomeTransaction(e) {
        const t = new Xr(e);
        t.uint32(), t.uint32(), t.uint32();
        const r = t.string();
        return this.getTransactionModelConstructorFromType(r).decode(e);
      }
      getTransactionModelConstructorFromType(e) {
        const { baseType: t } = this.transactionHelper.parseType(e);
        return this.getTransactionModelConstructorFromBaseType(t);
      }
      getTransactionModelConstructorFromBaseType(e) {
        const t = Re.VM.get(e);
        if (!t) throw new pc(c.INVALID_BASE_TYPE, { base_type: e });
        return t;
      }
      getTransactionTypeFromTransactionFactoryConstructor(e) {
        const t = Mr.FV.get(e);
        if (!t) throw new pc(c.UNREGISTERED_TRANSACTION_FACTORY, { factoryName: e.name });
        const r = Mr.VK.get(t);
        if (!r) throw new pc(c.UNREGISTERED_TRANSACTION_BASE_TYPE, { trs_base: t });
        const n = this.transactionHelper[r];
        if (!n) throw new pc(c.UNREGISTERED_TRANSACTION_TYPE, { trs_key: r });
        return n;
      }
      getMoveAmount(e, t = { magic: this.config.magic, assetType: this.config.assetType }) {
        return this.getTransactionFactoryFromType(e.type).getMoveAmount(e, t);
      }
    };
    $t = l([J("bfchain-core:TransactionCore"), be(3, D("keypairHelper")), be(4, D("Buffer")), u("design:paramtypes", [Ee, me, Or, Object, Object, ne, ze])], $t);
    const Mr = (() => {
      const i = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
      for (const n in v) {
        const s = v[n];
        e.set(n, s), i.set(s, n);
      }
      const t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
      return [[v.SIGNATURE, Ih], [v.DAPP, ll], [v.DAPP_PURCHASING, eg], [v.MARK, tg], [v.ISSUE_ASSET, rg], [v.INCREASE_ASSET, ng], [v.DESTROY_ASSET, bh], [v.TRANSFER_ASSET, Sh], [v.TO_EXCHANGE_ASSET, Nh], [v.BE_EXCHANGE_ASSET, sg], [v.GIFT_ASSET, Oh], [v.GRAB_ASSET, ig], [v.TRUST_ASSET, Rh], [v.SIGN_FOR_ASSET, og], [v.EMIGRATE_ASSET, ag], [v.IMMIGRATE_ASSET, cg], [v.STAKE_ASSET, Bh], [v.UNSTAKE_ASSET, pg], [v.LOCATION_NAME, lg], [v.SET_LNS_RECORD_VALUE, ug], [v.SET_LNS_MANAGER, hg], [v.ISSUE_ENTITY_FACTORY, ho], [v.ISSUE_ENTITY_FACTORY_V1, Ph], [v.ISSUE_ENTITY, Mh], [v.DESTROY_ENTITY, fg], [v.ISSUE_ENTITY_MULTI, Hh], [v.TRANSFER_ANY, wh], [v.GIFT_ANY, hl], [v.GRAB_ANY, Ch], [v.TO_EXCHANGE_ANY, ul], [v.BE_EXCHANGE_ANY, Lh], [v.TO_EXCHANGE_ANY_MULTI, vh], [v.BE_EXCHANGE_ANY_MULTI, kh], [v.TO_EXCHANGE_ANY_MULTI_ALL, Dh], [v.BE_EXCHANGE_ANY_MULTI_ALL, gg], [v.ISSUE_CERTIFICATE, dg], [v.DESTROY_CERTIFICATE, yg]].forEach(([n, s]) => {
        t.set(n, s), r.set(s, n);
      }), { VK: i, KV: e, VF: t, FV: r, trsTypeToV(n) {
        const s = n.indexOf("-", n.indexOf("-") + 1);
        return n.substr(s + 1);
      } };
    })();
    const { ConsensusException: At } = ee("VERIFIER", "HelperLogicVerifier");
    let wi = class {
      deepClone(e) {
        const t = Array.isArray(e) ? [] : {};
        if (typeof e === "object") {
          for (const r in e) e[r] && typeof e[r] === "object" ? t[r] = this.deepClone(e[r]) : t[r] = e[r];
          return t;
        } else return e;
      }
      async isAccountFrozen(e, t) {
        const r = await this.accountGetterHelper.getAccountInfo(e, t);
        if (r && r.accountStatus !== 0) throw new At(c.ACCOUNT_FROZEN, { address: e, status: r.accountStatus });
      }
      async isPossessAssetExceptChainAsset(e, t, r = this.configHelper) {
        for (const s in t) {
          const o = t[s];
          for (const a in o) if (a !== r.assetType && o[a].assetNumber > BigInt(0)) throw new At(c.POSSESS_ASSET_EXCEPT_CHAIN_ASSET);
        }
        if (await this.accountGetterHelper.isPossessFrozenAssetExceptMain(e)) throw new At(c.POSSESS_FROZEN_ASSET_EXCEPT_CHAIN_ASSET);
      }
      async isDAppPossessor(e, t = this.configHelper) {
        if (await this.accountGetterHelper.isDAppPossessor(t.magic, e)) throw new At(c.ACCOUNT_CAN_NOT_BE_FROZEN, { address: e, reason: "DApp id possessor can not initiate a frozen account transaction" });
      }
      async isLnsPossessorOrManager(e, t = this.configHelper) {
        if (await this.accountGetterHelper.isLocationNamePossessor(t.magic, e)) throw new At(c.ACCOUNT_CAN_NOT_BE_FROZEN, { address: e, reason: "Location name possessor or manager can not initiate a frozen account transaction" });
      }
      async isEntityFactoryPossessor(e, t = this.configHelper) {
        if (await this.accountGetterHelper.isEntityFactoryPossessor(t.magic, e)) throw new At(c.ACCOUNT_CAN_NOT_BE_FROZEN, { address: e, reason: "EntityFactory possessor can not initiate a frozen account transaction" });
      }
      async isEntityPossessor(e, t = this.configHelper) {
        if (await this.accountGetterHelper.isEntityPossessor(t.magic, e)) throw new At(c.ACCOUNT_CAN_NOT_BE_FROZEN, { address: e, reason: "Entity possessor can not initiate a frozen account transaction" });
      }
      async isCertApplicantOrPossessor(e, t = this.configHelper) {
        if (await this.accountGetterHelper.isCertApplicantOrPossessor(t.magic, e)) throw new At(c.ACCOUNT_CAN_NOT_BE_FROZEN, { address: e, reason: "Certificate applicant or possessor can not initiate a frozen account transaction" });
      }
      async isStakeAsset(e) {
        if (await this.accountGetterHelper.isStakeAsset(e)) throw new At(c.ACCOUNT_CAN_NOT_BE_FROZEN, { address: e, reason: "Already stake asset can not initiate a frozen account transaction" });
      }
      async isChainAssetPossessor(e) {
        await this.isDAppPossessor(e, this.configHelper), await this.isLnsPossessorOrManager(e, this.configHelper), await this.isEntityFactoryPossessor(e, this.configHelper), await this.isEntityPossessor(e, this.configHelper), await this.isCertApplicantOrPossessor(e, this.configHelper), await this.isStakeAsset(e);
      }
      async isAssetExist(e, t, r) {
        const n = await this.accountGetterHelper.getAsset(t, r);
        if (!n) throw new At(c.NOT_EXIST, { prop: `asset with magic ${t} assetType ${r}`, target: "blockChain" });
        if (n.sourceChainName !== e) throw new At(c.NOT_MATCH, { to_compare_prop: `sourceChainName ${n.sourceChainName}`, be_compare_prop: `sourceChainName ${e}`, to_target: `blockChain magic ${t} assetType ${r}`, be_target: `transaction magic ${t} assetType ${r}` });
        return n;
      }
      async isDAppExist(e, t, r, n) {
        const s = await this.accountGetterHelper.getDApp(t, r, n);
        if (!s) throw new At(c.DAPPID_IS_NOT_EXIST, { dappid: r, errorId: Ce.DAPPID_NOT_EXIST });
        if (s.sourceChainName !== e) throw new At(c.NOT_MATCH, { to_compare_prop: `sourceChainName ${s.sourceChainName}`, be_compare_prop: `sourceChainName ${e}`, to_target: `blockChain magic ${t} dappid ${r}`, be_target: `transaction magic ${t} dappid ${r}` });
        return s;
      }
      async isLocationNameExist(e, t, r, n) {
        const s = await this.accountGetterHelper.getLocationName(t, r, n);
        if (!s) throw new At(c.LOCATION_NAME_IS_NOT_EXIST, { locationName: r, errorId: Ce.LOCATION_NAME_NOT_EXIST });
        if (s.sourceChainName !== e) throw new At(c.NOT_MATCH, { to_compare_prop: `sourceChainName ${s.sourceChainName}`, be_compare_prop: `sourceChainName ${e}`, to_target: `blockChain magic ${t} locationName ${r}`, be_target: `transaction magic ${t} locationName ${r}` });
        return s;
      }
      async isEntityFactoryExist(e, t, r, n) {
        const s = await this.accountGetterHelper.getEntityFactory(t, r, n);
        if (!s) throw new At(c.ENTITY_FACTORY_IS_NOT_EXIST, { factoryId: r, errorId: Ce.ENTITY_FACTORY_NOT_EXIST });
        if (s.sourceChainName !== e) throw new At(c.NOT_MATCH, { to_compare_prop: `sourceChainName ${s.sourceChainName}`, be_compare_prop: `sourceChainName ${e}`, to_target: `blockChain magic ${t} factoryId ${r}`, be_target: `transaction magic ${t} factoryId ${r}` });
        return s;
      }
      async isEntityExist(e, t, r, n) {
        const s = await this.accountGetterHelper.getEntity(t, r, n);
        if (!s) throw new At(c.ENTITY_IS_NOT_EXIST, { entityId: r, errorId: Ce.ENTITY_NOT_EXIST });
        if (s.sourceChainName !== e) throw new At(c.NOT_MATCH, { to_compare_prop: `sourceChainName ${s.sourceChainName}`, be_compare_prop: `sourceChainName ${e}`, to_target: `blockChain magic ${t} entityId ${r}`, be_target: `transaction magic ${t} entityId ${r}` });
        return s;
      }
      async isCertificateExist(e, t, r, n) {
        const s = await this.accountGetterHelper.getCertificate(t, r, n);
        if (!s) throw new At(c.CERTIFICATE_IS_NOT_EXIST, { certificateId: r, errorId: Ce.CERTIFICATE_NOT_EXIST });
        if (s.sourceChainName !== e) throw new At(c.NOT_MATCH, { to_compare_prop: `sourceChainName ${s.sourceChainName}`, be_compare_prop: `sourceChainName ${e}`, to_target: `blockChain magic ${t} certificateId ${r}`, be_target: `transaction magic ${t} certificateId ${r}` });
        return s;
      }
      async getAccountForce(e, t, r) {
        let n = e.get(t);
        if (!n) {
          if (n = await this.accountGetterHelper.getAccountInfo(t, r), !n) throw new At(c.NOT_EXIST, { prop: `Account with address ${t}`, target: "blockChain" });
          e.set(t, n);
        }
        return n;
      }
      async getFrozenAssetForce(e, t, r) {
        const n = await this.accountGetterHelper.getFrozenAsset(e, t, r);
        if (!n) throw new At(c.FROZEN_ASSET_NOT_EXIST_OR_EXPIRED, { frozenAddress: e, signature: t, assetType: r });
        return n;
      }
      async getStakeAssetForce(e, t) {
        const r = await this.accountGetterHelper.getStakeAsset(e, t);
        if (!r) throw new At(c.STAKE_ASSET_NOT_EXIST_OR_EXPIRED, { stakeAddress: e, stakeId: t });
        return r;
      }
    };
    l([D(ne), u("design:type", ne)], wi.prototype, "configHelper", void 0);
    l([D("accountGetterHelper", { dynamics: true }), u("design:type", Object)], wi.prototype, "accountGetterHelper", void 0);
    wi = l([J()], wi);
    const { ConsensusException: Z, NoFoundException: qO } = ee("VERIFIER", "EventLogicVerifier");
    let Jn = class {
      addRecord(e, t, r) {
        const { recordType: n, recordValue: s } = t;
        if (r && r[n] && r[n][s]) throw new Z(c.SET_LOCATION_NAME_RECORD_VALUE_FIELD, { locationName: e, reason: "New location name record value already exist" });
      }
      deleteRecord(e, t, r) {
        const { recordType: n, recordValue: s } = t;
        if (!(r[n] && r[n][s])) throw new Z(c.SET_LOCATION_NAME_RECORD_VALUE_FIELD, { locationName: e, reason: "Delete location name record value not exist" });
      }
      __listenEventFee(e, t, r) {
        r.on("fee", async ({ transaction: n, applyInfo: s }, o) => {
          const { magic: a, assetType: p } = this.configHelper;
          if (a !== this.configHelper.magic) throw new Z(c.SHOULD_BE, { to_compare_prop: `magic ${a}`, to_target: "applyInfo", be_compare_prop: this.configHelper.magic });
          if (p !== this.configHelper.assetType) throw new Z(c.SHOULD_BE, { to_compare_prop: `assetType ${p}`, to_target: "applyInfo", be_compare_prop: this.configHelper.assetType });
          const h = BigInt(s.amount), f = s.address, { assets: g } = await this.helperLogicVerifier.getAccountForce(e, f, t);
          g[a] = g[a] || {}, g[a][p] = g[a][p] || { sourceChainMagic: a, assetType: p, assetNumber: BigInt(0), history: {} };
          const d = g[a][p], y = d.assetNumber;
          if (d.assetNumber += h, d.assetNumber < BigInt(0)) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `Transaction signature: ${n.signature} address: ${f} magic ${s.assetInfo.magic} assetType: ${s.assetInfo.assetType} hodingAsset: ${y.toString()} spendFee: ${s.amount}`, errorId: Ce.ASSET_NOT_ENOUGH });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/fee" });
      }
      __listenEventDestroyMainAsset(e, t, r) {
        r.on("destroyMainAsset", async ({ transaction: n, applyInfo: s }, o) => {
          const { magic: a, assetType: p } = this.configHelper;
          if (a !== this.configHelper.magic) throw new Z(c.SHOULD_BE, { to_compare_prop: `magic ${a}`, to_target: "applyInfo", be_compare_prop: this.configHelper.magic });
          if (p !== this.configHelper.assetType) throw new Z(c.SHOULD_BE, { to_compare_prop: `assetType ${p}`, to_target: "applyInfo", be_compare_prop: this.configHelper.assetType });
          const { amount: h, sourceAmount: f } = s, g = await this.accountGetterHelper.getAsset(a, p);
          if (!g) throw new Z(c.ASSET_NOT_EXIST, { magic: a, assetType: p, errorId: Ce.ASSET_NOT_EXIST });
          if (g.remainAssetPrealnum < BigInt(f)) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `Asset ${a} ${p} remain: ${g.remainAssetPrealnum.toString()} destroyAsset: ${h}`, errorId: Ce.ASSET_NOT_ENOUGH });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/destroyMainAsset" });
      }
      __listenEventAsset(e, t, r) {
        r.on("asset", async ({ transaction: n, applyInfo: s }, o) => {
          const { magic: a, assetType: p } = s.assetInfo, h = s.address, { assets: f } = await this.helperLogicVerifier.getAccountForce(e, h, t);
          f[a] = f[a] || {}, f[a][p] = f[a][p] || { sourceChainMagic: a, assetType: p, assetNumber: BigInt(0), history: {} };
          const g = f[a][p], d = g.assetNumber;
          if (g.assetNumber += BigInt(s.amount), g.assetNumber < BigInt(0)) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `Transaction signature: ${n.signature} address: ${h} magic ${s.assetInfo.magic} assetType: ${s.assetInfo.assetType} hodingAsset: ${d.toString()} spendAsset: ${s.amount}`, errorId: Ce.ASSET_NOT_ENOUGH });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/asset" });
      }
      __listenEventFrozenAsset(e, t, r) {
        r.on("frozenAsset", async ({ transaction: n, applyInfo: s }, o) => {
          const { magic: a, assetType: p } = s.assetInfo, h = s.address, { assets: f } = await this.helperLogicVerifier.getAccountForce(e, h, t);
          f[a] = f[a] || {}, f[a][p] = f[a][p] || { sourceChainMagic: a, assetType: p, assetNumber: BigInt(0), history: {} };
          const g = f[a][p], d = g.assetNumber;
          if (g.assetNumber += BigInt(s.amount), g.assetNumber < BigInt(0)) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `Transaction signature: ${n.signature} address: ${h} magic ${s.assetInfo.magic} assetType: ${s.assetInfo.assetType} hodingAsset: ${d.toString()} frozenAsset: ${s.amount}`, errorId: Ce.ASSET_NOT_ENOUGH });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/frozenAsset" });
      }
      __listenEventUnfrozenAsset(e, t) {
        t.on("unfrozenAsset", async ({ transaction: r, applyInfo: n }, s) => {
          const { assetInfo: o, frozenId: a, amount: p, recipientId: h } = n, { magic: f, assetType: g } = o, d = await this.helperLogicVerifier.getFrozenAssetForce(h, a, g), { maxEffectiveHeight: y, minEffectiveHeight: _, remainUnfrozenTimes: I, amount: S } = d;
          if (_ > e) throw new Z(c.NOT_BEGIN_UNFROZEN_YET, { frozenId: a });
          if (e > y) throw new Z(c.FROZEN_ASSET_EXPIRATION, { frozenId: a });
          if (y < e) throw new Z(c.FROZEN_ASSET_EXPIRATION, { frozenId: a });
          if (BigInt(p) > BigInt(S)) throw new Z(c.FROZEN_ASSET_NOT_ENOUGH, { reason: `No enough asset to unfrozen magic ${f} assetType ${g} remain ${S} spend ${p}`, frozenId: a });
          if (I !== void 0 && I === 0) throw new Z(c.UNFROZEN_TIME_USE_UP, { frozenId: a });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/unfrozenAsset" });
      }
      __listenEventSignForAsset(e, t) {
        t.on("signForAsset", async ({ transaction: r, applyInfo: n }, s) => {
          const { frozenId: o, frozenAddress: a, assetInfo: p } = n, h = await this.helperLogicVerifier.getFrozenAssetForce(a, o, p.assetType), { maxEffectiveHeight: f, minEffectiveHeight: g, remainUnfrozenTimes: d, amount: y } = h;
          if (g > e) throw new Z(c.NOT_BEGIN_UNFROZEN_YET, { frozenId: o });
          if (e > f) throw new Z(c.FROZEN_ASSET_EXPIRATION, { frozenId: o });
          if (f < e) throw new Z(c.FROZEN_ASSET_EXPIRATION, { frozenId: o });
          if (BigInt(y) === BigInt(0)) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `No enough asset to sign for magic ${h.sourceChainMagic} assetType ${h.assetType} remain ${y}` });
          if (d !== void 0 && d === 0) throw new Z(c.UNFROZEN_TIME_USE_UP, { frozenId: o });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/signForAsset" });
      }
      __listenEventFrozenAccount(e, t, r) {
        r.on("frozenAccount", async ({ applyInfo: n }, s) => {
          const { address: o } = n, p = (await this.helperLogicVerifier.getAccountForce(e, o, t)).accountStatus;
          if (p === 1 || p === 16 || p === 17) throw new Z(c.ACCOUNT_FROZEN, { address: o, status: p });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/frozenAccount" });
      }
      __listenEventSetSecondPublicKey(e) {
        e.on("setSecondPublicKey", ({ applyInfo: t }, r) => r(), { taskname: "applyTransaction/logicVerifier/setSecondPublicKey" });
      }
      async __checkAsset(e, t, r) {
        await this.helperLogicVerifier.isAccountFrozen(e, r);
        const n = this.configHelper.magic;
        if (await this.accountGetterHelper.isCurrencyForbidden(t)) throw new Z(c.FORBIDDEN, { prop: `AssetType ${t}`, target: "blockChain" });
        if (await this.accountGetterHelper.getCurrency(t)) throw new Z(c.ALREADY_EXIST, { prop: `AssetType ${t}`, target: "blockChain", errorId: Ce.ASSETTYPE_ALREADY_EXIST });
        if (await this.accountGetterHelper.getAsset(n, t)) throw new Z(c.ASSET_ALREADY_EXIST, { magic: n, assetType: t, errorId: Ce.ASSET_ALREADY_EXIST });
      }
      __listenEventIssueAsset(e, t, r) {
        r.on("issueAsset", async ({ transaction: n, applyInfo: s }, o) => {
          const { address: a, assetInfo: p, genesisAddress: h, sourceAmount: f } = s, { assetType: g } = p;
          await this.__checkAsset(h, g, t);
          const { assets: d } = await this.helperLogicVerifier.getAccountForce(e, a, t);
          await this.helperLogicVerifier.isPossessAssetExceptChainAsset(a, d), await this.helperLogicVerifier.isChainAssetPossessor(a);
          const { magic: y, assetType: _, issueAssetMinChainAsset: I } = this.configHelper, S = d[y][_].assetNumber;
          if (BigInt(I) > S) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `No enough asset, Min account asset ${I}, remain Assets: ${S}`, errorId: Ce.CHAIN_ASSET_NOT_ENOUGH });
          const w = this.jsbiHelper.multiplyFloorFraction(S, this.configHelper.maxMultipleOfAssetAndMainAsset);
          if (BigInt(f) > w) throw new Z(c.PROP_SHOULD_LTE_FIELD, { prop: `expectedIssuedAssets ${f}`, target: "issueAsset", field: `calc max assets ${w}` });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/issueAsset" });
      }
      __listenEventIncreaseAsset(e, t, r) {
        r.on("increaseAsset", async ({ transaction: n, applyInfo: s }, o) => {
          const { address: a, recipientId: p, assetInfo: h, applyAddress: f, sourceAmount: g } = s, { magic: d, assetType: y } = h, _ = await this.accountGetterHelper.getAsset(d, y);
          if (!_) throw new Z(c.ASSET_NOT_EXIST, { magic: d, assetType: y, errorId: Ce.ASSET_NOT_EXIST });
          if (f !== _.applyAddress) throw new Z(c.NOT_MATCH, { to_compare_prop: `applyAddress ${f}`, to_target: "increaseAsset", be_compare_prop: `applyAddress ${_.applyAddress}`, be_target: "blockChain" });
          if (a !== _.genesisAddress) throw new Z(c.NOT_MATCH, { to_compare_prop: `genesisAddress ${a}`, to_target: "increaseAsset", be_compare_prop: `genesisAddress ${_.genesisAddress}`, be_target: "blockChain" });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/increaseAsset" });
      }
      __listenEventDestroyAsset(e) {
        e.on("destroyAsset", async ({ applyInfo: t }, r) => {
          const { sourceAmount: n, assetInfo: s } = t, { magic: o, assetType: a } = s, p = await this.accountGetterHelper.getAsset(o, a);
          if (!p) throw new Z(c.ASSET_NOT_EXIST, { magic: o, assetType: a, errorId: Ce.ASSET_NOT_EXIST });
          if (p.remainAssetPrealnum < BigInt(n)) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `Asset ${o} ${a} remain: ${p.remainAssetPrealnum.toString()} destroyAsset: ${n}`, errorId: Ce.ASSET_NOT_ENOUGH });
          return r();
        }, { taskname: "applyTransaction/logicVerifier/destroyAsset" });
      }
      __listenEventIssueDAppid(e, t) {
        t.on("issueDAppid", async ({ applyInfo: r }, n) => {
          const { address: s, dappid: o, sourceChainMagic: a, possessorAddress: p } = r;
          if (s !== p && await this.helperLogicVerifier.isAccountFrozen(p, e), await this.accountGetterHelper.getDApp(a, o, e)) throw new Z(c.DAPPID_IS_ALREADY_EXIST, { dappid: o, errorId: Ce.DAPP_ALREADY_EXISTS });
          return n();
        }, { taskname: "applyTransaction/logicVerifier/issueDAppid" });
      }
      __listenEventFrozenDAppid(e, t) {
        t.on("frozenDAppid", async ({ applyInfo: r }, n) => {
          const { address: s, sourceChainName: o, sourceChainMagic: a, dappid: p } = r, h = await this.helperLogicVerifier.isDAppExist(o, a, p, e);
          if (h.possessorAddress !== s) throw new Z(c.ACCOUNT_NOT_DAPPID_POSSESSOR, { address: s, dappid: p, errorId: Ce.ACCOUNT_NOT_DAPPID_POSSESSOR });
          if (h.status === 17) throw new Z(c.DAPPID_ALREADY_FROZEN, { dappid: p });
          return n();
        }, { taskname: "applyTransaction/logicVerifier/frozenDAppid" });
      }
      __listenEventUnfrozenDAppid(e, t) {
        t.on("unfrozenDAppid", async ({ transaction: r, applyInfo: n }, s) => {
          const { address: o, sourceChainName: a, sourceChainMagic: p, dappid: h, frozenId: f } = n, g = await this.helperLogicVerifier.isDAppExist(a, p, h, e);
          if (g.status !== 17) throw new Z(c.DAPPID_NOT_FROZEN, { dappid: h });
          if (g.frozenId !== f) throw new Z(c.SHOULD_BE, { to_compare_prop: `frozenId ${f}`, to_target: "transaction", be_compare_prop: `dapp frozenId ${g.frozenId}` });
          if (r.recipientId !== g.possessorAddress) throw new Z(c.SHOULD_BE, { to_compare_prop: `recipientId ${r.recipientId}`, to_target: "transaction", be_compare_prop: `dapp possessor ${g.possessorAddress}` });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/unfrozenDAppid" });
      }
      __listenEventChangeDAppidPossessor(e, t) {
        t.on("changeDAppidPossessor", async ({ transaction: r, applyInfo: n }, s) => {
          const { address: o, possessorAddress: a, sourceChainName: p, sourceChainMagic: h, dappid: f } = n;
          o !== a && await this.helperLogicVerifier.isAccountFrozen(a, e);
          const g = await this.helperLogicVerifier.isDAppExist(p, h, f, e);
          if (g.status === 17) throw new Z(c.DAPPID_ALREADY_FROZEN, { dappid: f });
          if (r.senderId !== g.possessorAddress) throw new Z(c.SHOULD_BE, { to_compare_prop: `senderId ${r.senderId}`, to_target: "transaction", be_compare_prop: `dapp possessor ${g.possessorAddress}` });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/changeDAppidPossessor" });
      }
      __listenEventRegisterChain(e, t, r) {
        r.on("registerChain", async ({ transaction: n, applyInfo: s }, o) => {
          const { address: a, genesisBlock: p } = s, { assets: h } = await this.helperLogicVerifier.getAccountForce(e, a, t);
          await this.helperLogicVerifier.isPossessAssetExceptChainAsset(a, h), await this.helperLogicVerifier.isChainAssetPossessor(a);
          const { magic: f, assetType: g, registerChainMinChainAsset: d } = this.configHelper, y = h[f][g].assetNumber;
          if (BigInt(d) > y) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `No enough asset, Min account asset ${d}, remain Assets: ${y}`, errorId: Ce.CHAIN_ASSET_NOT_ENOUGH });
          const { magic: _, assetType: I, chainName: S } = p;
          if (await this.accountGetterHelper.getMagic(_)) throw new Z(c.ALREADY_EXIST, { prop: `Magic ${_}`, target: "blockChain", errorId: Ce.MAGIC_ALREADY_EXIST });
          if (await this.accountGetterHelper.getCurrency(S)) throw new Z(c.ALREADY_EXIST, { prop: `ChainName ${S}`, target: "blockChain", errorId: Ce.CHAINNAME_ALREADY_EXIST });
          if (await this.accountGetterHelper.getCurrency(I)) throw new Z(c.ALREADY_EXIST, { prop: `AssetType ${I}`, target: "blockChain", errorId: Ce.ASSETTYPE_ALREADY_EXIST });
          if (await this.accountGetterHelper.getChain(_)) throw new Z(c.ALREADY_EXIST, { prop: `Chain with magic ${_}`, target: "blockChain" });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/registerChain" });
      }
      __listenEventRegisterLocationName(e, t) {
        t.on("registerLocationName", async ({ applyInfo: r }, n) => {
          const { address: s, sourceChainMagic: o, name: a, possessorAddress: p } = r;
          if (s !== p && await this.helperLogicVerifier.isAccountFrozen(p, e), await this.accountGetterHelper.getLocationName(o, a, e)) throw new Z(c.LOCATION_NAME_IS_ALREADY_EXIST, { prop: a, target: "blockChain", errorId: Ce.LOCATION_NAME_ALREADY_EXIST });
          if (await this.accountGetterHelper.isLocationNameForbidden(a)) throw new Z(c.FORBIDDEN, { prop: `Location name ${a}`, target: "blockChain" });
          if (a.split(".").length > 2) {
            const d = a.indexOf(".") + 1, y = a.substr(d);
            if (!await this.accountGetterHelper.getLocationName(o, y, e)) throw new Z(c.LOCATION_NAME_IS_NOT_EXIST, { locationName: y });
          }
          return n();
        }, { taskname: "applyTransaction/logicVerifier/registerLocationName" });
      }
      __listenEventCancelLocationName(e, t) {
        t.on("cancelLocationName", async ({ transaction: r, applyInfo: n }, s) => {
          const { sourceChainName: o, sourceChainMagic: a, name: p } = n, h = await this.helperLogicVerifier.isLocationNameExist(o, a, p, e);
          if (h.status === 17) throw new Z(c.CAN_NOT_DELETE_LOCATION_NAME, { locationName: p, reason: "Frozen location name can not be delete" });
          if (h.status === 255) throw new Z(c.CAN_NOT_DELETE_LOCATION_NAME, { locationName: p, reason: "Location name has been deleted" });
          if (r.senderId !== r.recipientId) throw new Z(c.SHOULD_BE, { to_compare_prop: "recipientId", to_target: "transaction", be_compare_prop: r.senderId });
          if (h.possessorAddress !== r.senderId) throw new Z(c.CAN_NOT_DELETE_LOCATION_NAME, { locationName: p, reason: "Only location name possessor can delete location name" });
          if (await this.accountGetterHelper.isSubLocationNameExist(a, p)) throw new Z(c.CAN_NOT_DELETE_LOCATION_NAME, { locationName: p, reason: "Location name have child location name, please delete it at first" });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/cancelLocationName" });
      }
      __listenEventSetLnsManager(e, t) {
        t.on("setLnsManager", async ({ applyInfo: r }, n) => {
          const { address: s, sourceChainName: o, sourceChainMagic: a, name: p, manager: h } = r;
          await this.helperLogicVerifier.isAccountFrozen(h, e);
          const f = await this.helperLogicVerifier.isLocationNameExist(o, a, p, e);
          if (f.status === 17) throw new Z(c.SET_LOCATION_NAME_MANAGER_FIELD, { locationName: p, reason: "Frozen location name can not set manager" });
          if (h === f.manager) throw new Z(c.SET_LOCATION_NAME_MANAGER_FIELD, { locationName: p, reason: "Can not set the same account as manager", errorId: Ce.CAN_NOT_SET_SAME_ACCOUNT_AS_MANAGER });
          if (f.type === "MULTI_LEVEL") {
            const d = p.split(".")[0].length + 1, y = p.substr(d), _ = await this.accountGetterHelper.getLocationName(a, y, e);
            if (!_) throw new Z(c.SET_LOCATION_NAME_MANAGER_FIELD, { locationName: y, reason: "Last location name is not exists" });
            if (!(s === f.possessorAddress || s === _.manager)) throw new Z(c.SET_LOCATION_NAME_MANAGER_FIELD, { locationName: y, reason: "Only the location name possessor or upper level location name manager can set manager of multi level location name" });
          } else if (s !== f.possessorAddress) throw new Z(c.SET_LOCATION_NAME_MANAGER_FIELD, { locationName: p, reason: "Only the location name possessor can set manager of top level location name" });
          return n();
        }, { taskname: "applyTransaction/logicVerifier/setLnsManager" });
      }
      __listenEventSetLnsRecordValue(e, t) {
        t.on("setLnsRecordValue", async ({ applyInfo: r }, n) => {
          const { address: s, sourceChainName: o, sourceChainMagic: a, name: p, operationType: h, addRecord: f, deleteRecord: g } = r, d = await this.helperLogicVerifier.isLocationNameExist(o, a, p, e), { records: y, status: _ } = d;
          if (_ === 17) throw new Z(c.SET_LOCATION_NAME_RECORD_VALUE_FIELD, { locationName: p, reason: "Frozen location name can not set record value" });
          if (!(s === d.possessorAddress || s === d.manager)) throw new Z(c.SET_LOCATION_NAME_RECORD_VALUE_FIELD, { locationName: p, reason: "Only the location name possessor or manager can set record value" });
          if (h === 0) {
            if (!f) throw new Z(c.SET_LOCATION_NAME_RECORD_VALUE_FIELD, { locationName: p, reason: "New location name record value lose" });
            this.addRecord(p, f, y);
          } else if (h === 1) {
            if (!g) throw new Z(c.SET_LOCATION_NAME_RECORD_VALUE_FIELD, { locationName: p, reason: "Delete location name record value lose" });
            this.deleteRecord(p, g, y);
          } else if (h === 2) {
            if (!(f && g)) throw new Z(c.SET_LOCATION_NAME_RECORD_VALUE_FIELD, { locationName: p, reason: "New location name record value and delete location name record value lose" });
            this.deleteRecord(p, g, y), this.addRecord(p, f, y);
          }
          return n();
        }, { taskname: "applyTransaction/logicVerifier/setLnsRecordValue" });
      }
      __listenEventFrozenLocationName(e, t) {
        t.on("frozenLocationName", async ({ applyInfo: r }, n) => {
          const { address: s, sourceChainName: o, sourceChainMagic: a, name: p } = r, h = await this.helperLogicVerifier.isLocationNameExist(o, a, p, e);
          if (h.status === 17) throw new Z(c.LOCATION_NAME_ALREADY_FROZEN, { locationName: p });
          if (h.type !== "TOP_LEVEL") throw new Z(c.ONLY_TOP_LEVEL_LOCATION_NAME_CAN_EXCHANGE);
          if (h.possessorAddress !== s) throw new Z(c.ACCOUNT_NOT_LOCATION_NAME_POSSESSOR, { address: s, locationName: p, errorId: Ce.ACCOUNT_NOT_LNS_POSSESSOR });
          return n();
        }, { taskname: "applyTransaction/logicVerifier/frozenLocationName" });
      }
      __listenEventUnfrozenLocationName(e, t) {
        t.on("unfrozenLocationName", async ({ transaction: r, applyInfo: n }, s) => {
          const { address: o, sourceChainName: a, sourceChainMagic: p, name: h, frozenId: f } = n, g = await this.helperLogicVerifier.isLocationNameExist(a, p, h, e);
          if (g.status !== 17) throw new Z(c.LOCATION_NAME_NOT_FROZEN, { locationName: h });
          if (g.frozenId !== f) throw new Z(c.SHOULD_BE, { to_compare_prop: `frozenId ${f}`, to_target: "transaction", be_compare_prop: `location name frozenId ${g.frozenId}` });
          if (g.type !== "TOP_LEVEL") throw new Z(c.ONLY_TOP_LEVEL_LOCATION_NAME_CAN_EXCHANGE);
          if (r.recipientId !== g.possessorAddress) throw new Z(c.SHOULD_BE, { to_compare_prop: `recipientId ${r.recipientId}`, to_target: "transaction", be_compare_prop: `locationName possessor ${g.possessorAddress}` });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/unfrozenLocationName" });
      }
      __listenEventChangeLocationNamePossessor(e, t) {
        t.on("changeLocationNamePossessor", async ({ transaction: r, applyInfo: n }, s) => {
          const { address: o, possessorAddress: a, sourceChainName: p, sourceChainMagic: h, name: f } = n;
          o !== a && await this.helperLogicVerifier.isAccountFrozen(a, e);
          const g = await this.helperLogicVerifier.isLocationNameExist(p, h, f, e);
          if (g.type !== "TOP_LEVEL") throw new Z(c.ONLY_TOP_LEVEL_LOCATION_NAME_CAN_EXCHANGE);
          if (g.status === 17) throw new Z(c.LOCATION_NAME_ALREADY_FROZEN, { locationName: f });
          if (r.senderId !== g.possessorAddress) throw new Z(c.SHOULD_BE, { to_compare_prop: `senderId ${r.senderId}`, to_target: "transaction", be_compare_prop: `locationName possessor ${g.possessorAddress}` });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/changeLocationNamePossessor" });
      }
      async __checkEntityFactory(e, t, r, n) {
        if (await this.helperLogicVerifier.isAccountFrozen(t, e), await this.accountGetterHelper.getEntityFactory(r, n, e)) throw new Z(c.ENTITY_FACTORY_IS_ALREADY_EXIST, { factoryId: n, errorId: Ce.ENTITY_FACTORY_ALREADY_EXIST });
      }
      __listenEventIssueEntityFactoryByFrozen(e, t, r) {
        r.on("issueEntityFactoryByFrozen", async ({ transaction: n, applyInfo: s }, o) => {
          const { address: a, factoryId: p, sourceChainMagic: h, possessorAddress: f, entityPrealnum: g } = s;
          await this.__checkEntityFactory(t, f, h, p);
          const { assets: d } = await this.helperLogicVerifier.getAccountForce(e, a, t);
          await this.helperLogicVerifier.isPossessAssetExceptChainAsset(a, d), await this.helperLogicVerifier.isChainAssetPossessor(a);
          const { magic: y, assetType: _, issueEntityFactoryMinChainAsset: I } = this.configHelper, S = d[y][_].assetNumber;
          if (BigInt(I) > S) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `No enough asset, Min account asset ${I}, remain Assets: ${S}`, errorId: Ce.CHAIN_ASSET_NOT_ENOUGH });
          const w = this.jsbiHelper.multiplyFractionAndFloor({ numerator: S, denominator: eA }, this.configHelper.maxMultipleOfEntityAndMainAsset);
          if (BigInt(g) > w) throw new Z(c.PROP_SHOULD_LTE_FIELD, { prop: `entityPrealnum ${g}`, target: "issueEntityFactory", field: `calc max entities ${w}` });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/issueEntityFactoryByFrozen" });
      }
      __listenEventIssueEntityFactoryByDestroy(e, t) {
        t.on("issueEntityFactoryByDestroy", async ({ transaction: r, applyInfo: n }, s) => {
          const { factoryId: o, sourceChainMagic: a, possessorAddress: p } = n;
          return await this.__checkEntityFactory(e, p, a, o), s();
        }, { taskname: "applyTransaction/logicVerifier/issueEntityFactoryByDestroy" });
      }
      __isEntityFactoryMatch(e, t, r) {
        if (e.sourceChainMagic !== t.sourceChainMagic || e.sourceChainName !== t.sourceChainName || e.factoryId !== t.factoryId || e.entityPrealnum !== t.entityPrealnum.toString() || e.entityFrozenAssetPrealnum !== t.entityFrozenAssetPrealnum || e.purchaseAssetPrealnum !== t.purchaseAssetPrealnum) throw new Z(c.NOT_MATCH, { to_compare_prop: `entityFactory ${JSON.stringify(e)}`, be_compare_prop: `entityFactory ${JSON.stringify({ sourceChainName: t.sourceChainName, sourceChainMagic: t.sourceChainMagic, factoryId: t.factoryId, entityPrealnum: t.entityPrealnum.toString(), entityFrozenAssetPrealnum: t.entityFrozenAssetPrealnum, purchaseAssetPrealnum: t.purchaseAssetPrealnum })}`, to_target: r, be_target: "blockChain" });
      }
      __listenEventIssueEntity(e, t, r) {
        r.on("issueEntity", async ({ transaction: n, applyInfo: s }, o) => {
          const { address: a, possessorAddress: p, entityFactoryPossessorAddress: h, factoryId: f, entityId: g, sourceChainName: d, sourceChainMagic: y, entityFrozenAssetPrealnum: _ } = s;
          a !== p && await this.helperLogicVerifier.isAccountFrozen(p, t);
          const I = await this.helperLogicVerifier.isEntityFactoryExist(d, y, f, t);
          if (this.__isEntityFactoryMatch(n.asset.issueEntity.entityFactory.toJSON(), I, "IssueEntityTransaction"), h !== I.possessorAddress) throw new Z(c.NOT_MATCH, { to_compare_prop: `entityFactoryPossessor ${h}`, be_compare_prop: `possessorAddress ${I.possessorAddress}`, to_target: "issueEntity", be_target: "memEntityFactory" });
          if (I.remainEntityPrealnum === BigInt(0)) throw new Z(c.ISSUE_ENTITY_TIMES_USE_UP, { entityFactory: f });
          if (await this.accountGetterHelper.getEntity(y, g, t)) throw new Z(c.ENTITY_IS_ALREADY_EXIST, { entityId: g, errorId: Ce.ENTITY_ALREADY_EXIST });
          const { assets: w } = await this.helperLogicVerifier.getAccountForce(e, a, t), { magic: N, assetType: B } = this.configHelper;
          let O = w[N][B].assetNumber;
          const P = I.purchaseAssetPrealnum;
          if (P !== "0" && (O -= BigInt(P), O < BigInt(0))) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `No enough asset, Min account asset ${P}, remain Assets: ${O}`, errorId: Ce.CHAIN_ASSET_NOT_ENOUGH });
          if (_ !== "0" && BigInt(_) > O) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `No enough asset, Min account asset ${_}, remain Assets: ${O}`, errorId: Ce.CHAIN_ASSET_NOT_ENOUGH });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/issueEntityV1" });
      }
      __listenEventIssueEntityMulti(e, t, r) {
        r.on("issueEntityMulti", async ({ transaction: n, applyInfo: s }, o) => {
          const { address: a, possessorAddress: p, entityFactoryPossessorAddress: h, factoryId: f, entityStructList: g, sourceChainName: d, sourceChainMagic: y, entityFrozenAssetPrealnum: _ } = s;
          a !== p && await this.helperLogicVerifier.isAccountFrozen(p, t);
          const I = await this.helperLogicVerifier.isEntityFactoryExist(d, y, f, t);
          if (this.__isEntityFactoryMatch(n.asset.issueEntityMulti.entityFactory.toJSON(), I, "IssueEntityMultiTransactionV1"), h !== I.possessorAddress) throw new Z(c.NOT_MATCH, { to_compare_prop: `entityFactoryPossessor ${h}`, be_compare_prop: `possessorAddress ${I.possessorAddress}`, to_target: "issueEntity", be_target: "memEntityFactory" });
          const { remainEntityPrealnum: S } = I;
          if (S === BigInt(0)) throw new Z(c.ISSUE_ENTITY_TIMES_USE_UP, { entityFactory: f });
          if (S < BigInt(g.length)) throw new Z(c.NOT_ENOUGH_ISSUE_ENTITY_TIMES, { entityFactory: f });
          if (I.entityPrealnum !== S) {
            for (const { entityId: C } of g) if (await this.accountGetterHelper.getEntity(y, C, t)) throw new Z(c.ENTITY_IS_ALREADY_EXIST, { entityId: C, errorId: Ce.ENTITY_ALREADY_EXIST });
          }
          const { assets: w } = await this.helperLogicVerifier.getAccountForce(e, a, t), { magic: N, assetType: B } = this.configHelper;
          let O = w[N][B].assetNumber;
          const P = I.purchaseAssetPrealnum;
          if (P !== "0" && (O -= BigInt(P), O < BigInt(0))) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `No enough asset, Min account asset ${P}, remain Assets: ${O}`, errorId: Ce.CHAIN_ASSET_NOT_ENOUGH });
          if (_ !== "0" && BigInt(_) > O) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `No enough asset, Min account asset ${_}, remain Assets: ${O}`, errorId: Ce.CHAIN_ASSET_NOT_ENOUGH });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/issueEntityV1" });
      }
      __listenEventDestroyEntity(e, t) {
        t.on("destroyEntity", async ({ transaction: r, applyInfo: n }, s) => {
          const { sourceChainName: o, sourceChainMagic: a, entityId: p, entityFactoryApplicantAddress: h, entityFactoryPossessorAddress: f, entityFactory: g } = n, d = g.factoryId, y = await this.helperLogicVerifier.isEntityFactoryExist(o, a, d, e);
          if (this.__isEntityFactoryMatch(r.asset.destroyEntity.entityFactory.toJSON(), y, "DestroyEntityTransaction"), h !== y.applyAddress) throw new Z(c.NOT_MATCH, { to_compare_prop: `entityFactoryApplicant ${h}`, be_compare_prop: `applyAddress ${y.applyAddress}`, to_target: "destroyEntity", be_target: "memEntityFactory" });
          if (f !== y.possessorAddress) throw new Z(c.NOT_MATCH, { to_compare_prop: `entityFactoryPossessor ${f}`, be_compare_prop: `possessorAddress ${y.possessorAddress}`, to_target: "destroyEntity", be_target: "memEntityFactory" });
          const _ = await this.helperLogicVerifier.isEntityExist(o, a, p, e);
          if (_.status === 17) throw new Z(c.CAN_NOT_DESTROY_ENTITY, { entityId: p, reason: "Frozen entity can not be destroy" });
          if (_.status === 255) throw new Z(c.ENTITY_ALREADY_DESTROY, { entityId: p, reason: "Entity already be destroy" });
          if (_.possessorAddress !== r.senderId) throw new Z(c.CAN_NOT_DESTROY_ENTITY, { entityId: p, reason: `Only entity possessor can deestory entity ${p}` });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/destroyEntity" });
      }
      __listenEventFrozenEntity(e, t) {
        t.on("frozenEntity", async ({ applyInfo: r }, n) => {
          const { address: s, sourceChainName: o, sourceChainMagic: a, entityId: p } = r, h = await this.helperLogicVerifier.isEntityExist(o, a, p, e);
          if (h.possessorAddress !== s) throw new Z(c.ACCOUNT_NOT_ENTITY_POSSESSOR, { address: s, entityId: p, errorId: Ce.ACCOUNT_NOT_ENTITY_POSSESSOR });
          if (h.status === 17) throw new Z(c.ENTITY_ALREADY_FROZEN, { entityId: p });
          if (h.status === 255) throw new Z(c.ENTITY_ALREADY_DESTROY, { entityId: p });
          return n();
        }, { taskname: "applyTransaction/logicVerifier/frozenEntity" });
      }
      __listenEventUnfrozenEntity(e, t) {
        t.on("unfrozenEntity", async ({ transaction: r, applyInfo: n }, s) => {
          const { address: o, sourceChainName: a, sourceChainMagic: p, entityId: h, frozenId: f } = n, g = await this.helperLogicVerifier.isEntityExist(a, p, h, e);
          if (g.status === 0) throw new Z(c.ENTITY_NOT_FROZEN, { entityId: h });
          if (g.frozenId !== f) throw new Z(c.SHOULD_BE, { to_compare_prop: `frozenId ${f}`, to_target: "transaction", be_compare_prop: `entity frozenId ${g.frozenId}` });
          if (g.status === 255) throw new Z(c.ENTITY_ALREADY_DESTROY, { entityId: h });
          if (r.recipientId !== g.possessorAddress) throw new Z(c.SHOULD_BE, { to_compare_prop: `recipientId ${r.recipientId}`, to_target: "transaction", be_compare_prop: `entity possessor ${g.possessorAddress}` });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/unfrozenEntity" });
      }
      __listenEventChangeEntityPossessor(e, t) {
        t.on("changeEntityPossessor", async ({ transaction: r, applyInfo: n }, s) => {
          const { address: o, possessorAddress: a, sourceChainName: p, sourceChainMagic: h, entityId: f } = n;
          o !== a && await this.helperLogicVerifier.isAccountFrozen(a, e);
          const g = await this.helperLogicVerifier.isEntityExist(p, h, f, e);
          if (g.status === 17) throw new Z(c.ENTITY_ALREADY_FROZEN, { entityId: f });
          if (g.status === 255) throw new Z(c.ENTITY_ALREADY_DESTROY, { entityId: f });
          if (r.senderId !== g.possessorAddress) throw new Z(c.SHOULD_BE, { to_compare_prop: `senderId ${r.senderId}`, to_target: "transaction", be_compare_prop: `entity possessor ${g.possessorAddress}` });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/changeEntityPossessor" });
      }
      __listenEventMigrateCertificate(e) {
        e.on("migrateCertificate", async ({ applyInfo: t }, r) => {
          const { migrateCertificateId: n } = t;
          if (await this.accountGetterHelper.getMigrateCertificate(n)) throw new Z(c.ASSET_IS_ALREADY_MIGRATION, { migrateCertificateId: n });
          return r();
        }, { taskname: "applyTransaction/logicVerifier/migrateCertificate" });
      }
      __listenEventPayTax(e, t) {
        t.on("payTax", async ({ applyInfo: r }, n) => {
          const { sourceChainName: s, sourceChainMagic: o, parentAssetType: a, assetType: p, taxInformation: h } = r;
          if (a === G.ENTITY) {
            const f = await this.helperLogicVerifier.isEntityExist(s, o, p, e);
            if (f.taxAssetRecipientId !== h.taxCollector) throw new Z(c.NOT_MATCH, { to_compare_prop: `taxAssetRecipientId ${f.taxAssetRecipientId}`, be_compare_prop: `taxCollector ${h.taxCollector}`, to_target: "taxInformation", be_target: "memEntity" });
            if (f.taxAssetPrealnum !== h.taxAssetPrealnum) throw new Z(c.NOT_MATCH, { to_compare_prop: `taxAssetPrealnum ${f.taxAssetPrealnum}`, be_compare_prop: `taxAssetPrealnum ${h.taxAssetPrealnum}`, to_target: "taxInformation", be_target: "memEntity" });
          }
          return n();
        }, { taskname: "applyTransaction/logicVerifier/payTax" });
      }
      __listenEventIssueCertificate(e, t) {
        t.on("issueCertificate", async ({ transaction: r, applyInfo: n }, s) => {
          const { address: o, possessorAddress: a, sourceChainMagic: p, sourceChainName: h, certificateId: f } = n;
          if (o !== a && await this.helperLogicVerifier.isAccountFrozen(a, e), await this.accountGetterHelper.getCertificate(p, f, e)) throw new Z(c.CERTIFICATE_IS_ALREADY_EXIST, { certificateId: f, errorId: Ce.CERTIFICATE_ALREADY_EXIST });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/issueCertificate" });
      }
      __listenEventDestroyCertificate(e, t) {
        t.on("destroyCertificate", async ({ transaction: r, applyInfo: n }, s) => {
          const { sourceChainMagic: o, sourceChainName: a, certificateId: p } = n, h = await this.helperLogicVerifier.isCertificateExist(a, o, p, e);
          if (h.status === 255) throw new Z(c.CERTIFICATE_ALREADY_DESTROY, { certificateId: p });
          if (h.status === 17) throw new Z(c.CAN_NOT_DESTROY_CERTIFICATE, { certificateId: p, reason: "Frozen certificate can not be destroy" });
          if (h.type === 0) throw new Z(c.CAN_NOT_DESTROY_CERTIFICATE, { certificateId: p, reason: "Certificate with type 0 can not be destroy" });
          if (h.type === 1 && h.applyAddress !== r.senderId) throw new Z(c.CAN_NOT_DESTROY_CERTIFICATE, { certificateId: p, reason: `Only certificate applicant can deestory certificate ${p}` });
          if (h.possessorAddress !== r.senderId) throw new Z(c.CAN_NOT_DESTROY_CERTIFICATE, { certificateId: p, reason: `Only certificate possessor can deestory certificate ${p}` });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/destroyCertificate" });
      }
      __listenEventFrozenCertificate(e, t) {
        t.on("frozenCertificate", async ({ applyInfo: r }, n) => {
          const { address: s, sourceChainName: o, sourceChainMagic: a, certificateId: p } = r, h = await this.helperLogicVerifier.isCertificateExist(o, a, p, e);
          if (h.status === 255) throw new Z(c.CERTIFICATE_ALREADY_DESTROY, { certificateId: p });
          if (h.status === 17) throw new Z(c.CERTIFICATE_ALREADY_FROZEN, { certificateId: p });
          if (h.possessorAddress !== s) throw new Z(c.ACCOUNT_NOT_CERTIFICATE_POSSESSOR, { address: s, certificateId: p, errorId: Ce.ACCOUNT_NOT_CERTIFICATE_POSSESSOR });
          return n();
        }, { taskname: "applyTransaction/logicVerifier/frozenCertificate" });
      }
      __listenEventUnfrozenCertificate(e, t) {
        t.on("unfrozenCertificate", async ({ transaction: r, applyInfo: n }, s) => {
          const { address: o, sourceChainName: a, sourceChainMagic: p, certificateId: h, frozenId: f } = n, g = await this.helperLogicVerifier.isCertificateExist(a, p, h, e);
          if (g.status === 255) throw new Z(c.CERTIFICATE_ALREADY_DESTROY, { certificateId: h });
          if (g.status !== 17) throw new Z(c.CERTIFICATE_NOT_FROZEN, { certificateId: h });
          if (g.frozenId !== f) throw new Z(c.SHOULD_BE, { to_compare_prop: `frozenId ${f}`, to_target: "transaction", be_compare_prop: `certificate frozenId ${g.frozenId}` });
          if (r.recipientId !== g.possessorAddress) throw new Z(c.SHOULD_BE, { to_compare_prop: `recipientId ${r.recipientId}`, to_target: "transaction", be_compare_prop: `Certificate possessor ${g.possessorAddress}` });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/unfrozenCertificate" });
      }
      __listenEventChangeCertificatePossessor(e, t) {
        t.on("changeCertificatePossessor", async ({ transaction: r, applyInfo: n }, s) => {
          const { address: o, possessorAddress: a, sourceChainName: p, sourceChainMagic: h, certificateId: f } = n;
          o !== a && await this.helperLogicVerifier.isAccountFrozen(a, e);
          const g = await this.helperLogicVerifier.isCertificateExist(p, h, f, e);
          if (g.status === 255) throw new Z(c.CERTIFICATE_ALREADY_DESTROY, { certificateId: f });
          if (g.status === 17) throw new Z(c.CERTIFICATE_ALREADY_FROZEN, { certificateId: f });
          if (r.senderId !== g.possessorAddress) throw new Z(c.SHOULD_BE, { to_compare_prop: `senderId ${r.senderId}`, to_target: "transaction", be_compare_prop: `Certificate possessor ${g.possessorAddress}` });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/changeCertificatePossessor" });
      }
      __listenEventStakeAsset(e, t, r) {
        r.on("stakeAsset", async ({ transaction: n, applyInfo: s }, o) => {
          const { address: a, stakeId: p, beginUnstakeHeight: h, assetInfo: f } = s, { magic: g, chainName: d, assetType: y } = f, _ = await this.accountGetterHelper.getStakeAsset(a, p);
          if (_) {
            if (h < _.beginUnstakeHeight) throw new Z(c.PROP_SHOULD_GTE_FIELD, { prop: `beginUnstakeHeight ${h}`, target: "stakeAsset", field: _.beginUnstakeHeight });
            if (g !== _.sourceChainMagic || y !== _.assetType) throw new Z(c.NOT_MATCH, { to_compare_prop: `stakeAsset: ${JSON.stringify({ sourceChainMagic: g, sourceChainName: d, assetType: y })}`, be_compare_prop: `stakeAsset: ${JSON.stringify({ sourceChainMagic: _.sourceChainMagic, sourceChainName: _.sourceChainName, assetType: _.assetType })}`, to_target: "StakeAssetTransaction.asset.stakeAsset", be_target: "blockChain" });
          }
          const { assets: I } = await this.helperLogicVerifier.getAccountForce(e, a, t);
          I[g] = I[g] || {}, I[g][y] = I[g][y] || { sourceChainMagic: g, assetType: y, assetNumber: BigInt(0), history: {} };
          const S = I[g][y], w = S.assetNumber;
          if (S.assetNumber += BigInt(s.amount), S.assetNumber < BigInt(0)) throw new Z(c.ASSET_NOT_ENOUGH, { reason: `Transaction signature: ${n.signature} address: ${a} magic ${s.assetInfo.magic} assetType: ${s.assetInfo.assetType} hodingAsset: ${w.toString()} stakeAsset: ${s.amount}`, errorId: Ce.ASSET_NOT_ENOUGH });
          return o();
        }, { taskname: "applyTransaction/logicVerifier/stakeAsset" });
      }
      __listenEventUnstakeAsset(e, t) {
        t.on("unstakeAsset", async ({ transaction: r, applyInfo: n }, s) => {
          const { address: o, assetInfo: a, stakeId: p, amount: h } = n, { magic: f, assetType: g } = a, d = await this.helperLogicVerifier.getStakeAssetForce(o, p), { beginUnstakeHeight: y, amount: _ } = d;
          if (y > e) throw new Z(c.NOT_BEGIN_UNSTAKE_YET, { stakeId: p });
          if (BigInt(h) > BigInt(_)) throw new Z(c.STAKE_ASSET_NOT_ENOUGH, { reason: `No enough asset to unstake magic ${f} assetType ${g} remain ${_} spend ${h}`, stakeId: p });
          return s();
        }, { taskname: "applyTransaction/logicVerifier/unstakeAsset" });
      }
      listenEvent(e, t, r) {
        this.__listenEventFee(e, t, r), this.__listenEventDestroyMainAsset(e, t, r), this.__listenEventAsset(e, t, r), this.__listenEventFrozenAsset(e, t, r), this.__listenEventUnfrozenAsset(t, r), this.__listenEventSignForAsset(t, r), this.__listenEventFrozenAccount(e, t, r), this.__listenEventSetSecondPublicKey(r), this.__listenEventIssueAsset(e, t, r), this.__listenEventIncreaseAsset(e, t, r), this.__listenEventDestroyAsset(r), this.__listenEventIssueDAppid(t, r), this.__listenEventFrozenDAppid(t, r), this.__listenEventUnfrozenDAppid(t, r), this.__listenEventChangeDAppidPossessor(t, r), this.__listenEventRegisterChain(e, t, r), this.__listenEventRegisterLocationName(t, r), this.__listenEventCancelLocationName(t, r), this.__listenEventSetLnsManager(t, r), this.__listenEventSetLnsRecordValue(t, r), this.__listenEventFrozenLocationName(t, r), this.__listenEventUnfrozenLocationName(t, r), this.__listenEventChangeLocationNamePossessor(t, r), this.__listenEventIssueEntityFactoryByFrozen(e, t, r), this.__listenEventIssueEntityFactoryByDestroy(t, r), this.__listenEventIssueEntity(e, t, r), this.__listenEventIssueEntityMulti(e, t, r), this.__listenEventDestroyEntity(t, r), this.__listenEventFrozenEntity(t, r), this.__listenEventUnfrozenEntity(t, r), this.__listenEventChangeEntityPossessor(t, r), this.__listenEventMigrateCertificate(r), this.__listenEventPayTax(t, r), this.__listenEventIssueCertificate(t, r), this.__listenEventDestroyCertificate(t, r), this.__listenEventFrozenCertificate(t, r), this.__listenEventUnfrozenCertificate(t, r), this.__listenEventChangeCertificatePossessor(t, r), this.__listenEventStakeAsset(e, t, r), this.__listenEventUnstakeAsset(t, r);
      }
      async awaitEventResult(e, t) {
        await this.transactionCore.getTransactionFactoryFromType(e.type).applyTransaction(e, t);
      }
    };
    l([D(xt), u("design:type", xt)], Jn.prototype, "jsbiHelper", void 0);
    l([D(ne), u("design:type", ne)], Jn.prototype, "configHelper", void 0);
    l([D(dt), u("design:type", dt)], Jn.prototype, "blockHelper", void 0);
    l([D(Ee), u("design:type", Ee)], Jn.prototype, "transactionHelper", void 0);
    l([D(wi), u("design:type", wi)], Jn.prototype, "helperLogicVerifier", void 0);
    l([D("bfchain-core:TransactionCore"), u("design:type", Object)], Jn.prototype, "transactionCore", void 0);
    l([D("accountGetterHelper", { dynamics: true }), u("design:type", Object)], Jn.prototype, "accountGetterHelper", void 0);
    Jn = l([J()], Jn);
    let Va = class {
      constructor() {
        this.__cacheMap = /* @__PURE__ */ new Map();
      }
      getCache(e) {
        return this.__cacheMap.get(e);
      }
      setCache(e, t) {
        this.__cacheMap.set(e, t);
      }
      clearCache() {
        this.__cacheMap.clear();
      }
    };
    Va = l([J()], Va);
    const { ConsensusException: ut, NoFoundException: tC } = ee("VERIFIER", "TransactionLogicVerifier");
    const Me = class {
      async logicVerify(e, t, r) {
        if (e.version > this.configHelper.version) throw new ut(c.PROP_SHOULD_LTE_FIELD, { prop: `version ${e.version}`, target: `transaction ${e.signature}`, field: `blockChain version ${this.configHelper.version}` });
        const { senderId: n, recipientId: s } = e, o = await this.helperLogicVerifier.getAccountForce(r, n, t);
        if (this.checkSenderAccountStatus(o), this.checkSecondPublicKey(o, e), this.checkApplyBlockHeight(e, t), this.checkEffectiveBlockHeight(e, t), await this.checkTransactionMagic(e), t > 1 && this.checkTransactionTimestamp(e), await this.checkTransactionRange(e, t), s) {
          const a = await this.helperLogicVerifier.getAccountForce(r, s, t);
          this.checkRecipientAccountStatus(a);
        }
        return this.checkTrsMaxBytes(e.getBytes().length), await this.checkDAppId(e, t), await this.checkLocationName(e, t), true;
      }
      checkSenderAccountStatus(e) {
        if (!(e && e.hasOwnProperty("accountStatus"))) throw new ut(c.PROP_LOSE, { prop: "accountStatus", target: "accountInfo" });
        if (e.accountStatus === 16 || e.accountStatus === 17) throw new ut(c.ACCOUNT_FROZEN, { address: e.address, errorId: Ce.TRANSACTION_SENDER_ASSET_FROZEN });
      }
      checkRecipientAccountStatus(e) {
        if (!e.hasOwnProperty("accountStatus")) throw new ut(c.PROP_LOSE, { prop: "accountStatus", target: "accountInfo" });
        if (e.accountStatus === 1 || e.accountStatus === 17) throw new ut(c.ACCOUNT_FROZEN, { address: e.address, errorId: Ce.TRANSACTION_RECIPIENT_ASSET_FROZEN });
      }
      checkSecondPublicKey(e, t) {
        const { type: r, senderId: n, senderSecondPublicKey: s, applyBlockHeight: o, signature: a, signSignature: p } = t, h = e.secondPublicKey;
        if (h) {
          if (!(s && p)) throw new ut(c.TRANSACTION_SIGN_SIGNATURE_IS_REQUIRED, { signature: a, senderId: n, applyBlockHeight: o, type: r });
          if (h !== s) throw new ut(c.TRANSACTION_SENDER_SECOND_PUBLICKEY_ALREADY_CHANGE, { signature: a, senderId: n, applyBlockHeight: o, type: r });
        } else {
          if (s) throw new ut(c.TRANSACTION_SHOULD_NOT_HAVE_SENDER_SECOND_PUBLICKEY, { signature: a, senderId: n, applyBlockHeight: o, type: r });
          if (p) throw new ut(c.TRANSACTION_SHOULD_NOT_HAVE_SIGN_SIGNATURE, { signature: a, senderId: n, applyBlockHeight: o, type: r });
        }
      }
      checkApplyBlockHeight(e, t) {
        const r = e.applyBlockHeight;
        if (r > t) throw new ut(c.INVALID_TRANSACTION_APPLY_BLOCK_HEIGHT, { signature: e.signature, reason: `applyBlockHeight ${r} must less than currntBlockHeight ${t}` }, void 0, "minor");
      }
      checkEffectiveBlockHeight(e, t) {
        const r = e.effectiveBlockHeight;
        if (r < t) throw new ut(c.INVALID_TRANSACTION_EFFECTIVE_BLOCK_HEIGHT, { signature: e.signature, reason: `effectiveBlockHeight ${r} must greate than or equal to currntBlockHeight ${t}` });
      }
      async checkTransactionMagic(e) {
        const t = e.fromMagic, r = e.toMagic, n = this.configHelper.magic;
        if (t === n) {
          if (r === n) return;
          if (!await this.accountGetterHelper.getChain(r)) throw new ut(c.INVALID_TRANSACTION_TO_MAGIC, { reason: "Transaction toMagic chain not exists", signature: e.signature, senderId: e.senderId, applyBlockHeight: e.applyBlockHeight, type: e.type });
        } else {
          if (!await this.accountGetterHelper.getChain(t)) throw new ut(c.INVALID_TRANSACTION_FROM_MAGIC, { reason: "Transaction fromMagic chain not exists", signature: e.signature, senderId: e.senderId, applyBlockHeight: e.applyBlockHeight, type: e.type });
          if (r !== n) throw new ut(c.INVALID_TRANSACTION_TO_MAGIC, { reason: "Transaction to magic must be local", signature: e.signature, senderId: e.senderId, applyBlockHeight: e.applyBlockHeight, type: e.type });
        }
      }
      checkTransactionTimestamp(e) {
        const { timeHelper: t } = this, r = t.getTimestamp(), n = t.getSlotNumberByTimestamp(e.timestamp), s = t.getSlotNumberByTimestamp(r);
        if (n > s) throw new ut(c.INVALID_TRANSACTION_TIMESTAMP, { reason: `Transaction timestamp in future. Transaction time is ahead of the time on the server, transaction timestamp ${e.timestamp}, transaction timestamp slot ${n}, blockChain now timestamp ${r}, blockChain now timestamp slot ${s}`, signature: e.signature, senderId: e.senderId, applyBlockHeight: e.applyBlockHeight, type: e.type });
      }
      async checkTransactionRange(e, t) {
        const { accountGetterHelper: r } = this, { rangeType: n, range: s } = e, { magic: o } = this.configHelper;
        switch (n) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            for (const a of s) if (!await r.getDApp(o, a, t)) throw new ut(c.DAPPID_IS_NOT_EXIST, { dappid: a });
            break;
          case 4:
            for (const a of s) if (!await r.getLocationName(o, a, t)) throw new ut(c.LOCATION_NAME_IS_NOT_EXIST, { locationName: a });
            break;
          default:
            throw new ut(c.UNKNOWN_RANGE_TYPE, { rangeType: n });
        }
      }
      checkTrsMaxBytes(e) {
        if (BigInt(e) > BigInt(this.configHelper.maxTransactionSize)) throw new ut(c.INVALID_TRANSACTION_BYTE_LENGTH, { reason: `The size of the transaction ${e} exceeds the limit` });
      }
      async checkDAppId(e, t) {
        const { dappid: r, senderId: n } = e;
        if (!r) return;
        const { accountGetterHelper: s, transactionGetterHelper: o } = this, a = await s.getDApp(e.fromMagic, r, t);
        if (!a) throw new ut(c.DAPPID_IS_NOT_EXIST, { dappid: r });
        const p = a.possessorAddress;
        if (!await s.getAccountInfo(p, t)) throw new ut(c.NOT_FOUND, { porp: `Dapp possessor ${p}` });
        if (a.type === 0 && !await o.getPurchaseDApp(n, r)) throw new ut(c.NEED_PURCHASE_DAPPID_BEFORE_USE, { dappid: `${r} user ${n} possessor ${p}` });
      }
      async checkLocationName(e, t) {
        const r = e.lns;
        if (!r) return;
        if (!await this.accountGetterHelper.getLocationName(this.configHelper.magic, r, t)) throw new ut(c.LOCATION_NAME_IS_NOT_EXIST, { locationName: r, errorId: Ce.LOCATION_NAME_NOT_EXIST });
      }
      isFeeEnough(e, t, r) {
        return BigInt(t) < BigInt(r) ? { signature: e, isFeeEnough: false, minFee: r } : { signature: e, isFeeEnough: true, minFee: r };
      }
      checkTrsFeeAndWebFee(e, t) {
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByBytes(e, t) + this.transactionHelper.calcTransactionBlobFee(e)).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByBytes(e, t, r) + this.transactionHelper.calcTransactionBlobFee(e, r)).toString());
      }
      checkTransactionBlobSize(e, t) {
        const { maxBlockBlobSize: r } = this.configHelper, n = t === void 0 || r < t ? r : t, s = e.getBlobSize(true);
        if (s > n) throw new ut(c.PROP_SHOULD_LTE_FIELD, { prop: `transaction blob size ${s}`, target: "transaction", field: n });
      }
      async checkRepeatInUntreatedTransaction(e) {
        const { senderId: t, signature: r } = e;
        if (await this.transactionGetterHelper.countTransactionInUntreatedBySignature(t, r) > 0) throw new ut(c.ALREADY_EXIST, { prop: `Transaction with signature ${r}`, target: "untreated transaction" });
      }
      async checkRepeatInBlockChainTransaction(e, t, r = 0) {
        const { signature: n, applyBlockHeight: s } = e;
        if (await this.transactionGetterHelper.countTransactionInBlockChainBySignature(n, this.transactionHelper.calcTransactionQueryRangeByApplyBlockHeight(s, t)) > r) throw new ut(c.ALREADY_EXIST, { prop: `Transaction with signature ${n}`, target: "blockChain" });
      }
      getLockData(e) {
        return [];
      }
      clearCache() {
        this.memoryCache.clearCache();
      }
    };
    l([D(ne), u("design:type", ne)], Me.prototype, "configHelper", void 0);
    l([D(Ft), u("design:type", Ft)], Me.prototype, "timeHelper", void 0);
    l([D(dt), u("design:type", dt)], Me.prototype, "blockHelper", void 0);
    l([D(Ee), u("design:type", Ee)], Me.prototype, "transactionHelper", void 0);
    l([D(xt), u("design:type", xt)], Me.prototype, "jsbiHelper", void 0);
    l([D(Jn, { dynamics: true }), u("design:type", Jn)], Me.prototype, "eventLogicVerifier", void 0);
    l([D(wi), u("design:type", wi)], Me.prototype, "helperLogicVerifier", void 0);
    l([D("transactionGetterHelper", { dynamics: true }), u("design:type", Object)], Me.prototype, "transactionGetterHelper", void 0);
    l([D("blockGetterHelper", { dynamics: true }), u("design:type", Object)], Me.prototype, "blockGetterHelper", void 0);
    l([D("accountGetterHelper", { dynamics: true }), u("design:type", Object)], Me.prototype, "accountGetterHelper", void 0);
    l([D(Va), u("design:type", Va)], Me.prototype, "memoryCache", void 0);
    let mg = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
    };
    mg = l([J(), u("design:paramtypes", [])], mg);
    let _g = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.asset.dapp.dappid];
      }
    };
    _g = l([J(), u("design:paramtypes", [])], _g);
    const { ConsensusException: Ko } = ee("VERIFIER", "DAppPurchasingLogicVerifier");
    let Ag = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.isDAppidMatch(e, t), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      async isDAppidMatch(e, t) {
        const { dappAsset: r } = e.asset.dappPurchasing, { sourceChainMagic: n, dappid: s } = r, o = await this.accountGetterHelper.getDApp(n, s, t);
        if (!o) throw new Ko(c.DAPPID_IS_NOT_EXIST, { dappid: s });
        if (e.recipientId !== o.possessorAddress) throw new Ko(c.SHOULD_BE, { to_compare_prop: `recipientId ${e.recipientId}`, to_target: "DAppPurchasingTransaction", be_compare_prop: `dapp possessor ${o.possessorAddress}` });
        if (r.sourceChainName !== o.sourceChainName || r.type !== o.type) throw new Ko(c.NOT_MATCH, { to_compare_prop: `dapp ${JSON.stringify(r.toJSON())}`, be_compare_prop: `dapp ${JSON.stringify({ sourceChainMagic: r.sourceChainMagic, sourceChainName: o.sourceChainName, dappid: s, type: o.type })}`, to_target: "DAppPurchasingTransaction.asset.dappPurchasing", be_target: "blockChain dapp" });
        if (o.purchaseAsset) {
          if (!r.purchaseAsset) throw new Ko(c.PROP_IS_REQUIRE, { prop: "purchaseAsset", target: "DAppPurchasingTransaction.asset.dappPurchasing.dappAsset" });
          if (r.purchaseAsset !== o.purchaseAsset) throw new Ko(c.NOT_MATCH, { to_compare_prop: `dapp ${JSON.stringify(r.toJSON())}`, be_compare_prop: `dapp ${JSON.stringify({ sourceChainMagic: r.sourceChainMagic, sourceChainName: o.sourceChainName, dappid: s, type: o.type, purchaseAsset: o.purchaseAsset })}`, to_target: "DAppPurchasingTransaction.asset.dappPurchasing", be_target: "blockChain dapp" });
        } else if (r.purchaseAsset) throw new Ko(c.SHOULD_NOT_EXIST, { prop: "purchaseAsset", target: "DAppPurchasingTransaction.asset.dappPurchasing.dappAsset" });
      }
    };
    Ag = l([J(), u("design:paramtypes", [])], Ag);
    const { ConsensusException: lc } = ee("VERIFIER", "MarkLogicVerifier");
    let Eg = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.isDAppidMatch(e, t), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      async isDAppidMatch(e, t) {
        const { dapp: r } = e.asset.mark, { sourceChainMagic: n, dappid: s } = r, o = await this.accountGetterHelper.getDApp(n, s, t);
        if (!o) throw new lc(c.DAPPID_IS_NOT_EXIST, { dappid: s });
        if (r.sourceChainName !== o.sourceChainName || r.type !== o.type) throw new lc(c.NOT_MATCH, { to_compare_prop: `dapp ${JSON.stringify(r.toJSON())}`, be_compare_prop: `dapp ${JSON.stringify({ sourceChainMagic: r.sourceChainMagic, sourceChainName: o.sourceChainName, dappid: s, type: o.type })}`, to_target: "MarkTransaction.asset.mark", be_target: "blockChain dapp" });
        if (o.purchaseAsset) {
          if (!r.purchaseAsset) throw new lc(c.PROP_IS_REQUIRE, { prop: "purchaseAsset", target: "MarkTransaction.asset.mark.dapp" });
          if (r.purchaseAsset !== o.purchaseAsset) throw new lc(c.NOT_MATCH, { to_compare_prop: `dapp ${JSON.stringify(r.toJSON())}`, be_compare_prop: `dapp ${JSON.stringify({ sourceChainMagic: r.sourceChainMagic, sourceChainName: o.sourceChainName, dappid: s, type: o.type, purchaseAsset: o.purchaseAsset })}`, to_target: "MarkTransaction.asset.mark", be_target: "blockChain dapp" });
        } else if (r.purchaseAsset) throw new lc(c.SHOULD_NOT_EXIST, { prop: "purchaseAsset", target: "MarkTransaction.asset.mark.dapp" });
      }
    };
    Eg = l([J(), u("design:paramtypes", [])], Eg);
    let Ig = class extends Me {
      constructor(e, t) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t;
      }
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.type];
      }
    };
    Ig = l([J(), be(0, D(me)), be(1, D(Ee)), u("design:paramtypes", [me, Ee])], Ig);
    const { ConsensusException: Wm } = ee("VERIFIER", "TransactionLogicVerifier");
    let Tg = class extends Me {
      constructor(e, t) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t;
      }
      async verify(e, t, r, n, s) {
        const { sourceChainMagic: o, assetType: a, sourceChainName: p } = e.asset.increaseAsset;
        await this.helperLogicVerifier.isAssetExist(p, o, a);
        const h = await this.helperLogicVerifier.getAccountForce(r, e.recipientId, t);
        this.checkRecipientStatus(a, h), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: f } = this;
        return n === false && f.listenEvent(r, t, s), await f.awaitEventResult(e, s), true;
      }
      checkRecipientStatus(e, t) {
        if (!t.hasOwnProperty("accountStatus")) throw new Wm(c.PROP_LOSE, { prop: "accountStatus", target: "accountInfo" });
        if (t.accountStatus === 16 && e !== this.configHelper.assetType) throw new Wm(c.PERMISSION_DENIED, { operationName: `Increase asset ${e} to ${t.address}, because ${t.address} was frozen` });
      }
      getLockData(e) {
        return [e.asset.increaseAsset.applyAddress];
      }
    };
    Tg = l([J(), be(0, D(me)), be(1, D(Ee)), u("design:paramtypes", [me, Ee])], Tg);
    const { ConsensusException: Xm } = ee("VERIFIER", "TransactionLogicVerifier");
    let Sg = class extends Me {
      
      async verify(e, t, r, n, s) {
        const { sourceChainMagic: o, assetType: a, sourceChainName: p } = e.asset.transferAsset;
        await this.helperLogicVerifier.isAssetExist(p, o, a);
        const h = await this.helperLogicVerifier.getAccountForce(r, e.recipientId, t);
        this.checkRecipientStatus(a, h), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: f } = this;
        return n === false && f.listenEvent(r, t, s), await f.awaitEventResult(e, s), true;
      }
      checkRecipientStatus(e, t) {
        if (!t.hasOwnProperty("accountStatus")) throw new Xm(c.PROP_LOSE, { prop: "accountStatus", target: "accountInfo" });
        if (t.accountStatus === 16 && e !== this.configHelper.assetType) throw new Xm(c.PERMISSION_DENIED, { operationName: `Transfer asset ${e} to ${t.address}, because ${t.address} was frozen` });
      }
    };
    Sg = l([J(), u("design:paramtypes", [])], Sg);
    const { ConsensusException: qm } = ee("VERIFIER", "TransactionLogicVerifier");
    let wg = class extends Me {
      
      async verify(e, t, r, n, s) {
        const { sourceChainName: o, sourceChainMagic: a, parentAssetType: p, assetType: h } = e.asset.transferAny;
        p === G.ASSETS && await this.helperLogicVerifier.isAssetExist(o, a, h);
        const f = await this.helperLogicVerifier.getAccountForce(r, e.recipientId, t);
        this.checkRecipientStatus(h, f), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: g } = this;
        return n === false && g.listenEvent(r, t, s), await g.awaitEventResult(e, s), true;
      }
      checkRecipientStatus(e, t) {
        if (!t.hasOwnProperty("accountStatus")) throw new qm(c.PROP_LOSE, { prop: "accountStatus", target: "accountInfo" });
        if (t.accountStatus === 16 && e !== this.configHelper.assetType) throw new qm(c.PERMISSION_DENIED, { operationName: `Transfer asset ${e} to ${t.address}, because ${t.address} was frozen` });
      }
      getLockData(e) {
        const { parentAssetType: t, assetType: r, taxInformation: n } = e.asset.transferAny, s = [];
        return (t === G.DAPP || t === G.LOCATION_NAME || t === G.ENTITY) && (s.push(r), n && s.push(n.taxCollector)), s;
      }
    };
    wg = l([J(), u("design:paramtypes", [])], wg);
    const { ConsensusException: s0 } = ee("VERIFIER", "TransactionLogicVerifier");
    let bg = class extends Me {
      
      async verify(e, t, r, n, s) {
        const { sourceChainMagic: o, assetType: a, sourceChainName: p } = e.asset.destroyAsset, h = await this.helperLogicVerifier.isAssetExist(p, o, a);
        if (h.applyAddress !== e.recipientId) throw new s0(c.SHOULD_BE, { to_compare_prop: `recipientId ${e.recipientId}`, to_target: "transaction", be_compare_prop: `asset apply account address ${h.applyAddress}` });
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: f } = this;
        return n === false && f.listenEvent(r, t, s), await f.awaitEventResult(e, s), true;
      }
    };
    bg = l([J(), u("design:paramtypes", [])], bg);
    let Ng = class extends Me {
      
      async verify(e, t, r, n, s) {
        const { sourceChainMagic: o, assetType: a, sourceChainName: p, totalGrabableTimes: h } = e.asset.giftAsset;
        await this.helperLogicVerifier.isAssetExist(p, o, a), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: f } = this;
        return n === false && f.listenEvent(r, t, s), await f.awaitEventResult(e, s), true;
      }
      checkTrsFeeAndWebFee(e, t) {
        const r = e.asset.giftAsset.totalGrabableTimes + 1;
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMaxBytes(r) + this.transactionHelper.calcTransactionBlobFee(e)).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        const n = e.asset.giftAsset.totalGrabableTimes + 1;
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMaxBytes(n, r) + this.transactionHelper.calcTransactionBlobFee(e, r)).toString());
      }
    };
    Ng = l([J(), u("design:paramtypes", [])], Ng);
    let xg = class extends Me {
      
      async verify(e, t, r, n, s) {
        const { sourceChainMagic: o, assetType: a, parentAssetType: p, sourceChainName: h } = e.asset.giftAny;
        p === G.ASSETS && await this.helperLogicVerifier.isAssetExist(h, o, a), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: f } = this;
        return n === false && f.listenEvent(r, t, s), await f.awaitEventResult(e, s), true;
      }
      checkTrsFeeAndWebFee(e, t) {
        const r = e.asset.giftAny.totalGrabableTimes + 1;
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMaxBytes(r) + this.transactionHelper.calcTransactionBlobFee(e)).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        const n = e.asset.giftAny.totalGrabableTimes + 1;
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMaxBytes(n, r) + this.transactionHelper.calcTransactionBlobFee(e, r)).toString());
      }
      getLockData(e) {
        const { parentAssetType: t, assetType: r } = e.asset.giftAny, n = [];
        return (t === G.DAPP || t === G.LOCATION_NAME || t === G.ENTITY) && n.push(r), n;
      }
    };
    xg = l([J(), u("design:paramtypes", [])], xg);
    const { ConsensusException: ir, NoFoundException: i0 } = ee("VERIFIER", "GrabAssetLogicVerifier");
    let Fh = class extends Me {
      
      async verify(e, t, r, n, s) {
        const o = e.asset.grabAsset, { transactionSignature: a } = o, p = await this.transactionGetterHelper.getTransactionAndBlockSignatureBySignature(a, this.transactionHelper.calcTransactionQueryRange(t));
        if (!p) throw new i0(c.NOT_EXIST_OR_EXPIRED, { prop: `Transaction with signature ${a}`, target: "grabAsset" });
        const h = p.transaction, g = (await this.transactionCore.recombineTransaction(h)).as(Ki, a);
        if (!g) throw new ir(c.NOT_EXPECTED_RELATED_TRANSACTION, { signature: `${a}` });
        this.isValidRecipientId(e, g), this.isBlockSignatureMatch(e, p.blockSignature), this.isDependentTransactionMatch(e, g), await this.isValidAmount(e), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: d } = this;
        return n === false && d.listenEvent(r, t, s), await d.awaitEventResult(e, s), true;
      }
      async isValidAmount(e) {
        const { senderId: t, recipientId: r, asset: n } = e, s = n.grabAsset, { giftAsset: o, blockSignatureBuffer: a, transactionSignatureBuffer: p } = s;
        let h;
        switch (o.giftDistributionRule) {
          case 0:
            h = this.transactionHelper.calcGrabAverageGiftAssetNumber(o.amount, o.totalGrabableTimes);
            break;
          case 1:
            h = await this.transactionHelper.calcGrabRandomGiftAssetNumber(t, a, p, r, o.amount, o.totalGrabableTimes);
            break;
          case 2:
            h = await this.transactionHelper.calcGrabRandomGiftAssetNumber(t, a, p, r, o.amount, o.totalGrabableTimes);
            break;
        }
        if (!h) throw new ir(c.PROP_IS_INVALID, { prop: `calculate amount ${h.toString()}`, target: "giftAsset" });
        if (h.toString() !== s.amount) throw new ir(c.SHOULD_BE, { to_compare_prop: `amount ${s.amount}`, to_target: "grabAsset", be_compare_prop: h.toString() });
      }
      isValidRecipientId(e, t) {
        if (e.recipientId !== t.senderId) throw new ir(c.NOT_MATCH, { to_compare_prop: `GrabAssetTransaction.recipientId ${e.recipientId}`, be_compare_prop: `GiftAssetTransaction.senderId ${t.senderId}`, to_target: "GrabAssetTransaction", be_target: "GiftAssetTransaction" });
      }
      isBlockSignatureMatch(e, t) {
        if (t !== e.asset.grabAsset.blockSignature) throw new ir(c.NOT_MATCH, { to_compare_prop: `blockSignature ${t}`, be_compare_prop: `blockSignature ${e.asset.grabAsset.blockSignature}`, to_target: "grabAsset", be_target: "blockChain" });
      }
      isDependentTransactionMatch(e, t) {
        const r = e.asset.grabAsset, { giftAsset: n, ciphertextSignature: s } = r, { sourceChainMagic: o, sourceChainName: a, assetType: p, amount: h, giftDistributionRule: f, totalGrabableTimes: g, cipherPublicKeys: d, beginUnfrozenBlockHeight: y } = n, _ = t.asset.giftAsset;
        if (_.sourceChainMagic !== o || _.sourceChainName !== a || _.assetType !== p || _.totalGrabableTimes !== g || _.amount !== h || _.giftDistributionRule !== f) throw new ir(c.NOT_MATCH, { to_compare_prop: `grabAsset.giftAsset: ${JSON.stringify(n.toJSON())}`, be_compare_prop: `giftAsset: ${JSON.stringify(_)}`, to_target: "GrabAssetTransaction", be_target: "GiftAssetTransaction" });
        if (_.beginUnfrozenBlockHeight !== void 0) {
          if (y === void 0) throw new ir(c.PROP_IS_REQUIRE, { prop: "beginUnfrozenBlockHeight", target: "grabAsset.giftAsset" });
          if (_.beginUnfrozenBlockHeight !== y) throw new ir(c.NOT_MATCH, { to_compare_prop: `grabAsset.giftAsset: ${JSON.stringify(n.toJSON())}`, be_compare_prop: `giftAsset: ${JSON.stringify(_)}`, to_target: "GrabAssetTransaction", be_target: "GiftAssetTransaction" });
        } else if (y !== void 0) throw new ir(c.SHOULD_NOT_EXIST, { prop: "beginUnfrozenBlockHeight", target: "grabAsset.giftAsset" });
        if (_.cipherPublicKeys.length !== d.length) throw new ir(c.NOT_MATCH, { to_compare_prop: `grabAsset.giftAsset: ${JSON.stringify(n.toJSON())}`, be_compare_prop: `giftAsset: ${JSON.stringify(_)}`, to_target: "GrabAssetTransaction", be_target: "GiftAssetTransaction" });
        for (const w of _.cipherPublicKeys) if (!d.includes(w)) throw new ir(c.NOT_MATCH, { to_compare_prop: `grabAsset.giftAsset: ${JSON.stringify(n.toJSON())}`, be_compare_prop: `giftAsset: ${JSON.stringify(_)}`, to_target: "GrabAssetTransaction", be_target: "GiftAssetTransaction" });
        if (d.length > 0) {
          if (!s) throw new ir(c.PROP_IS_REQUIRE, { prop: "ciphertextSignature", target: "grabAsset" });
          const { publicKey: w } = s;
          if (!d.includes(w)) throw new ir(c.NOT_MATCH, { to_compare_prop: `publicKey ${w}`, be_compare_prop: "cipherPublicKeys", to_target: "grabAsset.ciphertextSignature", be_target: "giftAsset.cipherPublicKeys" });
        } else if (s) throw new ir(c.SHOULD_NOT_EXIST, { prop: "ciphertextSignature", target: "grabAsset" });
        const { rangeType: I, range: S } = t;
        if (I & 1) {
          if (!S.includes(e.senderId)) throw new ir(c.SHOULD_BE, { to_compare_prop: `senderId ${e.senderId}`, to_target: "grabAssetTransaction", be_compare_prop: "giftAssetTransaction.range" });
        } else if (I & 2) {
          if (!e.dappid || !S.includes(e.dappid)) throw new ir(c.SHOULD_BE, { to_compare_prop: `dappid ${e.dappid}`, to_target: "grabAssetTransaction", be_compare_prop: "giftAssetTransaction.range" });
        } else if (I & 4 && (!e.lns || !S.includes(e.lns))) throw new ir(c.SHOULD_BE, { to_compare_prop: `lns ${e.lns}`, to_target: "grabAssetTransaction", be_compare_prop: "giftAssetTransaction.range" });
      }
      checkTrsFeeAndWebFee(e, t) {
        return this.isFeeEnough(e.signature, e.fee, this.transactionHelper.calcTransactionBlobFee(e).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        return this.isFeeEnough(e.signature, e.fee, this.transactionHelper.calcTransactionBlobFee(e, r).toString());
      }
      async checkSecondaryTransaction(e, t) {
        if (await this.transactionGetterHelper.checkSecondaryTransaction({ senderId: e.senderId, storageValue: e.storageValue, heightRange: this.transactionHelper.calcTransactionQueryRange(t) })) throw new ir(c.CAN_NOT_SECONDARY_TRANSACTION, { reason: `Can not secondary grab asset, sender ${e.senderId} gift transaction signature ${e.storageValue}` });
      }
      getLockData(e) {
        const { transactionSignature: t } = e.asset.grabAsset;
        return [t];
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], Fh.prototype, "transactionCore", void 0);
    Fh = l([J(), u("design:paramtypes", [])], Fh);
    const { ConsensusException: Lt, NoFoundException: o0 } = ee("VERIFIER", "GrabAnyLogicVerifier");
    let $h = class extends Me {
      
      async verify(e, t, r, n, s) {
        const o = e.asset.grabAny, { transactionSignature: a, giftAny: p } = o, h = await this.transactionGetterHelper.getTransactionAndBlockSignatureBySignature(a, this.transactionHelper.calcTransactionQueryRange(t));
        if (!h) throw new o0(c.NOT_EXIST_OR_EXPIRED, { prop: `Transaction with signature ${a}`, target: "grabAny" });
        const f = h.transaction, d = (await this.transactionCore.recombineTransaction(f)).as(Yi, a);
        if (!d) throw new Lt(c.NOT_EXPECTED_RELATED_TRANSACTION, { signature: `${a}` });
        this.isValidRecipientId(e, d), this.isBlockSignatureMatch(e, h.blockSignature), this.isDependentTransactionMatch(e, d), await this.isValidAmount(e), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: y } = this;
        return n === false && y.listenEvent(r, t, s), await y.awaitEventResult(e, s), true;
      }
      async isValidAmount(e) {
        const { senderId: t, recipientId: r, asset: n } = e, s = n.grabAny, { giftAny: o, blockSignatureBuffer: a, transactionSignatureBuffer: p } = s, { giftDistributionRule: h, parentAssetType: f, totalGrabableTimes: g, amount: d } = o;
        if (f === G.ASSETS) {
          let y;
          switch (h) {
            case 0:
              y = this.transactionHelper.calcGrabAverageGiftAssetNumber(d, g);
              break;
            case 1:
              y = await this.transactionHelper.calcGrabRandomGiftAssetNumber(t, a, p, r, d, g);
              break;
            case 2:
              y = await this.transactionHelper.calcGrabRandomGiftAssetNumber(t, a, p, r, d, g);
              break;
          }
          if (!y) throw new Lt(c.PROP_IS_INVALID, { prop: "calculate amount", target: "giftAsset" });
          if (y.toString() !== s.amount) throw new Lt(c.SHOULD_BE, { to_compare_prop: `amount ${s.amount}`, to_target: "grabAny", be_compare_prop: y.toString() });
        } else if (s.amount !== "1") throw new Lt(c.SHOULD_BE, { to_compare_prop: `amount ${s.amount}`, to_target: "giftAny", be_compare_prop: "1" });
      }
      isValidRecipientId(e, t) {
        if (e.recipientId !== t.senderId) throw new Lt(c.NOT_MATCH, { to_compare_prop: `GrabAnyTransaction.recipientId ${e.recipientId}`, be_compare_prop: `GiftAnyTransaction.senderId ${t.senderId}`, to_target: "GrabAnyTransaction", be_target: "GiftAnyTransaction" });
      }
      isBlockSignatureMatch(e, t) {
        if (t !== e.asset.grabAny.blockSignature) throw new Lt(c.NOT_MATCH, { to_compare_prop: `blockSignature ${t}`, be_compare_prop: `blockSignature ${e.asset.grabAny.blockSignature}`, to_target: "grabAny", be_target: "blockChain" });
      }
      isDependentTransactionMatch(e, t) {
        const { giftAny: r, ciphertextSignature: n } = e.asset.grabAny, { sourceChainMagic: s, sourceChainName: o, assetType: a, amount: p, giftDistributionRule: h, totalGrabableTimes: f, beginUnfrozenBlockHeight: g, taxInformation: d, cipherPublicKeys: y } = r, _ = t.asset.giftAny;
        if (_.sourceChainMagic !== s || _.sourceChainName !== o || _.assetType !== a || _.amount !== p || _.giftDistributionRule !== h || _.totalGrabableTimes !== f) throw new Lt(c.NOT_MATCH, { to_compare_prop: `grabAny.giftAny: ${JSON.stringify(r.toJSON())}`, be_compare_prop: `giftAny: ${JSON.stringify(_)}`, to_target: "GrabAnyTransaction", be_target: "GiftAnyTransaction" });
        if (_.beginUnfrozenBlockHeight !== void 0) {
          if (g === void 0) throw new Lt(c.PROP_IS_REQUIRE, { prop: "beginUnfrozenBlockHeight", target: "grabAny.giftAny" });
          if (_.beginUnfrozenBlockHeight !== g) throw new Lt(c.NOT_MATCH, { to_compare_prop: `grabAny.giftAny: ${JSON.stringify(r.toJSON())}`, be_compare_prop: `giftAny: ${JSON.stringify(_)}`, to_target: "GrabAnyTransaction", be_target: "GiftAnyTransaction" });
        } else if (g !== void 0) throw new Lt(c.SHOULD_NOT_EXIST, { prop: "beginUnfrozenBlockHeight", target: "grabAny.giftAny" });
        if (_.taxInformation) {
          if (!d) throw new Lt(c.PROP_IS_REQUIRE, { prop: "taxInformation", target: "grabAny.giftAny" });
          if (_.taxInformation.taxAssetPrealnum !== d.taxAssetPrealnum || _.taxInformation.taxCollector !== d.taxCollector) throw new Lt(c.NOT_MATCH, { to_compare_prop: `grabAny.giftAny: ${JSON.stringify(r.toJSON())}`, be_compare_prop: `giftAny: ${JSON.stringify(_)}`, to_target: "GrabAnyTransaction", be_target: "GiftAnyTransaction" });
        } else if (d) throw new Lt(c.SHOULD_NOT_EXIST, { prop: "taxInformation", target: "grabAny.giftAny" });
        if (_.cipherPublicKeys.length !== y.length) throw new Lt(c.NOT_MATCH, { to_compare_prop: `grabAny.giftAny: ${JSON.stringify(r.toJSON())}`, be_compare_prop: `giftAny: ${JSON.stringify(_)}`, to_target: "GrabAnyTransaction", be_target: "GiftAnyTransaction" });
        for (const w of _.cipherPublicKeys) if (!y.includes(w)) throw new Lt(c.NOT_MATCH, { to_compare_prop: `grabAny.giftAny: ${JSON.stringify(r.toJSON())}`, be_compare_prop: `giftAny: ${JSON.stringify(_)}`, to_target: "GrabAnyTransaction", be_target: "GiftAnyTransaction" });
        if (y.length > 0) {
          if (!n) throw new Lt(c.NOT_EXIST, { prop: "ciphertextSignature", target: "grabAny" });
          const { publicKey: w } = n;
          if (!y.includes(w)) throw new Lt(c.NOT_MATCH, { to_compare_prop: `publicKey ${w}`, be_compare_prop: "cipherPublicKeys", to_target: "grabAny.ciphertextSignature", be_target: "giftAny.cipherPublicKeys" });
        } else if (n) throw new Lt(c.SHOULD_NOT_EXIST, { prop: "ciphertextSignature", target: "grabAny" });
        const { rangeType: I, range: S } = t;
        if (I & 1) {
          if (!S.includes(e.senderId)) throw new Lt(c.SHOULD_BE, { to_compare_prop: `senderId ${e.senderId}`, to_target: "grabAnyTransaction", be_compare_prop: "giftAnyTransaction.range" });
        } else if (I & 2) {
          if (!e.dappid || !S.includes(e.dappid)) throw new Lt(c.SHOULD_BE, { to_compare_prop: `dappid ${e.dappid}`, to_target: "grabAnyTransaction", be_compare_prop: "giftAnyTransaction.range" });
        } else if (I & 4 && (!e.lns || !S.includes(e.lns))) throw new Lt(c.SHOULD_BE, { to_compare_prop: `lns ${e.lns}`, to_target: "grabAnyTransaction", be_compare_prop: "giftAnyTransaction.range" });
      }
      checkTrsFeeAndWebFee(e, t) {
        return this.isFeeEnough(e.signature, e.fee, this.transactionHelper.calcTransactionBlobFee(e).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        return this.isFeeEnough(e.signature, e.fee, this.transactionHelper.calcTransactionBlobFee(e, r).toString());
      }
      async checkSecondaryTransaction(e, t) {
        if (await this.transactionGetterHelper.checkSecondaryTransaction({ senderId: e.senderId, storageValue: e.storageValue, heightRange: this.transactionHelper.calcTransactionQueryRange(t) })) throw new Lt(c.CAN_NOT_SECONDARY_TRANSACTION, { reason: `Can not secondary grab asset, sender ${e.senderId} gift transaction signature ${e.storageValue}` });
      }
      getLockData(e) {
        const { transactionSignature: t, giftAny: r } = e.asset.grabAny, { parentAssetType: n, assetType: s, taxInformation: o } = r, a = [t];
        return (n === G.DAPP || n === G.LOCATION_NAME || n === G.ENTITY) && (a.push(s), o && a.push(o.taxCollector)), a;
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], $h.prototype, "transactionCore", void 0);
    $h = l([J(), u("design:paramtypes", [])], $h);
    const { ConsensusException: Zm } = ee("VERIFIER", "TrustAssetLogicVerifier");
    let Og = class extends Me {
      
      async verify(e, t, r, n, s) {
        const { sourceChainMagic: o, assetType: a, sourceChainName: p, numberOfSignFor: h } = e.asset.trustAsset;
        if (!(o === this.configHelper.magic && a === this.configHelper.assetType)) throw new Zm(c.TRUST_MAIN_ASSET_ONLY, { assetType: a, mainAsset: this.configHelper.assetType, errorId: Ce.TRUST_MAIN_ASSET_ONLY });
        await this.isTrusteesFrozen(e.asset.trustAsset.trustees, t), await this.helperLogicVerifier.isAssetExist(p, o, a), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: f } = this;
        return n === false && f.listenEvent(r, t, s), await f.awaitEventResult(e, s), true;
      }
      async isTrusteesFrozen(e, t) {
        for (const r of e) {
          const n = await this.accountGetterHelper.getAccountInfo(r, t);
          if (n && n.accountStatus !== 0) throw new Zm(c.ACCOUNT_FROZEN, { address: n.address, errorId: Ce.TRANSACTION_SENDER_ASSET_FROZEN });
        }
      }
      checkTrsFeeAndWebFee(e, t) {
        const r = e.asset.trustAsset.numberOfSignFor + 1;
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMaxBytes(r) + this.transactionHelper.calcTransactionBlobFee(e)).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        const n = e.asset.trustAsset.numberOfSignFor + 1;
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMaxBytes(n, r) + this.transactionHelper.calcTransactionBlobFee(e, r)).toString());
      }
    };
    Og = l([J(), u("design:paramtypes", [])], Og);
    const { ConsensusException: vi } = ee("VERIFIER", "SignForAssetLogicVerifier");
    let Uh = class extends Me {
      constructor(e) {
        super(), this.accountBaseHelper = e;
      }
      async verify(e, t, r, n, s) {
        const { transactionSignature: o } = e.asset.signForAsset, a = await this.transactionGetterHelper.getTransactionBySignature(o, this.transactionHelper.calcTransactionQueryRange(t));
        if (!a) throw new vi(c.NOT_EXIST_OR_EXPIRED, { prop: `Transaction with signature ${o}`, target: "blockChain" });
        const h = (await this.transactionCore.recombineTransaction(a)).as(pa, o);
        if (!h) throw new vi(c.NOT_EXPECTED_RELATED_TRANSACTION, { signature: `${o}` });
        await this.isDependentTransactionMatch(e, h), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: f } = this;
        return n === false && f.listenEvent(r, t, s), await f.awaitEventResult(e, s), true;
      }
      async isDependentTransactionMatch(e, t) {
        const { trustAsset: r, trustSenderId: n, trustRecipientId: s } = e.asset.signForAsset, o = t.asset.trustAsset;
        if (n !== t.senderId) throw new vi(c.SHOULD_BE, { to_compare_prop: `trustSenderId ${n}`, be_compare_prop: `trustSenderId ${t.senderId}`, to_target: "SignForAssetTransaction.asset.signForAsset", be_target: "TrustAssetTransaction" });
        if (s !== t.recipientId) throw new vi(c.NOT_MATCH, { to_compare_prop: `recipientId ${e.recipientId}`, be_compare_prop: `recipientId ${t.recipientId}`, to_target: "SignForAssetTransaction", be_target: "TrustAssetTransaction" });
        if (o.sourceChainMagic !== r.sourceChainMagic || o.sourceChainName !== r.sourceChainName || o.assetType !== r.assetType || o.amount !== r.amount || o.numberOfSignFor !== r.numberOfSignFor || o.trustees.length !== r.trustees.length) throw new vi(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(o)}`, be_compare_prop: `trustAsset: ${JSON.stringify(r.toJSON())}`, to_target: "SignForAssetTransaction.asset.signForAsset", be_target: "TrustAssetTransaction.asset.trustAsset" });
        const a = [...o.trustees], p = [...r.trustees];
        for (const h of a) if (!p.includes(h)) throw new vi(c.NOT_MATCH, { to_compare_prop: `trustees: ${JSON.stringify(p)}`, be_compare_prop: `address: ${h}`, to_target: "SignForAssetTransaction.asset.signForAsset.trustAsset", be_target: "TrustAssetTransaction.asset.trustAsset" });
      }
      checkTrsFeeAndWebFee(e, t) {
        return this.isFeeEnough(e.signature, e.fee, this.transactionHelper.calcTransactionBlobFee(e).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        return this.isFeeEnough(e.signature, e.fee, this.transactionHelper.calcTransactionBlobFee(e, r).toString());
      }
      async checkSecondaryTransaction(e, t) {
        if (await this.transactionGetterHelper.checkSecondaryTransaction({ senderId: e.senderId, storageValue: e.storageValue, heightRange: this.transactionHelper.calcTransactionQueryRange(t) })) throw new vi(c.CAN_NOT_SECONDARY_TRANSACTION, { reason: `Can not secondary sign for asset, sender ${e.senderId} trust transaction signature ${e.storageValue}` });
      }
      getLockData(e) {
        return [e.asset.signForAsset.transactionSignature];
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], Uh.prototype, "transactionCore", void 0);
    Uh = l([J(), be(0, D(me)), u("design:paramtypes", [me])], Uh);
    let Cg = class extends Me {
      
      async verify(e, t, r, n, s) {
        const o = e.asset.toExchangeAsset;
        await this.isExchangeAssetAlreadyExist(o), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: a } = this;
        return n === false && a.listenEvent(r, t, s), await a.awaitEventResult(e, s), true;
      }
      async isExchangeAssetAlreadyExist(e) {
        const { toExchangeSource: t, toExchangeChainName: r, toExchangeAsset: n, beExchangeSource: s, beExchangeChainName: o, beExchangeAsset: a } = e;
        await this.helperLogicVerifier.isAssetExist(r, t, n), await this.helperLogicVerifier.isAssetExist(o, s, a);
      }
    };
    Cg = l([J(), u("design:paramtypes", [])], Cg);
    const { ConsensusException: or, NoFoundException: a0 } = ee("VERIFIER", "TransactionLogicVerifier");
    let Vh = class extends Me {
      constructor(e) {
        super(), this.jsbiHelper = e;
      }
      async verify(e, t, r, n, s) {
        const o = e.asset.beExchangeAsset, { transactionSignature: a } = o, p = await this.transactionGetterHelper.getTransactionBySignature(a, this.transactionHelper.calcTransactionQueryRange(t));
        if (!p) throw new a0(c.NOT_EXIST_OR_EXPIRED, { prop: `Transaction with signature ${a}`, target: "blockChain" });
        const f = (await this.transactionCore.recombineTransaction(p)).as(la, a);
        if (!f) throw new or(c.NOT_EXPECTED_RELATED_TRANSACTION, { signature: `${a}` });
        this.isValidRecipientId(e, f), this.isDependentTransactionMatch(e, f), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: g } = this;
        return n === false && g.listenEvent(r, t, s), await g.awaitEventResult(e, s), true;
      }
      isValidRecipientId(e, t) {
        if (e.recipientId !== t.senderId) throw new or(c.NOT_MATCH, { to_compare_prop: `recipientId ${e.recipientId}`, be_compare_prop: `senderId ${t.senderId}`, to_target: "BeExchangeAssetTransaction", be_target: "ToExchangeAssetTransaction" });
      }
      isDependentTransactionMatch(e, t) {
        const r = e.asset.beExchangeAsset, { exchangeAsset: n, ciphertextSignature: s, toExchangeNumber: o, beExchangeNumber: a } = r, { cipherPublicKeys: p, exchangeRate: h } = n, f = t.asset.toExchangeAsset;
        if (f.toExchangeSource !== n.toExchangeSource || f.beExchangeSource !== n.beExchangeSource || f.toExchangeChainName !== n.toExchangeChainName || f.beExchangeChainName !== n.beExchangeChainName || f.toExchangeAsset !== n.toExchangeAsset || f.beExchangeAsset !== n.beExchangeAsset || f.toExchangeNumber !== n.toExchangeNumber) throw new or(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(f)}`, be_compare_prop: `exchangeAsset: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAssetTransaction", be_target: "ToExchangeAssetTransaction" });
        if (f.exchangeRate) {
          if (!h) throw new or(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(f)}`, be_compare_prop: `exchangeAsset: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAssetTransaction", be_target: "ToExchangeAssetTransaction" });
          if (f.exchangeRate.prevWeight !== h.prevWeight || f.exchangeRate.nextWeight !== h.nextWeight) throw new or(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(f)}`, be_compare_prop: `exchangeAsset: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAssetTransaction", be_target: "ToExchangeAssetTransaction" });
        } else if (h) throw new or(c.SHOULD_NOT_EXIST, { prop: "exchangeRate", target: "BeExchangeAssetTransaction.beExchangeAsset.exchangeAsset" });
        if (e.senderId === e.recipientId) {
          if (o === "0") throw new or(c.PROP_SHOULD_GT_FIELD, { prop: `toExchangeNumber ${o}`, field: "0", target: "BeExchangeAssetTransaction.beExchangeAsset" });
          if (a !== "0") throw new or(c.PROP_SHOULD_EQ_FIELD, { prop: `beExchangeNumber ${a}`, field: "0", target: "BeExchangeAssetTransaction.beExchangeAsset" });
        } else {
          if (o === "0" && a === "0") throw new or(c.PROP_SHOULD_GT_FIELD, { prop: `beExchangeNumber ${a}`, field: "0", target: "beExchangeAsset" });
          const y = this.jsbiHelper.multiplyRoundFraction(o, { numerator: n.exchangeRate.nextWeight, denominator: n.exchangeRate.prevWeight });
          if (y > BigInt(a)) throw new or(c.PROP_SHOULD_GTE_FIELD, { prop: `beExchangeNumber ${a}`, field: y.toString(), target: "BeExchangeAssetTransaction.beExchangeAsset" });
        }
        if (f.cipherPublicKeys.length !== p.length) throw new or(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(f)}`, be_compare_prop: `exchangeAsset: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAssetTransaction", be_target: "ToExchangeAssetTransaction" });
        for (const y of f.cipherPublicKeys) if (!p.includes(y)) throw new or(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(f)}`, be_compare_prop: `exchangeAsset: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAssetTransaction", be_target: "ToExchangeAssetTransaction" });
        if (p.length > 0) {
          if (!s) throw new or(c.NOT_EXIST, { prop: "ciphertextSignature", target: "beExchangeAsset" });
          const { publicKey: y } = s;
          if (!p.includes(y)) throw new or(c.NOT_MATCH, { to_compare_prop: `publicKey ${y}`, be_compare_prop: "cipherPublicKeys", to_target: "beExchangeAsset.ciphertextSignature", be_target: "toExchangeAsset.cipherPublicKeys" });
        } else if (s) throw new or(c.SHOULD_NOT_EXIST, { prop: "ciphertextSignature", target: "beExchangeAsset" });
        const { rangeType: g, range: d } = t;
        if (g & 1) {
          if (!d.includes(e.senderId)) throw new or(c.SHOULD_BE, { to_compare_prop: `senderId ${e.senderId}`, to_target: "beExchangeAssetTransaction", be_compare_prop: "toExchangeAssetTransaction.range" });
        } else if (g & 2) {
          if (!e.dappid || !d.includes(e.dappid)) throw new or(c.SHOULD_BE, { to_compare_prop: `dappid ${e.dappid}`, to_target: "beExchangeAssetTransaction", be_compare_prop: "toExchangeAssetTransaction.range" });
        } else if (g & 4 && (!e.lns || !d.includes(e.lns))) throw new or(c.SHOULD_BE, { to_compare_prop: `lns ${e.lns}`, to_target: "beExchangeAssetTransaction", be_compare_prop: "toExchangeAssetTransaction.range" });
      }
      getLockData(e) {
        return [e.asset.beExchangeAsset.transactionSignature];
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], Vh.prototype, "transactionCore", void 0);
    Vh = l([J(), u("design:paramtypes", [xt])], Vh);
    const { ConsensusException: Rn } = ee("VERIFIER", "EmigrateAssetLogicVerifier");
    let Rg = class extends Me {
      constructor(e, t, r) {
        super(), this.accountBaseHelper = e, this.configMap = t, this.migrateCertificateHelper = r;
      }
      async verify(e, t, r, n, s) {
        const { accountGetterHelper: o } = this, { senderId: a, toMagic: p } = e, h = await this.helperLogicVerifier.getAccountForce(r, a, t);
        if (await o.isFrozenAsset(a)) throw new Rn(c.POSSESS_FROZEN_ASSET);
        await this.helperLogicVerifier.isPossessAssetExceptChainAsset(a, h.assets), await this.helperLogicVerifier.isDAppPossessor(a, this.configHelper), await this.helperLogicVerifier.isLnsPossessorOrManager(a, this.configHelper), await this.helperLogicVerifier.isEntityFactoryPossessor(a, this.configHelper), await this.helperLogicVerifier.isEntityPossessor(a, this.configHelper);
        let g;
        try {
          g = JSON.parse(e.asset.emigrateAsset.migrateCertificate);
        } catch {
          throw new Rn(c.PROP_IS_INVALID, { prop: "migrateCertificate", target: "transaction.asset.immigrateAsset" });
        }
        const d = this.migrateCertificateHelper.getMigrateCertificateConverter(g), y = g.body, _ = d.assetId.decode(y.assetId, true), S = d.fromChainId.decode(y.fromChainId, true).magic;
        if (!(S === this.configHelper.magic && _.assetType === this.configHelper.assetType)) throw new Rn(c.MIGRATE_MAIN_ASSET_ONLY, { assetType: _.assetType, mainAsset: this.configHelper.assetType, errorId: Ce.MIGRATE_MAIN_ASSET_ONLY });
        const w = await o.getChain(p);
        if (!w) throw new Rn(c.NOT_EXIST, { prop: `Chain with magic ${p}`, target: "blockChain" });
        const N = w.genesisBlock, B = d.toChainId.decode(y.toChainId, true);
        await this.migrateCertificateHelper.checkChainInfo("toChain", B, { chainName: N.chainName, magic: N.magic, generatorPublicKey: N.genesisAccount.publicKey, genesisBlockSignature: N.genesisBlockSignature, genesisGenerators: N.genesisGenerators.map((L) => L.address) });
        const { publicKey: O, secondPublicKey: P, signSignature: C } = d.fromAuthSignature.decode(g.fromAuthSignature, true), V = await this.accountBaseHelper.getAddressFromPublicKeyString(O), F = await o.getAccountInfo(V, t);
        if (!F) throw new Rn(c.NOT_EXIST, { prop: `Account with address ${V}`, target: "blockChain" });
        if (F.secondPublicKey) {
          if (!P) throw new Rn(c.PROP_IS_REQUIRE, { prop: "secondPublicKey", target: "genesisGeneratorsignature" });
          if (!C) throw new Rn(c.PROP_IS_REQUIRE, { prop: "signSignature", target: "genesisGeneratorsignature" });
          if (F.secondPublicKey !== P) throw new Rn(c.NOT_MATCH, { to_compare_prop: `secondPublicKey ${F.secondPublicKey}`, be_compare_prop: `secondPublicKey ${P}`, to_target: "transaction", be_target: "generator" });
        } else {
          if (P) throw new Rn(c.CAN_NOT_CARRY_SECOND_PUBLICKEY);
          if (C) throw new Rn(c.CAN_NOT_CARRY_SECOND_SIGNATURE, { signature: e.signature, senderId: e.senderId, applyBlockHeight: e.applyBlockHeight, type: e.type });
        }
        if (_.parentAssetType === G.ASSETS) {
          const L = _.assetType === this.configHelper.assetType ? BigInt(e.fee) + BigInt(y.assetPrealnum) : BigInt(y.assetPrealnum);
          if (h.assets[S][_.assetType].assetNumber !== L) throw new Rn(c.NEED_EMIGRATE_TOTAL_ASSET, { address: a });
        }
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: K } = this;
        return n === false && K.listenEvent(r, t, s), await K.awaitEventResult(e, s), true;
      }
    };
    Rg = l([J(), be(0, D(me)), u("design:paramtypes", [me, xr, Fs])], Rg);
    const { ConsensusException: qs, NoFoundException: EC } = ee("VERIFIER", "ImmigrateAssetLogicVerifier");
    let Bg = class extends Me {
      constructor(e, t, r, n) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.configMap = r, this.migrateCertificateHelper = n;
      }
      async verify(e, t, r, n, s) {
        const o = this.accountGetterHelper;
        let a;
        try {
          a = JSON.parse(e.asset.immigrateAsset.migrateCertificate);
        } catch {
          throw new qs(c.PROP_IS_INVALID, { prop: "migrateCertificate", target: "transaction.asset.immigrateAsset" });
        }
        const p = this.migrateCertificateHelper.getMigrateCertificateConverter(a), h = p.fromChainId.decode(a.body.fromChainId, true), f = e.fromMagic, g = await o.getChain(f);
        if (!g) throw new qs(c.NOT_EXIST, { prop: `Chain with magic ${h.magic}`, target: "blockChain" });
        const d = g.genesisBlock;
        await this.migrateCertificateHelper.checkChainInfo("fromChain", h, { chainName: d.chainName, magic: d.magic, generatorPublicKey: d.genesisAccount.publicKey, genesisBlockSignature: d.genesisBlockSignature, genesisGenerators: d.genesisGenerators.map((B) => B.address) });
        const { publicKey: y, secondPublicKey: _, signSignature: I } = p.toAuthSignature.decode(a.toAuthSignature, true), S = await this.accountBaseHelper.getAddressFromPublicKeyString(y), w = await o.getAccountInfo(S, t);
        if (!w) throw new qs(c.NOT_EXIST, { prop: `Account with address ${S}`, target: "blockChain" });
        if (w.secondPublicKey) {
          if (!_) throw new qs(c.PROP_IS_REQUIRE, { prop: "secondPublicKey", target: "genesisGeneratorsignature" });
          if (!I) throw new qs(c.PROP_IS_REQUIRE, { prop: "signSignature", target: "genesisGeneratorsignature" });
          if (w.secondPublicKey !== _) throw new qs(c.NOT_MATCH, { to_compare_prop: `secondPublicKey ${w.secondPublicKey}`, be_compare_prop: `secondPublicKey ${_}`, to_target: "transaction", be_target: "generator" });
        } else {
          if (_) throw new qs(c.CAN_NOT_CARRY_SECOND_PUBLICKEY);
          if (I) throw new qs(c.CAN_NOT_CARRY_SECOND_SIGNATURE);
        }
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: N } = this;
        return n === false && N.listenEvent(r, t, s), await N.awaitEventResult(e, s), true;
      }
    };
    Bg = l([J(), be(0, D(me)), be(1, D(Ee)), u("design:paramtypes", [me, Ee, xr, Fs])], Bg);
    let Pg = class extends Me {
      
      async verify(e, t, r, n, s) {
        const { sourceChainMagic: o, assetType: a, sourceChainName: p } = e.asset.stakeAsset;
        await this.helperLogicVerifier.isAssetExist(p, o, a), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: h } = this;
        return n === false && h.listenEvent(r, t, s), await h.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.asset.stakeAsset.stakeId];
      }
    };
    Pg = l([J(), u("design:paramtypes", [])], Pg);
    const { ConsensusException: c0 } = ee("VERIFIER", "UnstakeAssetLogicVerifier");
    let Gh = class extends Me {
      constructor(e) {
        super(), this.accountBaseHelper = e;
      }
      async verify(e, t, r, n, s) {
        const { stakeId: o, sourceChainMagic: a, sourceChainName: p, assetType: h } = e.asset.unstakeAsset, f = await this.helperLogicVerifier.getStakeAssetForce(e.senderId, o);
        if (f.sourceChainMagic !== a || f.sourceChainName !== p || f.assetType !== h) throw new c0(c.NOT_MATCH, { to_compare_prop: `stakeAsset: ${JSON.stringify({ sourceChainMagic: f.sourceChainMagic, sourceChainName: f.sourceChainName, assetType: f.assetType })}`, be_compare_prop: `unstakeAsset: ${JSON.stringify({ sourceChainMagic: a, sourceChainName: p, assetType: h })}`, to_target: "UnstakeAssetTransaction.asset.unstakeAsset", be_target: "StakeAssetTransaction.asset.stakeAsset" });
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: g } = this;
        return n === false && g.listenEvent(r, t, s), await g.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.asset.unstakeAsset.stakeId];
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], Gh.prototype, "transactionCore", void 0);
    Gh = l([J(), be(0, D(me)), u("design:paramtypes", [me])], Gh);
    let Mg = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.asset.locationName.name];
      }
    };
    Mg = l([J(), u("design:paramtypes", [])], Mg);
    let Lg = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.asset.lnsManager.name];
      }
    };
    Lg = l([J(), u("design:paramtypes", [])], Lg);
    let Hg = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.asset.lnsRecordValue.name];
      }
    };
    Hg = l([J(), u("design:paramtypes", [])], Hg);
    let vg = class extends Me {
      constructor(e, t) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t;
      }
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.type];
      }
    };
    vg = l([J(), be(0, D(me)), be(1, D(Ee)), u("design:paramtypes", [me, Ee])], vg);
    let kg = class extends Me {
      constructor(e, t) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t;
      }
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.type];
      }
    };
    kg = l([J(), be(0, D(me)), be(1, D(Ee)), u("design:paramtypes", [me, Ee])], kg);
    let Dg = class extends Me {
      constructor(e, t) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t;
      }
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await this.eventLogicVerifier.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.asset.issueEntity.entityFactoryPossessor];
      }
    };
    Dg = l([J(), be(0, D(me)), be(1, D(Ee)), u("design:paramtypes", [me, Ee])], Dg);
    const { ConsensusException: zl, NoFoundException: p0 } = ee("VERIFIER", "DestroyEntityLogicVerifier");
    let Kh = class extends Me {
      
      async verify(e, t, r, n, s) {
        const o = e.asset.destroyEntity, { transactionSignature: a } = o, p = await this.transactionGetterHelper.getTransactionAndBlockSignatureBySignature(a, this.transactionHelper.calcTransactionQueryRange(t));
        if (!p) throw new p0(c.NOT_EXIST_OR_EXPIRED, { prop: `Transaction with signature ${a}`, target: "destroyEntity" });
        let h = "";
        const f = p.transaction, g = await this.transactionCore.recombineTransaction(f), d = g.as(ji, a);
        if (d) {
          const _ = d.asset.issueEntity;
          if (_.entityId !== o.entityId) throw new zl(c.NOT_MATCH, { to_compare_prop: `entityId ${o.entityId}`, be_compare_prop: `entityId ${_.entityId}`, to_target: "transaction", be_target: "issueEntityTransaction" });
          h = d.senderId;
        } else {
          const _ = g.as(Ji, a);
          if (!_) throw new zl(c.NOT_EXPECTED_RELATED_TRANSACTION, { signature: `${a}` });
          const I = _.asset.issueEntityMulti.entityStructList.map((S) => S.entityId);
          if (!I.includes(o.entityId)) throw new zl(c.NOT_MATCH, { to_compare_prop: `entityId ${o.entityId}`, be_compare_prop: `entityId [${I.slice(0, 3).join(",")}...]`, to_target: "transaction", be_target: "issueEntityMultiTransaction" });
          h = _.senderId;
        }
        if (e.recipientId !== h) throw new zl(c.NOT_MATCH, { to_compare_prop: `recipientId ${e.recipientId}`, be_compare_prop: `entityApplicant ${h}`, to_target: "transaction", be_target: "issueEntityTransaction" });
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: y } = this;
        return n === false && y.listenEvent(r, t, s), await y.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        const { entityFactoryApplicant: t, entityFactoryPossessor: r, entityId: n } = e.asset.destroyEntity;
        return [t, r, n];
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], Kh.prototype, "transactionCore", void 0);
    Kh = l([J(), u("design:paramtypes", [])], Kh);
    const { ConsensusException: l0 } = ee("CONTROLLER", "IssueEntityMultiLogicVerifier");
    let Fg = class extends Me {
      constructor(e, t) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t;
      }
      async verify(e, t, r, n, s) {
        this.__checkTrsFee(e), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await this.eventLogicVerifier.awaitEventResult(e, s), true;
      }
      __checkTrsFee(e) {
        const t = this.transactionHelper.calcTransactionMinFeeByMulti(e, e.asset.issueEntityMulti.entityStructList.length);
        if (BigInt(e.fee) < BigInt(t)) throw new l0(c.TRANSACTION_FEE_NOT_ENOUGH, { errorId: Ce.TRANSACTION_FEE_NOT_ENOUGH, minFee: t, target: "transaction" });
      }
      checkTrsFeeAndWebFee(e, t) {
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMulti(e, e.asset.issueEntityMulti.entityStructList.length) + this.transactionHelper.calcTransactionBlobFee(e)).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMulti(e, e.asset.issueEntityMulti.entityStructList.length, void 0, r) + this.transactionHelper.calcTransactionBlobFee(e, r)).toString());
      }
      getLockData(e) {
        return [e.asset.issueEntityMulti.entityFactoryPossessor];
      }
    };
    Fg = l([J(), be(0, D(me)), be(1, D(Ee)), u("design:paramtypes", [me, Ee])], Fg);
    const { ConsensusException: zo } = ee("VERIFIER", "ToExchangeAnyLogicVerifier");
    let $g = class extends Me {
      
      async verify(e, t, r, n, s) {
        const o = e.asset.toExchangeAny, { beExchangeSource: a, beExchangeChainName: p, beExchangeParentAssetType: h, beExchangeAssetType: f } = o, g = this.accountGetterHelper;
        if (h === G.ASSETS) await this.helperLogicVerifier.isAssetExist(p, a, f);
        else if (h === G.DAPP) {
          if (!await g.getDApp(a, f, t)) throw new zo(c.DAPPID_IS_NOT_EXIST, { dappid: f });
        } else if (h === G.LOCATION_NAME) {
          if (f.split(",").length > 2) throw new zo(c.ONLY_TOP_LEVEL_LOCATION_NAME_CAN_EXCHANGE);
          if (!await g.getLocationName(a, f, t)) throw new zo(c.LOCATION_NAME_IS_NOT_EXIST, { locationName: f, errorId: Ce.LOCATION_NAME_NOT_EXIST });
        } else if (h === G.ENTITY) {
          const y = await g.getEntity(a, f, t);
          if (!y) throw new zo(c.ENTITY_IS_NOT_EXIST, { entityId: f, errorId: Ce.ENTITY_NOT_EXIST });
          if (y.status === 255) throw new zo(c.ENTITY_ALREADY_DESTROY, { entityId: f, reason: "Entity already be destroy" });
        } else throw new zo(c.PROP_IS_INVALID, { prop: `beExchangeParentAssetType ${h}`, target: "transaction.asset.toExchangeAny" });
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: d } = this;
        return n === false && d.listenEvent(r, t, s), await d.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        const { toExchangeParentAssetType: t, toExchangeAssetType: r } = e.asset.toExchangeAny, n = [];
        return (t === G.DAPP || t === G.LOCATION_NAME || t === G.ENTITY) && n.push(r), n;
      }
    };
    $g = l([J(), u("design:paramtypes", [])], $g);
    const { ConsensusException: pt, NoFoundException: h0 } = ee("VERIFIER", "BeExchangeAnyLogicVerifier");
    let zh = class extends Me {
      constructor(e) {
        super(), this.jsbiHelper = e;
      }
      async verify(e, t, r, n, s) {
        const o = e.asset.beExchangeAny, { transactionSignature: a } = o, p = await this.transactionGetterHelper.getTransactionBySignature(a, this.transactionHelper.calcTransactionQueryRange(t));
        if (!p) throw new h0(c.NOT_EXIST_OR_EXPIRED, { prop: `Transaction with signature ${a}`, target: "blockChain" });
        const f = (await this.transactionCore.recombineTransaction(p)).as(ha, a);
        if (!f) throw new pt(c.NOT_EXPECTED_RELATED_TRANSACTION, { signature: `${a}` });
        if (e.recipientId !== f.senderId) throw new pt(c.NOT_MATCH, { to_compare_prop: `recipientId ${e.recipientId}`, be_compare_prop: `senderId ${f.senderId}`, to_target: "BeExchangeAnyTransaction", be_target: "ToExchangeAnyTransaction" });
        this.isDependentTransactionMatch(e, f), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: g } = this;
        return n === false && g.listenEvent(r, t, s), await g.awaitEventResult(e, s), true;
      }
      isDependentTransactionMatch(e, t) {
        const r = e.asset.beExchangeAny, { exchangeAny: n, ciphertextSignature: s } = r, { cipherPublicKeys: o, assetExchangeWeightRatio: a, taxInformation: p } = n, h = t.asset.toExchangeAny;
        if (h.toExchangeSource !== n.toExchangeSource || h.beExchangeSource !== n.beExchangeSource || h.toExchangeParentAssetType !== n.toExchangeParentAssetType || h.beExchangeParentAssetType !== n.beExchangeParentAssetType || h.toExchangeAssetType !== n.toExchangeAssetType || h.beExchangeAssetType !== n.beExchangeAssetType || h.toExchangeAssetPrealnum !== n.toExchangeAssetPrealnum) throw new pt(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(h)}`, be_compare_prop: `exchangeAny: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAnyTransaction", be_target: "ToExchangeAnyTransaction" });
        if (h.beExchangeAssetPrealnum) {
          if (!n.beExchangeAssetPrealnum) throw new pt(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(h)}`, be_compare_prop: `exchangeAny: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAnyTransaction", be_target: "ToExchangeAnyTransaction" });
          if (h.beExchangeAssetPrealnum !== n.beExchangeAssetPrealnum) throw new pt(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(h)}`, be_compare_prop: `exchangeAny: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAnyTransaction", be_target: "ToExchangeAnyTransaction" });
        } else if (n.beExchangeAssetPrealnum) throw new pt(c.SHOULD_NOT_EXIST, { prop: "beExchangeAssetPrealnum", target: "BeExchangeAnyTransaction.beExchangeAny.exchangeAny" });
        if (h.assetExchangeWeightRatio) {
          if (!a) throw new pt(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(h)}`, be_compare_prop: `exchangeAny: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAnyTransaction", be_target: "ToExchangeAnyTransaction" });
          if (h.assetExchangeWeightRatio.toExchangeAssetWeight !== a.toExchangeAssetWeight || h.assetExchangeWeightRatio.beExchangeAssetWeight !== a.beExchangeAssetWeight) throw new pt(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(h)}`, be_compare_prop: `exchangeAny: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAnyTransaction", be_target: "ToExchangeAnyTransaction" });
        } else if (a) throw new pt(c.SHOULD_NOT_EXIST, { prop: "assetExchangeWeightRatio", target: "BeExchangeAnyTransaction.beExchangeAny.exchangeAny" });
        if (h.taxInformation) {
          if (!p) throw new pt(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(h)}`, be_compare_prop: `exchangeAny: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAnyTransaction", be_target: "ToExchangeAnyTransaction" });
          if (h.taxInformation.taxCollector !== p.taxCollector || h.taxInformation.taxAssetPrealnum !== p.taxAssetPrealnum) throw new pt(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(h)}`, be_compare_prop: `exchangeAny: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAnyTransaction", be_target: "ToExchangeAnyTransaction" });
        } else if (p) throw new pt(c.SHOULD_NOT_EXIST, { prop: "taxInformation", target: "BeExchangeAnyTransaction.beExchangeAny.exchangeAny" });
        if (h.cipherPublicKeys.length !== o.length) throw new pt(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(h)}`, be_compare_prop: `exchangeAny: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAnyTransaction", be_target: "ToExchangeAnyTransaction" });
        for (const _ of h.cipherPublicKeys) if (!o.includes(_)) throw new pt(c.NOT_MATCH, { to_compare_prop: `trsAsset: ${JSON.stringify(h)}`, be_compare_prop: `exchangeAny: ${JSON.stringify(n.toJSON())}`, to_target: "BeExchangeAnyTransaction", be_target: "ToExchangeAnyTransaction" });
        if (o.length > 0) {
          if (!s) throw new pt(c.NOT_EXIST, { prop: "ciphertextSignature", target: "beExchangeAny" });
          const { publicKey: _ } = s;
          if (!o.includes(_)) throw new pt(c.NOT_MATCH, { to_compare_prop: `publicKey ${_}`, be_compare_prop: "cipherPublicKeys", to_target: "beExchangeAny.ciphertextSignature", be_target: "toExchangeAny.cipherPublicKeys" });
        } else if (s) throw new pt(c.SHOULD_NOT_EXIST, { prop: "ciphertextSignature", target: "beExchangeAny" });
        const { toExchangeAssetPrealnum: f, beExchangeAssetPrealnum: g } = r;
        if (e.senderId === e.recipientId) {
          if (n.toExchangeParentAssetType === G.ASSETS) {
            if (f === "0") throw new pt(c.PROP_SHOULD_GT_FIELD, { prop: `toExchangeAssetPrealnum ${f}`, field: "0", target: "beExchangeAny" });
          } else if (f !== "1") throw new pt(c.PROP_SHOULD_EQ_FIELD, { prop: `toExchangeAssetPrealnum ${f}`, field: "1", target: "beExchangeAny" });
          if (g !== "0") throw new pt(c.PROP_SHOULD_EQ_FIELD, { prop: `beExchangeAssetPrealnum ${g}`, field: "0", target: "beExchangeAny" });
        } else {
          if (f === "0" && g === "0") throw new pt(c.PROP_SHOULD_GT_FIELD, { prop: `beExchangeAssetPrealnum ${g}`, field: "0", target: "beExchangeAny" });
          if (a) {
            const _ = this.jsbiHelper.multiplyRoundFraction(f, { numerator: a.beExchangeAssetWeight, denominator: a.toExchangeAssetWeight });
            if (_ > BigInt(g)) throw new pt(c.PROP_SHOULD_GTE_FIELD, { prop: `beExchangeAssetPrealnum ${g}`, field: _.toString(), target: "beExchangeAny" });
          } else if (n.beExchangeParentAssetType === G.ASSETS) {
            if (BigInt(g) < BigInt(n.beExchangeAssetPrealnum)) throw new pt(c.PROP_SHOULD_GTE_FIELD, { prop: `beExchangeAssetPrealnum ${g}`, field: n.beExchangeAssetPrealnum, target: "beExchangeAny" });
          } else if (g !== "1") throw new pt(c.PROP_SHOULD_EQ_FIELD, { prop: `beExchangeAssetPrealnum ${g}`, field: "1", target: "beExchangeAny" });
        }
        const { rangeType: d, range: y } = t;
        if (d & 1) {
          if (!y.includes(e.senderId)) throw new pt(c.SHOULD_BE, { to_compare_prop: `senderId ${e.senderId}`, to_target: "beExchangeAnyTransaction", be_compare_prop: "beExchangeAnyTransaction.range" });
        } else if (d & 2) {
          if (!e.dappid || !y.includes(e.dappid)) throw new pt(c.SHOULD_BE, { to_compare_prop: `dappid ${e.senderId}`, to_target: "beExchangeAnyTransaction", be_compare_prop: "beExchangeAnyTransaction.range" });
        } else if (d & 4 && (!e.lns || !y.includes(e.lns))) throw new pt(c.SHOULD_BE, { to_compare_prop: `lns ${e.lns}`, to_target: "beExchangeAnyTransaction", be_compare_prop: "beExchangeAnyTransaction.range" });
      }
      getLockData(e) {
        const { transactionSignature: t, exchangeAny: r, taxInformation: n } = e.asset.beExchangeAny, { toExchangeParentAssetType: s, beExchangeParentAssetType: o } = r, a = [t];
        return (s === G.DAPP || s === G.LOCATION_NAME || s === G.ENTITY) && (a.push(r.toExchangeAssetType), r.taxInformation && a.push(r.taxInformation.taxCollector)), (o === G.DAPP || o === G.LOCATION_NAME || o === G.ENTITY) && (a.push(r.beExchangeAssetType), n && a.push(n.taxCollector)), a;
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], zh.prototype, "transactionCore", void 0);
    zh = l([J(), u("design:paramtypes", [xt])], zh);
    const { ConsensusException: ki } = ee("VERIFIER", "ToExchangeAnyMultiLogicVerifier");
    let Ug = class extends Me {
      
      async verify(e, t, r, n, s) {
        this.__checkTrsFee(e);
        const o = e.asset.toExchangeAnyMulti, { beExchangeAsset: a } = o, { beExchangeSource: p, beExchangeChainName: h, beExchangeParentAssetType: f, beExchangeAssetType: g } = a, d = this.accountGetterHelper;
        if (f === G.ASSETS) await this.helperLogicVerifier.isAssetExist(h, p, g);
        else if (f === G.DAPP) {
          if (!await d.getDApp(p, g, t)) throw new ki(c.DAPPID_IS_NOT_EXIST, { dappid: g });
        } else if (f === G.LOCATION_NAME) {
          if (g.split(",").length > 2) throw new ki(c.ONLY_TOP_LEVEL_LOCATION_NAME_CAN_EXCHANGE);
          if (!await d.getLocationName(p, g, t)) throw new ki(c.LOCATION_NAME_IS_NOT_EXIST, { locationName: g, errorId: Ce.LOCATION_NAME_NOT_EXIST });
        } else if (f === G.ENTITY) {
          const _ = await d.getEntity(p, g, t);
          if (!_) throw new ki(c.ENTITY_IS_NOT_EXIST, { entityId: g, errorId: Ce.ENTITY_NOT_EXIST });
          if (_.status === 255) throw new ki(c.ENTITY_ALREADY_DESTROY, { entityId: g, reason: "Entity already be destroy" });
        } else throw new ki(c.PROP_IS_INVALID, { prop: `beExchangeParentAssetType ${f}`, target: "transaction.asset.toExchangeAnyMulti" });
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: y } = this;
        return n === false && y.listenEvent(r, t, s), await y.awaitEventResult(e, s), true;
      }
      __checkTrsFee(e) {
        const t = this.transactionHelper.calcTransactionMinFeeByMulti(e, e.asset.toExchangeAnyMulti.toExchangeAssets.length);
        if (BigInt(e.fee) < BigInt(t)) throw new ki(c.TRANSACTION_FEE_NOT_ENOUGH, { errorId: Ce.TRANSACTION_FEE_NOT_ENOUGH, minFee: t, target: "transaction" });
      }
      checkTrsFeeAndWebFee(e, t) {
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMulti(e, e.asset.toExchangeAnyMulti.toExchangeAssets.length) + this.transactionHelper.calcTransactionBlobFee(e)).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMulti(e, e.asset.toExchangeAnyMulti.toExchangeAssets.length, void 0, r) + this.transactionHelper.calcTransactionBlobFee(e, r)).toString());
      }
      getLockData(e) {
        const { toExchangeAssets: t } = e.asset.toExchangeAnyMulti, r = [];
        for (const n of t) {
          const { toExchangeParentAssetType: s, toExchangeAssetType: o } = n;
          (s === G.DAPP || s === G.LOCATION_NAME || s === G.ENTITY) && r.push(o);
        }
        return r;
      }
    };
    Ug = l([J(), u("design:paramtypes", [])], Ug);
    const { ConsensusException: ft, NoFoundException: u0 } = ee("VERIFIER", "BeExchangeAnyMultiLogicVerifier");
    let jh = class extends Me {
      constructor(e) {
        super(), this.jsbiHelper = e;
      }
      async verify(e, t, r, n, s) {
        this.__checkTrsFee(e);
        const o = e.asset.beExchangeAnyMulti, { transactionSignature: a } = o, p = await this.transactionGetterHelper.getTransactionBySignature(a, this.transactionHelper.calcTransactionQueryRange(t));
        if (!p) throw new u0(c.NOT_EXIST_OR_EXPIRED, { prop: `Transaction with signature ${a}`, target: "blockChain" });
        const f = (await this.transactionCore.recombineTransaction(p)).as(ua, a);
        if (!f) throw new ft(c.NOT_EXPECTED_RELATED_TRANSACTION, { signature: `${a}` });
        if (e.recipientId !== f.senderId) throw new ft(c.NOT_MATCH, { to_compare_prop: `recipientId ${e.recipientId}`, be_compare_prop: `senderId ${f.senderId}`, to_target: "BeExchangeAnyMultiTransaction", be_target: "ToExchangeAnyMultiTransaction" });
        this.isDependentTransactionMatch(e, f), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: g } = this;
        return n === false && g.listenEvent(r, t, s), await g.awaitEventResult(e, s), true;
      }
      isDependentTransactionMatch(e, t) {
        const { toExchangeAssets: r, beExchangeAsset: n, cipherPublicKeys: s } = t.asset.toExchangeAnyMulti, { toExchangeAssets: o, beExchangeAsset: a, ciphertextSignature: p } = e.asset.beExchangeAnyMulti, h = {};
        for (const I of r) {
          const { toExchangeSource: S, toExchangeChainName: w, toExchangeParentAssetType: N, toExchangeAssetType: B, toExchangeAssetPrealnum: O, assetExchangeWeightRatio: P, taxInformation: C } = I;
          h[`${S}${B}`] = { toExchangeChainName: w, toExchangeParentAssetType: N, toExchangeAssetPrealnum: O, assetExchangeWeightRatio: P, taxInformation: C };
        }
        for (const I of o) {
          const { toExchangeSource: S, toExchangeChainName: w, toExchangeParentAssetType: N, toExchangeAssetType: B, toExchangeAssetPrealnum: O, assetExchangeWeightRatio: P, taxInformation: C } = I, V = `${S}${B}`, F = h[V];
          if (!F) throw new ft(c.SHOULD_NOT_INCLUDE, { prop: "toExchangeAssets", target: "toExchangeAnyMulti", value: `toExchangeChainName ${w} toExchangeSource ${S} toExchangeAssetType ${B}` });
          if (F.toExchangeChainName !== w || F.toExchangeParentAssetType !== N) throw new ft(c.NOT_MATCH, { to_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify({ toExchangeSource: S, toExchangeChainName: F.toExchangeChainName, toExchangeParentAssetType: F.toExchangeParentAssetType, toExchangeAssetType: B })}`, be_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify(I.toJSON())}`, to_target: "toExchangeAnyMulti", be_target: "beExchangeAnyMulti" });
          if (BigInt(O) > BigInt(F.toExchangeAssetPrealnum)) throw new ft(c.PROP_SHOULD_LTE_FIELD, { prop: `toExchangeAssets.toExchangeAsset.toExchangeAssetPrealnum ${O}`, target: "beExchangeAnyMulti", field: F.toExchangeAssetPrealnum });
          if (F.assetExchangeWeightRatio) {
            if (!P) throw new ft(c.PROP_IS_REQUIRE, { prop: "assetExchangeWeightRatio", target: "beExchangeAnyMulti.beExchangeAsset" });
            if (F.assetExchangeWeightRatio.toExchangeAssetWeight !== P.toExchangeAssetWeight || F.assetExchangeWeightRatio.beExchangeAssetWeight !== P.beExchangeAssetWeight) throw new ft(c.NOT_MATCH, { to_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify({ toExchangeSource: S, toExchangeChainName: w, toExchangeAssetType: B })}`, be_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify(I.toJSON())}`, to_target: "toExchangeAnyMulti", be_target: "beExchangeAnyMulti" });
          } else if (P) throw new ft(c.SHOULD_NOT_EXIST, { prop: "assetExchangeWeightRatio", target: "beExchangeAnyMulti.beExchangeAsset" });
          if (F.taxInformation) {
            if (!C) throw new ft(c.NOT_MATCH, { to_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify({ toExchangeSource: S, toExchangeChainName: w, toExchangeAssetType: B })}`, be_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify(I.toJSON())}`, to_target: "toExchangeAnyMulti", be_target: "beExchangeAnyMulti" });
            if (F.taxInformation.taxCollector !== C.taxCollector || F.taxInformation.taxAssetPrealnum !== C.taxAssetPrealnum) throw new ft(c.NOT_MATCH, { to_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify({ toExchangeSource: S, toExchangeChainName: w, toExchangeAssetType: B })}`, be_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify(I.toJSON())}`, to_target: "toExchangeAnyMulti", be_target: "beExchangeAnyMulti" });
          } else if (C) throw new ft(c.SHOULD_NOT_EXIST, { prop: "taxInformation", target: "BeExchangeAnyMultiTransaction.beExchangeAnyMulti.toExchangeAsset" });
        }
        if (n.beExchangeSource !== a.beExchangeSource || n.beExchangeChainName !== a.beExchangeChainName || n.beExchangeParentAssetType !== a.beExchangeParentAssetType || n.beExchangeAssetType !== a.beExchangeAssetType) throw new ft(c.NOT_MATCH, { to_compare_prop: `beExchangeAsset: ${JSON.stringify(n)}`, be_compare_prop: `beExchangeAsset: ${JSON.stringify(a.toJSON())}`, to_target: "toExchangeAnyMulti", be_target: "beExchangeAnyMulti" });
        const { beExchangeAssetPrealnum: f, beExchangeParentAssetType: g } = a, d = BigInt(f);
        if (e.senderId === e.recipientId) {
          for (const I of o) {
            const { toExchangeParentAssetType: S, toExchangeAssetPrealnum: w } = I;
            if (S === G.ASSETS) {
              if (w === "0") throw new ft(c.PROP_SHOULD_GT_FIELD, { prop: `toExchangeAssetPrealnum ${w}`, field: "0", target: "BeExchangeAnyMultiTransaction.beExchangeAnyMulti.toExchangeAssets" });
            } else if (w !== "1") throw new ft(c.PROP_SHOULD_EQ_FIELD, { prop: `toExchangeAssetPrealnum ${w}`, field: "1", target: "BeExchangeAnyMultiTransaction.beExchangeAnyMulti.toExchangeAssets" });
          }
          if (f !== "0") throw new ft(c.PROP_SHOULD_EQ_FIELD, { prop: `beExchangeAssetPrealnum ${f}`, field: "0", target: "BeExchangeAnyMultiTransaction.beExchangeAnyMulti.beExchangeAsset" });
        } else if (g === G.ASSETS) {
          let I = false;
          for (const S of o) {
            const { toExchangeParentAssetType: w, toExchangeAssetPrealnum: N, assetExchangeWeightRatio: B } = S;
            if (w !== G.ASSETS && (I = true), B) {
              const O = this.jsbiHelper.multiplyRoundFraction(N, { numerator: B.beExchangeAssetWeight, denominator: B.toExchangeAssetWeight });
              if (O > d) throw new ft(c.PROP_SHOULD_GTE_FIELD, { prop: `beExchangeAssetPrealnum ${f}`, field: O.toString(), target: "BeExchangeAnyMultiTransaction.beExchangeAnyMulti.beExchangeAsset" });
            }
            if (N === "0" && f === "0") throw new ft(c.PROP_SHOULD_GT_FIELD, { prop: `beExchangeAssetPrealnum ${f}`, field: "0", target: "BeExchangeAnyMultiTransaction.beExchangeAnyMulti.beExchangeAsset" });
          }
          if (I && n.beExchangeAssetPrealnum && a.beExchangeAssetPrealnum && BigInt(a.beExchangeAssetPrealnum) < BigInt(n.beExchangeAssetPrealnum)) throw new ft(c.PROP_SHOULD_GTE_FIELD, { prop: `beExchangeAsset.beExchangeAssetPrealnum ${a.beExchangeAssetPrealnum}`, target: "beExchangeAnyMulti", field: n.beExchangeAssetPrealnum });
        } else if (f !== "1") throw new ft(c.PROP_SHOULD_EQ_FIELD, { prop: `beExchangeAssetPrealnum ${f}`, field: "1", target: "BeExchangeAnyMultiTransaction.beExchangeAnyMulti.beExchangeAsset" });
        if (s.length > 0) {
          if (!p) throw new ft(c.NOT_EXIST, { prop: "ciphertextSignature", target: "beExchangeAnyMulti" });
          const { publicKey: I } = p;
          if (!s.includes(I)) throw new ft(c.NOT_MATCH, { to_compare_prop: `publicKey ${I}`, be_compare_prop: "cipherPublicKeys", to_target: "beExchangeAnyMulti.ciphertextSignature", be_target: "toExchangeAnyMulti.cipherPublicKeys" });
        } else if (p) throw new ft(c.SHOULD_NOT_EXIST, { prop: "ciphertextSignature", target: "beExchangeAnyMulti" });
        const { rangeType: y, range: _ } = t;
        if (y & 1) {
          if (!_.includes(e.senderId)) throw new ft(c.SHOULD_BE, { to_compare_prop: `senderId ${e.senderId}`, to_target: "beExchangeAnyMultiTransaction", be_compare_prop: "beExchangeAnyMultiTransaction.range" });
        } else if (y & 2) {
          if (!e.dappid || !_.includes(e.dappid)) throw new ft(c.SHOULD_BE, { to_compare_prop: `dappid ${e.senderId}`, to_target: "beExchangeAnyMultiTransaction", be_compare_prop: "beExchangeAnyMultiTransaction.range" });
        } else if (y & 4 && (!e.lns || !_.includes(e.lns))) throw new ft(c.SHOULD_BE, { to_compare_prop: `lns ${e.lns}`, to_target: "beExchangeAnyMultiTransaction", be_compare_prop: "beExchangeAnyMultiTransaction.range" });
      }
      __checkTrsFee(e) {
        const t = this.transactionHelper.calcTransactionMinFeeByMulti(e, e.asset.beExchangeAnyMulti.toExchangeAssets.length);
        if (BigInt(e.fee) < BigInt(t)) throw new ft(c.TRANSACTION_FEE_NOT_ENOUGH, { errorId: Ce.TRANSACTION_FEE_NOT_ENOUGH, minFee: t, target: "transaction" });
      }
      checkTrsFeeAndWebFee(e, t) {
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMulti(e, e.asset.beExchangeAnyMulti.toExchangeAssets.length) + this.transactionHelper.calcTransactionBlobFee(e)).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMulti(e, e.asset.beExchangeAnyMulti.toExchangeAssets.length, void 0, r) + this.transactionHelper.calcTransactionBlobFee(e, r)).toString());
      }
      getLockData(e) {
        const { transactionSignature: t, toExchangeAssets: r, beExchangeAsset: n } = e.asset.beExchangeAnyMulti, s = [t], { beExchangeParentAssetType: o, beExchangeAssetType: a } = n;
        for (const p of r) {
          const { toExchangeParentAssetType: h, toExchangeAssetType: f, taxInformation: g } = p;
          (h === G.DAPP || h === G.LOCATION_NAME || h === G.ENTITY) && (s.push(f), g && s.push(g.taxCollector));
        }
        return (o === G.DAPP || o === G.LOCATION_NAME || o === G.ENTITY) && (s.push(a), s.push(a), n.taxInformation && s.push(n.taxInformation.taxCollector)), s;
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], jh.prototype, "transactionCore", void 0);
    jh = l([J(), u("design:paramtypes", [xt])], jh);
    const { ConsensusException: Di } = ee("VERIFIER", "ToExchangeAnyMultiAllLogicVerifier");
    let Vg = class extends Me {
      
      async verify(e, t, r, n, s) {
        this.__checkTrsFee(e);
        const o = e.asset.toExchangeAnyMultiAll, { beExchangeAssets: a } = o, p = this.accountGetterHelper;
        for (const f of a) {
          const { beExchangeSource: g, beExchangeChainName: d, beExchangeParentAssetType: y, beExchangeAssetType: _ } = f;
          if (y === G.ASSETS) await this.helperLogicVerifier.isAssetExist(d, g, _);
          else if (y === G.DAPP) {
            if (!await p.getDApp(g, _, t)) throw new Di(c.DAPPID_IS_NOT_EXIST, { dappid: _ });
          } else if (y === G.LOCATION_NAME) {
            if (_.split(",").length > 2) throw new Di(c.ONLY_TOP_LEVEL_LOCATION_NAME_CAN_EXCHANGE);
            if (!await p.getLocationName(g, _, t)) throw new Di(c.LOCATION_NAME_IS_NOT_EXIST, { locationName: _, errorId: Ce.LOCATION_NAME_NOT_EXIST });
          } else if (y === G.ENTITY) {
            const I = await p.getEntity(g, _, t);
            if (!I) throw new Di(c.ENTITY_IS_NOT_EXIST, { entityId: _, errorId: Ce.ENTITY_NOT_EXIST });
            if (I.status === 255) throw new Di(c.ENTITY_ALREADY_DESTROY, { entityId: _, reason: "Entity already be destroy" });
          } else throw new Di(c.PROP_IS_INVALID, { prop: `beExchangeParentAssetType ${y}`, target: "transaction.asset.toExchangeAnyMultiAll.beExchangeAssets.beExchangeAsset" });
        }
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: h } = this;
        return n === false && h.listenEvent(r, t, s), await h.awaitEventResult(e, s), true;
      }
      __checkTrsFee(e) {
        const { toExchangeAssets: t, beExchangeAssets: r } = e.asset.toExchangeAnyMultiAll, n = this.transactionHelper.calcTransactionMinFeeByMulti(e, t.length + r.length);
        if (BigInt(e.fee) < BigInt(n)) throw new Di(c.TRANSACTION_FEE_NOT_ENOUGH, { errorId: Ce.TRANSACTION_FEE_NOT_ENOUGH, minFee: n, target: "transaction" });
      }
      checkTrsFeeAndWebFee(e, t) {
        const { toExchangeAssets: r, beExchangeAssets: n } = e.asset.toExchangeAnyMultiAll;
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMulti(e, r.length + n.length) + this.transactionHelper.calcTransactionBlobFee(e)).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        const { toExchangeAssets: n, beExchangeAssets: s } = e.asset.toExchangeAnyMultiAll;
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMulti(e, n.length + s.length, void 0, r) + this.transactionHelper.calcTransactionBlobFee(e, r)).toString());
      }
      getLockData(e) {
        const { toExchangeAssets: t } = e.asset.toExchangeAnyMultiAll, r = [];
        for (const n of t) {
          const { toExchangeParentAssetType: s, toExchangeAssetType: o } = n;
          (s === G.DAPP || s === G.LOCATION_NAME || s === G.ENTITY) && r.push(o);
        }
        return r;
      }
    };
    Vg = l([J(), u("design:paramtypes", [])], Vg);
    const { ConsensusException: Et, NoFoundException: f0 } = ee("VERIFIER", "BeExchangeAnyMultiAllLogicVerifier");
    let Jh = class extends Me {
      constructor(e) {
        super(), this.jsbiHelper = e;
      }
      async verify(e, t, r, n, s) {
        this.__checkTrsFee(e);
        const o = e.asset.beExchangeAnyMultiAll, { transactionSignature: a } = o, p = await this.transactionGetterHelper.getTransactionBySignature(a, this.transactionHelper.calcTransactionQueryRange(t));
        if (!p) throw new f0(c.NOT_EXIST_OR_EXPIRED, { prop: `Transaction with signature ${a}`, target: "blockChain" });
        const f = (await this.transactionCore.recombineTransaction(p)).as(fa, a);
        if (!f) throw new Et(c.NOT_EXPECTED_RELATED_TRANSACTION, { signature: `${a}` });
        if (e.recipientId !== f.senderId) throw new Et(c.NOT_MATCH, { to_compare_prop: `recipientId ${e.recipientId}`, be_compare_prop: `senderId ${f.senderId}`, to_target: "BeExchangeAnyMultiAllTransaction", be_target: "ToExchangeAnyMultiAllTransaction" });
        this.isDependentTransactionMatch(e, f), await this.logicVerify(e, t, r);
        const { eventLogicVerifier: g } = this;
        return n === false && g.listenEvent(r, t, s), await g.awaitEventResult(e, s), true;
      }
      isDependentTransactionMatch(e, t) {
        const { toExchangeAssets: r, beExchangeAssets: n, cipherPublicKeys: s } = t.asset.toExchangeAnyMultiAll, { toExchangeAssets: o, beExchangeAssets: a, ciphertextSignature: p } = e.asset.beExchangeAnyMultiAll;
        if (r.length !== o.length) throw new Et(c.NOT_MATCH, { to_compare_prop: `toExchangeAssets.length: ${r.length}`, be_compare_prop: `toExchangeAssets.length: ${o.length}`, to_target: "toExchangeAnyMultiAll", be_target: "beExchangeAnyMultiAll" });
        if (n.length !== a.length) throw new Et(c.NOT_MATCH, { to_compare_prop: `beExchangeAssets.length: ${n.length}`, be_compare_prop: `beExchangeAssets.length: ${a.length}`, to_target: "toExchangeAnyMultiAll", be_target: "beExchangeAnyMultiAll" });
        const h = {};
        for (const y of r) {
          const { toExchangeSource: _, toExchangeChainName: I, toExchangeParentAssetType: S, toExchangeAssetType: w, toExchangeAssetPrealnum: N, taxInformation: B } = y;
          h[`${_}${w}`] = { toExchangeChainName: I, toExchangeParentAssetType: S, toExchangeAssetPrealnum: N, taxInformation: B };
        }
        const f = {};
        for (const y of n) {
          const { beExchangeSource: _, beExchangeChainName: I, beExchangeParentAssetType: S, beExchangeAssetType: w, beExchangeAssetPrealnum: N, taxInformation: B } = y;
          f[`${_}${w}`] = { beExchangeChainName: I, beExchangeParentAssetType: S, beExchangeAssetPrealnum: N, taxInformation: B };
        }
        for (const y of o) {
          const { toExchangeSource: _, toExchangeChainName: I, toExchangeParentAssetType: S, toExchangeAssetType: w, toExchangeAssetPrealnum: N, taxInformation: B } = y, O = `${_}${w}`, P = h[O];
          if (!P) throw new Et(c.SHOULD_NOT_INCLUDE, { prop: "toExchangeAssets", target: "toExchangeAnyMultiAll", value: `toExchangeChainName ${I} toExchangeSource ${_} toExchangeAssetType ${w}` });
          const C = { toExchangeSource: _, toExchangeChainName: P.toExchangeChainName, toExchangeParentAssetType: P.toExchangeParentAssetType, toExchangeAssetType: w };
          if (P.toExchangeChainName !== I || P.toExchangeParentAssetType !== S) throw new Et(c.NOT_MATCH, { to_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify(C)}`, be_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify(y.toJSON())}`, to_target: "toExchangeAnyMultiAll", be_target: "beExchangeAnyMultiAll" });
          if (N !== P.toExchangeAssetPrealnum) throw new Et(c.PROP_SHOULD_EQ_FIELD, { prop: `toExchangeAssets.toExchangeAsset.toExchangeAssetPrealnum ${N}`, target: "beExchangeAnyMultiAll", field: P.toExchangeAssetPrealnum });
          if (P.taxInformation) {
            if (!B) throw new Et(c.NOT_MATCH, { to_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify(C)}`, be_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify(y.toJSON())}`, to_target: "toExchangeAnyMultiAll", be_target: "beExchangeAnyMultiAll" });
            if (P.taxInformation.taxCollector !== B.taxCollector || P.taxInformation.taxAssetPrealnum !== B.taxAssetPrealnum) throw new Et(c.NOT_MATCH, { to_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify({ ...C, taxInformation: { taxCollector: B.taxCollector, taxAssetPrealnum: B.taxAssetPrealnum } })}`, be_compare_prop: `toExchangeAssets.toExchangeAsset: ${JSON.stringify(y.toJSON())}`, to_target: "toExchangeAnyMultiAll", be_target: "beExchangeAnyMultiAll" });
          } else if (B) throw new Et(c.SHOULD_NOT_EXIST, { prop: "taxInformation", target: "beExchangeAnyMultiAll.toExchangeAssets.toExchangeAsset" });
        }
        for (const y of a) {
          const { beExchangeSource: _, beExchangeChainName: I, beExchangeParentAssetType: S, beExchangeAssetType: w, beExchangeAssetPrealnum: N, taxInformation: B } = y, O = `${_}${w}`, P = f[O];
          if (!P) throw new Et(c.SHOULD_NOT_INCLUDE, { prop: "beExchangeAssets", target: "beExchangeAnyMultiAll", value: `beExchangeChainName ${I} beExchangeSource ${_} beExchangeAssetType ${w}` });
          const C = { beExchangeSource: _, beExchangeChainName: P.beExchangeChainName, beExchangeParentAssetType: P.beExchangeParentAssetType, beExchangeAssetType: w };
          if (I !== P.beExchangeChainName || S !== P.beExchangeParentAssetType) throw new Et(c.NOT_MATCH, { to_compare_prop: `beExchangeAssets.beExchangeAsset: ${JSON.stringify(C)}`, be_compare_prop: `beExchangeAssets.beExchangeAsset: ${JSON.stringify(y.toJSON())}`, to_target: "toExchangeAnyMultiAll", be_target: "beExchangeAnyMultiAll" });
          if (e.senderId === e.recipientId) {
            if (N !== "0") throw new Et(c.PROP_SHOULD_EQ_FIELD, { prop: `beExchangeAssetPrealnum ${N}`, field: "0", target: "beExchangeAnyMultiAll.beExchangeAssets.beExchangeAsset" });
          } else if (N !== P.beExchangeAssetPrealnum) throw new Et(c.NOT_MATCH, { to_compare_prop: `beExchangeAssets.beExchangeAsset: ${JSON.stringify(C)}`, be_compare_prop: `beExchangeAssets.beExchangeAsset: ${JSON.stringify(y.toJSON())}`, to_target: "toExchangeAnyMultiAll", be_target: "beExchangeAnyMultiAll" });
          if (P.taxInformation) {
            if (!B) throw new Et(c.NOT_MATCH, { to_compare_prop: `beExchangeAssets.beExchangeAsset: ${JSON.stringify(C)}`, be_compare_prop: `beExchangeAssets.beExchangeAsset: ${JSON.stringify(y.toJSON())}`, to_target: "toExchangeAnyMultiAll", be_target: "beExchangeAnyMultiAll" });
            if (P.taxInformation.taxCollector !== B.taxCollector || P.taxInformation.taxAssetPrealnum !== B.taxAssetPrealnum) throw new Et(c.NOT_MATCH, { to_compare_prop: `beExchangeAssets.beExchangeAsset: ${JSON.stringify({ ...C, taxInformation: { taxCollector: B.taxCollector, taxAssetPrealnum: B.taxAssetPrealnum } })}`, be_compare_prop: `beExchangeAssets.beExchangeAsset: ${JSON.stringify(y.toJSON())}`, to_target: "toExchangeAnyMultiAll", be_target: "beExchangeAnyMultiAll" });
          } else if (B) throw new Et(c.SHOULD_NOT_EXIST, { prop: "taxInformation", target: "beExchangeAnyMultiAll.beExchangeAssets.beExchangeAsset" });
        }
        if (s.length > 0) {
          if (!p) throw new Et(c.NOT_EXIST, { prop: "ciphertextSignature", target: "beExchangeAnyMultiAll" });
          const { publicKey: y } = p;
          if (!s.includes(y)) throw new Et(c.NOT_MATCH, { to_compare_prop: `publicKey ${y}`, be_compare_prop: "cipherPublicKeys", to_target: "beExchangeAnyMultiAll.ciphertextSignature", be_target: "toExchangeAnyMultiAll.cipherPublicKeys" });
        } else if (p) throw new Et(c.SHOULD_NOT_EXIST, { prop: "ciphertextSignature", target: "beExchangeAnyMultiAll" });
        const { rangeType: g, range: d } = t;
        if (g & 1) {
          if (!d.includes(e.senderId)) throw new Et(c.SHOULD_BE, { to_compare_prop: `senderId ${e.senderId}`, to_target: "beExchangeAnyMultiAllTransaction", be_compare_prop: "beExchangeAnyMultiAllTransaction.range" });
        } else if (g & 2) {
          if (!e.dappid || !d.includes(e.dappid)) throw new Et(c.SHOULD_BE, { to_compare_prop: `dappid ${e.senderId}`, to_target: "beExchangeAnyMultiAllTransaction", be_compare_prop: "beExchangeAnyMultiAllTransaction.range" });
        } else if (g & 4 && (!e.lns || !d.includes(e.lns))) throw new Et(c.SHOULD_BE, { to_compare_prop: `lns ${e.lns}`, to_target: "beExchangeAnyMultiAllTransaction", be_compare_prop: "beExchangeAnyMultiAllTransaction.range" });
      }
      __checkTrsFee(e) {
        const { toExchangeAssets: t, beExchangeAssets: r } = e.asset.beExchangeAnyMultiAll, n = this.transactionHelper.calcTransactionMinFeeByMulti(e, t.length + r.length);
        if (BigInt(e.fee) < BigInt(n)) throw new Et(c.TRANSACTION_FEE_NOT_ENOUGH, { errorId: Ce.TRANSACTION_FEE_NOT_ENOUGH, minFee: n, target: "transaction" });
      }
      checkTrsFeeAndWebFee(e, t) {
        const { toExchangeAssets: r, beExchangeAssets: n } = e.asset.beExchangeAnyMultiAll;
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMulti(e, r.length + n.length) + this.transactionHelper.calcTransactionBlobFee(e)).toString());
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        const { toExchangeAssets: n, beExchangeAssets: s } = e.asset.beExchangeAnyMultiAll;
        return this.isFeeEnough(e.signature, e.fee, (this.transactionHelper.calcTransactionMinFeeByMulti(e, n.length + s.length, void 0, r) + this.transactionHelper.calcTransactionBlobFee(e, r)).toString());
      }
      getLockData(e) {
        const { transactionSignature: t, toExchangeAssets: r, beExchangeAssets: n } = e.asset.beExchangeAnyMultiAll, s = [t];
        for (const o of r) {
          const { toExchangeParentAssetType: a, toExchangeAssetType: p, taxInformation: h } = o;
          (a === G.DAPP || a === G.LOCATION_NAME || a === G.ENTITY) && (s.push(p), h && s.push(h.taxCollector));
        }
        for (const o of n) {
          const { beExchangeParentAssetType: a, beExchangeAssetType: p, taxInformation: h } = o;
          (a === G.DAPP || a === G.LOCATION_NAME || a === G.ENTITY) && (s.push(p), s.push(p), h && s.push(h.taxCollector));
        }
        return s;
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], Jh.prototype, "transactionCore", void 0);
    Jh = l([J(), u("design:paramtypes", [xt])], Jh);
    const { ConsensusException: e_, NoFoundException: DC } = ee("VERIFIER", "IssueCertificateLogicVerifier");
    let Gg = class extends Me {
      constructor(e, t) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t;
      }
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      checkCertificateOnChainHeight(e, t) {
        const r = e.asset.issueCertificate.certificateId, n = Number(r.split(":")[0]);
        if (n < t) throw new e_(c.PROP_SHOULD_GTE_FIELD, { prop: `CertificateId on chain height ${n}`, target: "issueCertificate", field: t });
      }
      isCertificateOnChainHeight(e, t) {
        const r = e.asset.issueCertificate.certificateId, n = Number(r.split(":")[0]);
        if (n !== t) throw new e_(c.SHOULD_BE, { to_compare_prop: `CertificateId on chain height ${n}`, to_target: "issueCertificate", be_compare_prop: t });
      }
      getLockData(e) {
        return [e.type];
      }
    };
    Gg = l([J(), be(0, D(me)), be(1, D(Ee)), u("design:paramtypes", [me, Ee])], Gg);
    const { ConsensusException: t_ } = ee("VERIFIER", "TransactionLogicVerifier");
    let Kg = class extends Me {
      
      async verify(e, t, r, n, s) {
        const { sourceChainMagic: o, sourceChainName: a, certificateId: p, type: h } = e.asset.destroyCertificate, f = await this.helperLogicVerifier.isCertificateExist(a, o, p, t);
        if (f.applyAddress !== e.recipientId) throw new t_(c.SHOULD_BE, { to_compare_prop: `recipientId ${e.recipientId}`, to_target: "transaction", be_compare_prop: `certificate apply account address ${f.applyAddress}` });
        if (f.type !== h) throw new t_(c.NOT_MATCH, { to_compare_prop: `type ${h}`, be_compare_prop: `type ${f.type}`, to_target: "transaction", be_target: "issueCertificateTransaction" });
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: g } = this;
        return n === false && g.listenEvent(r, t, s), await g.awaitEventResult(e, s), true;
      }
    };
    Kg = l([J(), u("design:paramtypes", [])], Kg);
    const { ArgumentFormatException: g0 } = ee("CONTROLLER", "TransactionLogicVerifierCore");
    let $s = class {
      constructor(e, t, r, n, s, o, a) {
        this.transactionHelper = e, this.accountBaseHelper = t, this.asymmetricHelper = r, this.keypairHelper = n, this.Buffer = s, this.config = o, this.moduleMap = a, this._txLogicVerifierCache = /* @__PURE__ */ new Map();
      }
      getTransactionLogicVerifier(e) {
        let t = this._txLogicVerifierCache.get(e);
        return t || (t = bt(e, this.moduleMap), this._txLogicVerifierCache.set(e, t)), t;
      }
      getTransactionLogicVerifierFromType(e) {
        const { baseType: t } = this.transactionHelper.parseType(e);
        return this.getTransactionLogicVerifierFromBaseType(t);
      }
      getTransactionLogicVerifierFromBaseType(e) {
        const t = pn.KLV.get(e);
        if (!t) throw new g0(c.INVALID_BASE_TYPE, { base_type: e });
        return this.getTransactionLogicVerifier(t);
      }
    };
    $s = l([J("bfchain-core:TransactionLogicVerifierCore"), be(3, D("keypairHelper")), be(4, D("Buffer")), u("design:paramtypes", [Ee, me, Or, Object, Object, ne, ze])], $s);
    const pn = (() => {
      const i = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
      return [[v.SIGNATURE, mg], [v.DAPP, _g], [v.DAPP_PURCHASING, Ag], [v.MARK, Eg], [v.ISSUE_ASSET, Ig], [v.INCREASE_ASSET, Tg], [v.DESTROY_ASSET, bg], [v.TRANSFER_ASSET, Sg], [v.TO_EXCHANGE_ASSET, Cg], [v.BE_EXCHANGE_ASSET, Vh], [v.GIFT_ASSET, Ng], [v.GRAB_ASSET, Fh], [v.TRUST_ASSET, Og], [v.SIGN_FOR_ASSET, Uh], [v.EMIGRATE_ASSET, Rg], [v.IMMIGRATE_ASSET, Bg], [v.STAKE_ASSET, Pg], [v.UNSTAKE_ASSET, Gh], [v.LOCATION_NAME, Mg], [v.SET_LNS_RECORD_VALUE, Hg], [v.SET_LNS_MANAGER, Lg], [v.ISSUE_ENTITY_FACTORY, vg], [v.ISSUE_ENTITY_FACTORY_V1, kg], [v.ISSUE_ENTITY, Dg], [v.DESTROY_ENTITY, Kh], [v.ISSUE_ENTITY_MULTI, Fg], [v.TRANSFER_ANY, wg], [v.GIFT_ANY, xg], [v.GRAB_ANY, $h], [v.TO_EXCHANGE_ANY, $g], [v.BE_EXCHANGE_ANY, zh], [v.TO_EXCHANGE_ANY_MULTI, Ug], [v.BE_EXCHANGE_ANY_MULTI, jh], [v.TO_EXCHANGE_ANY_MULTI_ALL, Vg], [v.BE_EXCHANGE_ANY_MULTI_ALL, Jh], [v.ISSUE_CERTIFICATE, Gg], [v.DESTROY_CERTIFICATE, Kg]].forEach(([t, r]) => {
        i.set(t, r), e.set(r, t);
      }), { KLV: i, LVK: e, trsTypeToV(t) {
        const r = t.indexOf("-", t.indexOf("-") + 1);
        return t.substr(r + 1);
      } };
    })();
    let Yh = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
      getLockData(e) {
        return [e.type];
      }
    };
    Yh = l([J(), u("design:paramtypes", [])], Yh);
    const { NoFoundException: r_ } = ee("VERIFIER", "LogicHelper");
    let Cr = class {
      async getMacroCallTransaction(e) {
        const { macroId: t, inputs: r } = e.asset.call, n = `${t}_${e.signature}`;
        let s = this.memoryCache.getCache(n);
        if (s === void 0) {
          const o = await this.transactionGetterHelper.getMacroCallTransaction(t, r);
          if (!o) throw new r_(c.NOT_EXIST, { prop: `Macro call transaction with macroId ${t}`, target: "blockChain" });
          s = await this.transactionCore.recombineTransaction(o), this.memoryCache.setCache(n, s);
        }
        return s;
      }
      async getPromiseTransaction(e) {
        let t = this.memoryCache.getCache(e);
        if (t === void 0) {
          const r = await this.transactionGetterHelper.getPromiseTransaction(e);
          if (!r) throw new r_(c.NOT_EXIST, { prop: `Promise transaction ${e}`, target: "blockChain" });
          t = await this.transactionCore.recombineTransaction(r), this.memoryCache.setCache(e, t);
        }
        return t;
      }
      async getCheckRepeatInfo(e, t = false) {
        let r = 0, n = e.applyBlockHeight;
        const s = [], o = async (a) => {
          switch (a.type) {
            case this.transactionHelper.MULTIPLE: {
              const p = a.asset.multiple.transactions;
              for (const h of p) await o(h);
              break;
            }
            case this.transactionHelper.MACRO_CALL: {
              const p = await this.getMacroCallTransaction(a);
              await o(p);
              break;
            }
            case this.transactionHelper.PROMISE: {
              if (t === false) {
                const p = a.asset.promise.transaction;
                await o(p);
              }
              break;
            }
            case this.transactionHelper.PROMISE_RESOLVE: {
              const p = await this.getPromiseTransaction(a.asset.resolve.promiseId);
              await o(p);
              break;
            }
          }
          n > a.applyBlockHeight && (n = a.applyBlockHeight), r += 1, s.push(a.signature);
        };
        return await o(e), { minHeight: n, count: r, ids: s };
      }
    };
    l([D(Va), u("design:type", Va)], Cr.prototype, "memoryCache", void 0);
    l([D(Ee), u("design:type", Ee)], Cr.prototype, "transactionHelper", void 0);
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], Cr.prototype, "transactionCore", void 0);
    l([D("bfchain-core:TransactionLogicVerifierCore", { dynamics: true }), u("design:type", $s)], Cr.prototype, "transactionLogicVerifierCore", void 0);
    l([D("transactionGetterHelper", { dynamics: true }), u("design:type", Object)], Cr.prototype, "transactionGetterHelper", void 0);
    Cr = l([J()], Cr);
    const { ConsensusException: n_ } = ee("VERIFIER", "MultipleLogicVerifier");
    let Ga = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s);
        const { transactions: a } = e.asset.multiple;
        for (const p of a) await this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(p.type).verify(p, t, r, true, s);
        return true;
      }
      checkTrsFeeAndWebFee(e, t) {
        const r = super.checkTrsFeeAndWebFee(e, t);
        if (r.isFeeEnough === false) return r;
        let n;
        const { transactions: s } = e.asset.multiple;
        for (const o of s) if (n = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(o.type).checkTrsFeeAndWebFee(o, o.getBytes().length), n.isFeeEnough === false) return n;
        return r;
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        const n = super.checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r);
        if (n.isFeeEnough === false) return n;
        let s;
        const { transactions: o } = e.asset.multiple;
        for (const a of o) if (s = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(a.type).checkTrsFeeAndMiningMachineFeeAndWebFee(a, a.getBytes().length, r), s.isFeeEnough === false) return s;
        return n;
      }
      checkTransactionBlobSize(e, t) {
        const { maxBlockBlobSize: r } = this.configHelper, n = t === void 0 || r < t ? r : t, s = e.getBlobSize(true);
        if (s > n) throw new n_(c.PROP_SHOULD_LTE_FIELD, { prop: `transaction blob size ${s}`, target: "transaction", field: n });
        const { transactions: o } = e.asset.multiple;
        for (const a of o) this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(a.type).checkTransactionBlobSize(a, t);
      }
      async checkRepeatInBlockChainTransaction(e, t, r = 0) {
        const { minHeight: n, count: s, ids: o } = await this.complexTransactionLogicHelper.getCheckRepeatInfo(e, r !== 0);
        if (await this.transactionGetterHelper.countTransactionsInBlockChainBySignature(o, this.transactionHelper.calcTransactionQueryRangeByApplyBlockHeight(n, t)) > (r === 0 ? 0 : s)) throw new n_(c.ALREADY_EXIST, { prop: `One of transactions with signatures [${o.slice(0, 3).join(",")}${o.length > 3 ? "..." : ""}]`, target: "blockChain" });
      }
      async checkSecondaryTransaction(e, t) {
        const { transactions: r } = e.asset.multiple;
        for (const n of r) {
          const s = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(n.type);
          s.checkSecondaryTransaction && await s.checkSecondaryTransaction(n, t);
        }
      }
      checkCertificateOnChainHeight(e, t) {
        const { transactions: r } = e.asset.multiple;
        for (const n of r) {
          const s = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(n.type);
          s.checkCertificateOnChainHeight && s.checkCertificateOnChainHeight(n, t);
        }
      }
      isCertificateOnChainHeight(e, t) {
        const { transactions: r } = e.asset.multiple;
        for (const n of r) {
          const s = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(n.type);
          s.isCertificateOnChainHeight && s.isCertificateOnChainHeight(n, t);
        }
      }
      getLockData(e) {
        const { transactions: t } = e.asset.multiple, r = [];
        for (const n of t) {
          const o = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(n.type).getLockData(n);
          r.push(...o);
        }
        return [...new Set(r)];
      }
    };
    l([D(Cr), u("design:type", Cr)], Ga.prototype, "complexTransactionLogicHelper", void 0);
    l([D("bfchain-core:TransactionLogicVerifierCore", { dynamics: true }), u("design:type", $s)], Ga.prototype, "transactionLogicVerifierCore", void 0);
    Ga = l([J(), u("design:paramtypes", [])], Ga);
    const { ConsensusException: cf } = ee("VERIFIER", "PromiseLogicVerifier");
    let Ka = class extends Me {
      
      async verify(e, t, r, n, s) {
        const o = e.asset.promise.transaction, { signature: a } = o;
        if (await this.transactionGetterHelper.getTransactionBySignature(a, this.transactionHelper.calcTransactionQueryRange(t))) throw new cf(c.ALREADY_EXIST, { prop: `promiseTransaction ${a}`, target: "blockChain", errorId: Ce.TRANSACTION_IN_TRS });
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: h } = this;
        return n === false && h.listenEvent(r, t, s), await h.awaitEventResult(e, s), await this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(o.type).verify(o, t, r, true, s), true;
      }
      checkTrsFeeAndWebFee(e, t) {
        const r = super.checkTrsFeeAndWebFee(e, t);
        if (r.isFeeEnough === false) return r;
        const n = e.asset.promise.transaction, o = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(n.type).checkTrsFeeAndWebFee(n, n.getBytes().length);
        return o.isFeeEnough === false ? o : r;
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        const n = super.checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r);
        if (n.isFeeEnough === false) return n;
        const s = e.asset.promise.transaction, a = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(s.type).checkTrsFeeAndMiningMachineFeeAndWebFee(s, s.getBytes().length, r);
        return a.isFeeEnough === false ? a : n;
      }
      checkTransactionBlobSize(e, t) {
        const { maxBlockBlobSize: r } = this.configHelper, n = t === void 0 || r < t ? r : t, s = e.getBlobSize(true);
        if (s > n) throw new cf(c.PROP_SHOULD_LTE_FIELD, { prop: `transaction blob size ${s}`, target: "transaction", field: n });
        const o = e.asset.promise.transaction;
        this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(o.type).checkTransactionBlobSize(o, t);
      }
      async checkRepeatInBlockChainTransaction(e, t, r = 0) {
        const { minHeight: n, count: s, ids: o } = await this.complexTransactionLogicHelper.getCheckRepeatInfo(e, r !== 0);
        if (await this.transactionGetterHelper.countTransactionsInBlockChainBySignature(o, this.transactionHelper.calcTransactionQueryRangeByApplyBlockHeight(n, t)) > (r === 0 ? 0 : s)) throw new cf(c.ALREADY_EXIST, { prop: `One of transactions with signatures [${o.slice(0, 3).join(",")}${o.length > 3 ? "..." : ""}]`, target: "blockChain" });
      }
    };
    l([D(Cr), u("design:type", Cr)], Ka.prototype, "complexTransactionLogicHelper", void 0);
    l([D("bfchain-core:TransactionLogicVerifierCore", { dynamics: true }), u("design:type", $s)], Ka.prototype, "transactionLogicVerifierCore", void 0);
    Ka = l([J(), u("design:paramtypes", [])], Ka);
    const { ConsensusException: Zs, NoFoundException: d0 } = ee("VERIFIER", "PromiseResolveLogicVerifier");
    let uo = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s);
        const { promiseId: a, transaction: p } = e.asset.resolve, h = await this.transactionGetterHelper.getTransactionBySignature(a, this.transactionHelper.calcTransactionQueryRange(t));
        if (!h) throw new d0(c.NOT_EXIST_OR_EXPIRED, { prop: `Transaction with signature ${a}`, target: "blockChain" });
        const g = (await this.transactionCore.recombineTransaction(h)).as(no, a);
        if (!g) throw new Zs(c.NOT_EXPECTED_RELATED_TRANSACTION, { signature: `${a}` });
        if (e.senderId !== g.recipientId) throw new Zs(c.NOT_MATCH, { to_compare_prop: `senderId ${e.senderId}`, be_compare_prop: `recipientId ${g.recipientId}`, to_target: "promiseResolveTransaction", be_target: "doPromiseTransaction" });
        if (e.recipientId !== g.senderId) throw new Zs(c.NOT_MATCH, { to_compare_prop: `recipientId ${e.recipientId}`, be_compare_prop: `senderId ${g.senderId}`, to_target: "promiseResolveTransaction", be_target: "doPromiseTransaction" });
        const d = await this.complexTransactionLogicHelper.getPromiseTransaction(a);
        if (xe(p.getBytes()) !== xe(d.getBytes())) throw new Zs(c.NOT_MATCH, { to_compare_prop: `transaction with promiseId ${a}`, be_compare_prop: `transaction with promiseId ${a}`, to_target: "promiseResolveTransaction", be_target: "blockChain" });
        const y = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(p.type);
        if (p.applyBlockHeight > t) throw new Zs(c.NOT_BEGIN_RESOLVE_YET, { promiseId: a });
        if (p.effectiveBlockHeight < t) throw new Zs(c.ALREADY_EXPIRED, { prop: `promise transaction ${a}`, target: "blockChain" });
        return await y.verify(p, t, r, true, s), true;
      }
      checkTrsFeeAndWebFee(e, t) {
        const r = super.checkTrsFeeAndWebFee(e, t);
        if (r.isFeeEnough === false) return r;
        const n = e.asset.resolve.transaction, o = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(n.type).checkTrsFeeAndWebFee(n, n.getBytes().length);
        return o.isFeeEnough === false ? o : r;
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        const n = super.checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r);
        if (n.isFeeEnough === false) return n;
        const s = e.asset.resolve.transaction, a = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(s.type).checkTrsFeeAndMiningMachineFeeAndWebFee(s, s.getBytes().length, r);
        return a.isFeeEnough === false ? a : n;
      }
      checkTransactionBlobSize(e, t) {
        const { maxBlockBlobSize: r } = this.configHelper, n = t === void 0 || r < t ? r : t, s = e.getBlobSize(true);
        if (s > n) throw new Zs(c.PROP_SHOULD_LTE_FIELD, { prop: `transaction blob size ${s}`, target: "transaction", field: n });
        const o = e.asset.resolve.transaction;
        this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(o.type).checkTransactionBlobSize(o, t);
      }
      async checkRepeatInBlockChainTransaction(e, t, r = 0) {
        const { minHeight: n, count: s, ids: o } = await this.complexTransactionLogicHelper.getCheckRepeatInfo(e, r !== 0);
        if (await this.transactionGetterHelper.countTransactionsInBlockChainBySignature(o, this.transactionHelper.calcTransactionQueryRangeByApplyBlockHeight(n, t)) > (r === 0 ? 0 : s)) throw new Zs(c.ALREADY_EXIST, { prop: `One of transactions with signatures [${o.slice(0, 3).join(",")}${o.length > 3 ? "..." : ""}]`, target: "blockChain" });
      }
      async checkSecondaryTransaction(e, t) {
        const r = e.asset.resolve.transaction, n = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(r.type);
        n.checkSecondaryTransaction && await n.checkSecondaryTransaction(r, t);
      }
      checkCertificateOnChainHeight(e, t) {
        const r = e.asset.resolve.transaction, n = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(r.type);
        n.checkCertificateOnChainHeight && n.checkCertificateOnChainHeight(r, t);
      }
      isCertificateOnChainHeight(e, t) {
        const r = e.asset.resolve.transaction, n = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(r.type);
        n.isCertificateOnChainHeight && n.isCertificateOnChainHeight(r, t);
      }
      getLockData(e) {
        const { transaction: t, promiseId: r } = e.asset.resolve, s = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(t.type).getLockData(t);
        return s.push(r), [...new Set(s)];
      }
    };
    l([D(Cr), u("design:type", Cr)], uo.prototype, "complexTransactionLogicHelper", void 0);
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], uo.prototype, "transactionCore", void 0);
    l([D("bfchain-core:TransactionLogicVerifierCore", { dynamics: true }), u("design:type", $s)], uo.prototype, "transactionLogicVerifierCore", void 0);
    uo = l([J(), u("design:paramtypes", [])], uo);
    let fl = class extends Me {
      
      async verify(e, t, r, n, s) {
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: o } = this;
        return n === false && o.listenEvent(r, t, s), await o.awaitEventResult(e, s), true;
      }
    };
    l([D("bfchain-core:TransactionLogicVerifierCore", { dynamics: true }), u("design:type", $s)], fl.prototype, "transactionLogicVerifierCore", void 0);
    fl = l([J(), u("design:paramtypes", [])], fl);
    const { ConsensusException: hc, NoFoundException: y0 } = ee("VERIFIER", "MacroCallLogicVerifier");
    let fo = class extends Me {
      
      async verify(e, t, r, n, s) {
        const { macroId: o, inputs: a } = e.asset.call, p = await this.transactionGetterHelper.getTransactionBySignature(o, this.transactionHelper.calcTransactionQueryRange(t));
        if (!p) throw new y0(c.NOT_EXIST_OR_EXPIRED, { prop: `Transaction with signature ${o}`, target: "blockChain" });
        const f = (await this.transactionCore.recombineTransaction(p)).as(oo, o);
        if (!f) throw new hc(c.NOT_EXPECTED_RELATED_TRANSACTION, { signature: `${o}` });
        this.isInputMatch(a, f.asset.macro.inputs);
        const g = await this.isTransactionMatch(o, e);
        await this.logicVerify(e, t, r);
        const { eventLogicVerifier: d } = this;
        return n === false && d.listenEvent(r, t, s), await d.awaitEventResult(e, s), await this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(g.type).verify(g, t, r, true, s), true;
      }
      isInputMatch(e, t) {
        const r = new Set(t.map((n) => n.name));
        for (const n in e) if (r.has(n) === false) throw new hc(c.SHOULD_NOT_EXIST, { prop: `input ${n}`, target: "inputs" });
      }
      async isTransactionMatch(e, t) {
        const r = await this.complexTransactionLogicHelper.getMacroCallTransaction(t), n = t.asset.call.transaction;
        if (xe(n.getBytes()) !== xe(r.getBytes())) throw new hc(c.NOT_MATCH, { to_compare_prop: `transaction with macroId ${e}`, be_compare_prop: `transaction with macroId ${e}`, to_target: "MacroCallTransaction", be_target: "blockChain" });
        return n;
      }
      checkTrsFeeAndWebFee(e, t) {
        const r = super.checkTrsFeeAndWebFee(e, t);
        if (r.isFeeEnough === false) return r;
        const n = e.asset.call.transaction, o = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(n.type).checkTrsFeeAndWebFee(n, n.getBytes().length);
        return o.isFeeEnough === false ? o : r;
      }
      checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r) {
        const n = super.checkTrsFeeAndMiningMachineFeeAndWebFee(e, t, r);
        if (n.isFeeEnough === false) return n;
        const s = e.asset.call.transaction, a = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(s.type).checkTrsFeeAndMiningMachineFeeAndWebFee(s, s.getBytes().length, r);
        return a.isFeeEnough === false ? a : n;
      }
      checkTransactionBlobSize(e, t) {
        const { maxBlockBlobSize: r } = this.configHelper, n = t === void 0 || r < t ? r : t, s = e.getBlobSize(true);
        if (s > n) throw new hc(c.PROP_SHOULD_LTE_FIELD, { prop: `transaction blob size ${s}`, target: "transaction", field: n });
        const o = e.asset.call.transaction;
        this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(o.type).checkTransactionBlobSize(o, t);
      }
      async checkRepeatInBlockChainTransaction(e, t, r = 0) {
        const { minHeight: n, count: s, ids: o } = await this.complexTransactionLogicHelper.getCheckRepeatInfo(e, r !== 0);
        if (await this.transactionGetterHelper.countTransactionsInBlockChainBySignature(o, this.transactionHelper.calcTransactionQueryRangeByApplyBlockHeight(n, t)) > (r === 0 ? 0 : s)) throw new hc(c.ALREADY_EXIST, { prop: `One of transactions with signatures [${o.slice(0, 3).join(",")}${o.length > 3 ? "..." : ""}]`, target: "blockChain" });
      }
      async checkSecondaryTransaction(e, t) {
        const r = e.asset.call.transaction, n = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(r.type);
        n.checkSecondaryTransaction && await n.checkSecondaryTransaction(r, t);
      }
      checkCertificateOnChainHeight(e, t) {
        const r = e.asset.call.transaction, n = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(r.type);
        n.checkCertificateOnChainHeight && n.checkCertificateOnChainHeight(r, t);
      }
      isCertificateOnChainHeight(e, t) {
        const r = e.asset.call.transaction, n = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(r.type);
        n.isCertificateOnChainHeight && n.isCertificateOnChainHeight(r, t);
      }
      getLockData(e) {
        const { transaction: t, macroId: r } = e.asset.call, s = this.transactionLogicVerifierCore.getTransactionLogicVerifierFromType(t.type).getLockData(t);
        return s.push(r), [...new Set(s)];
      }
    };
    l([D(Cr), u("design:type", Cr)], fo.prototype, "complexTransactionLogicHelper", void 0);
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], fo.prototype, "transactionCore", void 0);
    l([D("bfchain-core:TransactionLogicVerifierCore", { dynamics: true }), u("design:type", $s)], fo.prototype, "transactionLogicVerifierCore", void 0);
    fo = l([J(), u("design:paramtypes", [])], fo);
    pn.KLV.set(v.REGISTER_CHAIN, Yh);
    pn.LVK.set(Yh, v.REGISTER_CHAIN);
    pn.KLV.set(v.MULTIPLE, Ga);
    pn.LVK.set(Ga, v.MULTIPLE);
    pn.KLV.set(v.PROMISE, Ka);
    pn.LVK.set(Ka, v.PROMISE);
    pn.KLV.set(v.PROMISE_RESOLVE, uo);
    pn.LVK.set(uo, v.PROMISE_RESOLVE);
    pn.KLV.set(v.MACRO, fl);
    pn.LVK.set(fl, v.MACRO);
    pn.KLV.set(v.MACRO_CALL, fo);
    pn.LVK.set(fo, v.MACRO_CALL);
    const { ArgumentIllegalException: uc, NoFoundException: m0, ConsensusException: _0, info: s_ } = ee("CONTROLLER", "_blockbase");
    const i_ = Zp("generateBlock");
    const My = class {
      transactionInBlockFromJSON(e) {
        return qt.fromObject(e);
      }
      async generateBlock(e, t, r, n, s, o, a, p = this.config) {
        i_ && s_("begin generateBlock"), await this.generateBlockCore.generateBlockBefore(e, t, r, o);
        const h = this._generateBlock(e, t);
        return await this.generateBlockCore.generateBlockAfter(h, r, n, s, o, a, p), i_ && s_("finish generateBlock"), h;
      }
      async replayBlock(e, t, r, n = {}, s = this.config) {
        return await this.replayBlockCore.replayBlock(e, t, r, n, s);
      }
      async checkAssetChangeHash(e, t, r = {}) {
        let n = r.accountGetterHelper;
        if (!n && (n = this.moduleMap.get("accountGetterHelper"), !n)) throw new m0(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        const s = await n.getAccountsAssetsChange(e), o = await this.blockHelper.calcAssetChangeHash(s);
        if (o !== t) throw new _0(c.NOT_MATCH, { to_compare_prop: `assetChangeHash ${t}`, be_compare_prop: `assetChangeHash ${o}`, to_target: "block", be_target: "calculate" });
      }
      verifyKeypair(e) {
        if (!e) throw new uc(c.PARAM_LOST, { param: "keypair" });
        const t = { target: "keypair" }, { baseHelper: r } = this, { publicKey: n, secretKey: s } = e;
        if (!n) throw new uc(c.PROP_IS_REQUIRE, { prop: "publicKey", ...t });
        if (!r.isValidPublicKey(n)) throw new uc(c.PROP_IS_INVALID, { prop: `publicKey ${n}`, ...t });
        if (!s) throw new uc(c.PROP_IS_REQUIRE, { param: "secretKey", ...t });
        if (!r.isValidSecretKey(s)) throw new uc(c.PROP_IS_INVALID, { prop: `secretKey ${s}`, ...t });
      }
      async verifyBlockBody(e, t, r = this.config) {
        this.commonBlockVerify.verifyBlockBody(e, t);
      }
      async verify(e, t = this.config) {
        await this.verifyBlockCore.verify(e, t);
      }
      async generateSignature(e) {
        return await this.blockHelper.generateSignature(e);
      }
      async isBlockAlreadyExist(e, t, r) {
        await this.commonBlockVerify.isBlockAlreadyExist(e, t, r);
      }
    };
    const { NoFoundException: QC, ArgumentException: A0 } = ee("Core", "BlockGeneratorCalculator");
    let wn = class {
      constructor(e, t, r, n) {
        this.config = e, this.timeHelper = t, this.blockHelper = r, this.accountBaseHelper = n, this.getAddressSeedMap = (s) => new wt((a) => {
          let p = 0;
          for (let h = 1; h < a.length; h++) p += a.charCodeAt(h);
          return p * s % 256;
        });
      }
      async fastCalcGenerateBlockGenerator(e, t = {}) {
        let r;
        if ("toTimestamp" in t) r = t.toTimestamp;
        else {
          const { nowTimestamp: n = this.timeHelper.getTimestamp() } = t;
          r = this.timeHelper.getTimestampBySlotNumber(this.timeHelper.getSlotNumberByTimestamp(n) + 1);
        }
        if (e.timestamp >= r) throw new A0(`lastblock timestamp(${e.timestamp}) should not be greater than toTimestamp(${r})`);
        for await (const n of this.calcGenerateBlockGeneratorIterator(e, { toTimestamp: r, blockGetterHelper: t.blockGetterHelper, ignoreOfflineGeneraters: true })) if (n.timestamp === r) return { address: n.address, timestamp: n.timestamp };
        throw new Error();
      }
      async calcGenerateBlockGenerator(e, t) {
        for await (const r of this.calcGenerateBlockGeneratorIterator(e, t)) if (r.timestamp === t.toTimestamp) return r;
        throw new Error();
      }
      async *calcGenerateBlockGeneratorIterator(e, t = {}) {
        const { toTimestamp: r = 1 / 0, blockGetterHelper: n = this.blockHelper.blockGetterHelper, ignoreOfflineGeneraters: s, yieldSkip: o = 1 } = t, a = e.timestamp + this.config.forgeInterval;
        let p = a;
        const h = new wt(() => []), f = [], g = e.height % this.config.blockPerRound, d = t.blockCache || {};
        for (let K = 0; K < g; K++) {
          const L = e.height - K;
          f.push(d[L] || await this.blockHelper.forceGetBlockByHeight(L, n));
        }
        const y = Math.max(1, this.blockHelper.calcRoundEndHeight(this.blockHelper.calcRoundByHeight(e.height + 1) - 1)), _ = d[y] || await this.blockHelper.forceGetBlockByHeight(y, n), I = this.blockHelper.calcRoundByHeight(_.height + 1), S = (K) => {
          const L = (K - _.timestamp) / this.config.forgeInterval / this.config.blockPerRound;
          return L % 1 === 0 && L > 0 ? L - 1 : Math.floor(L);
        }, w = (K) => (K * this.config.blockPerRound + 1) * this.config.forgeInterval + _.timestamp, N = d[e.height] || await this.blockHelper.forceGetBlockByHeight(e.height, n);
        if (s) {
          if (!Number.isSafeInteger(r)) throw new RangeError("toTimestamp must be an integer, when you ignore Offline Generaters.");
          const K = S(a), L = S(r);
          L > K && (p = w(L));
        }
        const B = _.height === 1 ? _.asset.genesisAsset.nextRoundGenerators : _.asset.roundLastAsset.nextRoundGenerators, O = async (K) => {
          const L = /* @__PURE__ */ new Set();
          if (K === 0) for (const z of B) L.add(z.address);
          else if (I - K <= 1) for (const $ of this.config.genesisBlock.asset.genesisAsset.nextRoundGenerators) L.add($.address);
          else for (const $ of B) L.add($.address);
          const H = /* @__PURE__ */ new Set();
          for (const z of f) S(z.timestamp) === K && H.add(await this.accountBaseHelper.getAddressFromPublicKey(z.generatorPublicKeyBuffer));
          const W = [];
          for (const z of L) H.has(z) || W.push(z);
          return W;
        }, P = N.signatureBuffer.reduce((K, L) => K + L, 0), C = (K) => K.slice().sort((L, H) => {
          const W = this.getAddressSeedMap(P).forceGet(L) - this.getAddressSeedMap(P).forceGet(H);
          return W === 0 ? K.indexOf(L) - K.indexOf(H) : W;
        }), V = (K) => ({ address: K, timestamp: this.timeHelper.getTimestampBySlotNumber(this.timeHelper.getSlotNumberByTimestamp(p)) });
        let F = 0;
        for (; p <= r; ) {
          const K = S(p), L = await O(K), H = (w(K + 1) - p) / this.config.forgeInterval;
          L.length > H && (L.length = H);
          const W = C(L);
          let z;
          do {
            const $ = W.shift();
            if (!$) break;
            o > 1 ? (++F === o || p === r) && (F = 0, yield V($)) : yield V($), (z || (z = h.forceGet(K))).push($), p += this.config.forgeInterval;
          } while (W.length);
        }
      }
      async calcNextBlockGenerator(e) {
        const t = e.timestamp + this.config.forgeInterval;
        for await (const r of this.calcGenerateBlockGeneratorIterator({ timestamp: e.timestamp, height: e.height }, { toTimestamp: t, blockCache: { [e.height]: e } })) if (r.timestamp === t) return r;
        throw new Error();
      }
    };
    wn = l([J(), u("design:paramtypes", [ne, Ft, dt, me])], wn);
    const { ArgumentIllegalException: Yr, ConsensusException: o_ } = ee("CONTROLLER", "_blockbase");
    let ys = class {
      constructor(e, t, r, n) {
        this.config = e, this.blockHelper = t, this.baseHelper = r, this.chainAssetInfoHelper = n;
      }
      verifyBlockBody(e, t) {
        const { baseHelper: r } = this;
        if (!e) throw new Yr(c.PARAM_LOST, { param: "body" });
        if (!t) throw new Yr(c.PARAM_LOST, { param: "asset" });
        const n = { target: "body" };
        if (!r.isPositiveInteger(e.version)) throw new Yr(c.PROP_IS_INVALID, { prop: `version ${e.version}`, type: "positive integer", ...n });
        const s = e.height;
        if (!r.isPositiveInteger(s)) throw new Yr(c.PROP_IS_INVALID, { prop: `height ${s}`, type: "positive integer", ...n });
        if (s > 1 && !e.previousBlockSignature) throw new Yr(c.PROP_IS_REQUIRE, { prop: "previousBlockSignature", ...n });
        if (!r.isNaturalNumber(e.timestamp)) throw new Yr(c.PROP_IS_INVALID, { prop: `timestamp ${e.timestamp}`, type: "positive integer or 0", ...n });
        const o = e.remark;
        if (!o) throw new Yr(c.PROP_IS_REQUIRE, { prop: "remark", ...n });
        if (r.getVariableType(o) !== "[object Object]") throw new Yr(c.PROP_IS_INVALID, { prop: "remark", ...n });
        for (const a in o) if (!r.isString(o[a])) throw new Yr(c.PROP_IS_INVALID, { prop: "remark", ...n });
        if (!o && r.getVariableType(o) !== "[object Object]") throw new Yr(c.PARAM_LOST, { param: "remark", ...n });
      }
      verifyBlockSize(e, t) {
        const r = this.calcBlockSize(e, t);
        if (e.blockSize !== r) throw new Yr(c.NOT_MATCH, { to_compare_prop: `blockSize ${e.blockSize}`, be_compare_prop: `blockSize ${r}`, to_target: "block", be_target: "calculate" });
        const { maxBlockSize: n } = this.config;
        if (r > n) throw new Yr(c.PROP_SHOULD_LTE_FIELD, { prop: `block size ${r}`, target: "block", field: n });
      }
      verifyBlockBlobSize(e) {
        const { maxBlockBlobSize: t } = this.config;
        if (e.blobSize > t) throw new Yr(c.PROP_SHOULD_LTE_FIELD, { prop: `block blob size ${e.blobSize}`, target: "block", field: t });
      }
      verifySignature(e) {
        return this.blockHelper.verifyBlockSignature(e);
      }
      get canInsertTransaction() {
        return this.transactionCore.canCreateTransaction.bind(this.transactionCore);
      }
      calcBlockSize(e, t) {
        const r = Nt.$type.fields.blockSize.id, n = (a) => ({ value: a, size: a === 0 ? 0 : new kn().uint32(r).uint32(a).finish().length }), s = e.blockSize;
        let o = s;
        if (o = e.getBytes(false, false, t).length + (e.signatureBuffer.length ? 0 : 66), e.generatorPublicKeyBuffer) {
          const a = e.signSignatureBuffer && e.signSignatureBuffer.length || 0;
          o += a ? 0 : 66;
        }
        if (s !== o) {
          let a = n(s);
          do {
            const p = n(o);
            if (p.size === a.size) break;
            o += p.size - a.size, a = p;
          } while (true);
        }
        return o;
      }
      async isBlockAlreadyExist(e, t, r) {
        if (typeof r.getCountBlock !== "function") throw new o_(c.PROP_IS_INVALID, { prop: "getCountBlock", target: "blockGetterHelper" });
        if (await r.getCountBlock({ signature: e }) > 0) throw new o_(c.ALREADY_EXIST, { prop: `Block with signature ${e}`, target: "blockChain", errorId: `Block already exists: ${e} height: ${t}` });
      }
    };
    l([D("bfchain-core:TransactionCore"), u("design:type", Object)], ys.prototype, "transactionCore", void 0);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], ys.prototype, "canInsertTransaction", null);
    ys = l([J(), u("design:paramtypes", [ne, dt, Be, ve])], ys);
    const { ArgumentIllegalException: Is, ArgumentFormatException: qC, ConsensusException: ZC } = ee("CONTROLLER", "_blockbase");
    let za = class {
      constructor(e, t, r, n, s, o, a, p, h) {
        this.blockHelper = e, this.baseHelper = t, this.config = r, this.statisticsHelper = n, this.asymmetricHelper = s, this.chainAssetInfoHelper = o, this.commonBlockVerify = a, this.accountBaseHelper = p, this.cryptoHelper = h;
      }
      async verify(e, t = this.config) {
        this.commonBlockVerify.verifyBlockBody(e, e.remark), await this.verifyBlockDerivativeInfo(e, t), await this.commonBlockVerify.verifySignature(e);
      }
      async verifyBlockDerivativeInfo(e, t = this.config) {
        const r = { target: "block" }, { baseHelper: n } = this;
        if (e.height !== 1 && !e.previousBlockSignature && n.isValidBlockSignature(e.previousBlockSignature)) throw new Is(c.PROP_IS_INVALID, { prop: `previousBlockSignature ${e.previousBlockSignature}`, ...r });
        if (!n.isNaturalNumber(e.numberOfTransactions)) throw new Is(c.PROP_IS_INVALID, { prop: `numberOfTransactions ${e.numberOfTransactions}`, type: "natural number", ...r });
        if (!e.payloadHash) throw new Is(c.PROP_IS_REQUIRE, { prop: `payloadHash ${e.payloadHash}`, ...r });
        if (!n.isNaturalNumber(e.payloadLength)) throw new Is(c.PROP_IS_INVALID, { prop: `payloadLength ${e.payloadLength}`, type: "natural number", ...r });
        if (e.magic !== t.magic) throw new Is(c.NOT_MATCH, { to_compare_prop: `block.magic ${e.magic}`, be_compare_prop: `genesisBlock.magic ${t.magic}`, to_target: "block_body", be_target: "genesis_block", ...r });
        if (!e.generatorPublicKey) throw new Is(c.PROP_IS_REQUIRE, { prop: "generatorPublicKey", ...r });
        if (!n.isValidPublicKey(e.generatorPublicKey)) throw new Is(c.PROP_IS_INVALID, { prop: `generatorPublicKey ${e.generatorPublicKey}`, type: "account publicKey", ...r });
        if (!e.signature) throw new Is(c.PROP_IS_REQUIRE, { prop: "signature", ...r });
        if (!n.isValidSignature(e.signature)) throw new Is(c.PROP_IS_INVALID, { prop: `signature ${e.signature}`, type: "signature", ...r });
        this.commonBlockVerify.verifyBlockSize(e), this.commonBlockVerify.verifyBlockBlobSize(e);
      }
    };
    l([D("bfchain-core:TransactionCore"), u("design:type", Object)], za.prototype, "transactionCore", void 0);
    za = l([J(), be(8, D("cryptoHelper")), u("design:paramtypes", [dt, Be, ne, Ds, Or, ve, ys, me, Object])], za);
    const { ConsensusException: a_ } = ee("CONTROLLER", "_blockbase");
    let gl = class {
      async applyTransaction(e, t, r) {
        const n = r.type, s = this.transactionCore, o = s.transactionHelper;
        if (await s.getTransactionFactoryFromType(n).applyTransaction(r, e), n === o.MULTIPLE) {
          const { transactions: p } = r.asset.multiple;
          for (const h of p) await this.applyTransaction(e, t, h);
        } else if (n === o.PROMISE_RESOLVE) {
          const { promiseId: p } = r.asset.resolve, h = await t.getPromiseTransaction(p);
          if (!h) throw new a_(c.NOT_EXIST, { prop: `promise transaction ${p}`, target: "blockChain" });
          const f = await s.recombineTransaction(h), g = f.type;
          g === o.MULTIPLE || g === o.PROMISE_RESOLVE || g === o.MACRO_CALL ? await this.applyTransaction(e, t, f) : await s.getTransactionFactoryFromType(f.type).applyTransaction(f, e);
        } else if (n === o.MACRO_CALL) {
          const { macroId: p, inputs: h } = r.asset.call, f = await t.getMacroCallTransaction(p, h);
          if (!f) throw new a_(c.NOT_EXIST, { prop: `macro transaction ${p}`, target: "blockChain" });
          const g = await s.recombineTransaction(f), d = g.type;
          d === o.MULTIPLE || d === o.PROMISE_RESOLVE || d === o.MACRO_CALL ? await this.applyTransaction(e, t, g) : await s.getTransactionFactoryFromType(g.type).applyTransaction(g, e);
        }
      }
    };
    l([D("bfchain-core:TransactionCore"), u("design:type", Object)], gl.prototype, "transactionCore", void 0);
    gl = l([J()], gl);
    const { ArgumentIllegalException: fc, ArgumentFormatException: rR, NoFoundException: pf, log: jl, info: c_, warn: p_, ConsensusException: l_ } = ee("CONTROLLER", "_blockbase");
    const jo = Zp("generateBlock");
    let ja = class {
      constructor(e, t, r, n, s, o, a, p, h, f) {
        this.blockHelper = e, this.baseHelper = t, this.config = r, this.statisticsHelper = n, this.asymmetricHelper = s, this.blockGeneratorCalculator = o, this.commonBlockVerify = a, this.blockUtils = p, this.cryptoHelper = h, this.moduleMap = f;
      }
      async generateBlockBefore(e, t, r, n) {
        if (!e) throw new fc(c.PARAM_LOST, { param: "body" });
        if (!t) throw new fc(c.PARAM_LOST, { param: "asset" });
        if (!r) throw new fc(c.PARAM_LOST, { param: "transactions" });
        jo && jl("before generateBlock"), n && await this._wrapBlockError(n.emit("beforeGenerateBlock", e), n, "beforeGenerateBlock", e);
      }
      async _wrapBlockError(e, t, r, n) {
        if (e) try {
          return await e;
        } catch (s) {
          await t.emit("blockError", { type: `generateBlock/${r}`, error: s, blockBody: n });
        }
      }
      async generateBlockAfter(e, t, r, n, s, o, a = this.config) {
        return e.magic = a.magic, await this.insertTransactions(e, t, r, n, s, o), jo && jl("before signatureBlock"), s && await this._wrapBlockError(s.emit("beforeSignatureBlock", e), s, "beforeSignatureBlock", e), e.blockSize = this.commonBlockVerify.calcBlockSize(e), e.signatureBuffer = await this.asymmetricHelper.detachedSign(e.getBytes(true, true, true), r.secretKey), n && (e.signSignatureBuffer = await this.asymmetricHelper.detachedSign(e.getBytes(false, true, true), n.secretKey)), jo && jl("before generatedBlock"), s && await this._wrapBlockError(s.emit("generatedBlock", e), s, "generatedBlock", e), e;
      }
      async insertTransactions(e, t, r, n, s = new ii(), o) {
        if (!o && (o = this.moduleMap.get("transactionGetterHelper"), !o)) throw new pf(c.NOT_EXIST, { prop: "transactionGetterHelper", target: "moduleStroge" });
        if (!s.blockRewardsGetter) throw new pf(c.NOT_EXIST, { prop: "blockRewardsGetter", target: "eventEmitter" });
        const { transactionCore: a, blockUtils: p } = this, h = a.abortForbiddenTransaction, { height: f, generatorPublicKey: g, statisticInfo: d } = e, { maxBlockSize: y } = this.config;
        let _ = this.config.maxBlockBlobSize;
        if (s.customMaxBlobSizeGetter) {
          const P = s.customMaxBlobSizeGetter();
          _ = P < _ ? P : _;
        }
        const I = this.cryptoHelper.sha256();
        let S = 0, w = 0;
        const N = this.statisticsHelper.forceGetStatisticsInfoByBlock(s.taskname || `core-generate-${f}`, g, d), B = [], O = /* @__PURE__ */ new Set();
        try {
          this.statisticsHelper.bindApplyTransactionEventEmiter(s, N);
          const P = new wt((F) => 0);
          jo && c_("begin insertTransactions");
          for await (const F of t) {
            s.tIndexGetter && (F.tIndex = await s.tIndexGetter(F)), jo && jl("insert transaction: %d / %d", F.tIndex, e.numberOfTransactions);
            try {
              const K = F.transaction, { type: L, senderId: H, signature: W } = K;
              if (O.has(W)) throw new l_(c.SHOULD_NOT_DUPLICATE, { prop: `transaction with signature ${W}`, target: `block with height ${e.height}` });
              if (O.add(W), !this.commonBlockVerify.canInsertTransaction(L)) {
                const ie = Re.VK.get(Re.trsTypeToV(L)), ge = new l_(c.DISABLED_INSERT_TRANSACTION, { trsName: ie });
                if (h) throw ge;
                p_(ge);
              }
              B.push(F), F.height = e.height;
              const z = a.getTransactionFactoryFromType(L);
              await z.beginDealTransaction(K, s), await p.applyTransaction(s, o, K), s.assetPrealnumGetter && (F.assetPrealnum = await s.assetPrealnumGetter(F));
              const $ = F.assetPrealnum;
              if ($) {
                const ie = `height ${F.height} tIndex ${F.tIndex} type ${L} senderId ${H} ${K.recipientId ? " recipientId " + K.recipientId : " "} signature ${F.transaction.signature}`, { remainAssetPrealnum: ge, frozenMainAssetPrealnum: Ae } = $;
                if (BigInt(ge) < BigInt(0)) throw new fc(c.PROP_IS_INVALID, { prop: `remainAssetPrealnum ${ge}`, target: "assetPrealnum", detail: ie });
                if (BigInt(Ae) < BigInt(0)) throw new fc(c.PROP_IS_INVALID, { prop: `frozenMainAssetPrealnum ${Ae}`, target: "assetPrealnum", detail: ie });
              }
              F.signatureBuffer = await this.asymmetricHelper.detachedSign(F.getBytes(true, true), r.secretKey), n && (F.signSignatureBuffer = await this.asymmetricHelper.detachedSign(F.getBytes(false, true), n.secretKey)), Object.freeze(F);
              const q = F.getBytes();
              I.update(q), S += q.length, S > y * 0.95 && await s.emit("nearMaxPayloadLength", { payloadLength: S }), w += F.transaction.getBlobSize(), w > _ * 0.95 && await s.emit("nearMaxBlobSize", { blobSize: w }), await z.endDealTransaction(F, s);
            } catch (K) {
              const L = await s.emit("error", { error: K, type: "genesisBlock", transactionInBlock: F });
              if (L && L.continue) continue;
              throw K;
            }
          }
          jo && c_("finish insertTransactions"), e.reward = await s.blockRewardsGetter(f);
          const C = B.length;
          if (e.transactionInfo.offset = C, C > 0) e.transactionInfo.startTindex = B[0].tIndex;
          else {
            if (!s.startTindexGetter) throw new pf(c.NOT_EXIST, { prop: "startTindexGetter", target: "eventEmitter" });
            e.transactionInfo.startTindex = await s.startTindexGetter();
          }
          e.transactionInfo.statisticInfo = N.toModel(), e.transactionInfo.payloadHashBuffer = await I.digest(), e.transactionInfo.payloadLength = S, e.transactionInfo.blobSize = w, e.transactionInfo.transactionInBlocks = B;
          const V = e.transactionInfo.statisticInfo.numberOfTransactions;
          e.transactionInfo.numberOfTransactions = V, s.has("finishedDealTransactions") && (p_("@deprecated", 'logic "finishedDealTransactions" \u4E8B\u4EF6\u5DF2\u7ECF\u88AB\u9057\u5F03\uFF0C\u8BF7\u53CA\u65F6\u66F4\u65B0\u5E76\u5347\u7EA7\u4EE3\u7801'), await s.emit("finishedDealTransactions", e));
        } finally {
          N.unref(g);
        }
        return e;
      }
    };
    l([D("bfchain-core:TransactionCore"), u("design:type", Object)], ja.prototype, "transactionCore", void 0);
    ja = l([J(), be(8, D("cryptoHelper")), u("design:paramtypes", [dt, Be, ne, Ds, Or, wn, ys, gl, Object, ze])], ja);
    const { ArgumentIllegalException: Pr, OutOfRangeException: E0, ArgumentFormatException: lf, NoFoundException: Jo, log: Jl, info: Yl, warn: h_, ConsensusException: gc } = ee("CONTROLLER", "_blockbase");
    const ei = Zp("generateBlock");
    let Ja = class {
      constructor(e, t, r, n, s, o, a, p, h, f, g, d, y, _) {
        this.blockHelper = e, this.accountBaseHelper = t, this.transactionHelper = r, this.baseHelper = n, this.config = s, this.statisticsHelper = o, this.asymmetricHelper = a, this.chainAssetInfoHelper = p, this.chainTimeHelper = h, this.blockGeneratorCalculator = f, this.moduleMap = g, this.commonBlockVerify = d, this.blockUtils = y, this.cryptoHelper = _;
      }
      async _wrapBlockError(e, t, r, n) {
        if (e) try {
          return await e;
        } catch (s) {
          t.emit("blockError", { type: `replayBlock/${r}`, error: s, blockBody: n });
        }
      }
      async replayBlock(e, t, r, n = {}, s = this.config) {
        ei && Yl("begin replayBlock");
        const { verifySignature: o, recordForkBlock: a } = n;
        if (!t) throw new Pr(c.PARAM_LOST, { param: "transactions" });
        if (ei && Jl("before replayBlock"), r && await this._wrapBlockError(r.emit("beforeGenerateBlock", e), r, "beforeGenerateBlock", e), this.blockHelper.verifyBlockVersion(e, s), e.height > 1) {
          const h = await this.blockHelper.forceGetBlockByHeight(e.height - 1);
          if (e.previousBlockSignature !== h.signature) {
            if (a) {
              let I = n.blockGetterHelper;
              if (!I && (I = this.moduleMap.get("blockGetterHelper"), !I)) throw new Jo(c.NOT_EXIST, { prop: "blockGetterHelper", target: "moduleStroge" });
              await I.chainBlockFork(e, ph.DIFFERENT_PRE_BLOCK_SIGNATURE);
            }
            throw new Pr(c.NOT_MATCH, { to_compare_prop: `previousBlockSignature ${e.previousBlockSignature}`, be_compare_prop: `blockSignature ${e.signature}`, to_target: "block", be_target: "blockChain lastBlock" });
          }
          const f = this.chainTimeHelper, g = f.getSlotNumberByTimestamp(e.timestamp), d = f.getNextSlotNumberByTimestamp(h.timestamp);
          if (g < d) throw new gc(c.PROP_SHOULD_GT_FIELD, { prop: `timestamp ${e.timestamp}`, target: "block", field: `lastBlock timestamp ${h.timestamp}` });
          const { address: y } = await this.blockGeneratorCalculator.calcGenerateBlockGenerator(h, { toTimestamp: e.timestamp }), _ = await this.accountBaseHelper.getAddressFromPublicKeyString(e.generatorPublicKey);
          if (y !== _) {
            const I = f.getSlotNumberByTimestamp(e.timestamp);
            throw new gc(c.INVALID_BLOCK_GENERATOR, { reason: `lastBlock.timestamp: ${h.timestamp} lastBlock.height: ${h.height}, block.timestamp: ${e.timestamp} curTime: ${f.getTimeByTimestamp(e.timestamp)} \u8BE5\u533A\u5757\u7684\u6253\u5757\u4EBA\u6821\u9A8C\u4E0D\u901A\u8FC7\uFF0C\u533A\u5757signature\uFF1A${e.signature} height: ${e.height} \u5F53\u524Dslot\u4E3A ${I}\uFF0C\u5F53\u524D\u5E94\u8BE5\u7531\u59D4\u6258\u4EBA ${y} \u6253\u5757\uFF0C\u5B9E\u9645\u662F\u7531 ${_} \u6253\u5757\uFF0C\u6821\u9A8C\u65E0\u6CD5\u901A\u8FC7` });
          }
        }
        const p = await this.insertTransactionsForReplay(e, t, r, n, s);
        return ei && Jl("before signatureBlock"), r && await this._wrapBlockError(r.emit("beforeSignatureBlock", e), r, "beforeSignatureBlock", e), this.commonBlockVerify.verifyBlockSize(e, p), this.commonBlockVerify.verifyBlockBlobSize(e), o && await this.commonBlockVerify.verifySignature(e), ei && Jl("before generatedBlock"), r && await this._wrapBlockError(r.emit("generatedBlock", e), r, "generatedBlock", e), ei && Yl("finish replayBlock"), e;
      }
      async insertTransactionsForReplay(e, t, r = new ii(), n, s = this.config) {
        let o = n.transactionGetterHelper;
        if (!o && (o = this.moduleMap.get("transactionGetterHelper"), !o)) throw new Jo(c.NOT_EXIST, { prop: "transactionGetterHelper", target: "moduleStroge" });
        const { verifySignature: a, skipVerifyStatisticInfo: p, skipVerifyParticipation: h } = n, { height: f, signature: g, generatorPublicKeyBuffer: d, statisticInfo: y } = e, _ = this.cryptoHelper.sha256();
        let I = 0, S = 0;
        const w = this.statisticsHelper.forceGetStatisticsInfoByBlock(r.taskname || `core-replay-${f}`, g), N = [], { transactionCore: B, asymmetricHelper: O, transactionHelper: P, baseHelper: C, blockUtils: V } = this, { GRAB_ASSET: F, SIGN_FOR_ASSET: K } = P, L = B.abortForbiddenTransaction, H = /* @__PURE__ */ new Set();
        if (!r.startTindexGetter) throw new Jo(c.NOT_EXIST, { prop: "startTindexGetter", target: "eventEmitter" });
        if (!r.tIndexGetter) throw new Jo(c.NOT_EXIST, { prop: "tIndexGetter", target: "eventEmitter" });
        if (!r.assetPrealnumGetter) throw new Jo(c.NOT_EXIST, { prop: "assetPrealnumGetter", target: "eventEmitter" });
        if (!r.blockRewardsGetter) throw new Jo(c.NOT_EXIST, { prop: "blockRewardsGetter", target: "eventEmitter" });
        const W = await r.startTindexGetter();
        if (e.startTindex !== W) throw new Pr(c.NOT_MATCH, { to_compare_prop: `startTindex ${e.startTindex}`, be_compare_prop: `startTindex ${W}`, to_target: "block", be_target: "calculate" });
        const z = /* @__PURE__ */ new Map();
        try {
          this.statisticsHelper.bindApplyTransactionEventEmiter(r, w), ei && Yl("begin insertTransactionsForReplay");
          for await (const he of t) {
            const x = r.tIndexGetter(he);
            ei && Jl("insert transaction: %d / %d", he.tIndex + 1, e.numberOfTransactions);
            try {
              if (he.tIndex !== x) throw new E0(c.NOT_MATCH, { to_compare_prop: `tIndex ${he.tIndex}`, be_compare_prop: `tIndex ${x}`, to_target: "transactionInBlock", be_target: "calculate" });
              const ce = he.transaction, { type: de, senderId: ke, storageValue: pe, signature: j } = ce;
              if (H.has(j)) throw new gc(c.SHOULD_NOT_DUPLICATE, { prop: `transaction with signature ${j}`, target: `block with height ${e.height}` });
              if (H.add(j), !this.commonBlockVerify.canInsertTransaction(de)) {
                const ae = Re.VK.get(Re.trsTypeToV(de)), le = new gc(c.DISABLED_INSERT_TRANSACTION, { trsName: ae });
                if (L) throw le;
                h_(le);
              }
              if (N.push(he.getBytes()), pe && (de === F || de === K)) {
                const ae = z.get(pe);
                if (ae) {
                  for (const le of ae) if (le.senderId === ke) throw new gc(c.SHOULD_NOT_INCLUDE, { prop: "Transactions", target: `block with height ${f}`, value: `transaction with storageValue ${pe}` });
                  ae.push(ce);
                } else z.set(pe, [ce]);
              }
              const re = B.getTransactionFactoryFromType(de);
              if (await re.beginDealTransaction(ce, r), await V.applyTransaction(r, o, ce), !p) {
                const ae = he.assetPrealnum;
                if (ae) {
                  const le = await r.assetPrealnumGetter(he);
                  if (!le) throw new Pr(c.NOT_FOUND, { prop: `transaction assetPrealnum ${j}`, target: "blockChain" });
                  if (le.remainAssetPrealnum !== ae.remainAssetPrealnum) throw new Pr(c.NOT_MATCH, { to_compare_prop: `assetPrealnum.remainAssetPrealnum ${JSON.stringify(ae.remainAssetPrealnum)}`, be_compare_prop: `assetPrealnum.remainAssetPrealnum ${JSON.stringify(le.remainAssetPrealnum)}`, to_target: `transactionInBlock ${ke} ${j}`, be_target: "calculate" });
                  if (le.frozenMainAssetPrealnum !== ae.frozenMainAssetPrealnum) throw new Pr(c.NOT_MATCH, { to_compare_prop: `assetPrealnum.frozenMainAssetPrealnum ${JSON.stringify(ae.frozenMainAssetPrealnum)}`, be_compare_prop: `assetPrealnum.frozenMainAssetPrealnum ${JSON.stringify(le.frozenMainAssetPrealnum)}`, to_target: `transactionInBlock ${ke} ${j}`, be_target: "calculate" });
                }
              }
              if (a) {
                if (!await O.detachedVeriy(he.getBytes(true, true), he.signatureBuffer, d)) throw new lf("Invalid transactionInBlock signature: %O", he.toJSON());
                if (e.generatorSecondPublicKeyBuffer) {
                  if (!he.signSignatureBuffer) throw new lf(c.PROP_IS_REQUIRE, { prop: "signSignature", target: "transactionInBlock" });
                  if (!await O.detachedVeriy(he.getBytes(false, true), he.signSignatureBuffer, e.generatorSecondPublicKeyBuffer)) throw new lf("Invalid transactionInBlock signSignature: %O", he.toJSON());
                }
              }
              Object.freeze(he);
              const se = he.getBytes();
              _.update(se), I += se.length, S += he.transaction.getBlobSize(), await re.endDealTransaction(he, r);
            } catch (ce) {
              const de = await r.emit("error", { error: ce, type: "replayBlock", transactionInBlock: he });
              if (de && de.continue) continue;
              throw ce;
            }
          }
          ei && Yl("finish insertTransactionsForReplay");
          const $ = await r.blockRewardsGetter(f);
          if (e.reward !== $) throw new Pr(c.NOT_MATCH, { to_compare_prop: `blockReward ${e.reward}`, be_compare_prop: `expectedReward ${$}`, to_target: "block", be_target: "calculate" });
          const q = N.length;
          if (e.offset !== q) throw new Pr(c.NOT_MATCH, { to_compare_prop: `offset ${e.offset}`, be_compare_prop: `offset ${q}`, to_target: "block", be_target: "calculate" });
          if (e.payloadLength !== I) throw new Pr(c.NOT_MATCH, { to_compare_prop: `payloadLength ${e.payloadLength}`, be_compare_prop: `payloadLength ${I}`, to_target: "block", be_target: "calculate" });
          if (e.blobSize !== S) throw new Pr(c.NOT_MATCH, { to_compare_prop: `blobSize ${e.blobSize}`, be_compare_prop: `blobSize ${S}`, to_target: "block", be_target: "calculate" });
          const ie = await _.digest("hex");
          if (e.payloadHash !== ie) throw new Pr(c.NOT_MATCH, { to_compare_prop: `payloadHashHex ${e.payloadHash}`, be_compare_prop: `payloadHashHex ${ie}`, to_target: "block", be_target: "calculate" });
          const ge = w.toModel(), Ae = ge.numberOfTransactions;
          if (e.numberOfTransactions !== Ae) throw new Pr(c.NOT_MATCH, { to_compare_prop: `numberOfTransactions ${e.numberOfTransactions}`, be_compare_prop: `numberOfTransactions ${Ae}`, to_target: "block", be_target: "calculate" });
          if (!p) {
            if (!this.baseHelper.isArrayEqual(y.getBytes(), ge.getBytes())) throw new Pr(c.NOT_MATCH, { to_compare_prop: `statisticsInfo ${JSON.stringify(y.toJSON())}`, be_compare_prop: `statisticsInfo ${JSON.stringify(ge.toJSON())}`, to_target: "block", be_target: "calculate" });
            const he = w.totalAsset, x = w.totalFee;
            if (BigInt(e.totalAmount) !== he) throw new Pr(c.NOT_MATCH, { to_compare_prop: `totalAmount ${e.totalAmount}`, be_compare_prop: `totalAmount ${he.toString()}`, to_target: "block", be_target: "calculate" });
            if (BigInt(e.totalFee) !== x) throw new Pr(c.NOT_MATCH, { to_compare_prop: `totalFee ${e.totalFee}`, be_compare_prop: `totalFee ${x.toString()}`, to_target: "block", be_target: "calculate" });
            e.transactionInfo.transactionInBlockBufferList = N;
          }
          r.has("finishedDealTransactions") && (h_("@deprecated", 'logic "finishedDealTransactions" \u4E8B\u4EF6\u5DF2\u7ECF\u88AB\u9057\u5F03\uFF0C\u8BF7\u53CA\u65F6\u66F4\u65B0\u5E76\u5347\u7EA7\u4EE3\u7801'), await r.emit("finishedDealTransactions", e));
        } finally {
          w.unref(e.signature);
        }
        return N;
      }
    };
    l([D("bfchain-core:TransactionCore"), u("design:type", Object)], Ja.prototype, "transactionCore", void 0);
    Ja = l([J(), be(13, D("cryptoHelper")), u("design:paramtypes", [dt, me, Ee, Be, ne, Ds, Or, ve, Ft, wn, ze, ys, gl, Object])], Ja);
    let Qh = class extends My {
      constructor(e, t, r, n, s, o, a, p, h, f, g, d) {
        super(), this.blockHelper = e, this.baseHelper = t, this.config = r, this.statisticsHelper = n, this.asymmetricHelper = s, this.cryptoHelper = o, this.blockGeneratorCalculator = a, this.commonBlockVerify = p, this.verifyBlockCore = h, this.generateBlockCore = f, this.replayBlockCore = g, this.moduleMap = d;
      }
      async fromJSON(e, t) {
        const r = Aa.fromObject(e);
        return t && t.verify && await this.verify(r, t.config), r;
      }
      async verifyBlockBody(e, t, r = this.config) {
        await super.verifyBlockBody(e, t, r);
      }
      _generateBlock(e, t) {
        const r = Aa.fromObject({ ...e, asset: t });
        return r.reward = this.config.basicRewards, r;
      }
      async replayBlock(e, t, r, n = {}, s = this.config) {
        return await super.replayBlock(e, t, r, n, s), n.verifyAsset && await this.checkAssetChangeHash(e.height, e.asset.commonAsset.assetChangeHash, n), e;
      }
    };
    l([D("bfchain-core:TransactionCore"), u("design:type", Object)], Qh.prototype, "transactionCore", void 0);
    Qh = l([J(), be(5, D("cryptoHelper")), u("design:paramtypes", [dt, Be, ne, Ds, Or, Object, wn, ys, za, ja, Ja, ze])], Qh);
    const { ArgumentIllegalException: Le } = ee("CONTROLLER", "GenesisBlockFactory");
    let Wh = class extends My {
      constructor(e, t, r, n, s, o, a, p, h, f, g, d, y) {
        super(), this.blockHelper = e, this.accountBaseHelper = t, this.baseHelper = r, this.config = n, this.statisticsHelper = s, this.asymmetricHelper = o, this.cryptoHelper = a, this.blockGeneratorCalculator = p, this.commonBlockVerify = h, this.verifyBlockCore = f, this.generateBlockCore = g, this.replayBlockCore = d, this.moduleMap = y;
      }
      async fromJSON(e, t) {
        const r = ro.fromObject(e);
        return t && t.verify && await this.verify(r, t.config), r;
      }
      async verifyBlockBody(e, t, r = this.config) {
        await super.verifyBlockBody(e, t);
        const { baseHelper: n } = this, s = t.genesisAsset;
        if (!s) throw new Le(c.PARAM_LOST, { param: "genesisBlock" });
        const o = { target: "genesisBlock" }, a = s.assetType;
        if (!a) throw new Le(c.PROP_IS_REQUIRE, { prop: "assetType", ...o });
        if (!n.isValidAssetType(a)) throw new Le(c.PROP_IS_INVALID, { prop: `assetType ${s.assetType}`, ...o });
        const p = s.chainName;
        if (!p) throw new Le(c.PROP_IS_REQUIRE, { prop: "chainName", ...o });
        if (!n.isValidChainName(p)) throw new Le(c.PROP_IS_INVALID, { prop: `chainName ${s.chainName}`, ...o });
        const h = s.magic;
        if (!h) throw new Le(c.PROP_IS_REQUIRE, { prop: "magic", ...o });
        if (!n.isValidChainMagic(h)) throw new Le(c.PROP_IS_INVALID, { prop: `magic ${s.magic}`, ...o });
        const f = s.bnid;
        if (!f) throw new Le(c.PROP_IS_REQUIRE, { prop: "bnid", ...o });
        if (f !== ah.TESTNET && f !== ah.MAINNET) throw new Le(c.SHOULD_BE, { to_compare_prop: `bnid ${f}`, to_target: "remark", be_compare_prop: "BNID_TYPE", ...o });
        if (!n.isPositiveInteger(s.beginEpochTime)) throw new Le(c.PROP_IS_INVALID, { prop: `beginEpochTime ${s.beginEpochTime}`, ...o });
        const g = s.genesisLocationName;
        if (!g) throw new Le(c.PROP_IS_REQUIRE, { prop: "genesisLocationName", ...o });
        if (!n.isValidLocationName(g, r.chainName)) throw new Le(c.PROP_IS_INVALID, { prop: `genesisLocationName ${s.genesisLocationName}`, ...o });
        if (!s.genesisAmount) throw new Le(c.PROP_IS_REQUIRE, { prop: "genesisAmount", ...o });
        if (!n.isValidAssetNumber(s.genesisAmount)) throw new Le(c.PROP_IS_INVALID, { prop: `genesisAmount ${s.genesisAmount}`, ...o });
        if (!s.maxSupply) throw new Le(c.PROP_IS_REQUIRE, { prop: "maxSupply", ...o });
        if (!n.isValidAssetNumber(s.maxSupply)) throw new Le(c.PROP_IS_INVALID, { prop: `maxSupply ${s.maxSupply}`, ...o });
        if (BigInt(s.maxSupply) < BigInt(s.genesisAmount)) throw new Le(c.PROP_SHOULD_GTE_FIELD, { prop: "maxSupply", ...o, field: s.genesisAmount });
        if (!n.isPositiveFloatContainZero(s.minTransactionFeePerByte)) throw new Le(c.PROP_IS_INVALID, { prop: `minTransactionFeePerByte ${s.minTransactionFeePerByte}`, ...o });
        if (!n.isPositiveInteger(s.maxTPSPerBlock)) throw new Le(c.PROP_IS_INVALID, { prop: `maxTPSPerBlock ${s.maxTPSPerBlock}`, ...o });
        if (!n.isPositiveInteger(s.maxTransactionSize)) throw new Le(c.PROP_IS_INVALID, { prop: `maxTransactionSize ${s.maxTransactionSize}`, ...o });
        if (s.maxTransactionBlobSize === void 0) throw new Le(c.PROP_IS_REQUIRE, { prop: `maxTransactionBlobSize ${s.maxTransactionBlobSize}`, ...o });
        if (!n.isNaturalNumber(s.maxTransactionBlobSize)) throw new Le(c.PROP_IS_INVALID, { prop: `maxTransactionBlobSize ${s.maxTransactionBlobSize}`, ...o });
        if (!n.isPositiveInteger(s.maxBlockSize)) throw new Le(c.PROP_IS_INVALID, { prop: `maxBlockSize ${s.maxBlockSize}`, ...o });
        if (s.maxBlockBlobSize === void 0) throw new Le(c.PROP_IS_REQUIRE, { prop: `maxBlockBlobSize ${s.maxBlockBlobSize}`, ...o });
        if (!n.isNaturalNumber(s.maxBlockBlobSize)) throw new Le(c.PROP_IS_INVALID, { prop: `maxBlockBlobSize ${s.maxBlockBlobSize}`, ...o });
        if (!n.isNaturalNumber(s.consessusBeforeSyncBlockDiff)) throw new Le(c.PROP_IS_INVALID, { prop: `consessusBeforeSyncBlockDiff ${s.consessusBeforeSyncBlockDiff}`, ...o });
        if (!n.isPositiveInteger(s.maxGrabTimesOfGiftAsset)) throw new Le(c.PROP_IS_INVALID, { prop: `maxGrabTimesOfGiftAsset ${s.maxGrabTimesOfGiftAsset}`, ...o });
        if (!s.issueAssetMinChainAsset) throw new Le(c.PROP_IS_REQUIRE, { prop: "issueAssetMinChainAsset", ...o });
        if (!n.isValidAssetNumber(s.issueAssetMinChainAsset)) throw new Le(c.PROP_IS_INVALID, { prop: `issueAssetMinChainAsset ${s.issueAssetMinChainAsset}`, ...o });
        if (!s.maxMultipleOfAssetAndMainAsset) throw new Le(c.PROP_IS_REQUIRE, { prop: "maxMultipleOfAssetAndMainAsset", ...o });
        if (!n.isPositiveBigFloatNotContainZero(s.maxMultipleOfAssetAndMainAsset)) throw new Le(c.PROP_IS_INVALID, { prop: `maxMultipleOfAssetAndMainAsset ${s.maxMultipleOfAssetAndMainAsset}`, ...o });
        if (!s.issueEntityFactoryMinChainAsset) throw new Le(c.PROP_IS_REQUIRE, { prop: "issueEntityFactoryMinChainAsset", ...o });
        if (!n.isValidAssetNumber(s.issueEntityFactoryMinChainAsset)) throw new Le(c.PROP_IS_INVALID, { prop: `issueEntityFactoryMinChainAsset ${s.issueEntityFactoryMinChainAsset}`, ...o });
        if (!s.maxMultipleOfEntityAndMainAsset) throw new Le(c.PROP_IS_REQUIRE, { prop: "maxMultipleOfEntityAndMainAsset", ...o });
        if (!n.isPositiveBigFloatNotContainZero(s.maxMultipleOfEntityAndMainAsset)) throw new Le(c.PROP_IS_INVALID, { prop: `maxMultipleOfEntityAndMainAsset ${s.maxMultipleOfEntityAndMainAsset}`, ...o });
        if (!s.registerChainMinChainAsset) throw new Le(c.PROP_IS_REQUIRE, { prop: `registerChainMinChainAsset ${s.registerChainMinChainAsset}`, ...o });
        if (!n.isValidAssetNumber(s.registerChainMinChainAsset)) throw new Le(c.PROP_IS_INVALID, { prop: `registerChainMinChainAsset ${s.registerChainMinChainAsset}`, ...o });
        if (!n.isPositiveInteger(s.maxApplyAndConfirmedBlockHeightDiff)) throw new Le(c.PROP_IS_INVALID, { prop: `maxApplyAndConfirmedBlockHeightDiff ${s.maxApplyAndConfirmedBlockHeightDiff}`, ...o });
        const { blockPerRound: d, forgeInterval: y, basicRewards: _, whetherToAllowGeneratorContinusElections: I } = s;
        if (!n.isPositiveInteger(d)) throw new Le(c.PROP_IS_INVALID, { prop: `blockPerRound ${d}`, ...o });
        if (!_) throw new Le(c.PROP_IS_REQUIRE, { prop: "maxSupply", ...o });
        if (!n.isValidAssetNumber(_)) throw new Le(c.PROP_IS_INVALID, { prop: `basicRewards ${_}`, ...o });
        if (!n.isBoolean(I)) throw new Le(c.PROP_IS_INVALID, { prop: `whetherToAllowGeneratorContinusElections ${I}`, ...o });
        if (!n.isPositiveInteger(y)) throw new Le(c.PROP_IS_INVALID, { prop: `forgeInterval ${y}`, ...o });
        if (y < 5) throw new Le(c.PROP_SHOULD_GTE_FIELD, { prop: `forgeInterval ${y}`, field: 5, ...o });
        if (!s.ports) throw new Le(c.PROP_IS_REQUIRE, { prop: "ports", ...o });
        if (!n.isValidChainPorts(s.ports)) throw new Le(c.PROP_IS_INVALID, { prop: `ports ${s.ports}`, ...o });
        if (!s.assetChangeHash) throw new Le(c.PROP_IS_REQUIRE, { prop: "assetChangeHash", ...o });
        if (!n.isValidAssetChangeHash(s.assetChangeHash)) throw new Le(c.PROP_IS_INVALID, { prop: `assetChangeHash ${s.assetChangeHash}`, ...o });
        const { nextRoundGenerators: S } = s;
        if (!S) throw new Le(c.PROP_IS_REQUIRE, { prop: "nextRoundGenerators", ...o });
        if (!n.isArray(S)) throw new Le(c.SHOULD_BE, { to_compare_prop: "nextRoundGenerators", to_target: "genesisBlock", be_compare_prop: "array", ...o });
        if (S.length !== s.blockPerRound) throw new Le(c.NOT_MATCH, { to_compare_prop: `nextRoundGenerators's length ${S.length}`, to_target: "genesisBlock", be_compare_prop: `blockPerRound: ${r.blockPerRound}`, be_target: "genesisBlock" });
        for (let w = 0; w < S.length; w++) {
          const N = S[w];
          if (!await this.accountBaseHelper.isAddress(N.address)) throw new Le(c.NOT_EXIST, { prop: `genesisBlock.nextRoundGenerators[${w}].address ${N.address}`, target: "genesisBlock.newGenerators" });
          if (!this.baseHelper.isNaturalNumber(N.numberOfForgeEntities)) throw new Le(c.PROP_IS_INVALID, { prop: `nextRoundGenerators[${w}].numberOfForgeEntities ${N.numberOfForgeEntities}`, target: "genesisBlock.nextRoundGenerators" });
        }
      }
      _generateBlock(e, t) {
        const r = ro.fromObject({ ...e, asset: t });
        return r.generatorPublicKey = e.generatorPublicKey, r.reward = "0", r;
      }
      async replayBlock(e, t, r, n = {}, s = this.config) {
        return await super.replayBlock(e, t, r, n, s), n.verifyAsset && await this.checkAssetChangeHash(e.height, e.asset.genesisAsset.assetChangeHash, n), e;
      }
    };
    l([D("bfchain-core:TransactionCore"), u("design:type", Object)], Wh.prototype, "transactionCore", void 0);
    Wh = l([J(), be(6, D("cryptoHelper")), u("design:paramtypes", [dt, me, Be, ne, Ds, Or, Object, wn, ys, za, ja, Ja, ze])], Wh);
    const { ArgumentIllegalException: u_, ConsensusException: Ql, NoFoundException: f_ } = ee("CONTROLLER", "RoundLastBlockFactory");
    let Xh = class extends My {
      constructor(e, t, r, n, s, o, a, p, h, f, g, d) {
        super(), this.blockHelper = e, this.baseHelper = t, this.config = r, this.statisticsHelper = n, this.asymmetricHelper = s, this.cryptoHelper = o, this.blockGeneratorCalculator = a, this.commonBlockVerify = p, this.verifyBlockCore = h, this.generateBlockCore = f, this.replayBlockCore = g, this.moduleMap = d;
      }
      async fromJSON(e, t) {
        const r = Ea.fromObject(e);
        return t && t.verify && await this.verify(r, t.config), r;
      }
      async verifyBlockBody(e, t, r = this.config) {
        await super.verifyBlockBody(e, t, r);
        const n = t.roundLastAsset, s = { target: "roundLastBlockAsset" }, { baseHelper: o } = this;
        if (!n.nextRoundGenerators) throw new u_(c.PROP_IS_REQUIRE, { prop: "nextRoundGenerators", ...s });
        if (!o.isValidChainOnChainHash(n.chainOnChainHash)) throw new u_(c.PROP_IS_INVALID, { prop: `chainOnChainHash ${n.chainOnChainHash}`, type: "chainOnChainHash", ...s });
      }
      _generateBlock(e, t) {
        const r = Ea.fromObject({ ...e, asset: t });
        return r.reward = this.config.basicRewards, r;
      }
      async replayBlock(e, t, r, n = {}, s = this.config) {
        if (await super.replayBlock(e, t, r, n, s), n.verifyAsset) {
          const { height: o, asset: a } = e;
          let p = n.transactionGetterHelper;
          if (!p && (p = this.moduleMap.get("transactionGetterHelper"), !p)) throw new f_(c.NOT_EXIST, { prop: "transactionGetterHelper", target: "moduleStroge" });
          const h = a.roundLastAsset;
          let f = n.blockGetterHelper;
          if (!f && (f = this.moduleMap.get("blockGetterHelper"), !f)) throw new f_(c.NOT_EXIST, { prop: "blockGetterHelper", target: "moduleStroge" });
          await this.checkAssetChangeHash(o, h.assetChangeHash, n), await this.__checkChainOnChainHash(o, h.chainOnChainHash, f), await this.__checkNextRoundGenerators(e, f);
        }
        return e;
      }
      async __checkChainOnChainHash(e, t, r) {
        const n = await this.blockHelper.calcChainOnChainHash(e, r);
        if (n !== t) throw new Ql(c.NOT_MATCH, { to_compare_prop: `chainOnChainHash ${t}`, be_compare_prop: `chainOnChainHash ${n}`, to_target: "block", be_target: "calculate" });
      }
      async __checkNextRoundGenerators(e, t) {
        const r = await t.getNextRoundGenerators(await t.getLastBlock(), e.generatorPublicKey), n = e.asset.roundLastAsset.nextRoundGenerators, s = r.length;
        if (s !== n.length) throw new Ql(c.NOT_MATCH, { to_compare_prop: `nextRoundGenerators length ${n.length}`, be_compare_prop: `nextRoundGenerators length ${r.length}`, to_target: "block remark", be_target: "calculate" });
        for (let o = 0; o < s; o++) {
          const { address: a, numberOfForgeEntities: p } = r[o], h = n[o];
          if (h.address !== a) throw new Ql(c.NOT_MATCH, { to_compare_prop: `nextRoundGenerators index ${o} address ${h.address}`, be_compare_prop: `nextRoundGenerators index ${o} address ${a}`, to_target: "block remark", be_target: "calculate" });
          if (h.numberOfForgeEntities !== p) throw new Ql(c.NOT_MATCH, { to_compare_prop: `nextRoundGenerators index ${o} address ${h.address} numberOfForgeEntities ${h.numberOfForgeEntities}`, be_compare_prop: `nextRoundGenerators index ${o} address ${a} numberOfForgeEntities ${p}`, to_target: "block remark", be_target: "calculate" });
        }
      }
    };
    l([D("bfchain-core:TransactionCore"), u("design:type", Object)], Xh.prototype, "transactionCore", void 0);
    Xh = l([J(), be(5, D("cryptoHelper")), u("design:paramtypes", [dt, Be, ne, Ds, Or, Object, wn, ys, za, ja, Ja, ze])], Xh);
    const { NoFoundException: hr } = ee("helper-account", "accountHelper");
    let qh = class {
      getAccounts(e, t, r = this.accountGetterHelper) {
        if (!r) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return r.getAccounts(e, t);
      }
      getNextRoundGenerators(e = this.accountGetterHelper) {
        if (!e && !e) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return e.getNextRoundGenerators();
      }
      getAccountInfo(e, t, r = this.accountGetterHelper) {
        if (!r) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return r.getAccountInfo(e, t);
      }
      getAccountTxCountInBlock(e, t = this.accountGetterHelper) {
        if (!t) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return t.getAccountTxCountInBlock(e);
      }
      getDApp(e, t, r, n = this.accountGetterHelper) {
        if (!n) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return n.getDApp(e, t, r);
      }
      isDAppPossessor(e, t, r = this.accountGetterHelper) {
        if (!r) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return r.isDAppPossessor(e, t);
      }
      getLocationName(e, t, r, n = this.accountGetterHelper) {
        if (!n) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return n.getLocationName(e, t, r);
      }
      isLocationNamePossessor(e, t, r = this.accountGetterHelper) {
        if (!r) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return r.isLocationNamePossessor(e, t);
      }
      isSubLocationNameExist(e, t, r = this.accountGetterHelper) {
        if (!r) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return r.isSubLocationNameExist(e, t);
      }
      isLocationNameForbidden(e, t = this.accountGetterHelper) {
        if (!t) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return t.isLocationNameForbidden(e);
      }
      getFrozenAsset(e, t, r, n = this.accountGetterHelper) {
        if (!n) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return n.getFrozenAsset(e, t, r);
      }
      getAsset(e, t, r = this.accountGetterHelper) {
        if (!r) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return r.getAsset(e, t);
      }
      getCurrency(e, t = this.accountGetterHelper) {
        if (!t) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return t.getCurrency(e);
      }
      isCurrencyForbidden(e, t = this.accountGetterHelper) {
        if (!t) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return t.isCurrencyForbidden(e);
      }
      getMagic(e, t = this.accountGetterHelper) {
        if (!t) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return t.getMagic(e);
      }
      getChain(e, t = this.accountGetterHelper) {
        if (!t) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return t.getChain(e);
      }
      getMigrateCertificate(e, t = this.accountGetterHelper) {
        if (!t) throw new hr(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        return t.getMigrateCertificate(e);
      }
    };
    l([D("accountGetterHelper", { optional: true }), u("design:type", Object)], qh.prototype, "accountGetterHelper", void 0);
    qh = l([J()], qh);
    let g_ = class {
      constructor(e, t, r, n) {
        this.config = e, this.blockHelper = t, this.accountHelper = r, this.transactionHelper = n;
      }
      async getNextRoundGenerators(e, t) {
        const r = this.blockHelper.calcRoundByHeight(e);
        return await this.calcForgingGenerators(r, t);
      }
      async calcForgingGenerators(e, t) {
        let r = await this.accountHelper.getNextRoundGenerators(t);
        const n = r.length < this.config.blockPerRound;
        let s = r.map((a) => a.address), o = e - 1;
        for (; r.length < this.config.blockPerRound && o !== 0; ) {
          const a = await this.__getAlternateGenerators(o, r, s, t);
          r = a.results, s = a.pickAddressArr, o--;
        }
        return n && (r = this.blockHelper.sortInRankAccountInfoList(r)), r;
      }
      async __getAlternateGenerators(e, t, r, n) {
        const s = await this.blockHelper.forceGetBlockGeneratorAddressByRound(e), o = [];
        for (const p of s) r.includes(p) || (r[r.length] = p, o[o.length] = p);
        let a = await this.accountHelper.getAccounts(o, e, n);
        return a = this.__sortByProducedblocks(a), t.push.apply(t, a.slice(0, this.config.blockPerRound - t.length)), { results: t, pickAddressArr: r };
      }
      __sortByProducedblocks(e) {
        if (e.length <= 1) return e;
        const t = [...e], r = Math.floor(t.length / 2), n = t.splice(r, 1)[0], s = [], o = [];
        for (let a = 0; a < t.length; a++) t[a].producedblocks > n.producedblocks ? s[s.length] = t[a] : o[o.length] = t[a];
        return this.__sortByProducedblocks(s).concat([n], this.__sortByProducedblocks(o));
      }
    };
    g_ = l([J(), u("design:paramtypes", [ne, dt, qh, Ee])], g_);
    const { warn: d_, ConsensusException: hf, log: I0 } = ee("Core", "blockForkCheck");
    let We;
    (function(i) {
      i[i.KEEP = 1] = "KEEP", i[i.MERGE = 2] = "MERGE", i[i.FORK = 3] = "FORK";
    })(We || (We = {}));
    let Zh;
    (function(i) {
      i[i.PUZZLED = 11] = "PUZZLED";
    })(Zh || (Zh = {}));
    let y_ = class {
      constructor(e, t, r) {
        this.blockHelper = e, this.timeHelper = t, this.config = r;
      }
      async checkNewBlockFromChainChannel(e, t, r = this.blockHelper.blockGetterHelper) {
        const n = await this.checkNewBlock(e, t.toBlockGetterHelper({ maxHeight: e.height }), r);
        if (n.plot === We.MERGE) {
          const s = await this.blockHelper.getCurrentReplayingBlockInfo(r), o = s && s.chainChannelGroup;
          o && o.addChainChannels(t);
        }
        return n;
      }
      checkSameHeightBlockPlot_(e, t) {
        if (e.timestamp > t.timestamp) return We.FORK;
        if (e.timestamp < t.timestamp) return We.KEEP;
        if (e.previousBlockSignature === t.previousBlockSignature && e.timestamp === t.timestamp) {
          if (e.numberOfTransactions > t.numberOfTransactions) return We.KEEP;
          if (e.totalFee > t.totalFee) return We.KEEP;
          if (e.totalFee === t.totalFee) {
            if (e.signature > t.signature) return We.KEEP;
            if (e.signature === t.signature) return We.MERGE;
          }
        }
        return We.FORK;
      }
      checkSameHeightBlockListPlot_(e, t) {
        return this.checkSameHeightBlockPlot_(this.blockHelper.parseBlockPlotCheckerListToPlotChecker(e), this.blockHelper.parseBlockPlotCheckerListToPlotChecker(t));
      }
      async getBlockPlotCheckerEnd_(e, t) {
        const r = { pc: t, blockGetterHelper: e }, n = await this.blockHelper.getCurrentReplayingBlockInfo(e);
        n && (r.blockGetterHelper = n.blockGetterHelper, r.pc = this.blockHelper.parseBlockToPlotChecker(await n.blockGetterHelper.getLastBlock()));
        const s = await this.blockHelper.getCurrentGenerateBlock(e);
        return s && (r.pc = this.blockHelper.parseNewBlockToPlotChecker(s)), r;
      }
      async checkBlockGetterPlot(e, t, r, n) {
        const [s, o] = await Promise.all([this.getBlockPlotCheckerEnd_(t, e), this.getBlockPlotCheckerEnd_(n, r)]);
        if (s.pc.height <= o.pc.height) {
          const p = await this.checkBlockGetterPlotEnd(s.pc, o.pc, o.blockGetterHelper);
          return p.plot === We.KEEP ? { plot: We.KEEP, height: e.height, blockPlotChecker: e } : p.plot === We.MERGE ? { plot: We.MERGE, height: r.height, blockPlotChecker: r } : p.plot === We.FORK && typeof p.height === "number" && p.height <= e.height ? { plot: p.plot, height: p.height } : p;
        }
        const a = await this.checkBlockGetterPlotEnd(o.pc, s.pc, s.blockGetterHelper);
        return a.plot === We.MERGE ? { plot: We.MERGE, height: r.height, blockPlotChecker: r } : a.plot === We.FORK ? { plot: We.KEEP, height: e.height, blockPlotChecker: e } : (d_(`should not happen: the pc5.height is large then pc6.height, Why plot is ${We[a.plot]}?`), a);
      }
      async checkBlockGetterPlotEnd(e, t, r) {
        const n = { plot: We.MERGE, height: t.height, blockPlotChecker: t }, s = { plot: We.KEEP, height: e.height, blockPlotChecker: e }, o = (p) => ({ plot: We.FORK, height: p }), a = () => ({ plot: Zh.PUZZLED });
        if (e.height < t.height) return (e.height === t.height - 1 ? t.previousBlockSignature : await this.blockHelper.forceGetBlockSignatureByHeight(e.height, r)) === e.signature ? n : o();
        if (e.height === t.height) {
          if (e.signature === t.signature) return n;
          if (e.previousBlockSignature === t.previousBlockSignature) {
            const p = this.checkSameHeightBlockPlot_(e, t);
            return p === We.FORK ? o(e.height - 1) : p === We.KEEP ? s : n;
          }
          return a();
        }
        return s;
      }
      async checkNewBlock(e, t, r = this.blockHelper.blockGetterHelper) {
        const n = await this.blockHelper.getLastBlock(r), s = this.blockHelper.parseBlockToPlotChecker(await this.blockHelper.getLastBlock(r));
        let o;
        e instanceof Nt ? o = this.blockHelper.parseBlockToPlotChecker(e) : o = e;
        const a = await this.checkBlockGetterPlot(s, r, o, t), p = { plot: We.MERGE, height: o.height, block: this.blockHelper.getBlockFromPlotChecker(o) }, h = { plot: We.KEEP, height: s.height, block: n }, f = (g, d) => ({ plot: We.FORK, height: g, block: d });
        if (a.plot === Zh.PUZZLED) {
          const g = await this.findNearestSameBlock(s.height - 1, r, t), d = (await this.blockHelper.forceGetBlockListByHeightRange(g.height + 1, s.height, r)).map((I) => this.blockHelper.parseBlockToPlotChecker(I)), y = (await this.blockHelper.forceGetBlockListByHeightRange(g.height + 1, o.height, t)).map((I) => this.blockHelper.parseBlockToPlotChecker(I)), _ = this.checkSameHeightBlockListPlot_(d, y);
          if (_ === We.FORK) return f(g.height, g);
          if (_ === We.KEEP) return h;
          if (_ === We.MERGE) return d_("should not happen. pc1 and pc2 are puzzled. should not 'MERGE'!"), p;
          throw new Error("should not happen in PUZZLED");
        }
        if (a.plot === We.FORK) {
          if (typeof a.height === "number") return f(a.height, a.height === s.height ? n : void 0);
          const g = await this.findNearestSameBlock(s.height - 1, r, t);
          return f(g.height, g);
        }
        if (a.plot === We.MERGE) return p;
        if (a.plot === We.KEEP) return h;
        throw new Error("should not happen in checkResult");
      }
      async findNearestSameBlock(e, t, r) {
        if (e < 1) throw new hf(c.GENESIS_BLOCK_MAYBE_NO_EQUAL);
        const n = this.blockHelper.calcRoundByHeight(e) - 1, s = this.blockHelper.calcRoundEndHeight(n), o = await this.findNearestSameBlockInOneRound(e, s, t, r);
        if (o) return o;
        let a = s;
        do {
          const f = await this.blockHelper.forceGetBlockByHeight(a, t);
          if ((await this.blockHelper.forceGetBlockByHeight(a, r)).asset.roundLastAsset.chainOnChainHash === f.asset.roundLastAsset.chainOnChainHash) break;
          a -= this.config.blockPerRound;
        } while (a > 1);
        const p = a + this.config.blockPerRound;
        I0(`\u94FE\u4E0A\u94FE\u4E8E ${p} \u9AD8\u5EA6\u7684\u8F6E\u6B21\u51FA\u9519\uFF0C\u6240\u4EE5\u4ECE\u8FD9\u91CC\u5F00\u59CB\u5F80\u56DE\u67E5\u8BE258\u4E2A\u5757\u80FD\u53D1\u73B0\u5206\u53C9 (\u4E0A\u4E00\u4E2A\u8F6E\u7684\u8F6E\u672B\u5757\u4E5F\u8981\u5224\u65AD)`);
        const h = await this.findNearestSameBlockInOneRound(p, p - this.config.blockPerRound, t, r);
        if (!h) throw new hf(c.FAILED_TO_FIND_NEAREST_SAME_BLOCK_IN_ONE_ROUND);
        return h;
      }
      async findNearestSameBlockInOneRound(e, t, r, n) {
        for (let s = e; s >= t - 1; s--) {
          const o = await this.blockHelper.forceGetBlockByHeight(s, n), a = await this.blockHelper.forceGetBlockByHeight(s, r);
          if (o.signature === a.signature) return a;
          if (s === 1) throw new hf(c.GENESIS_BLOCK_NOT_MATCH);
        }
      }
    };
    y_ = l([J(), u("design:paramtypes", [dt, Ft, ne])], y_);
    const { ArgumentFormatException: m_, log: hR, warn: T0 } = ee("Core", "Block");
    let dl = class {
      constructor(e, t, r, n, s, o, a) {
        this.blockHelper = e, this.asymmetricHelper = t, this.blockGeneratorCalculator = r, this.keypairHelper = n, this.cryptoHelper = s, this.Buffer = o, this.moduleMap = a, this._blockFactoryCache = /* @__PURE__ */ new Map(), this.fromJSON = this.recombineBlock;
      }
      getBlockFactory(e) {
        let t = this._blockFactoryCache.get(e);
        return t || (t = bt(e, this.moduleMap), this._blockFactoryCache.set(e, t)), t;
      }
      getBlockFactoryFromHeight(e) {
        const t = this.blockHelper.parseTypeByHeight(e);
        return this.getBlockFactoryFromBaseType(t);
      }
      getBlockFactoryFromBaseType(e) {
        const t = S0.KF.get(e);
        if (!t) throw new m_(c.INVALID_BASE_TYPE, { base_type: e });
        return this.getBlockFactory(t);
      }
      async generateBlock(e, t, r, n, s, o, a, p) {
        const h = this.getBlockFactory(e);
        return h.verifyKeypair(s), o && (h.verifyKeypair(o), t.generatorSecondPublicKey = xe(o.publicKey)), t.remark = t.remark || {}, await h.verifyBlockBody(t, r), await h.generateBlock(t, r, n, s, o, a, p);
      }
      async replayBlock(e, t, r, n = {}) {
        const s = this.getBlockFactoryFromHeight(e.height);
        return await s.verifyBlockBody(e, e.asset), await s.replayBlock(e, t, r, n);
      }
      async recombineBlock(e) {
        return await this.getBlockFactoryFromHeight(e.height).fromJSON(e);
      }
      parseBytesToBlock(e) {
        return Nt.decode(e);
      }
      parseBytesToSomeBlock(e, t) {
        if (typeof t !== "number") {
          const n = new Xr(e);
          n.uint32(), n.uint32(), n.uint32(), t = n.uint32();
        }
        return this.getBlockModelConstructorFromHeight(t).decode(e);
      }
      getBlockModelConstructorFromHeight(e) {
        return this.getBlockModelConstructorFromBaseType(e);
      }
      getBlockModelConstructorFromBaseType(e) {
        const t = this.blockHelper.parseTypeByHeight(e), r = Zl.KM.get(t);
        if (!r) throw new m_(c.INVALID_BASE_TYPE, { base_type: t });
        return r;
      }
      getRoundLastBlockRemarkHash(...e) {
        return T0("@deprecated", "\u8BF7\u76F4\u63A5\u4F7F\u7528blockHelper.getRoundLastBlockRemarkHash"), this.blockHelper.calcChainOnChainHash(...e);
      }
    };
    dl = l([J("bfchain-core:BlockCore"), be(3, D("keypairHelper")), be(4, D("cryptoHelper")), be(5, D("Buffer")), u("design:paramtypes", [dt, Or, wn, Object, Object, Object, ze])], dl);
    const S0 = (() => {
      const i = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
      return [[Kt.GENESIS, Wh], [Kt.COMMON, Qh], [Kt.ROUNDEND, Xh]].forEach(([t, r]) => {
        i.set(t, r), e.set(r, t);
      }), { KF: i, FK: e };
    })();
    const { ConsensusException: fn, NoFoundException: w0 } = ee("VERIFIER", "BlockLogicVerifier");
    let eu;
    (function(i) {
      i[i.SYNC = 1] = "SYNC", i[i.REBUILD = 2] = "REBUILD", i[i.GENERATEBLOCK = 3] = "GENERATEBLOCK";
    })(eu || (eu = {}));
    const ln = class {
      async verifyBlockBase(e, t, r) {
        this.blockHelper.verifyBlockVersion(e, this.configHelper), t !== eu.REBUILD && await this.isBlockAlreadyExist(e.signature, e.height), this.checkBlockTimestamp(e), e.height !== 1 && await this.checkPreviousBlock(e), await this.checkSecondPublicKey(e, r);
      }
      async checkSecondPublicKey(e, t) {
        const { height: r, generatorPublicKey: n, generatorSecondPublicKey: s, signature: o, signSignature: a } = e, p = await this.accountBaseHelper.getAddressFromPublicKeyString(n);
        if (!t) throw new w0(c.NOT_EXIST, { prop: `generator with address ${p}`, target: "blockChain" });
        if (t.secondPublicKey) {
          if (!(s && a)) throw new fn(c.BLOCK_SIGN_SIGNATURE_IS_REQUIRED, { signature: o, generatorAddress: p, height: r });
          if (t.secondPublicKey !== s) throw new fn(c.BLOCK_GENERATOR_SECOND_PUBLICKEY_ALREADY_CHANGE, { signature: o, generatorAddress: p, height: r });
        } else {
          if (s) throw new fn(c.BLOCK_SHOULD_NOT_HAVE_GENERATOR_SECOND_PUBLICKEY, { signature: o, generatorAddress: p, height: r });
          if (a) throw new fn(c.BLOCK_SHOULD_NOT_HAVE_SIGN_SIGNATURE, { signature: o, generatorAddress: p, height: r });
        }
      }
      checkBlockTimestamp(e) {
        const { timeHelper: t } = this, r = t.getTimestamp(), n = t.getSlotNumberByTimestamp(e.timestamp), s = t.getSlotNumberByTimestamp(r);
        n > s && ;
      }
      async isBlockAlreadyExist(e, t) {
        const r = this.blockGetterHelper;
        if (typeof r.getCountBlock !== "function") throw new fn(c.PROP_IS_INVALID, { prop: "getCountBlock", target: "blockGetterHelper" });
        if (await r.getCountBlock({ signature: e }) > 0) throw new fn(c.ALREADY_EXIST, { prop: `Block with signature ${e}`, target: "blockChain", errorId: `Block already exists: ${e} height: ${t}` });
      }
      async verifyBlockWithTransactions(e, t) {
        t !== eu.GENERATEBLOCK && await this.blockCore.getBlockFactoryFromHeight(e.height).verify(e);
      }
      async checkPreviousBlock(e) {
        const t = this.blockGetterHelper;
        if (typeof t.chainBlockFork !== "function") throw new fn(c.PROP_IS_INVALID, { prop: "chainBlockFork", target: "blockGetterHelper" });
        const { height: r, previousBlockSignature: n, timestamp: s } = e, o = await t.getBlockByHeight(r - 1);
        if (!o) throw new fn(c.NOT_EXIST, { prop: `Block with height ${r - 1}`, target: "blockChain" });
        const a = o.signature;
        if (n !== a) throw await t.chainBlockFork(e, ph.DIFFERENT_PRE_BLOCK_SIGNATURE), new fn(c.NOT_MATCH, { to_compare_prop: `previousBlockSignature: ${n}`, be_compare_prop: `__signature: ${a}`, to_target: `block ${r}`, be_target: `lastBlock ${o.height}` });
        const { timeHelper: p } = this, h = p.getSlotNumberByTimestamp(s), f = p.getNextSlotNumberByTimestamp(o.timestamp);
        if (h < f) throw new fn(c.PROP_SHOULD_GT_FIELD, { prop: `timestamp ${s}`, target: "block", field: `lastBlock timestamp ${o.timestamp}` });
      }
      async isValidBlockSlot(e) {
        const { timeHelper: t, blockGeneratorCalculator: r, blockGetterHelper: n } = this, s = await this.accountBaseHelper.getAddressFromPublicKeyString(e.generatorPublicKey), o = t.getSlotNumberByTimestamp(e.timestamp), a = await n.getLastBlock(), p = await r.calcGenerateBlockGenerator({ timestamp: a.timestamp, height: a.height }, { toTimestamp: e.timestamp, blockGetterHelper: n });
        if (p.address !== s) throw new fn(c.INVALID_BLOCK_GENERATOR, { reason: `lastBlock.timestamp: ${a.timestamp} lastBlock.height: ${a.height}, block.timestamp: ${e.timestamp} curTime: ${t.getTimeByTimestamp(e.timestamp)} \u8BE5\u533A\u5757\u7684\u6253\u5757\u4EBA\u6821\u9A8C\u4E0D\u901A\u8FC7\uFF0C\u533A\u5757signature\uFF1A${e.signature} height: ${e.height} \u5F53\u524Dslot\u4E3A${o}\uFF0C\u5F53\u524D\u5E94\u8BE5\u7531\u59D4\u6258\u4EBA${p.address}\u6253\u5757\uFF0C\u5B9E\u9645\u662F\u7531${s}\u6253\u5757\uFF0C\u6821\u9A8C\u65E0\u6CD5\u901A\u8FC7` });
      }
      async checkAssetChangeHash(e, t) {
        const r = await this.accountGetterHelper.getAccountsAssetsChange(e), n = await this.blockHelper.calcAssetChangeHash(r);
        if (n !== t) throw new fn(c.NOT_MATCH, { to_compare_prop: `assetChangeHash ${t}`, be_compare_prop: `assetChangeHash ${n}`, to_target: "block", be_target: "calculate" });
      }
    };
    l([D(dt), u("design:type", dt)], ln.prototype, "blockHelper", void 0);
    l([D(me), u("design:type", me)], ln.prototype, "accountBaseHelper", void 0);
    l([D(ne), u("design:type", ne)], ln.prototype, "configHelper", void 0);
    l([D(Ft), u("design:type", Ft)], ln.prototype, "timeHelper", void 0);
    l([D(ve), u("design:type", ve)], ln.prototype, "chainAssetInfoHelper", void 0);
    l([D("bfchain-core:BlockCore"), u("design:type", Object)], ln.prototype, "blockCore", void 0);
    l([D(wn), u("design:type", wn)], ln.prototype, "blockGeneratorCalculator", void 0);
    l([D("transactionGetterHelper", { dynamics: true }), u("design:type", Object)], ln.prototype, "transactionGetterHelper", void 0);
    l([D("blockGetterHelper", { dynamics: true }), u("design:type", Object)], ln.prototype, "blockGetterHelper", void 0);
    l([D("accountGetterHelper", { dynamics: true }), u("design:type", Object)], ln.prototype, "accountGetterHelper", void 0);
    const b0 = class extends ln {
      async verify(e, t, r) {
        return await this.verifyBlockBase(e, t, r), true;
      }
      async verifyBlockAsset(e) {
        await this.checkAssetChangeHash(e.height, e.asset.genesisAsset.assetChangeHash);
      }
    };
    const N0 = class extends ln {
      async verify(e, t, r) {
        return await this.verifyBlockBase(e, t, r), await this.checkPreviousBlock(e), await this.isValidBlockSlot(e), true;
      }
      async verifyBlockAsset(e) {
        await this.checkAssetChangeHash(e.height, e.asset.commonAsset.assetChangeHash);
      }
    };
    const { ConsensusException: dc, NoFoundException: fR } = ee("VERIFIER", "BlockLogicVerifier");
    const x0 = class extends ln {
      async verify(e, t, r) {
        return await this.verifyBlockBase(e, t, r), await this.checkPreviousBlock(e), await this.isValidBlockSlot(e), true;
      }
      async verifyBlockAsset(e) {
        const { height: t, asset: r } = e, { assetChangeHash: n, chainOnChainHash: s } = r.roundLastAsset;
        await this.checkAssetChangeHash(t, n), await this.checkChainOnChainHash(t, s), await this.checkNextRoundGenerators(e);
      }
      async checkChainOnChainHash(e, t) {
        const r = await this.blockHelper.calcChainOnChainHash(e, this.blockGetterHelper);
        if (r !== t) throw new dc(c.NOT_MATCH, { to_compare_prop: `hashString ${r}`, be_compare_prop: `hash ${t}`, to_target: "block", be_target: "calculate" });
      }
      async checkNextRoundGenerators(e) {
        const t = this.blockGetterHelper;
        if (typeof t.getNextRoundGenerators !== "function") throw new dc(c.PROP_IS_INVALID, { prop: "checkNextRoundGenerators", target: "blockGetterHelper" });
        const r = await t.getNextRoundGenerators(await t.getLastBlock(), e.generatorPublicKey), n = e.asset.roundLastAsset.nextRoundGenerators;
        if (r.length !== n.length) throw new dc(c.NOT_MATCH, { to_compare_prop: `generators length ${r.length}`, be_compare_prop: `generators length ${n.length}`, to_target: "block asset", be_target: "calculate" });
        for (let s = 0; s < r.length; s++) {
          const o = r[s].address, a = n[s];
          if (a.address !== o) throw new dc(c.NOT_MATCH, { to_compare_prop: `nextRoundGenerators index ${s} address ${a.address}`, be_compare_prop: `nextRoundGenerators index ${s} address ${o}`, to_target: "block asset", be_target: "calculate" });
          const p = r[s].numberOfForgeEntities;
          if (a.numberOfForgeEntities !== p) throw new dc(c.NOT_MATCH, { to_compare_prop: `nextRoundGenerators index ${s} address ${a.address} numberOfForgeEntities ${a.numberOfForgeEntities}`, be_compare_prop: `nextRoundGenerators index ${s} address ${o} numberOfForgeEntities ${p}`, to_target: "block asset", be_target: "calculate" });
        }
      }
    };
    const { ArgumentFormatException: O0 } = ee("Core", "BlockLogicVerifierCore");
    let zg = class {
      constructor(e, t) {
        this.blockHelper = e, this.moduleMap = t, this._blockLogicVerifierCache = /* @__PURE__ */ new Map();
      }
      getBlockLogicVerifier(e) {
        let t = this._blockLogicVerifierCache.get(e);
        return t || (t = bt(e, this.moduleMap), this._blockLogicVerifierCache.set(e, t)), t;
      }
      getBlockLogicVerifierFromHeight(e) {
        const t = this.blockHelper.parseTypeByHeight(e);
        return this.getBlockLogicVerifierFromBaseType(t);
      }
      getBlockLogicVerifierFromBaseType(e) {
        const t = C0.KLV.get(e);
        if (!t) throw new O0(c.INVALID_BASE_TYPE, { base_type: e });
        return this.getBlockLogicVerifier(t);
      }
    };
    zg = l([J("bfchain-core:BlockLogicVerifierCore"), u("design:paramtypes", [dt, ze])], zg);
    const C0 = (() => {
      const i = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
      return [[Kt.GENESIS, b0], [Kt.COMMON, N0], [Kt.ROUNDEND, x0]].forEach(([t, r]) => {
        i.set(t, r), e.set(r, t);
      }), { KLV: i, LVK: e };
    })();
    const { ConsensusException: dR, NoFoundException: Yo } = ee("TICKER", "BlockLogicTicker");
    let Vr = class {
      async tickBlockBase(e, t = this.accountGetterHelper, r = this.blockTickGetterHelper) {
        const n = await this.__calcForginAndHoldingRewards(e, t);
        await this.__updateForgingAndHoldingAccount(e, n, r);
      }
      async __getShareEntityHolders(e = this.accountGetterHelper) {
        if (!e) throw new Yo(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        const t = await e.getShareEntityHolders();
        let r = 0;
        for (const n of t) r += n.numberOfShareEntities;
        return { holders: t, totalEntities: r };
      }
      async __calcForginAndHoldingRewards(e, t = this.accountGetterHelper, r = this.blockGetterHelper) {
        if (!t) throw new Yo(c.NOT_EXIST, { prop: "accountGetterHelper", target: "moduleStroge" });
        if (!r) throw new Yo(c.NOT_EXIST, { prop: "blockGetterHelper", target: "moduleStroge" });
        const { blockHelper: n } = this;
        let s = 0, o = [], a = BigInt(0);
        if (n.isRoundLastBlock(e.height) && e.reward !== "0") {
          const h = await this.__getShareEntityHolders(t);
          if (s = h.totalEntities, o = h.holders, !r.getBlocksByRange) throw new Yo(c.NOT_EXIST, { prop: "blockGetterHelper.getBlocksByRange", target: "moduleStroge" });
          const f = this.blockHelper.calcRoundStartHeightByHeight(e.height), g = await r.getBlocksByRange(f, e.height);
          for (const _ of g) a += BigInt(_.totalFee);
          const d = await t.getAsset(this.configHelper.magic, this.configHelper.assetType);
          if (!d) throw new Yo(c.NOT_EXIST, { prop: `asset(${this.configHelper.magic}-${this.configHelper.assetType})`, target: "blockChain" });
          const y = d.issuedAssetPrealnum - d.circulatedAssetPrealnum - BigInt(e.reward);
          y < a && (a = y);
        }
        return this.blockHelper.calcForginAndHoldingRewards(e, a, s, o);
      }
      async __updateForgingAndHoldingAccount(e, t, r = this.blockTickGetterHelper) {
        if (!r) throw new Yo(c.NOT_EXIST, { prop: "blockTickGetterHelper", target: "moduleStroge" });
        const { forgingRewards: n, holdingRewardsList: s, circulations: o } = t;
        s.length > 0 && await r.updateHoldingAccount(e, s), await r.updateForgingAccount(e, n), o > BigInt(0) && await r.accumulateCirculations(e, this.configHelper.magic, this.configHelper.assetType, o);
      }
    };
    l([D(dt), u("design:type", dt)], Vr.prototype, "blockHelper", void 0);
    l([D(ne), u("design:type", ne)], Vr.prototype, "configHelper", void 0);
    l([D(Ft), u("design:type", Ft)], Vr.prototype, "timeHelper", void 0);
    l([D(me), u("design:type", me)], Vr.prototype, "accountBaseHelper", void 0);
    l([D(xt), u("design:type", xt)], Vr.prototype, "jsbiHelper", void 0);
    l([D(wn), u("design:type", wn)], Vr.prototype, "blockGeneratorCalculator", void 0);
    l([D("accountGetterHelper", { optional: true, dynamics: true }), u("design:type", Object)], Vr.prototype, "accountGetterHelper", void 0);
    l([D("blockGetterHelper", { optional: true, dynamics: true }), u("design:type", Object)], Vr.prototype, "blockGetterHelper", void 0);
    l([D("blockTickGetterHelper", { optional: true, dynamics: true }), u("design:type", Object)], Vr.prototype, "blockTickGetterHelper", void 0);
    Vr = l([J()], Vr);
    ee("CONTROLLER", "BlockLogicVerifier");
    let jg = class extends Vr {
      async tick(e, t = this.accountGetterHelper, r = this.blockTickGetterHelper) {
        await this.tickBlockBase(e, t, r);
      }
    };
    jg = l([J()], jg);
    let Jg = class extends Vr {
      async tick(e, t = this.accountGetterHelper, r = this.blockTickGetterHelper) {
        await this.tickBlockBase(e, t, r);
      }
    };
    Jg = l([J()], Jg);
    ee("TICKER", "BlockLogicTicker");
    let Yg = class extends Vr {
      async tick(e, t = this.accountGetterHelper, r = this.blockTickGetterHelper) {
        await this.tickBlockBase(e, t, r);
      }
      async roundEnd(e, t, r = this.accountGetterHelper, n = this.blockTickGetterHelper) {
      }
    };
    Yg = l([J()], Yg);
    const { ArgumentFormatException: R0, log: ER, warn: IR } = ee("Core", "BlockTicker");
    let Qg = class {
      constructor(e, t) {
        this.blockHelper = e, this.moduleMap = t, this._blockTickerCache = /* @__PURE__ */ new Map();
      }
      getBlockTicker(e) {
        let t = this._blockTickerCache.get(e);
        return t || (t = bt(e, this.moduleMap), this._blockTickerCache.set(e, t)), t;
      }
      getBlockTickerFromHeight(e) {
        const t = this.blockHelper.parseTypeByHeight(e);
        return this.getBlockTickerFromBaseType(t);
      }
      getBlockTickerFromBaseType(e) {
        const t = B0.KT.get(e);
        if (!t) throw new R0(c.INVALID_BASE_TYPE, { base_type: e });
        return this.getBlockTicker(t);
      }
    };
    Qg = l([J("bfchain-core:BlockTickerCore"), u("design:paramtypes", [dt, ze])], Qg);
    const B0 = (() => {
      const i = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
      return [[Kt.GENESIS, jg], [Kt.COMMON, Jg], [Kt.ROUNDEND, Yg]].forEach(([t, r]) => {
        i.set(t, r), e.set(r, t);
      }), { KT: i, TK: e };
    })();
    const { ArgumentIllegalException: gn } = ee("CONTROLLER", "RegisterChainTransactionFactory");
    let tu = class extends Ge {
      constructor(e, t, r, n, s, o, a) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.registerChainCertificateHelper = o, this.configMap = a;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), e.recipientId) throw new gn(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new gn(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "chain magic", ...n });
        if (e.toMagic !== r.magic) throw new gn(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "chain magic", ...n });
        if (!e.storage) throw new gn(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const s = e.storage;
        if (s.key !== "magic") throw new gn(c.SHOULD_BE, { to_compare_prop: `key ${s.key}`, to_target: "storage", be_compare_prop: "magic", ...n });
        const o = t.registerChain;
        if (!o) throw new gn(c.PARAM_LOST, { param: "registerChain" });
        const a = { ...n, target: "registerChainAsset" }, p = o.genesisBlock;
        if (!p) throw new gn(c.PROP_IS_REQUIRE, { prop: "genesisBlock", ...a });
        if (!this.baseHelper.isString(p)) throw new gn(c.PROP_IS_INVALID, { prop: "genesisBlock", ...a });
        const h = this.registerChainCertificateHelper.decode(p);
        await this.registerChainCertificateHelper.verifyRegisterChainCertificate(h);
        const { bnid: f, magic: g, assetType: d, chainName: y } = h.body.genesisBlockInfo;
        if (g === r.magic) throw new gn(c.SHOULD_NOT_BE, { to_compare_prop: `magic ${g}`, to_target: "genesisBlockJson.asset.genesisAsset", be_compare_prop: r.magic, ...a });
        if (d === r.assetType) throw new gn(c.SHOULD_NOT_BE, { to_compare_prop: `assetType ${d}`, to_target: "genesisBlockJson.asset.genesisAsset", be_compare_prop: r.assetType, ...a });
        if (y === r.chainName) throw new gn(c.SHOULD_NOT_BE, { to_compare_prop: `chainName ${y}`, to_target: "genesisBlockJson.asset.genesisAsset", be_compare_prop: r.chainName, ...a });
        if (r.initials !== f) throw new gn(c.NOT_MATCH, { to_compare_prop: `initials ${r.initials}`, be_compare_prop: `bnid ${f}`, to_target: "config", be_target: "genesisBlockJson.asset.genesisBlock", ...n });
      }
      init(e, t) {
        return Ia.fromObject({ ...e, asset: t });
      }
      async applyTransaction(e, t, r = this.configHelper) {
        const n = new RA();
        n.next = super.applyTransaction(e, t, r);
        const { senderId: s, senderPublicKeyBuffer: o } = e, a = e.asset.registerChain.genesisBlock, p = this.registerChainCertificateHelper.decode(a);
        return n.next = t.emit("frozenAccount", { type: "frozenAccount", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, accountStatus: 16 } }), n.next = t.emit("registerChain", { type: "registerChain", transaction: e, applyInfo: { address: s, publicKeyBuffer: o, genesisBlock: p.body.genesisBlockInfo } }), n.toPromise();
      }
    };
    tu = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, Eh, xr])], tu);
    const { ArgumentIllegalException: Bn } = ee("CONTROLLER", "MultipleTransactionFactory");
    let yl = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), e.recipientId) throw new Bn(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Bn(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Bn(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.storage) throw new Bn(c.SHOULD_NOT_EXIST, { prop: "storage", ...n });
        const s = t.multiple;
        if (!s) throw new Bn(c.PARAM_LOST, { param: "multiple" });
        const o = { ...n, target: "multiple" }, { transactions: a } = s;
        if (!a) throw new Bn(c.PROP_IS_REQUIRE, { prop: "transactions", ...o });
        if (a.length === 0) throw new Bn(c.PROP_LENGTH_SHOULD_GT_FIELD, { prop: "transactions", field: 0, ...o });
        const p = /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ new Set(), { GRAB_ANY: g, GRAB_ASSET: d, SIGN_FOR_ASSET: y, MULTIPLE: _, PROMISE_RESOLVE: I, MACRO_CALL: S } = this.transactionHelper, w = (N) => {
          if (p.has(N.signature)) throw new Bn(c.SHOULD_NOT_DUPLICATE, { prop: `transactions ${N.signature}`, ...o });
          switch (N.type) {
            case d: {
              const B = `${N.senderId}-${N.storageValue}`;
              if (h.has(B)) throw new Bn(c.SHOULD_NOT_DUPLICATE, { prop: `transactions ${B}`, ...o });
              h.add(B);
              break;
            }
            case g: {
              const B = `${N.senderId}-${N.storageValue}`;
              if (h.has(B)) throw new Bn(c.SHOULD_NOT_DUPLICATE, { prop: `transactions ${B}`, ...o });
              h.add(B);
              break;
            }
            case y: {
              const B = `${N.senderId}-${N.storageValue}`;
              if (f.has(B)) throw new Bn(c.SHOULD_NOT_DUPLICATE, { prop: `transactions ${B}`, ...o });
              f.add(B);
              break;
            }
            case _: {
              const B = N.asset.multiple.transactions;
              for (const O of B) w(O);
              break;
            }
            case I: {
              w(N.asset.resolve.transaction);
              break;
            }
            case S: {
              w(N.asset.call.transaction);
              break;
            }
          }
          p.add(N.signature);
        };
        for (const N of a) {
          w(N);
          const B = this.transactionCore.getTransactionFactoryFromType(N.type), O = await B.fromJSON(N);
          await B.verify(O);
        }
      }
      init(e, t) {
        return Sa.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        return "0";
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], yl.prototype, "transactionCore", void 0);
    yl = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], yl);
    const { ArgumentIllegalException: Qo } = ee("CONTROLLER", "PromiseTransactionFactory");
    let ml = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), !e.recipientId) throw new Qo(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new Qo(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new Qo(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.storage) throw new Qo(c.SHOULD_NOT_EXIST, { prop: "storage", ...n });
        const s = t.promise;
        if (!s) throw new Qo(c.PARAM_LOST, { param: "promise" });
        const o = { ...n, target: "promise" }, { transaction: a } = s;
        if (!a) throw new Qo(c.PROP_IS_REQUIRE, { prop: "transaction", ...o });
        const p = this.transactionCore.getTransactionFactoryFromType(a.type), h = await p.fromJSON(a);
        await p.verify(h);
      }
      init(e, t) {
        return no.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        return "0";
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], ml.prototype, "transactionCore", void 0);
    ml = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], ml);
    const { ArgumentIllegalException: ts } = ee("CONTROLLER", "PromiseResolveTransactionFactory");
    let _l = class extends Ge {
      constructor(e, t, r, n, s) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), !e.recipientId) throw new ts(c.PROP_IS_REQUIRE, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new ts(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new ts(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new ts(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const s = e.storage;
        if (s.key !== "promiseId") throw new ts(c.SHOULD_BE, { to_compare_prop: `storage.key ${s.key}`, to_target: "storage", be_compare_prop: "promiseId", ...n });
        const o = t.resolve;
        if (!o) throw new ts(c.PARAM_LOST, { param: "resolve" });
        const a = { ...n, target: "resolve" }, { promiseId: p, transaction: h } = o;
        if (!p) throw new ts(c.PROP_IS_REQUIRE, { prop: "promiseId", ...a });
        if (this.baseHelper.isValidSignature(p) === false) throw new ts(c.PROP_IS_INVALID, { prop: `promiseId ${p}`, ...a });
        if (!h) throw new ts(c.PROP_IS_REQUIRE, { prop: "transaction", ...a });
        const f = await this.transactionCore.recombineTransaction(h);
        if (await this.transactionCore.getTransactionFactoryFromType(f.type).verify(f), s.value !== p) throw new ts(c.NOT_MATCH, { to_compare_prop: `storage.value ${s.value}`, be_compare_prop: `promiseId ${p}`, to_target: "storage", be_target: "resolve", ...n });
      }
      init(e, t) {
        return ba.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r), n.next = t.emit("promiseResolve", { type: "promiseResolve", transaction: e, applyInfo: { promiseId: e.asset.resolve.promiseId, recipientId: e.recipientId } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        return "0";
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], _l.prototype, "transactionCore", void 0);
    _l = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve])], _l);
    const { ArgumentIllegalException: lt } = ee("CONTROLLER", "MacrotionFactory");
    let Al = class extends Ge {
      constructor(e, t, r, n, s, o) {
        super(), this.accountBaseHelper = e, this.transactionHelper = t, this.baseHelper = r, this.configHelper = n, this.chainAssetInfoHelper = s, this.jsbiHelper = o;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), e.recipientId) throw new lt(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new lt(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new lt(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.storage) throw new lt(c.SHOULD_NOT_EXIST, { prop: "storage", ...n });
        const s = t.macro;
        if (!s) throw new lt(c.PARAM_LOST, { param: "macro" });
        const o = { ...n, target: "macro" }, { inputs: a, template: p } = s, h = p instanceof Je ? p.toJSON() : p;
        if (!a) throw new lt(c.PROP_IS_REQUIRE, { prop: "inputs", ...o });
        if (!h) throw new lt(c.PROP_IS_REQUIRE, { prop: "template", ...o });
        const f = this.transactionCore.getTransactionFactoryFromType(h.type), g = await f.fromJSON(h);
        await f.verify(g);
        const d = this.baseHelper, y = /* @__PURE__ */ new Set(), _ = /* @__PURE__ */ new Set();
        for (const I of a) {
          const { type: S, name: w, keyPath: N, pattern: B } = I;
          if (!w) throw new lt(c.PROP_IS_REQUIRE, { prop: "name", target: `macro.inputs.input ${JSON.stringify(I)}` });
          if (B) try {
            new RegExp(B);
          } catch {
            throw new lt(c.PROP_IS_INVALID, { prop: "pattern", target: `macro.inputs.input ${JSON.stringify(I)}` });
          }
          if (d.isValidMacroInputName(w) === false) throw new lt(c.PROP_IS_REQUIRE, { prop: "name", target: `macro.inputs.input ${JSON.stringify(I)}` });
          if (y.has(w)) throw new lt(c.SHOULD_NOT_DUPLICATE, { prop: `name ${w}`, target: `macro.inputs.input ${JSON.stringify(I)}` });
          if (y.add(w), !N) throw new lt(c.PROP_IS_REQUIRE, { prop: "keyPath", target: `macro.inputs.input ${JSON.stringify(I)}` });
          if (_.has(N)) throw new lt(c.SHOULD_NOT_DUPLICATE, { prop: `keyPath ${N}`, target: `macro.inputs.input ${JSON.stringify(I)}` });
          if (_.add(N), !S) throw new lt(c.PROP_IS_REQUIRE, { prop: "type", target: `macro.inputs.input ${JSON.stringify(I)}` });
          if (N.includes(".")) {
            let O = h;
            const P = N.split("."), C = P.pop();
            for (const V of P) {
              if (O.hasOwnProperty(V) === false) throw new lt(c.NOT_EXIST, { prop: `keyPath ${N}`, target: "macro.template" });
              O = O[V];
            }
            if (O.hasOwnProperty(C) === false) throw new lt(c.NOT_EXIST, { prop: `keyPath ${N}`, target: "macro.template" });
          } else if (h.hasOwnProperty(N) === false) throw new lt(c.NOT_EXIST, { prop: `keyPath ${N}`, target: "macro.template" });
          if (S === kt.NUMBER || S === kt.CALC) {
            const { base: O, min: P, max: C, step: V, format: F } = I;
            if (F === void 0) throw new lt(c.PROP_IS_REQUIRE, { prop: "format", target: `macro.inputs.input ${JSON.stringify(I)}` });
            if (F !== Na.LITERAL && F !== Na.STRING) throw new lt(c.PROP_IS_INVALID, { prop: `format ${F}`, target: `macro.inputs.input ${JSON.stringify(I)}` });
            if (O && d.isPositiveBigFloatContainZero(O) === false) throw new lt(c.PROP_IS_INVALID, { prop: "base", target: `macro.inputs.input ${JSON.stringify(I)}` });
            if (P && d.isPositiveBigFloatContainZero(P) === false) throw new lt(c.PROP_IS_INVALID, { prop: "min", target: `macro.inputs.input ${JSON.stringify(I)}` });
            if (C) {
              if (d.isPositiveBigFloatContainZero(C) === false) throw new lt(c.PROP_IS_INVALID, { prop: "max", target: `macro.inputs.input ${JSON.stringify(I)}` });
              if (O && this.jsbiHelper.compareFraction(C, O) === -1) throw new lt(c.PROP_SHOULD_LTE_FIELD, { prop: "base", target: `macro.inputs.input ${JSON.stringify(I)}`, field: JSON.stringify(C) });
            }
            if (V) {
              if (d.isPositiveBigFloatContainZero(V) === false) throw new lt(c.PROP_IS_INVALID, { prop: "step", target: `macro.inputs.input ${JSON.stringify(I)}` });
              if (this.jsbiHelper.compareFraction(V, { numerator: "0", denominator: "1" }) < 1) throw new lt(c.PROP_SHOULD_GT_FIELD, { prop: "step", target: `macro.inputs.input ${JSON.stringify(I)}`, field: "0" });
            }
            if (S === kt.CALC) {
              const { calc: K } = I;
              if (K === void 0) throw new lt(c.PROP_IS_REQUIRE, { prop: "calc", target: `macro.inputs.input ${JSON.stringify(I)}` });
            }
          } else if (!(S === kt.TEXT || S === kt.ADDRESS || S === kt.PUBLICKEY || S === kt.SIGNATURE)) throw new lt(c.PROP_IS_INVALID, { prop: `type ${S}`, target: `macro.inputs.input ${JSON.stringify(I)}` });
        }
      }
      init(e, t) {
        return oo.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        return "0";
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], Al.prototype, "transactionCore", void 0);
    Al = l([J(), u("design:paramtypes", [me, Ee, Be, ne, ve, xt])], Al);
    const { ArgumentIllegalException: It } = ee("CONTROLLER", "MacroCallTransactionFactory");
    let El = class extends Ge {
      constructor(e, t, r, n, s, o, a) {
        super(), this.accountBaseHelper = e, this.asymmetricHelper = t, this.transactionHelper = r, this.baseHelper = n, this.configHelper = s, this.chainAssetInfoHelper = o, this.jsbiHelper = a;
      }
      trySet(e, t, r) {
        let n;
        if (t.includes(".")) {
          const s = t.split(".");
          n = s.pop();
          for (const o of s) {
            if (e.hasOwnProperty(o) === false) return false;
            e = e[o];
          }
        } else n = t;
        return e.hasOwnProperty(n) === false ? false : (e[n] = r, true);
      }
      parseToMacroCallInputs(e) {
        return Object.fromEntries(Object.entries(e).map((t) => [t[0], JSON.stringify(t[1])]));
      }
      async generateTransactionWithJsonInput(e, t, r, n = true) {
        return await this.generateTransaction(e, t, this.parseToMacroCallInputs(r), n);
      }
      async generateTransaction(e, t, r, n = true) {
        const s = new X_(r), o = this.baseHelper, a = e.toJSON();
        for (const h of t) {
          const { name: f, pattern: g, repeat: d } = h;
          let y = s.get(f);
          const _ = async (I) => {
            if (typeof I !== "string") throw new It(c.PROP_IS_INVALID, { prop: `${h.name} ${I}`, target: "inputs" });
            if (g && new RegExp(g).test(I) === false) throw new It(c.NOT_MATCH, { to_compare_prop: `${f} ${I}`, to_target: "inputs", be_compare_prop: `pattern ${g}`, be_target: "defineInput" });
            switch (h.type) {
              case kt.ADDRESS:
                if (await this.accountBaseHelper.isAddress(I) === false) throw new It(c.NOT_MATCH, { to_compare_prop: `${f} ${I}`, to_target: "inputs", be_compare_prop: "pattern chain address", be_target: "defineInput" });
                break;
              case kt.PUBLICKEY:
                if (this.baseHelper.isValidPublicKey(I) === false) throw new It(c.NOT_MATCH, { to_compare_prop: `${f} ${I}`, to_target: "inputs", be_compare_prop: "pattern chain publicKey", be_target: "defineInput" });
                break;
              case kt.SIGNATURE:
                if (this.transactionHelper.isValidTransactionSignature(I) === false) throw new It(c.NOT_MATCH, { to_compare_prop: `${f} ${I}`, to_target: "inputs", be_compare_prop: "pattern chain signature", be_target: "defineInput" });
                break;
              case kt.TEXT:
                break;
              case kt.CALC:
                I = wA(h.calc, s.toObject());
              case kt.NUMBER: {
                if (I.includes(".")) {
                  const O = I.split(".");
                  if (BigInt(O[1]) === BigInt(0)) throw new It(c.SHOULD_BE, { to_compare_prop: `name ${f}(${I})`, to_target: "inputs", be_compare_prop: O[0] });
                }
                const S = h.base || { numerator: "0", denominator: "1" };
                let w = this.jsbiHelper.toFraction(I);
                if (h.min && this.jsbiHelper.compareFraction(h.min, w) === 1) throw new It(c.PROP_SHOULD_GTE_FIELD, { prop: `name ${f} ${I}`, target: "inputs", field: JSON.stringify(h.min) });
                if (h.max && this.jsbiHelper.compareFraction(h.max, w) === -1) throw new It(c.PROP_SHOULD_LTE_FIELD, { prop: `name ${f} ${I}`, target: "inputs", field: JSON.stringify(h.max) });
                w = this.jsbiHelper.minusFraction(w, S);
                const N = h.step || { numerator: "1", denominator: "1" }, B = this.jsbiHelper.divisionFractionAndCeil(w, N);
                if (this.jsbiHelper.compareFraction(w, this.jsbiHelper.multiplyFraction({ numerator: B, denominator: BigInt(1) }, N)) !== 0) throw new It(c.SHOULD_BE, { to_compare_prop: `name ${f}(${I})'s step`, to_target: "inputs", be_compare_prop: JSON.stringify(h.step) });
                h.format === Na.LITERAL && (I = Number(I));
                break;
              }
            }
            return I;
          };
          if (d) {
            if (o.isArray(y) === false) throw new It(c.PROP_IS_INVALID, { prop: `${h.name}(repeat ${d}) ${y}`, target: "inputs" });
            const I = [];
            for (const S of y) I.push(await _(S));
            if (this.trySet(a, h.keyPath, I) === false) throw new It(c.PROP_IS_INVALID, { prop: `name ${f}`, target: "inputs" });
          } else {
            const I = await _(y);
            if (this.trySet(a, h.keyPath, I) === false) throw new It(c.PROP_IS_INVALID, { prop: `name ${f}`, target: "inputs" });
          }
        }
        const p = await this.transactionCore.recombineTransaction(a);
        for (const h of t) if (h.type === kt.NUMBER) {
          const f = h.keyPath.split(".");
          let g = a, d = p;
          for (const y of f) g = g[y], d = d[y];
          if (g.toString() !== d.toString()) throw new It(c.PROP_IS_INVALID, { prop: `${h.name} ${g}`, target: "inputs" });
        }
        return n === false && await this.transactionCore.getTransactionFactoryFromType(p.type).verify(p, this.configHelper), p;
      }
      async signTransaction(e, t, r) {
        const n = await this.transactionCore.recombineTransaction(e.toJSON()), { accountBaseHelper: s, asymmetricHelper: o } = this, a = await s.createSecretKeypair(t);
        n.signatureBuffer = await o.detachedSign(n.getBytes(true, true), a.secretKey);
        let p;
        return r && (p = await s.createSecondSecretKeypair(t, r), n.signSignatureBuffer = await o.detachedSign(n.getBytes(false, true), p.secretKey), await this.transactionHelper.verifyTransactionSignature(n)), n;
      }
      async verifyTransactionBody(e, t, r = this.configHelper) {
        await super.verifyTransactionBody(e, t, r);
        const n = { target: "body" };
        if (this.emptyRangeType(e, n), e.recipientId) throw new It(c.SHOULD_NOT_EXIST, { prop: "recipientId", ...n });
        if (e.fromMagic !== r.magic) throw new It(c.SHOULD_BE, { to_compare_prop: `fromMagic ${e.fromMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (e.toMagic !== r.magic) throw new It(c.SHOULD_BE, { to_compare_prop: `toMagic ${e.toMagic}`, to_target: "body", be_compare_prop: "local chain magic", ...n });
        if (!e.storage) throw new It(c.PROP_IS_REQUIRE, { prop: "storage", ...n });
        const s = e.storage;
        if (s.key !== "macroId") throw new It(c.SHOULD_BE, { to_compare_prop: `storage.key ${s.key}`, to_target: "storage", be_compare_prop: "macroId", ...n });
        const o = t.call;
        if (!o) throw new It(c.PARAM_LOST, { param: "call" });
        const a = { ...n, target: "call" }, { macroId: p, inputs: h, transaction: f } = o;
        if (!p) throw new It(c.PROP_IS_REQUIRE, { prop: "macroId", ...a });
        if (!this.baseHelper.isValidSignature(p)) throw new It(c.PROP_IS_INVALID, { prop: `macroId ${p}`, type: "transaction signature", ...a });
        if (!h) throw new It(c.PROP_IS_REQUIRE, { prop: "inputs", ...a });
        if (!f) throw new It(c.PROP_IS_REQUIRE, { prop: "transaction", ...a });
        const g = await this.transactionCore.recombineTransaction(f);
        if (await this.transactionCore.getTransactionFactoryFromType(g.type).verify(g), s.value !== p) throw new It(c.NOT_MATCH, { to_compare_prop: `storage.value ${s.value}`, be_compare_prop: `macroId ${p}`, to_target: "storage", be_target: "call", ...n });
      }
      init(e, t) {
        return Oa.fromObject({ ...e, asset: t });
      }
      applyTransaction(e, t, r = this.configHelper) {
        return $e((n) => {
          n.next = super.applyTransaction(e, t, r);
          const { macroId: s, inputs: o } = e.asset.call;
          n.next = t.emit("macroCall", { type: "macroCall", transaction: e, applyInfo: { macroId: s, inputs: o } });
        });
      }
      getMoveAmount(e, t = { magic: this.configHelper.magic, assetType: this.configHelper.assetType }) {
        return "0";
      }
    };
    l([D("bfchain-core:TransactionCore", { dynamics: true }), u("design:type", $t)], El.prototype, "transactionCore", void 0);
    El = l([J(), u("design:paramtypes", [me, Or, Ee, Be, ne, ve, xt])], El);
    Mr.VF.set(v.REGISTER_CHAIN, tu);
    Mr.FV.set(tu, v.REGISTER_CHAIN);
    Mr.VF.set(v.MULTIPLE, yl);
    Mr.FV.set(yl, v.MULTIPLE);
    Mr.VF.set(v.PROMISE, ml);
    Mr.FV.set(ml, v.PROMISE);
    Mr.VF.set(v.PROMISE_RESOLVE, _l);
    Mr.FV.set(_l, v.PROMISE_RESOLVE);
    Mr.VF.set(v.MACRO, Al);
    Mr.FV.set(Al, v.MACRO);
    Mr.VF.set(v.MACRO_CALL, El);
    Mr.FV.set(El, v.MACRO_CALL);
    const uf = class extends Yt {
      constructor() {
        super(), this._startTime = Date.now(), this._sleepTime = 0, this.onFinished(() => this.clearTimeout());
      }
      get sleepTime() {
        return this._sleepTime;
      }
      get endTime() {
        return this._startTime + this._sleepTime;
      }
      setTimeout(e, t) {
        this.clearTimeout(), this._startTime = Date.now(), this._sleepTi = bs(this._sleepTime = e, t);
      }
      clearTimeout() {
        this._sleepTi && (CA(this._sleepTi), this._sleepTime = 0, this._sleepTi = void 0);
      }
    };
    let ti;
    let __;
    let A_;
    let E_;
    const { ArgumentIllegalException: ye, ArgumentFormatException: Ot, TimeOutException: P0 } = ee("channel", "chainChannelHelper");
    let Fe = ti = class {
      constructor(e, t, r, n, s) {
        this.baseHelper = e, this.transctionHelper = t, this.blockHelper = r, this.timeHelper = n, this.accountBaseHelper = s;
      }
      async boxQueryTransactionArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = ao.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (V) {
          throw new Ot(c.INVALID_PARAMS, { error: V, params: e });
        }
        const r = this.baseHelper, { type: n, types: s, signature: o, senderId: a, recipientId: p, dappid: h, lns: f, storage: g, blockSignature: d, minHeight: y, maxHeight: _, trusteeId: I, purchaseDAppid: S, range: w, offset: N, limit: B, address: O } = t.query;
        let P = false;
        if (n && (P = true, !r.isValidTransactionType(n))) throw new ye(c.INVALID_PARAMS_FIELD, { field: `type ${n}` });
        if (s) {
          P = true;
          for (const V of s) if (!r.isValidTransactionType(V)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `types.type ${V}` });
        }
        if (o && (P = true, o.length !== ti.MAX_SIGNATURE_LENGTH)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `signature ${o}` });
        if (a && (P = true, a.length > ti.MAX_ADDRESS_LENGTH)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `senderId ${a}` });
        if (p && (P = true, p.length > ti.MAX_ADDRESS_LENGTH)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `recipientId ${p}` });
        if (O && (P = true, O.length > ti.MAX_ADDRESS_LENGTH)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `address ${O}` });
        if (h && (P = true, !r.isValidDAppId(h))) throw new ye(c.INVALID_PARAMS_FIELD, { field: `dappid ${h}` });
        if (f && (P = true, !r.isValidLocationName(f))) throw new ye(c.INVALID_PARAMS_FIELD, { field: `lns ${f}` });
        if (g) {
          if (P = true, !(g.key && g.key.length)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `storage.key ${g.key}` });
          if (!(g.value && g.value.length)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `storage.value ${g.value}` });
        }
        if (d && (P = true, d.length !== ti.MAX_SIGNATURE_LENGTH)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `blockSignature ${d}` });
        if (y !== void 0 && (P = true, !r.isUint32(y))) throw new ye(c.INVALID_PARAMS_FIELD, { field: `minHeight ${y}` });
        if (_ !== void 0 && (P = true, !r.isUint32(_))) throw new ye(c.INVALID_PARAMS_FIELD, { field: `maxHeight ${_}` });
        if (I && (P = true, I.length > ti.MAX_ADDRESS_LENGTH)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `trusteeId ${I}` });
        if (S && (P = true, !r.isValidDAppId(S))) throw new ye(c.INVALID_PARAMS_FIELD, { field: `purchaseDAppid ${S}` });
        if (w && (P = true, !r.isString(w))) throw new ye(c.INVALID_PARAMS_FIELD, { field: `range ${w}` });
        if (P === false) throw new ye("Invalid QueryTransaction query params, no query conditions");
        if (!r.isUint32(N)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `offset ${N}` });
        if (B && !r.isUint32(B)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `limit ${B}` });
        const { tIndex: C } = t.sort;
        if (C !== void 0 && C !== -1 && C !== 1) throw new ye(c.INVALID_PARAMS_FIELD, { field: `tIndex ${C}` });
        return t;
      }
      async boxQueryTransactionReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = Pa.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (r) {
          throw new Ot(c.INVALID_PARAMS, { error: r, params: e });
        }
        if (t.status === Ne.success) {
          const { transactions: r } = t;
          for (const n of r) await this.transctionHelper.verifyTransactionSignature(n.transaction, { taskLabel: "QueryTransactionReturn" });
        }
        return t;
      }
      get boxIndexTransactionArg() {
        return this.boxQueryTransactionArg;
      }
      async boxIndexTransactionReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = Ha.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (r) {
          throw new Ot(c.INVALID_PARAMS, { error: r, params: e });
        }
        return t;
      }
      async boxDownloadTransactionArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = il.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (s) {
          throw s instanceof qe ? s : new Ot(c.INVALID_PARAMS, { error: s, params: e });
        }
        const { tIndexes: r } = t;
        if (r.length === 0) throw new ye("Invalid Download transaction query params, no query conditions");
        const n = this.baseHelper;
        for (const s of r) {
          const { height: o, tIndex: a, length: p } = s;
          if (!n.isPositiveInteger(o)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `height ${o}` });
          if (!n.isNaturalNumber(a)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `tIndex ${a}` });
          if (!n.isPositiveInteger(p)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `length ${p}` });
        }
        return t;
      }
      async boxDownloadTransactionReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = va.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (r) {
          throw new Ot(c.INVALID_PARAMS, { error: r, params: e });
        }
        if (t.status === Ne.success) {
          const { transactions: r } = t;
          for (const n of r) await this.transctionHelper.verifyTransactionSignature(n.transaction, { taskLabel: "DownloadTransactionReturn" });
        }
        return t;
      }
      async boxNewTransactionArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = nl.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (n) {
          throw n instanceof qe ? n : new Ot(c.INVALID_PARAMS, { error: n, params: e });
        }
        const { transaction: r } = t;
        return await this.transctionHelper.verifyTransactionSignature(r, { taskLabel: "NewTransactionArg" }), t;
      }
      boxNewTransactionReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = gs.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (r) {
          throw new Ot(c.INVALID_PARAMS, { error: r, params: e });
        }
        if (t.status === Ne.success && (Number.isNaN(parseFloat(t.minFee)) || BigInt(t.minFee) < BigInt(0))) throw new ye(c.INVALID_PARAMS_FIELD, { field: "minFee" });
        return t;
      }
      async boxOpenBlobArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = Ii.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (n) {
          throw n instanceof qe ? n : new Ot(c.INVALID_PARAMS, { error: n, params: e });
        }
        const { hash: r } = t;
        if (r === void 0 || r.length !== 64) throw new ye("Invalid Open Blob query params, wrong sha256 value");
        return t;
      }
      async boxOpenBlobReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = Ti.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (r) {
          throw new Ot(c.INVALID_PARAMS, { error: r, params: e });
        }
        return t;
      }
      async boxCloseBlobArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = ka.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (r) {
          throw r instanceof qe ? r : new Ot(c.INVALID_PARAMS, { error: r, params: e });
        }
        return t;
      }
      async boxCloseBlobReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = ol.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (r) {
          throw new Ot(c.INVALID_PARAMS, { error: r, params: e });
        }
        return t;
      }
      async boxReadBlobArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = ks.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (s) {
          throw s instanceof qe ? s : new Ot(c.INVALID_PARAMS, { error: s, params: e });
        }
        const { start: r, end: n } = t;
        if (r < 0 || r >= n) throw new ye("Invalid Read Blob range");
        return t;
      }
      async boxReadBlobReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = po.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (r) {
          throw new Ot(c.INVALID_PARAMS, { error: r, params: e });
        }
        return t;
      }
      boxQueryBlockArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = Da.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (a) {
          throw new Ot(c.INVALID_PARAMS, { error: a, params: e });
        }
        const r = this.baseHelper, { height: n, signature: s } = t.query;
        let o = false;
        if (n && (o = true, !r.isUint32(n))) throw new ye(c.INVALID_PARAMS_FIELD, { field: "height" });
        if (s && (o = true, !r.isValidBlockSignature(s))) throw new ye(c.INVALID_PARAMS_FIELD, { field: "signature" });
        if (o === false) throw new ye(c.INVALID_QUERYBLOCKARG_QUERY_PARAMS);
        return t;
      }
      async boxQueryBlockReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = Fa.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (n) {
          throw new Ot(c.INVALID_PARAMS, { error: n, params: e });
        }
        const { someBlock: r } = t;
        return t.status === Ne.success && r && await this.blockHelper.verifyBlockSignature(r.block, { taskLabel: "QueryBlockReturn" }), t;
      }
      boxNewBlockArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        let t;
        try {
          t = Ur.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (n) {
          throw new Ot(c.INVALID_PARAMS, { error: n, params: e });
        }
        const r = this.baseHelper;
        if (!r.isUint32(t.height)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `height ${t.height}` });
        if (!r.isValidBlockSignature(t.signature)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `signature ${t.signature}` });
        if (!r.isValidBlockSignature(t.previousBlockSignature)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `previousBlockSignature ${t.previousBlockSignature}` });
        if (!r.isFiniteBigInt(t.totalFee)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `totalFee ${t.totalFee}` });
        if (!r.isUint32(t.numberOfTransactions)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `numberOfTransactions ${t.numberOfTransactions}` });
        if (!r.isUint32(t.timestamp)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `timestamp ${t.timestamp}` });
        if (!r.isValidPublicKey(t.generatorPublicKeyBuffer)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `generatorPublicKey ${t.generatorPublicKey}` });
        if (!r.isUint32(t.version)) throw new ye(c.INVALID_PARAMS_FIELD, { field: `version ${t.version}` });
        return t;
      }
      boxNewBlockReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        try {
          return $a.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (t) {
          throw new Ot(c.INVALID_PARAMS, { error: t, params: e });
        }
      }
      boxGetPeerInfoArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        try {
          return al.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (t) {
          throw new Ot(c.INVALID_PARAMS, { error: t, params: e });
        }
      }
      boxGetPeerInfoReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { params: e });
        try {
          return Ua.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (t) {
          throw new Ot(c.INVALID_PARAMS, { error: t, params: e });
        }
      }
      async boxQueryTindexArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { function: "boxQueryTindexArg", params: e });
        let t;
        try {
          t = tl.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (C) {
          throw new Ot(c.INVALID_PARAMS, { function: "boxQueryTindexArg", error: C, params: e });
        }
        const r = this.baseHelper, { type: n, signature: s, senderId: o, recipientId: a, dappid: p, lns: h, storage: f, blockSignature: g, minHeight: d, maxHeight: y, trusteeId: _, purchaseDAppid: I, range: S, address: w, offset: N, limit: B } = t.query;
        let O = false;
        if (n && (O = true, !r.isValidTransactionType(n))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg", field: `type ${n}` });
        if (s && (O = true, !r.isValidTransactionSignature(s))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `signature ${s}` });
        if (o && (O = true, !await this.accountBaseHelper.isAddress(o))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `senderId ${o}` });
        if (a && (O = true, !await this.accountBaseHelper.isAddress(a))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `recipientId ${a}` });
        if (p && (O = true, !r.isValidDAppId(p))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `dappid ${p}` });
        if (h && (O = true, !r.isValidLocationName(h))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `lns ${h}` });
        if (f) {
          if (O = true, !(f.key && f.key.length)) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `storage.key ${f.key}` });
          if (!(f.value && f.value.length)) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `storage.value ${f.value}` });
        }
        if (g && (O = true, !r.isValidBlockSignature(g))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `blockSignature ${g}` });
        if (d !== void 0 && (O = true, !r.isUint32(d))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `minHeight ${d}` });
        if (y !== void 0 && (O = true, !r.isUint32(y))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `maxHeight ${y}` });
        if (_ && (O = true, !await this.accountBaseHelper.isAddress(_))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `trusteeId ${_}` });
        if (I && (O = true, !r.isValidDAppId(I))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `purchaseDAppid ${I}` });
        if (S && (O = true, !r.isString(S))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `range ${S}` });
        if (w && (O = true, !await this.accountBaseHelper.isAddress(w))) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `address ${w}` });
        if (O === false) throw new ye("Invalid QueryTransaction query params, no query conditions");
        if (!r.isUint32(N)) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `offset ${N}` });
        if (B && !r.isUint32(B)) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.query", field: `limit ${B}` });
        const { tIndex: P } = t.sort;
        if (P !== void 0 && P !== -1 && P !== 1) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexArg.sort", field: `tIndex ${P}` });
        return t;
      }
      async boxQueryTindexReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { function: "boxQueryTindexesReturn", params: e });
        let t;
        try {
          t = Ma.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (r) {
          throw new Ot(c.INVALID_PARAMS, { function: "boxQueryTindexesReturn", error: r, params: e });
        }
        if (t.status === Ne.success) {
          const r = t.tIndexes, n = this.baseHelper;
          for (const s of r) if (!n.isNaturalNumber(s)) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxQueryTindexesReturn", field: `tIndexes ${s}` });
        }
        return t;
      }
      async boxGetTransactionInBlockArg(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { function: "boxGetTransactionInBlockArg", params: e });
        let t;
        try {
          t = rl.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (n) {
          throw new Ot(c.INVALID_PARAMS, { function: "boxGetTransactionInBlockArg", error: n, params: e });
        }
        if (!this.baseHelper.isValidTindexRanges(t.query.tIndexRanges)) throw new ye(c.INVALID_PARAMS_FIELD, { function: "boxGetTransactionInBlockArg.query.tIndexRanges", field: `tIndexRanges ${t.query.tIndexRanges}` });
        return t;
      }
      async boxGetTransactionInBlockReturn(e) {
        if (!(e instanceof ArrayBuffer || e instanceof Uint8Array)) throw new ye(c.INVALID_PARAMS, { function: "boxGetTransactionInBlockReturn", params: e });
        let t;
        try {
          t = La.decode(e instanceof Uint8Array ? e : new Uint8Array(e));
        } catch (r) {
          throw new Ot(c.INVALID_PARAMS, { function: "boxGetTransactionInBlockReturn", error: r, params: e });
        }
        if (t.status === Ne.success) {
          const { transactionInBlocks: r } = t;
          r.forEach(async (n) => {
            await this.transctionHelper.verifyTransactionSignature(n.transaction, { taskLabel: "GetTransactionInBlockReturn" });
          });
        }
        return t;
      }
      parserAborterOptions(e, t) {
        if (e.disabledAborterOptions) return;
        let r;
        e.aborter && (r || (r = new uf()), this._bindRejectedToPromiseOut(e.aborter.abortedPromise, r));
        let n;
        if (e.timeout !== void 0 && (n = typeof e.timeout === "function" ? e.timeout(t) : e.timeout), e.deadlineTime !== void 0) {
          const s = this.timeHelper.now(), o = e.deadlineTime - s;
          n ? o < n && (n = o) : n = o;
        }
        if (n !== void 0) {
          const { reject: s } = r || (r = new uf());
          r.setTimeout(n, () => s(typeof e.timeoutException === "function" ? e.timeoutException(t) : e.timeoutException || new P0()));
        }
        return e.rejected && (r || (r = new uf()), this._bindRejectedToPromiseOut(e.rejected, r)), r;
      }
      _bindRejectedToPromiseOut(e, t) {
        Ui(e, void 0, t.reject), t.onFinished(() => th(e, void 0, t.reject));
      }
      wrapAborterOptions(e, t, r) {
        const n = t && this.parserAborterOptions(t, r);
        return n && (e.then(n.resolve, n.reject), e = n.promise), e;
      }
      wrapOutAborterOptions(e, t, r) {
        const n = t && this.parserAborterOptions(t, r);
        return n && (Ui(e.promise, n.resolve, n.reject), Ui(n.promise, e.resolve, e.reject), e = n), e;
      }
      getChainChannelTimeout(e, t = 3e4) {
        return Math.max(Number.isFinite(e.delay) ? e.delay : 1e3, 2e3) + t;
      }
      verifyDownloadBlobArgs(e) {
        const { algorithm: t, hash: r, downloadSize: n } = e;
        if (!Number.isInteger(n)) throw new ye(c.INVALID_PARAMS_FIELD, { function: "openArg.downloadSize", field: `openArg.downloadSize ${n}` });
        if (n <= 0) throw new ye(c.INVALID_PARAMS_FIELD, { function: "openArg.downloadSize", field: `openArg.downloadSize ${n}` });
      }
    };
    Fe.MAX_ADDRESS_LENGTH = 40;
    Fe.MAX_SIGNATURE_LENGTH = 128;
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxQueryTransactionArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxQueryTransactionReturn", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Fe.prototype, "boxIndexTransactionArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxIndexTransactionReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxDownloadTransactionReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxNewTransactionArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", void 0)], Fe.prototype, "boxNewTransactionReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxOpenBlobArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxOpenBlobReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxCloseBlobArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxCloseBlobReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxReadBlobArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxReadBlobReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Da)], Fe.prototype, "boxQueryBlockArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxQueryBlockReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Ur)], Fe.prototype, "boxNewBlockArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", $a)], Fe.prototype, "boxNewBlockReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", al)], Fe.prototype, "boxGetPeerInfoArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Ua)], Fe.prototype, "boxGetPeerInfoReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxQueryTindexArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxQueryTindexReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxGetTransactionInBlockArg", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", Promise)], Fe.prototype, "boxGetTransactionInBlockReturn", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object, typeof (__ = typeof ENV < "u" && ENV) === "function" ? __ : Object]), u("design:returntype", void 0)], Fe.prototype, "parserAborterOptions", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Promise, Object, typeof (A_ = typeof ENV < "u" && ENV) === "function" ? A_ : Object]), u("design:returntype", void 0)], Fe.prototype, "wrapAborterOptions", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Yt, Object, typeof (E_ = typeof ENV < "u" && ENV) === "function" ? E_ : Object]), u("design:returntype", void 0)], Fe.prototype, "wrapOutAborterOptions", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object, Object]), u("design:returntype", void 0)], Fe.prototype, "getChainChannelTimeout", null);
    Fe = ti = l([J(), u("design:paramtypes", [Be, Ee, dt, Ft, me])], Fe);
    const { RefuseException: kr, ArgumentFormatException: I_, NoFoundException: DA, error: M0, TimeOutException: Wg, success: T_, log: S_ } = ee("channel", "chainChannel");
    const FA = class extends xA {
      toBlockGetterHelper(e) {
        return this._blockGetterHelper || (this._blockGetterHelper = { getBlockByHeight: (t) => this.findBlock({ height: t }), getBlockBySignature: (t) => this.findBlock({ signature: t }), maxHeight: 1, lastBlock: ro.fromObject(this.config.genesisBlock), async getLastBlock() {
          if (this.lastBlock.height !== this.maxHeight) {
            const t = await this.getBlockByHeight(this.maxHeight);
            if (!t) throw new DA();
            this.lastBlock = t;
          }
          return this.lastBlock;
        } }), e && (this.baseHelper.isPositiveFloatNotContainZero(e.maxHeight) && (this._blockGetterHelper.maxHeight = e.maxHeight), e.lastBlock && (this._blockGetterHelper.lastBlock = e.lastBlock)), this._blockGetterHelper;
      }
    };
    const Ts = /* @__PURE__ */ new Map();
    const w_ = new Uint32Array(1);
    const L0 = () => {
      const i = w_[0]++ || w_[0]++, e = Ts.get(i);
      return e && (e.reject(new Wg(c.REQID_REUSE)), Ts.delete(i)), i;
    };
    const yc = /* @__PURE__ */ new Map([[Ie.QUERY_TRANSACTION, Ie.QUERY_TRANSACTION_RETURN], [Ie.INDEX_TRANSACTION, Ie.INDEX_TRANSACTION_RETURN], [Ie.DOWNLOAD_TRANSACTION, Ie.DOWNLOAD_TRANSACTION_RETURN], [Ie.NEW_TRANSACTION, Ie.NEW_TRANSACTION_RETURN], [Ie.QUERY_BLOCK, Ie.QUERY_BLOCK_RETURN], [Ie.NEW_BLOCK, Ie.NEW_BLOCK_RETURN], [Ie.GET_PEER_INFO, Ie.GET_PEER_INFO_RETURN], [Ie.OPEN_BLOB, Ie.OPEN_BLOB_RETURN], [Ie.READ_BLOB, Ie.READ_BLOB_RETURN], [Ie.CLOSE_BLOB, Ie.CLOSE_BLOB_RETURN]]);
    const H0 = 2;
    let Us = class extends FA {
      constructor(e, t = 1e3) {
        super(), this.endpoint = e, this.refuseTime = t, this._canQueryTindex = false, this._canGetTransactionInBlock = false, this._limitQT = 100, this._limitIT = 100, this._limitDT = 100, this.MESSAGE_VERSION = 2, this._closed = false, this._maybeHeight = 1, this._lastConsensusVersion = 1, this._address = "", this._delayHistroyList = new Float32Array(32), this._reqIdSet = /* @__PURE__ */ new Set(), this.reqresLimitInfoEM = wt.from({ creater(r) {
          return { preResponseTime: 0, preRefuseTime: 0, preResponseLimitConfig: { lockTimespan: 0, refuseTimespan: 1 / 0 } };
        } }), this._msgPostQuene = wt.from({ creater: (r) => {
          const n = { taskList: [], running: false, looper: async () => {
            if (!n.running) {
              n.running = true;
              do {
                const s = n.taskList.shift();
                if (s === void 0) break;
                const o = this.reqresLimitInfoEM.get(r);
                if (o !== void 0) {
                  const h = o.preResponseTime + o.preResponseLimitConfig.lockTimespan - this.timeHelper.now();
                  h > 0 && (S_("req chainChannel(%s) cmd:%d need wait %dms", this.address, s.cmd, h), await bs(h));
                }
                if (s.sign.is_rejected) continue;
                const a = Zr.fromObject({ version: this.config.version, req_id: s.req_id, cmd: s.cmd, binary: s.binary, messageVersion: this.MESSAGE_VERSION });
                this.endpoint.postMessage(a.getBytes(), self.location.origin), s.sign.resolve();
                const p = Ts.get(s.req_id);
                p && await new Promise((h) => p.onFinished(h));
              } while (n.taskList.length > 0);
              this._msgPostQuene.delete(r);
            }
          } };
          return n;
        } }), this._openedBlobs = /* @__PURE__ */ new Set(), this._busyNewTransaction = 0, this.initOnMessage(), e.onClose(() => {
          this._closed = true;
          for (const r of this._reqIdSet) {
            const n = Ts.get(r);
            n && (n.reject(new Wg(c.CHAINCHANNEL_CLOSED)), Ts.delete(r));
          }
          this._reqIdSet.clear();
        });
      }
      get canQueryTransactions() {
        return false;
      }
      get canIndexTransactions() {
        return false;
      }
      get canDownloadTransactions() {
        return true;
      }
      get blobSupportAlgorithms() {
        return [];
      }
      get canQueryBlock() {
        return true;
      }
      get canBroadcastTransaction() {
        return true;
      }
      get canBroadcastBlock() {
        return true;
      }
      get canQueryTindex() {
        return this._canQueryTindex;
      }
      get canGetTransactionInBlock() {
        return this._canGetTransactionInBlock;
      }
      get limitQueryTransactions() {
        return this._limitQT;
      }
      get limitIndexTransactions() {
        return this._limitIT;
      }
      get limitDownloadTransactions() {
        return this._limitDT;
      }
      get defaultReqOptions() {
      }
      get diffTime() {
        return 0;
      }
      onClose(e, t) {
        if (t) {
          const r = this.endpoint.onClose((n) => {
            e(n), r();
          });
          return r;
        } else return this.endpoint.onClose(e);
      }
      close(e) {
        return this.endpoint.close(e);
      }
      get maybeHeight() {
        return this._maybeHeight;
      }
      get lastConsensusVersion() {
        return this._lastConsensusVersion;
      }
      get address() {
        return this._address;
      }
      set address(e) {
        this._address = e;
      }
      get delay() {
        if (this._delayCache) return this._delayCache.value;
        const { _delayHistroyList: e } = this;
        let t = 0, r = e.length;
        for (let s = 0; s < e.length; s += 1) {
          const o = e[s];
          o ? t += o : r -= 1;
        }
        const n = t / r || 0;
        return this._delayCache = { value: n }, n;
      }
      pushDelayHistroy(e) {
        const { _delayHistroyList: t } = this, r = t.length;
        t.set(t.subarray(1, r), 0), t[r - 1] = e, this._delayCache = void 0;
      }
      _request(e, t, r, n) {
        return this._requestWithBinaryData(e, this._requestDataToBinary(t), r, n);
      }
      _requestDataToBinary(e) {
        return new Uint8Array(e.constructor.encode(e).finish());
      }
      _sendWithBinaryData(e, t) {
        return this.postChainChannelMessage(0, e, t);
      }
      async _requestWithBinaryData(e, t, r, n = this.defaultReqOptions) {
        const s = L0();
        this._reqIdSet.add(s), await this.postChainChannelMessage(s, e, t);
        let o = new Yt();
        o.onFinished(() => {
          Ts.delete(s), this._reqIdSet.delete(s);
        }), Ts.set(s, o), n && (n.timeout || (n.timeout = 1e3), n.timeoutException === void 0 && (n = Object.create(n, { timeoutException: { get() {
          return new Wg(c.CHAINCHANNEL_TIMEOUT, { endpoint: this.endpoint, cmd: Ie[e] });
        } } })), o = this.chainChannelHelper.wrapOutAborterOptions(o, n, { chainChannel: this }));
        const a = await r(await o.promise);
        return await this.emit("afterRequestWithBinaryData", { cmd: e, query: t, res: a }), a;
      }
      _getMaybeQueneTimeCache() {
        let e = this._maybeQueneTimeFastCache;
        return e === void 0 && (e = this._maybeQueneTimeFastCache = { cache: /* @__PURE__ */ new Map(), releaser: queueMicrotask(() => this._maybeQueneTimeFastCache = void 0) }), e.cache;
      }
      getApiMaybeQueueTime(e) {
        if (!(e & Ie.RESPONSE)) return 0;
        const t = this._getMaybeQueneTimeCache();
        let r = t.get(e);
        if (r === void 0) {
          const n = this.reqresLimitInfoEM.get(e);
          if (n === void 0) r = 0;
          else {
            const s = n.preResponseTime + n.preResponseLimitConfig.lockTimespan, o = Math.max(0, s - this.timeHelper.now()), a = this._msgPostQuene.get(e);
            a === void 0 ? r = o : r = a.taskList.length * n.preResponseLimitConfig.lockTimespan + o;
          }
          t.set(e, r);
        }
        return r;
      }
      async postChainChannelMessage(e, t, r) {
        if (this._closed) return;
        let n = 0, s = 0;
        if (yc.has(t)) {
          if (this.reqresLimitInfoEM.get(t) !== void 0) {
            const p = this._msgPostQuene.forceGet(t), h = new Yt();
            return p.taskList.push({ req_id: e, cmd: t, binary: r, sign: h }), p.looper(), h.promise;
          }
        } else if (t & Ie.RESPONSE && this.has("onGetResponseLimitConfig")) {
          let a = this.reqresLimitInfoEM.get(t);
          const p = this.timeHelper.now();
          if (a) {
            const f = a.preResponseLimitConfig;
            (a.preResponseTime || p) + f.lockTimespan < p && (a = void 0);
          }
          const h = await this.emit("onGetResponseLimitConfig", { cmd: t, requestLimitInfo: a });
          h !== void 0 && (a = a || this.reqresLimitInfoEM.forceGet(t), a.preResponseTime = p, a.preResponseLimitConfig = h, n = h.lockTimespan, s = h.refuseTimespan);
        }
        const o = Zr.fromObject({ version: this.config.version, req_id: e, cmd: t, binary: r, lockTimespan: n, refuseTimespan: s, messageVersion: this.MESSAGE_VERSION });
        return this.endpoint.postMessage(o.getBytes(), self.location.origin);
      }
      async queryTransactions(e, t, r) {
        if (!this.canQueryTransactions) return Pa.fromObject({ status: Ne.error, error: St.fromObject(new kr(c.REFUSE_RESPONSE_QUERY_TRANSACTION)) });
        const n = ao.fromObject({ query: it.fromObject(e), sort: qr.fromObject(t || {}) }), s = await this._request(Ie.QUERY_TRANSACTION, n, this.chainChannelHelper.boxQueryTransactionReturn, r);
        return await this._downloadBlobFromTibs(s.transactions), s;
      }
      async indexTransactions(e, t, r) {
        if (!this.canIndexTransactions) return Ha.fromObject({ status: Ne.error, error: St.fromObject(new kr(c.REFUSE_RESPONSE_INDEX_TRANSACTION)) });
        const n = sl.fromObject({ query: it.fromObject(e), sort: qr.fromObject(t || {}) });
        return this._request(Ie.INDEX_TRANSACTION, n, this.chainChannelHelper.boxIndexTransactionReturn, r);
      }
      async downloadTransactions(e, t) {
        if (!this.canDownloadTransactions) return va.fromObject({ status: Ne.error, error: St.fromObject(new kr(c.REFUSE_RESPONSE_DOWNLOAD_TRANSACTION)) });
        const r = il.fromObject({ tIndexes: e.map((s) => ds.fromObject(s)) }), n = await this._request(Ie.DOWNLOAD_TRANSACTION, r, this.chainChannelHelper.boxDownloadTransactionReturn, t);
        return await this._downloadBlobFromTibs(n.transactions), n;
      }
      async openBlob(e, t) {
        if (!this.blobSupportAlgorithms.includes(e.algorithm)) return Ti.fromObject({ status: Ne.error, error: St.fromObject(new kr(c.REFUSE_RESPONSE_OPEN_BLOB)) });
        const r = Ii.fromObject(e), n = await this._request(Ie.OPEN_BLOB, r, this.chainChannelHelper.boxOpenBlobReturn, t);
        return n.descriptor && this._openedBlobs.add(n.descriptor), n;
      }
      async readBlob(e, t) {
        if (this._openedBlobs.has(e.descriptor) === false) return po.fromObject({ status: Ne.error, error: St.fromObject(new kr(c.REFUSE_RESPONSE_READ_BLOB)) });
        const r = ks.fromObject(e);
        return this._request(Ie.READ_BLOB, r, this.chainChannelHelper.boxReadBlobReturn, t);
      }
      async closeBlob(e, t) {
        if (this._openedBlobs.has(e.descriptor) === false) return ol.fromObject({ status: Ne.error, error: St.fromObject(new kr(c.REFUSE_RESPONSE_CLOSE_BLOB)) });
        const r = ka.fromObject(e), n = await this._request(Ie.CLOSE_BLOB, r, this.chainChannelHelper.boxCloseBlobReturn, t);
        return n.status === Ne.success && this._openedBlobs.delete(e.descriptor), n;
      }
      async downloadBlob(e) {
        this.chainChannelHelper.verifyDownloadBlobArgs(e);
        const t = { totalSize: -1, totalCount: -1, currentCount: -1 };
        if (await this.blobHelper.exists(e)) return;
        let r;
        try {
          const n = await this.openBlob(e);
          if (n.status === Ne.busy && await bs(5e3), n.status !== Ne.success) throw n.error;
          r = n.descriptor;
          const s = e.downloadSize;
          let o = 1024 * 1024;
          o = o < s ? o : s;
          const a = await this.blobHelper.requestStorage(e, s, o, n.contentType, 0), p = Math.ceil(s / o), h = s - (p - 1) * o;
          t.totalSize = s, t.totalCount = p, t.currentCount = 0;
          const f = [];
          for (let _ = 0; _ < p; _++) f.push(async () => {
            let I = 0, S = false, w = 0;
            for (; I < 3; ) try {
              const N = o * _, B = await this.readBlob({ descriptor: r, start: N, end: _ === p - 1 ? N + h : N + o });
              if (B.status === Ne.busy || B.status !== Ne.success) throw B;
              if (w = B.chunkBuffer.length, w === 0) break;
              await this.blobHelper.saveChunk(a, _, B.chunkBuffer), S = true;
              break;
            } catch (N) {
              if (I++, I >= 3) throw N;
              await bs(100);
            }
            return { isSuccess: S, bytesRead: w };
          });
          let g = 0, d = true, y = 0;
          e: for (; ; ) {
            const _ = f.slice(g, g + 3);
            if (_.length === 0) break;
            const I = await Promise.all(_.map((S) => S()));
            for (const S of I) {
              if (S.isSuccess === false) {
                d = false;
                break e;
              }
              y += S.bytesRead;
            }
            g += _.length;
          }
          if (!d) throw new kr(c.FAIL_TO_DOWNLOAD_BLOB, { hash: e.hash, size: s });
          if (y !== s) throw new kr(c.NOT_MATCH, { to_compare_prop: `downloadSize ${y}`, to_target: "real downloaded", be_compare_prop: `downloadSize ${s}`, be_target: "transaction blob" });
          await this.blobHelper.saveAsBlob(a);
        } finally {
          if (r !== void 0) try {
            await this.closeBlob({ descriptor: r });
          } catch {
          }
        }
      }
      async _downloadBlobFromTibs(e) {
        for (const t of e) await this.downloadBlobFromTrs(t.transaction);
      }
      async downloadBlobFromTrs(e) {
        for (const [r, n, s, o] of e.blobMap.values()) await this.downloadBlob({ algorithm: r, hash: n, downloadSize: o });
        const t = this.transactionCore.transactionHelper;
        switch (e.type) {
          case t.MACRO_CALL: {
            const { transaction: r } = e.asset.call;
            await this.downloadBlobFromTrs(r);
            break;
          }
          case t.PROMISE_RESOLVE: {
            const { transaction: r } = e.asset.resolve;
            await this.downloadBlobFromTrs(r);
            break;
          }
          case t.MULTIPLE: {
            const { transactions: r } = e.asset.multiple;
            for (const n of r) await this.downloadBlobFromTrs(n);
            break;
          }
        }
      }
      async initBroadcastTransactionArg(e, t) {
        const r = nl.fromObject({ transaction: e instanceof Y ? e : await this.transactionCore.recombineTransaction(e), grabSecret: t == null ? void 0 : t.grabSecret });
        return [Ie.NEW_TRANSACTION, this._requestDataToBinary(r), this.chainChannelHelper.boxNewTransactionReturn, t];
      }
      calcDiffTimeToTargetTime(e) {
        return this.timeHelper.now() + this.diffTime - e;
      }
      async broadcastTransaction(e, t) {
        if (!this.canBroadcastTransaction) return gs.fromObject({ status: Ne.error, error: St.fromObject(new kr(c.REFUSE_RESPONSE_BROADCAST_TRANSACTION)) });
        const r = await this.initBroadcastTransactionArg(e, t), n = -this.calcDiffTimeToTargetTime(this.timeHelper.getTimeByTimestamp(e.timestamp));
        n > 0 && (S_("chainChannel(%s) seems in feature. need wait %dms then broadcast.", this.address, n), await bs(n));
        const s = await this._requestWithBinaryData(...r);
        return T_("broadcasted Transaction(%s)", this.transactionCore.transactionHelper.getTypeName(e.type), e.asset), s;
      }
      get isRefusePushNewTransaction() {
        return this.canBroadcastTransaction ? this._busyNewTransaction > this.timeHelper.now() - this.refuseTime : true;
      }
      async fastBroadcastTransaction(e) {
        if (this.isRefusePushNewTransaction) return 0;
        const t = await this.initBroadcastTransactionArg(e);
        return await this._sendWithBinaryData(t[0], t[1]), 1;
      }
      async queryBlock(e, t) {
        if (!this.canQueryBlock) return Fa.fromObject({ status: Ne.error, error: St.fromObject(new kr(c.REFUSE_RESPONSE_QUERY_BLOCK)) });
        const r = Da.fromObject({ query: lo.fromObject(e) });
        return this._request(Ie.QUERY_BLOCK, r, this.chainChannelHelper.boxQueryBlockReturn, t);
      }
      async findBlock(e, t) {
        const r = await this.queryBlock(e, t);
        return r.someBlock && r.someBlock.block;
      }
      initBroadcastBlockArg(e, t) {
        const r = Ur.fromObject(e);
        return r.generatorPublicKey = e.generatorPublicKey, [Ie.NEW_BLOCK, this._requestDataToBinary(r), this.chainChannelHelper.boxNewBlockReturn, t];
      }
      async broadcastBlock(e, t) {
        if (!this.canBroadcastBlock) return $a.fromObject({ status: Ne.error, error: St.fromObject(new kr(c.REFUSE_RESPONSE_BROADCAST_BLOCK)) });
        const r = await this._requestWithBinaryData(...this.initBroadcastBlockArg(e, t));
        return T_("broadcasted block:", e.height), r;
      }
      async queryTindexes(e, t, r) {
        if (!this.canQueryTindex) return Ma.fromObject({ status: Ne.error, error: St.fromObject(new kr("Refuse response query transaction index")) });
        const n = ao.fromObject({ query: it.fromObject(e), sort: qr.fromObject(t || {}) });
        return this._request(Ie.QUERY_TINDEX, n, this.chainChannelHelper.boxQueryTindexReturn, r);
      }
      async queryTransactionInBlocks(e, t) {
        if (!this.canGetTransactionInBlock) return La.fromObject({ status: Ne.error, error: St.fromObject(new kr("Refuse response query transactionInBlock")) });
        const r = rl.fromObject({ query: co.fromObject(e) });
        return this._request(Ie.GET_TRANSACTIONINBLOCK, r, this.chainChannelHelper.boxGetTransactionInBlockReturn, t);
      }
      initOnMessage() {
        this.endpoint.onMessage(async (e) => {
          try {
            let t, r, n, s, o;
            try {
              s = Zr.decode(e), t = s.req_id, r = s.cmd, n = s.binary, o = s.messageVersion;
            } catch {
              throw new I_(c.MESSAGE_TYPE_ERROR);
            }
            if (o < H0) return;
            let a, p;
            const h = (f, g) => (f.status = Ne.error, f.error = St.fromException(g), f);
            try {
              let f = true;
              if (yc.has(r)) {
                const g = r | Ie.RESPONSE, d = this.reqresLimitInfoEM.get(g), y = this.timeHelper.now();
                let _ = 0;
                if (d) {
                  const I = y - d.preResponseTime;
                  I < d.preResponseLimitConfig.lockTimespan && (d.preResponseLimitConfig.lockTimespan - I > d.preResponseLimitConfig.refuseTimespan ? _ = 2 : _ = 1);
                }
                if (this.has("onBreakRequestLimit")) {
                  const I = await this.emit("onBreakRequestLimit", { cmd: r, requestLimitStrategy: _, requestLimitInfo: d });
                  I !== void 0 && (_ = I.requestLimitStrategy);
                }
                if (_ === 2) {
                  d && (d.preRefuseTime = y), await this.postChainChannelMessage(t, Ie.REFUSE, new Uint8Array(0));
                  return;
                }
                _ === 1 && (f = false);
              } else if (r & Ie.RESPONSE) {
                const g = r - Ie.RESPONSE;
                let d = this.reqresLimitInfoEM.get(g);
                const { lockTimespan: y, refuseTimespan: _ } = s, I = y !== 0 || _ !== 0;
                d === void 0 ? I && (d = this.reqresLimitInfoEM.forceGet(g), d.preResponseTime = this.timeHelper.now(), d.preResponseLimitConfig = { lockTimespan: y, refuseTimespan: _ }) : I === false ? this.reqresLimitInfoEM.delete(g) : (d.preResponseTime = this.timeHelper.now(), d.preResponseLimitConfig = { lockTimespan: y, refuseTimespan: _ });
              }
              switch (r) {
                case Ie.QUERY_TRANSACTION: {
                  if (f && this.has("onQueryTransactionBinary")) {
                    p = await this.emit("onQueryTransactionBinary", await this.chainChannelHelper.boxQueryTransactionArg(n));
                    break;
                  }
                  const g = Pa.fromObject({ status: Ne.busy }), d = f && this.has("onQueryTransaction") ? await this.emit("onQueryTransaction", await this.chainChannelHelper.boxQueryTransactionArg(n)) : void 0;
                  d && (g.status = Ne.success, g.transactions = d.transactions.map((y) => qt.fromObject(y))), a = g;
                  break;
                }
                case Ie.INDEX_TRANSACTION: {
                  if (f && this.has("onIndexTransactionBinary")) {
                    p = await this.emit("onIndexTransactionBinary", await this.chainChannelHelper.boxIndexTransactionArg(n));
                    break;
                  }
                  const g = Ha.fromObject({ status: Ne.busy }), d = f && this.has("onQueryTransaction") ? await this.emit("onIndexTransaction", await this.chainChannelHelper.boxIndexTransactionArg(n)) : void 0;
                  d && (g.status = Ne.success, g.tIndexes = d.tIndexes.map((y) => ds.fromObject(y))), a = g;
                  break;
                }
                case Ie.DOWNLOAD_TRANSACTION: {
                  if (f && this.has("onDownloadTransactionBinary")) {
                    p = await this.emit("onDownloadTransactionBinary", await this.chainChannelHelper.boxDownloadTransactionArg(n));
                    break;
                  }
                  const g = va.fromObject({ status: Ne.busy }), d = f && this.has("onDownloadTransaction") ? await this.emit("onDownloadTransaction", await this.chainChannelHelper.boxDownloadTransactionArg(n)) : void 0;
                  d && (g.status = Ne.success, g.transactions = d.transactions.map((y) => qt.fromObject(y))), a = g;
                  break;
                }
                case Ie.NEW_TRANSACTION: {
                  const g = gs.fromObject({ status: Ne.busy }), d = this.has("onNewTransaction") ? await this.emit("onNewTransaction", await this.chainChannelHelper.boxNewTransactionArg(n)) : void 0;
                  d && (g.status = Ne.success, g.minFee = d.minFee, g.newTrsStatus = d.newTrsStatus, g.refuseReason = d.refuseReason, g.errorCode = d.errorCode, g.errorMessage = d.errorMessage), a = g;
                  break;
                }
                case Ie.OPEN_BLOB: {
                  const g = Ti.fromObject({ status: Ne.busy }), d = await this.chainChannelHelper.boxOpenBlobArg(n), y = this.has("onOpenBlob") ? await this.emit("onOpenBlob", d) : await this.blobHelper.open(d);
                  y && (g.status = Ne.success, g.descriptor = y.descriptor, g.contentType = y.contentType), a = g;
                  break;
                }
                case Ie.READ_BLOB: {
                  const g = po.fromObject({ status: Ne.busy }), d = await this.chainChannelHelper.boxReadBlobArg(n), y = this.has("onReadBlob") ? await this.emit("onReadBlob", d) : await this.blobHelper.read(d);
                  y && (g.status = Ne.success, g.chunkBuffer = y.chunkBuffer), a = g;
                  break;
                }
                case Ie.CLOSE_BLOB: {
                  const g = ol.fromObject({ status: Ne.busy }), d = await this.chainChannelHelper.boxCloseBlobArg(n);
                  (this.has("onCloseBlob") ? await this.emit("onCloseBlob", d) : await this.blobHelper.close(d)) && (g.status = Ne.success), a = g;
                  break;
                }
                case Ie.QUERY_BLOCK: {
                  if (f && this.has("onQueryBlockBinary")) {
                    p = await this.emit("onQueryBlockBinary", this.chainChannelHelper.boxQueryBlockArg(n));
                    break;
                  }
                  const g = Fa.fromObject({ status: Ne.busy }), d = f && this.has("onQueryBlock") ? await this.emit("onQueryBlock", this.chainChannelHelper.boxQueryBlockArg(n)) : void 0;
                  if (d && d.block !== void 0) {
                    g.status = Ne.success;
                    const y = d.block;
                    if (y) {
                      const _ = new Proxy(Nt.fromObject(y), { get(I, S, w) {
                        return S === "transactions" || S === "transactionBufferList" ? [] : Reflect.get(I, S, w);
                      } });
                      g.someBlock = mi.fromObject({ block: _ });
                    }
                  }
                  a = g;
                  break;
                }
                case Ie.NEW_BLOCK: {
                  const g = $a.fromObject({ status: Ne.busy }), d = this.chainChannelHelper.boxNewBlockArg(n);
                  this._maybeHeight = d.height, (this.has("onNewBlock") ? await this.emit("onNewBlock", d) : void 0) && (g.status = Ne.success), a = g;
                  break;
                }
                case Ie.GET_PEER_INFO: {
                  const g = Ua.fromObject({ status: Ne.busy }), d = this.has("onGetPeerInfo") ? await this.emit("onGetPeerInfo", this.chainChannelHelper.boxGetPeerInfoArg(n)) : void 0;
                  d && d.peerInfo && (g.status = Ne.success, g.peerInfo = on.fromObject(d.peerInfo)), a = g;
                  break;
                }
                case Ie.QUERY_TINDEX: {
                  const g = Ma.fromObject({ status: Ne.busy }), d = this.has("onQueryTindexes") ? await this.emit("onQueryTindexes", await this.chainChannelHelper.boxQueryTransactionArg(n)) : void 0;
                  d && (g.status = Ne.success, g.tIndexes = d.tIndexes), a = g;
                  break;
                }
                case Ie.GET_TRANSACTIONINBLOCK: {
                  const g = La.fromObject({ status: Ne.busy }), d = this.has("onGetTransactionInBlocks") ? await this.emit("onGetTransactionInBlocks", await this.chainChannelHelper.boxGetTransactionInBlockArg(n)) : void 0;
                  d && (g.status = Ne.success, g.transactionInBlocks = d.transactionInBlocks.map((y) => qt.fromObject(y))), a = g;
                  break;
                }
                case Ie.QUERY_TRANSACTION_RETURN:
                case Ie.INDEX_TRANSACTION_RETURN:
                case Ie.DOWNLOAD_TRANSACTION_RETURN:
                case Ie.NEW_TRANSACTION_RETURN:
                case Ie.QUERY_BLOCK_RETURN:
                case Ie.NEW_BLOCK_RETURN:
                case Ie.GET_PEER_INFO_RETURN:
                case Ie.OPEN_BLOB_RETURN:
                case Ie.READ_BLOB_RETURN:
                case Ie.CLOSE_BLOB_RETURN:
                case Ie.QUERY_TINDEX_RETURN:
                case Ie.GET_TRANSACTIONINBLOCK_RETURN:
                case Ie.RESPONSE: {
                  const g = Ts.get(t);
                  if (g === void 0) {
                    if (t !== 0) M0(new DA(c.ONMESSAGE_GET_INVALID_REQ_ID, { req_id: t }));
                    else if (r === Ie.NEW_TRANSACTION_RETURN) {
                      const { status: d } = this.chainChannelHelper.boxNewTransactionReturn(n);
                      d === Ne.busy && (this._busyNewTransaction = this.timeHelper.now());
                    }
                    return;
                  }
                  g.resolve(n);
                  break;
                }
                case Ie.REFUSE: {
                  const g = Ts.get(t);
                  if (g !== void 0) {
                    g.reject(new kr(c.REQUEST_LIMIT));
                    return;
                  }
                  this.close("chain channel refuse accpet data.");
                  return;
                }
                default:
                  throw new I_(c.INVALID_MESSAGE_CMD, { cmd: r });
              }
            } catch (f) {
              const g = h(er.fromObject({ status: Ne.error }), f);
              throw await this.postChainChannelMessage(t, yc.get(r) || Ie.RESPONSE, er.encode(g).finish()), f;
            }
            if (p) {
              await this.postChainChannelMessage(t, yc.get(r) || Ie.RESPONSE, p);
              return;
            }
            a && await this.postChainChannelMessage(t, yc.get(r) || Ie.RESPONSE, a.constructor.encode(a).finish());
          } catch (t) {
            this.emit("handleMessageError", { handleName: "onMessage", error: t });
          }
        });
      }
    };
    l([D("bfchain-core:TransactionCore"), u("design:type", Object)], Us.prototype, "transactionCore", void 0);
    l([D(ne), u("design:type", ne)], Us.prototype, "config", void 0);
    l([D(Be), u("design:type", Be)], Us.prototype, "baseHelper", void 0);
    l([D(Ft), u("design:type", Ft)], Us.prototype, "timeHelper", void 0);
    l([D(Fe), u("design:type", Fe)], Us.prototype, "chainChannelHelper", void 0);
    l([D(Si), u("design:type", Si)], Us.prototype, "blobHelper", void 0);
    Us = l([Oo(), be(0, D(ch.ENDPOINT)), be(1, D(ch.REFUSETIME, { optional: true })), u("design:paramtypes", [Object, Object])], Us);
    const v0 = class extends Yt {
      constructor(e) {
        super(), this.filter = e;
      }
      match(e) {
        return this.filter === void 0 || this.filter(e);
      }
    };
    const k0 = class {
      constructor() {
        this._queue = /* @__PURE__ */ new Set();
      }
      get size() {
        return this._queue.size;
      }
      enqueue(e) {
        const t = new v0(e);
        return this._queue.add(t), t;
      }
      dequeue(e) {
        for (const t of this._queue) if (t.match(e)) return t.resolve(e), this._queue.delete(t), t;
      }
    };
    let Xg;
    let qg;
    let Zg;
    let ed;
    let td;
    ee("channel", "chainChannelGroup");
    const Ml = class {
      constructor() {
        this._inQueneTaskMap = /* @__PURE__ */ new Map(), this._generateQueneTask = (e, t) => {
          const r = this._doRequest(e, t).then((n) => (r.resolved = r.finished = true, this._inQueneTaskMap.has(e) && this._retCCMap.set(n, e), n), (n) => {
            throw r.rejected = r.finished = true, this._inQueneTaskMap.has(e) && this._retCCMap.set(n, e), n;
          });
          return r;
        }, this._retCCMap = /* @__PURE__ */ new Map();
      }
      addChainChannel(e, t) {
        return this._inQueneTaskMap.has(e) || this._inQueneTaskMap.set(e, this._generateQueneTask(e, t)), this.helper.wrapAborterOptions(OA(this._inQueneTaskMap.values()), t, { chainChannel: e });
      }
      removeChainChannel(e) {
        return this._inQueneTaskMap.delete(e);
      }
      removeChainChannelByResult(e) {
        const t = this._retCCMap.get(e);
        return t ? this.removeChainChannel(t) : false;
      }
      getChainChannelByResult(e) {
        return this._retCCMap.get(e);
      }
      finish() {
        this._inQueneTaskMap.clear(), this._retCCMap.clear();
      }
    };
    const ru = { QUERY: /* @__PURE__ */ Symbol("query"), SORT: /* @__PURE__ */ Symbol("sort") };
    let nu = Xg = class extends Ml {
      constructor(e, t) {
        super(), this.query = e, this.sort = t;
      }
      _doRequest(e, t) {
        return e.queryTransactions(this.query, this.sort, t);
      }
      static create(e, t, r) {
        return bt(Xg, new ze([[ru.QUERY, t], [ru.SORT, r]], e));
      }
    };
    l([D(Fe), u("design:type", Fe)], nu.prototype, "helper", void 0);
    nu = Xg = l([Oo(), be(0, D(ru.QUERY)), be(1, D(ru.SORT, { optional: true })), u("design:paramtypes", [Object, Object])], nu);
    const su = { QUERY: /* @__PURE__ */ Symbol("query"), SORT: /* @__PURE__ */ Symbol("sort") };
    let iu = qg = class extends Ml {
      constructor(e, t) {
        super(), this.query = e, this.sort = t;
      }
      _doRequest(e, t) {
        return e.indexTransactions(this.query, this.sort, t);
      }
      static create(e, t, r) {
        return bt(qg, new ze([[su.QUERY, t], [su.SORT, r]], e));
      }
    };
    l([D(Fe), u("design:type", Fe)], iu.prototype, "helper", void 0);
    iu = qg = l([Oo(), be(0, D(su.QUERY)), be(1, D(su.SORT, { optional: true })), u("design:paramtypes", [Object, Object])], iu);
    const $A = { TINDEXES: /* @__PURE__ */ Symbol("tIndexes") };
    let ou = Zg = class extends Ml {
      constructor(e) {
        super(), this.tIndexes = e;
      }
      _doRequest(e, t) {
        return e.downloadTransactions(this.tIndexes, t);
      }
      static create(e, t) {
        return bt(Zg, new ze([[$A.TINDEXES, t]], e));
      }
    };
    l([D(Fe), u("design:type", Fe)], ou.prototype, "helper", void 0);
    ou = Zg = l([Oo(), be(0, D($A.TINDEXES)), u("design:paramtypes", [Array])], ou);
    const UA = { QUERY: /* @__PURE__ */ Symbol("query") };
    let au = ed = class extends Ml {
      constructor(e) {
        super(), this.query = e;
      }
      _doRequest(e, t) {
        return e.queryBlock(this.query, t);
      }
      getTimeoutExceptionInfo() {
        return ["[TIMEOUT]: queryBlock({query}).", { query: this.query }];
      }
      _getFinishInfo() {
        return { message: "finish queryBlock from other chainChannel" };
      }
      static create(e, t, r) {
        return bt(ed, new ze([[UA.QUERY, t]], e));
      }
    };
    l([D(Fe), u("design:type", Fe)], au.prototype, "helper", void 0);
    au = ed = l([Oo(), be(0, D(UA.QUERY)), u("design:paramtypes", [Object])], au);
    const VA = { QUERY: /* @__PURE__ */ Symbol("query") };
    let rd = td = class extends Ml {
      constructor(e) {
        super(), this.query = e;
      }
      _doRequest(e, t) {
        return e.queryTransactionInBlocks(this.query, t);
      }
      getTimeoutExceptionInfo() {
        return ["queryTransactionInBlocks({query} / {sort}) timeout.", { query: JSON.stringify(this.query) }];
      }
      _getFinishInfo() {
        return { message: "finish queryTransactionInBlocks from other chainChannel" };
      }
      static create(e, t, r) {
        return bt(td, new ze([[VA.QUERY, t]], e));
      }
    };
    l([D(Fe), u("design:type", Fe)], rd.prototype, "helper", void 0);
    rd = td = l([Oo(), be(0, D(VA.QUERY)), u("design:paramtypes", [Object])], rd);
    const { error: ff } = ee("channel", "IntSet");
    const D0 = class {
      constructor(e) {
        this._src = e, this._end = 1 / 0, this._maybeEnd = -1 / 0, this._srcIte = this._src[Symbol.iterator](), this._rl = [];
      }
      setEnd(e) {
        this._end = e, this._maybeEnd = e;
      }
      _previewSrcNext() {
        const e = this._cachedSrcNext || (this._cachedSrcNext = this._srcIte.next());
        if (e.done === false) return this._maybeEnd = e.value;
        this._end = this._maybeEnd;
      }
      _srcNext() {
        const e = this._previewSrcNext();
        return e !== void 0 && (this._cachedSrcNext = void 0), e;
      }
      getSerialRangeSet(e) {
        let t = -1 / 0, r = 0;
        const n = this._rl[Symbol.iterator]();
        let s = n.next();
        if (s.done === false) {
          if (t = s.value, r = 1, r >= e) return { start: t, length: r };
          delete this._rl[t];
          do {
            if (s = n.next(), s.done) break;
            const o = s.value;
            if (o - r === t) {
              if (delete this._rl[o], ++r, r >= e) return { start: t, length: r };
            } else return { start: t, length: r };
          } while (true);
        }
        if (t === -1 / 0) {
          const o = this._srcNext();
          if (o === void 0) return;
          if (t = o, r = 1, r >= e) return { start: t, length: r };
        }
        do {
          const o = this._previewSrcNext();
          if (o === void 0) return { start: t, length: r };
          if (o - r === t) {
            if (this._cachedSrcNext = void 0, ++r, r >= e) break;
          } else break;
        } while (true);
        return { start: t, length: r };
      }
      getRangeSet(e) {
        let t = 0;
        const r = [];
        do {
          const n = this.getSerialRangeSet(e);
          if (n === void 0 || (r[r.length] = n, t += n.length, t >= e)) break;
        } while (true);
        return r;
      }
      recycle(e) {
        if (Number.isInteger(e) === false) {
          ff("num:%o is not an integer", e);
          return;
        }
        const t = this._previewSrcNext();
        if (t !== void 0) {
          if (e > t) {
            ff("num:%d large then the next integer:%d", e, this._end);
            return;
          }
        } else if (e > this._end) {
          ff("num:%d large then the end:%d", e, this._end);
          return;
        }
        this.recycleUnSafe(e);
      }
      recycleUnSafe(e) {
        this._rl[e] = e;
      }
      recycleManyUnsafe(e) {
        for (const t of e) this._rl[t] = t;
      }
    };
    const { AbortException: Wl, InterruptedException: F0, error: Wo, success: b_, info: $0, warn: mc, log: N_, TimeOutException: Tc, IdempotentException: Xo } = ee("channel", "chainChannelGroup");
    const Oc = { GROUP_NAME: /* @__PURE__ */ Symbol("groupName"), CHANNEL_LIST: /* @__PURE__ */ Symbol("channelList"), OPTIONS: /* @__PURE__ */ Symbol("options") };
    let Ut = class extends FA {
      constructor(e, t = "", r) {
        super(), this.groupName = t, this._ccBlobSupportAlgorithms = wt.from({ creater: (n) => {
          const s = mn.from({ afterDelete: () => {
            s.size === 0 && this._ccBlobSupportAlgorithms.delete(n);
          } });
          return s;
        } }), this._initBlobSupportAlgorithmsBinding = false, this.chainChannelSet = /* @__PURE__ */ new Set(), this.options = {}, this._parallelTasksMap = /* @__PURE__ */ new Map(), this._workCountWM = new ss((n) => 0), this._DAWCLWM = /* @__PURE__ */ new WeakMap(), this._maybeHeight = 1, this._lastConsensusVersion = 1, r && Object.assign(this.options, r);
        for (const n of e) this.addChainChannel_(n, this.options);
      }
      get canQueryTransactions() {
        for (const e of this.chainChannelSet) if (e.canQueryTransactions) return true;
        return false;
      }
      get canIndexTransaction() {
        for (const e of this.chainChannelSet) if (e.canIndexTransactions) return true;
        return false;
      }
      get canDownloadTransaction() {
        for (const e of this.chainChannelSet) if (e.canDownloadTransactions) return true;
        return false;
      }
      get blobSupportAlgorithms() {
        let e;
        const t = this._ccBlobSupportAlgorithms;
        if (this._initBlobSupportAlgorithmsBinding === false) {
          this._initBlobSupportAlgorithmsBinding = true;
          for (const r of this.chainChannelSet) for (const n of r.blobSupportAlgorithms) t.forceGet(n).add(r);
          this._chainChannelEvents.on("addChainChannel", (r) => {
            for (const n of r.blobSupportAlgorithms) t.forceGet(n).add(r);
            this._blobSupportAlgorithms = void 0;
          }), this._chainChannelEvents.on("removeChainChannel", (r) => {
            for (const n of r.blobSupportAlgorithms) t.forceGet(n).delete(r);
            this._blobSupportAlgorithms = void 0;
          });
        }
        return (e = this._blobSupportAlgorithms) !== null && e !== void 0 ? e : this._blobSupportAlgorithms = [...t.keys()];
      }
      get canQueryBlock() {
        for (const e of this.chainChannelSet) if (e.canQueryBlock) return true;
        return false;
      }
      get canBroadcastTransaction() {
        for (const e of this.chainChannelSet) if (e.canBroadcastTransaction) return true;
        return false;
      }
      get canBroadcastBlock() {
        for (const e of this.chainChannelSet) if (e.canBroadcastBlock) return true;
        return false;
      }
      get limitQueryTransactions() {
        let e = 0;
        for (const t of this.chainChannelSet) {
          const { limitQueryTransactions: r } = t;
          r > e && (e = r);
        }
        return e;
      }
      get limitIndexTransactions() {
        let e = 0;
        for (const t of this.chainChannelSet) {
          const { limitIndexTransactions: r } = t;
          r > e && (e = r);
        }
        return e;
      }
      get limitDownloadTransactions() {
        let e = 0;
        for (const t of this.chainChannelSet) {
          const { limitDownloadTransactions: r } = t;
          r > e && (e = r);
        }
        return e;
      }
      getApiMaybeQueueTime(e) {
        let t = 1 / 0;
        for (let r of this.chainChannelSet) if (t = Math.min(r.getApiMaybeQueueTime(e), t), t === 0) break;
        return t;
      }
      get canQueryTindex() {
        for (const e of this.chainChannelSet) if (e.canQueryTindex) return true;
        return false;
      }
      get canGetTransactionInBlock() {
        for (const e of this.chainChannelSet) if (e.canGetTransactionInBlock) return true;
        return false;
      }
      bfOnInit() {
        let e = this._maybeHeight;
        for (const t of this.chainChannelSet) e = Math.max(t.maybeHeight, e);
        this._tryChangeMaybeHeight(e);
      }
      bfAfterInit() {
        this._initMaybeHeightWatcher();
      }
      get size() {
        return this.chainChannelSet.size;
      }
      forEach(e) {
        let t = 0;
        for (const r of this.chainChannelSet) e(r, t++);
      }
      include(e) {
        return this.chainChannelSet.has(e);
      }
      [Symbol.iterator]() {
        return this.chainChannelSet[Symbol.iterator]();
      }
      $requestParallelTask(e, t = {}) {
        let r = this._parallelTasksMap.get(e);
        if (r) return r;
        const { channelFirewall: n = () => true, abortWhenNoChainChannel: s } = t, o = this._workCountWM, { taskResponseCmd: a } = t, p = a !== void 0 ? (C, V) => C.delay * o.forceGet(C) + C.getApiMaybeQueueTime(a) - (V.delay * o.forceGet(V) + V.getApiMaybeQueueTime(a)) : (C, V) => C.delay * o.forceGet(C) - V.delay * o.forceGet(V), h = new Set([...this.chainChannelSet.values()].filter(n).toSorted(p)), f = /* @__PURE__ */ new Set(), g = new k0(), d = /* @__PURE__ */ new Set(), y = () => h.size > 0, _ = (C = {}) => {
          if (s && this.size === 0) throw new Wl(c.TASK_ABORT, { task_id: e });
          const V = C == null ? void 0 : C.filter;
          for (const K of h) if (V === void 0 || V(K)) return K;
          const F = g.enqueue(V);
          return N(), F.promise;
        }, I = (C) => (o.set(C, o.forceGet(C) - 1), f.delete(C) ? (B(C), true) : false), S = (C) => (o.set(C, o.forceGet(C) + 1), f.has(C) ? false : (f.add(C), h.delete(C), N(), true)), w = async (C = {}, V) => {
          const { autoFreeChainChannel: F = true } = C, K = await _(C);
          S(K);
          const L = { chainChannel: K, autoFreeChainChannel: F };
          try {
            return await V(L);
          } finally {
            L.autoFreeChainChannel && I(K);
          }
        }, N = () => {
          const C = 5e3 - Math.min(g.size / f.size, 1) * 4e3;
          if (f.size > d.size) {
            const V = bs(C, () => {
              d.delete(V);
              for (const F of h) if (g.dequeue(F) !== void 0) return;
              if (f.size !== 0) {
                let F = Math.floor(f.size * Math.random());
                for (const K of f) F-- <= 0 && I(K);
              }
            });
            d.add(V);
          }
        }, B = (C) => {
          if (n(C) !== true) return;
          g.dequeue(C) === void 0 && h.add(C);
        };
        this.onAddChainChannel(B);
        const O = (C) => {
          f.delete(C), h.delete(C), o.delete(C), N();
        };
        return this.onRemoveChainChannel(O), r = { freeChainChannels: h, busyChainChannels: f, chainChannelWaiterQueue: g, tiTasks: d, onDestroy: () => {
          h.clear(), f.clear();
          for (const C of d) CA(C);
          d.clear(), this.offAddChainChannel(B), this.offRemoveChainChannel(O);
        }, helpers: { hasFreeChainChannel: y, getFreeChainChannel: _, freeChainChannel: I, busyChainChannel: S, requestChainChannel: w }, refs: /* @__PURE__ */ new Set() }, this._parallelTasksMap.set(e, r), r;
      }
      $startParallelTask(e, t = {}) {
        return this.$requestParallelTask(e, t).helpers;
      }
      $releaseParallelTask(e) {
        const t = this._parallelTasksMap.get(e);
        if (!t) return false;
        this._parallelTasksMap.delete(e), t.onDestroy();
      }
      async wrapParallelTask(e, t = "unknowParallelTask", r = {}) {
        const n = this.$requestParallelTask(t, r);
        n.refs.add(e);
        try {
          return await e(n.helpers);
        } finally {
          n.refs.delete(e), n.refs.size === 0 && this.$releaseParallelTask(t);
        }
      }
      wrapCbParallelTask(e, t = "unknowParallelTask", r = {}) {
        const n = this.$requestParallelTask(t, r);
        return n.refs.add(e), e(n.helpers, () => {
          n.refs.delete(e), n.refs.size === 0 && this.$releaseParallelTask(t);
        });
      }
      async *wrapAgParallelTask(e, t = "unknowParallelTask", r = {}) {
        const n = this.$requestParallelTask(t, r);
        n.refs.add(e);
        try {
          return yield* e(n.helpers);
        } finally {
          n.refs.delete(e), n.refs.size === 0 && this.$releaseParallelTask(t);
        }
      }
      queryTransactionsVerbose(e, t, r, n) {
        const { offset: s, limit: o, ...a } = e, p = a.signature ? 1 : o || 1 / 0, h = `Group(${this.groupName}) queryTransactions-${Date.now() + Math.random()}`, f = (r == null ? void 0 : r.channelFilter) || (() => true), { requestChainChannel: g } = this.$startParallelTask(h, { channelFirewall: (O) => O.canQueryTransactions && f(O), abortWhenNoChainChannel: r == null ? void 0 : r.abortWhenNoChainChannel, taskResponseCmd: Ie.QUERY_TRANSACTION_RETURN });
        let d = () => true;
        {
          const O = e.maxHeight;
          typeof O === "number" && (d = (P) => P.maybeHeight >= O);
        }
        const y = r && this.helper.parserAborterOptions(r, { channelGroup: this }), _ = n || new Sr(), I = y && y.promise;
        if (I) {
          Ui(I, void 0, _.reject);
          const O = (P, C) => (th(I, void 0, _.reject), C());
          _.on("done", O), _.on("error", O);
        }
        const S = { timeout: (O, P) => `peer(${P.address}) queryTransactions(<offset:${O.data.offset},limit:${O.data.limit}>) timeout.
[query:]${JSON.stringify(O.requester.query)}
[sort:]${JSON.stringify(O.requester.sort)}` }, w = wt.from({ transformKey: (O) => `${O.offset}-${O.limit}`, creater: (O) => {
          const P = nu.create(this.moduleMap, { ...a, ...O }, t);
          return { requester: P, options: new Cc(S, O, P, this.helper.getChainChannelTimeout, y) };
        } }), B = (r == null ? void 0 : r.queryUnitLength) || (o ? Math.ceil(o / (this.chainChannelSet.size || 1)) : 100);
        return (async () => {
          let O = Promise.resolve(), P = p + s;
          const C = ($) => {
            P = $, F();
          };
          let V;
          const F = () => {
            V && (V.resolve(), V = void 0);
          };
          let K = -1;
          _.on("requestAll", ($, q) => (F(), K = 1 / 0, q()));
          let L = 0;
          _.on("requestItem", ($, q) => {
            const ie = L + s;
            return ie > K && (K = ie, F()), q();
          });
          const H = ($, q) => {
            let ie = 0;
            return O = O.then(async () => {
              do
                if (await g({ autoFreeChainChannel: false, filter: d }, async (Ae) => {
                  let he, x;
                  _.push({ type: "success", value: `\u7533\u8BF7\u5230\u53EF\u7528\u8282\u70B9(${Ae.chainChannel.address})\u7528\u4E8E\u8BF7\u6C42` });
                  const ce = Math.min(Ae.chainChannel.limitQueryTransactions, q), { requester: de, options: ke } = w.forceGet({ offset: $, limit: ce });
                  W.resolve(ce);
                  try {
                    const pe = Date.now(), j = await de.addChainChannel(Ae.chainChannel, ke), se = Date.now() - pe;
                    if (j.status === Ne.success) return _.push({ type: "success", value: `\u8282\u70B9(${Ae.chainChannel.address})\u8FD4\u56DE\u6210\u529F\u54CD\u5E94 +${se}ms` }), j.transactions.forEach((ae, le) => {
                      const Pe = $ - s + le;
                      _.canPush(_.list.length - L + Pe) && (L += 1, _.push({ type: "result", value: ae }));
                    }), j.transactions.length < ce ? (C($), Ae.autoFreeChainChannel = true, true) : (de.finish(), Ae.autoFreeChainChannel = true, true);
                    if (j.status === Ne.busy) return _.push({ type: "info", value: `\u8282\u70B9(${Ae.chainChannel.address})\u7E41\u5FD9 +${se}ms` }), de.removeChainChannelByResult(j), ie++, false;
                    if (j.status === Ne.error) throw _.push({ type: "warn", value: `\u8282\u70B9(${Ae.chainChannel.address})\u62A5\u544A\u5F02\u5E38: ${(he = j.error) === null || he === void 0 ? void 0 : he.message} +${se}ms` }), de.removeChainChannelByResult(j), j.error;
                    if (j.status === Ne.idempotentError) {
                      _.push({ type: "warn", value: `\u8282\u70B9(${Ae.chainChannel.address})\u62A5\u544A\u5E42\u7B49\u6027\u5F02\u5E38: ${(x = j.error) === null || x === void 0 ? void 0 : x.message} +${se}ms` }), de.removeChainChannelByResult(j);
                      const ae = j.error;
                      throw new Xo(ae.message, ae.detail, ae.CODE);
                    }
                    Ju(j.status);
                  } catch (pe) {
                    if (de.removeChainChannelByResult(pe), Wl.is(pe) || _.is_done) throw _.push({ type: "info", value: "\u4EFB\u52A1\u505C\u6B62" }), pe;
                    return Tc.is(pe) || (Xo.is(pe) ? mc("\u8282\u70B9\u5E42\u7B49\u6027\u51B2\u7A81", pe.message) : Wo(pe, "[GROUP]:", this.groupName, "[QUERY]:", e, "[OFFSET]:", $, "[TIMES]:", ie)), _.push({ type: "info", value: `\u5DF2\u91CD\u8BD5${ie}\u6B21` }), ie++ > 100;
                  }
                })) break;
              while (true);
            }, (ge) => W.reject(ge)), W.promise;
          };
          let W;
          const z = Math.min(B, p);
          for (let $ = 0, q = z; $ < p; $ += q) {
            const ie = $ + s;
            for (; ie > K && !(ie >= P); ) V || (V = new Yt(), await V.promise);
            if (ie >= P || (W = new Yt(), q = await H(ie, z), $ + q > p && (q = p - $, q <= 0))) break;
          }
          await O, await _.done();
        })().catch(_.reject).finally(() => {
          this.$releaseParallelTask(h);
        }), _;
      }
      queryTransactions(e, t, r, n = new Sr()) {
        return tf(this.queryTransactionsVerbose(e, t, r), n, (s) => s.type === "result" ? { filter: true, map: s.value } : { filter: false }), n;
      }
      indexTransactionsVerbose(e, t, r, n) {
        const { offset: s, limit: o, ...a } = e, p = a.signature ? 1 : o || 1 / 0, h = `Group(${this.groupName}) indexTransactions-${Date.now() + Math.random()}`, f = (r == null ? void 0 : r.channelFilter) || (() => true), { requestChainChannel: g } = this.$startParallelTask(h, { channelFirewall: (O) => O.canIndexTransactions && f(O), abortWhenNoChainChannel: r == null ? void 0 : r.abortWhenNoChainChannel, taskResponseCmd: Ie.INDEX_TRANSACTION_RETURN });
        let d;
        {
          const O = e.maxHeight;
          typeof O === "number" && (d = (P) => P.maybeHeight >= O);
        }
        const y = r && this.helper.parserAborterOptions(r, { channelGroup: this }), _ = n || new Sr(), I = y && y.promise;
        if (I) {
          Ui(I, void 0, _.reject);
          const O = (P, C) => (th(I, void 0, _.reject), C());
          _.on("done", O), _.on("error", O);
        }
        const S = { timeout: (O, P) => `peer(${P.address}) indexTransactions(<offset:${O.data.offset},limit:${O.data.limit}>) timeout.
[query:]${JSON.stringify(O.requester.query)}
[sort:]${JSON.stringify(O.requester.sort)}` }, w = wt.from({ transformKey: (O) => `${O.offset}-${O.limit}`, creater: (O) => {
          const P = iu.create(this.moduleMap, { ...a, ...O }, t);
          return { requester: P, options: new Cc(S, O, P, this.helper.getChainChannelTimeout, y) };
        } }), B = (r == null ? void 0 : r.queryUnitLength) || (o ? Math.ceil(o / (this.chainChannelSet.size || 1)) : 100);
        return (async () => {
          let O = Promise.resolve(), P = p + s;
          const C = ($) => {
            P = $, F();
          };
          let V;
          const F = () => {
            V && (V.resolve(), V = void 0);
          };
          let K = -1;
          _.on("requestAll", ($, q) => (F(), K = 1 / 0, q()));
          let L = 0;
          _.on("requestItem", ($, q) => {
            const ie = L + s;
            return ie > K && (K = ie, F()), q();
          });
          const H = ($, q) => {
            let ie = 0;
            return O = O.then(async () => {
              do
                if (await g({ autoFreeChainChannel: false, filter: d }, async (Ae) => {
                  let he, x;
                  _.push({ type: "success", value: `\u7533\u8BF7\u5230\u53EF\u7528\u8282\u70B9(${Ae.chainChannel.address})\u7528\u4E8E\u8BF7\u6C42` });
                  const ce = Math.min(Ae.chainChannel.limitQueryTransactions, q), { requester: de, options: ke } = w.forceGet({ offset: $, limit: ce });
                  W.resolve(ce);
                  try {
                    const pe = Date.now(), j = await de.addChainChannel(Ae.chainChannel, ke), se = Date.now() - pe;
                    if (j.status === Ne.success) return _.push({ type: "success", value: `\u8282\u70B9(${Ae.chainChannel.address})\u8FD4\u56DE\u6210\u529F\u54CD\u5E94 +${se}ms` }), j.tIndexes.forEach((ae, le) => {
                      const Pe = $ - s + le;
                      _.canPush(_.list.length - L + Pe) && (L += 1, _.push({ type: "result", value: ae }));
                    }), j.tIndexes.length < ce ? (C($), Ae.autoFreeChainChannel = true, true) : (de.finish(), Ae.autoFreeChainChannel = true, true);
                    if (j.status === Ne.busy) return _.push({ type: "info", value: `\u8282\u70B9(${Ae.chainChannel.address})\u7E41\u5FD9 +${se}ms` }), de.removeChainChannelByResult(j), ie++, false;
                    if (j.status === Ne.error) throw _.push({ type: "warn", value: `\u8282\u70B9(${Ae.chainChannel.address})\u62A5\u544A\u5F02\u5E38: ${(he = j.error) === null || he === void 0 ? void 0 : he.message} +${se}ms` }), de.removeChainChannelByResult(j), j.error;
                    if (j.status === Ne.idempotentError) {
                      _.push({ type: "warn", value: `\u8282\u70B9(${Ae.chainChannel.address})\u62A5\u544A\u5E42\u7B49\u6027\u5F02\u5E38: ${(x = j.error) === null || x === void 0 ? void 0 : x.message} +${se}ms` }), de.removeChainChannelByResult(j);
                      const ae = j.error;
                      throw new Xo(ae.message, ae.detail, ae.CODE);
                    }
                    Ju(j.status);
                  } catch (pe) {
                    if (de.removeChainChannelByResult(pe), Wl.is(pe) || _.is_done) throw _.push({ type: "info", value: "\u4EFB\u52A1\u505C\u6B62" }), pe;
                    return Tc.is(pe) || (Xo.is(pe) ? mc("\u8282\u70B9\u5E42\u7B49\u6027\u51B2\u7A81", pe.message) : Wo(pe, "[GROUP]:", this.groupName, "[QUERY]:", e, "[OFFSET]:", $, "[TIMES]:", ie)), _.push({ type: "info", value: `\u5DF2\u91CD\u8BD5${ie}\u6B21` }), ie++ > 100;
                  }
                })) break;
              while (true);
            }, (ge) => W.reject(ge)), W.promise;
          };
          let W;
          const z = Math.min(B, p);
          for (let $ = 0, q = z; $ < p; $ += q) {
            const ie = $ + s;
            for (; ie > K && !(ie >= P); ) V || (V = new Yt(), await V.promise);
            if (ie >= P || (W = new Yt(), q = await H(ie, z), $ + q > p && (q = p - $, q <= 0))) break;
          }
          await O, await _.done();
        })().catch(_.reject).finally(() => {
          this.$releaseParallelTask(h);
        }), _;
      }
      indexTransactions(e, t, r, n = new Sr()) {
        return tf(this.indexTransactionsVerbose(e, t, r), n, (s) => s.type === "result" ? { filter: true, map: s.value } : { filter: false }), n;
      }
      _formatHiList(e) {
        const t = [], r = new wt((p) => t.length + 1);
        for (const p of e.slice().toSorted((h, f) => h.height - f.height)) {
          const f = r.forceGet(p.height) + p.tIndex;
          t[f] = f;
        }
        const n = [];
        t.forEach((p) => n[n.length] = p);
        const s = new D0(n), o = [];
        for (const p of r) o[o.length] = { height: p[0], baseIndex: p[1] };
        let a = 0;
        return s.getRangeSet(1 / 0).map((p) => {
          const h = o.findIndex((_) => _.baseIndex > p.start, a);
          a = h === -1 ? o.length - 1 : h - 1;
          const f = o[a], g = f.height, d = p.start - f.baseIndex, y = p.length;
          return { height: g, tIndex: d, length: y };
        });
      }
      downloadTransactionsVerbose(e, t, r) {
        const n = Math.min(Math.ceil((this.limitDownloadTransactions || 1) / Math.SQRT2), 1), s = /* @__PURE__ */ new Map(), o = (S, w) => {
          s.set(`${S}-${w}`, { height: S, tIndex: w });
        };
        for (const S of e) if (S.length > 1) for (let w = 0; w < S.length; ++w) o(S.height, S.tIndex + w);
        else o(S.height, S.tIndex);
        const a = [...s.values()], p = a.length, h = t && this.helper.parserAborterOptions(t, { channelGroup: this }), f = r || new Sr(), g = `Group(${this.groupName}) downloadTransactions-${Date.now() + Math.random()}`, d = (t == null ? void 0 : t.channelFilter) || (() => true), { requestChainChannel: y } = this.$startParallelTask(g, { channelFirewall: (S) => S.canDownloadTransactions && d(S), abortWhenNoChainChannel: t == null ? void 0 : t.abortWhenNoChainChannel, taskResponseCmd: Ie.DOWNLOAD_TRANSACTION_RETURN }), _ = { timeout: (S, w) => `peer(${w.address}) downloadTransactions(<${S.data.map((N) => `${N.height}/${N.tIndex}:${N.length}`).join(",")}) timeout.` }, I = wt.from({ transformKey: (S) => S.map((w) => `${w.height}/${w.tIndex}:${w.length}`).join(","), creater: (S) => {
          const w = ou.create(this.moduleMap, S);
          return { requester: w, options: new Cc(_, S, w, this.helper.getChainChannelTimeout, h) };
        } });
        return (async () => {
          let S;
          const w = () => {
            S && (S.resolve(), S = void 0);
          };
          let N = f.requestProcess;
          f.on("requestAll", (P, C) => (w(), N = 1 / 0, C())), f.on("requestItem", (P, C) => (P >= N && (N = P + 1, w()), C()));
          let B = 0;
          const O = async () => {
            do {
              const P = a.slice(B, B += n);
              if (P.length === 0) break;
              const C = this._formatHiList(P), V = P.length, F = P[P.length - 1].height;
              let K = 0;
              for (; !await y({ filter: (H) => H.maybeHeight >= F }, async (H) => {
                let W, z;
                f.push({ type: "success", value: `\u7533\u8BF7\u5230\u53EF\u7528\u8282\u70B9(${H.chainChannel.address})\u7528\u4E8E\u8BF7\u6C42` });
                const { requester: $, options: q } = I.forceGet(C);
                try {
                  const ie = Date.now(), ge = await $.addChainChannel(H.chainChannel, q), he = Date.now() - ie;
                  if (ge.status === Ne.success) {
                    if (f.push({ type: "success", value: `\u8282\u70B9(${H.chainChannel.address})\u8FD4\u56DE\u6210\u529F\u54CD\u5E94 +${he}ms` }), ge.transactions.length < V) return $.removeChainChannelByResult(ge), K++, false;
                    {
                      const x = ge.transactions.map((ce) => ({ tib: ce, hiIndex: a.findIndex((de) => de.height === ce.height && de.tIndex === ce.tIndex) })).toSorted((ce, de) => ce.hiIndex - de.hiIndex);
                      for (const ce of x) f.canPush(f.list.length) && f.push({ type: "result", value: ce.tib });
                      return true;
                    }
                  } else {
                    if (ge.status === Ne.busy) return f.push({ type: "info", value: `\u8282\u70B9(${H.chainChannel.address})\u7E41\u5FD9 +${he}ms` }), $.removeChainChannelByResult(ge), K++, false;
                    if (ge.status === Ne.error) throw f.push({ type: "warn", value: `\u8282\u70B9(${H.chainChannel.address})\u62A5\u544A\u5F02\u5E38: ${(W = ge.error) === null || W === void 0 ? void 0 : W.message} +${he}ms` }), $.removeChainChannelByResult(ge), ge.error;
                    if (ge.status === Ne.idempotentError) {
                      f.push({ type: "warn", value: `\u8282\u70B9(${H.chainChannel.address})\u62A5\u544A\u5E42\u7B49\u6027\u5F02\u5E38: ${(z = ge.error) === null || z === void 0 ? void 0 : z.message} +${he}ms` }), $.removeChainChannelByResult(ge);
                      const x = ge.error;
                      throw new Xo(x.message, x.detail, x.CODE);
                    }
                  }
                  Ju(ge.status);
                } catch (ie) {
                  if ($.removeChainChannelByResult(ie), Wl.is(ie) || f.is_done) throw f.push({ type: "info", value: "\u4EFB\u52A1\u505C\u6B62" }), ie;
                  return Tc.is(ie) || (Xo.is(ie) ? mc("\u8282\u70B9\u5E42\u7B49\u6027\u51B2\u7A81", ie.message) : Wo(ie, "[GROUP]:", this.groupName, "[TINDEXES]:", P, "[TIMES]:", K)), f.push({ type: "info", value: `\u5DF2\u91CD\u8BD5${K}\u6B21` }), K++ > 100;
                }
              }); ) ;
            } while (true);
          };
          for (let P = 0; P < p; P += n) {
            for (; P >= N; ) S || (S = new Yt()), await S.promise;
            await O();
          }
          await f.done();
        })().finally(() => {
          this.$releaseParallelTask(g);
        }), f;
      }
      downloadTransactions(e, t, r = new Sr()) {
        return tf(this.downloadTransactionsVerbose(e, t), r, (n) => n.type === "result" ? { filter: true, map: n.value } : { filter: false }), r;
      }
      async broadcastTransaction(e, t, r) {
        let n;
        const s = this.timeHelper.now(), o = [];
        let a;
        try {
          let f = [];
          if (t && t.directAddress && t.directAddress.size > 0) {
            const y = t.directAddress;
            for (const _ of this.chainChannelSet.values()) y.has(_.address) && f.push(_);
          } else f = [...this.chainChannelSet.values()];
          let g = r && await r.emit("startBroadcasting", { chainChannelList: f });
          if (g && g.break) return [];
          const d = new aT(t && t.max_parallel_num);
          a = t && this.helper.parserAborterOptions(t, { channelGroup: this });
          for (const y of f) d.addTaskExecutor(async () => {
            const _ = n || (n = await y.initBroadcastTransactionArg(e, { timeout: (S) => this.helper.getChainChannelTimeout(S.chainChannel), rejected: a == null ? void 0 : a.promise }));
            let I;
            try {
              const S = -y.calcDiffTimeToTargetTime(this.timeHelper.getTimeByTimestamp(e.timestamp));
              if (S > 0) {
                if (N_("chainChannel(%s) seems in feature. need wait %dms then broadcast.", y.address, S), a && a.sleepTime > 0 && S + y.delay / 2 > a.sleepTime) {
                  N_("chainChannel(%s) need wait too much time, so skip in resultList."), bs(S, async () => {
                    try {
                      I = { error: false, result: await y._requestWithBinaryData(..._), chainChannel: y };
                    } catch (w) {
                      I = { error: true, result: w, chainChannel: y };
                    }
                    r && await r.emit("broadcasted", I);
                  });
                  return;
                }
                await bs(S);
              }
              o.push(I = { error: false, result: await y._requestWithBinaryData(..._), chainChannel: y });
            } catch (S) {
              o.push(I = { error: true, result: S, chainChannel: y });
            }
            r && (g = await r.emit("broadcasted", I));
          });
          for await (const y of d.yieldResults({ ignoreError: true })) if (g && g.break) break;
          a == null || a.resolve(void 0);
        } catch (f) {
          a == null || a.reject(f);
        } finally {
          const f = this.timeHelper.now();
          r && r.emit("endBroadcast", { duraction: f - s });
        }
        let p = 0, h = 0;
        return o.forEach((f) => {
          f.error ? h += 1 : p += 1;
        }), (p === 0 && h > 0 ? Wo : b_)("chainChannelGroup(%s) broadcasted Transaction(%s), successed: %d, fail: %d", this.groupName, this.transactionHelper.getTypeName(e.type), p, h, e.asset), o;
      }
      async fastBroadcastTransaction(e, t, r) {
        let n, s = [];
        if (t && t.directAddress && t.directAddress.size > 0) {
          const f = t.directAddress;
          for (const g of this.chainChannelSet.values()) f.has(g.address) && s.push(g);
        } else for (const f of this.chainChannelSet.values()) f.canBroadcastTransaction && s.push(f);
        let o = r && await r.emit("startBroadcasting", { chainChannelList: s }), a = 0;
        if (o && o.break) return a;
        const p = this.timeHelper.now();
        for (const f of s) if (!f.isRefusePushNewTransaction) {
          n || (n = await f.initBroadcastTransactionArg(e));
          try {
            a++, await f._sendWithBinaryData(n[0], n[1]);
          } catch {
          }
        }
        const h = this.timeHelper.now();
        return r && r.emit("endBroadcast", { duraction: h - p }), a;
      }
      async queryBlock(e, t, r) {
        if (typeof e.height === "number") {
          const f = e.height;
          if (![...this.chainChannelSet.values()].find((d) => d.maybeHeight >= f)) return;
        }
        const n = `Group(${this.groupName}) queryBlock-${Date.now() + Math.random()}`, { requestChainChannel: s } = this.$startParallelTask(n, { channelFirewall: t == null ? void 0 : t.channelFilter, abortWhenNoChainChannel: t == null ? void 0 : t.abortWhenNoChainChannel, taskResponseCmd: Ie.QUERY_BLOCK_RETURN }), o = t && this.helper.parserAborterOptions(t, { channelGroup: this });
        let a = false;
        const p = o == null ? void 0 : o.promise;
        let h;
        if (p) {
          const f = (g) => {
            mc(g), a = true;
          };
          Ui(p, void 0, f), h = () => {
            th(p, void 0, f);
          };
        }
        try {
          const f = Math.min(Math.max(this.size, 2), 5), g = au.create(this.moduleMap, e), d = { rejected: p, timeout: (S) => this.helper.getChainChannelTimeout(S.chainChannel) };
          {
            const S = new wt((w) => new Tc(c.QUERY_BLOCK_FROM_PEER_TIMEOUT, { query: JSON.stringify(g.query), peerId: w.address }));
            d.timeoutException = (w) => S.forceGet(w.chainChannel);
          }
          let y = 0, _, I = () => true;
          {
            const S = e.height;
            typeof S === "number" && (I = (w) => w.maybeHeight >= S);
          }
          do {
            if (a) return;
            await s({ autoFreeChainChannel: false, filter: I }, async (S) => {
              let w, N;
              try {
                const B = await g.addChainChannel(S.chainChannel, d);
                if (B.status === Ne.error) throw g.removeChainChannelByResult(B), B.error;
                if (B.status === Ne.busy) throw g.removeChainChannelByResult(B), void 0;
                if (_ = (w = B.someBlock) === null || w === void 0 ? void 0 : w.block, !_) {
                  const O = (N = g.getChainChannelByResult(B)) === null || N === void 0 ? void 0 : N.maybeHeight;
                  if (O && O >= this.maybeHeight) {
                    a = true;
                    return;
                  }
                }
                g.finish();
              } catch (B) {
                if (a) return;
                if (g.removeChainChannelByResult(B), B && mc(B), y += 1, y >= f) {
                  a = true;
                  return;
                }
              }
            });
          } while (!_);
          return _;
        } finally {
          this.$releaseParallelTask(n), h && h();
        }
      }
      findBlock(e, t) {
        return this.queryBlock(e, t);
      }
      async broadcastBlock(e, t) {
        let r, n = [];
        if (t && t.directAddress && t.directAddress.size > 0) {
          const h = t.directAddress;
          for (const f of this.chainChannelSet.values()) h.has(f.address) && n.push(f);
        } else n = [...this.chainChannelSet.values()];
        const s = t && this.helper.parserAborterOptions(t, { channelGroup: this }), o = await Promise.all(n.map((h) => (r || (r = h.initBroadcastBlockArg(e, { timeout: (f) => this.helper.getChainChannelTimeout(f.chainChannel), rejected: s == null ? void 0 : s.promise })), { chainChannel: h, result: h._requestWithBinaryData(...r) })));
        let a = 0, p = 0;
        return await Promise.all(o.map(async (h) => {
          try {
            (await h.result).error ? p += 1 : a += 1;
          } catch {
            p += 1;
          }
        })), (a === 0 && p > 0 ? Wo : b_)("chainChannelGroup(%s) broadcasted Block(%d), successed: %d, fail: %d", this.groupName, e.height, a, p), o;
      }
      async fastBroadcastBlock(e, t) {
        let r, n = [];
        if (t && t.directAddress && t.directAddress.size > 0) {
          const o = t.directAddress;
          for (const a of this.chainChannelSet.values()) o.has(a.address) && n.push(a);
        } else for (const o of this.chainChannelSet.values()) o.canBroadcastBlock && n.push(o);
        let s = 0;
        for (const o of n) {
          r || (r = o.initBroadcastBlockArg(e));
          try {
            s++, await o._sendWithBinaryData(r[0], r[1]);
          } catch {
          }
        }
        return s;
      }
      addChainChannel(e, t = this.options) {
        return this.chainChannelSet.has(e) ? false : (this.addChainChannel_(e, t), this._chainChannelEvents.emit("addChainChannel", e), true);
      }
      addChainChannels(e) {
        let t = 0, r = 0;
        const n = "size" in e ? e : [e];
        for (const s of n) this.addChainChannel(s) ? t += 1 : r += 1;
        return { ADD: t, FAIL: r };
      }
      removeChainChannel(e) {
        e.offEmit(this._eventFollower);
        const t = this._DAWCLWM.get(e);
        return t && (this._DAWCLWM.delete(e), t()), this.chainChannelSet.delete(e) ? (this._chainChannelEvents.emit("removeChainChannel", e), true) : false;
      }
      get _chainChannelEvents() {
        return new An();
      }
      get onAddChainChannel() {
        return this._chainChannelEvents.on.bind(this._chainChannelEvents, "addChainChannel");
      }
      get offAddChainChannel() {
        return this._chainChannelEvents.off.bind(this._chainChannelEvents, "addChainChannel");
      }
      get onRemoveChainChannel() {
        return this._chainChannelEvents.on.bind(this._chainChannelEvents, "removeChainChannel");
      }
      get offRemoveChainChannel() {
        return this._chainChannelEvents.off.bind(this._chainChannelEvents, "removeChainChannel");
      }
      _eventFollower(e) {
        return this.emit(e.eventname, e.args);
      }
      addChainChannel_(e, t = this.options) {
        if (this.chainChannelSet.add(e), !t.disableAutoRemove) {
          const r = e.onClose((n) => {
            F0.is(n) ? $0("channel auto removed in [%s], reason:", this.groupName, n.message) : Wo("channel auto removed in [%s], reason:", this.groupName, n), this.removeChainChannel(e);
          });
          this._DAWCLWM.set(e, r);
        }
        e.onEmit(this._eventFollower);
      }
      destroy() {
        for (const e of this.chainChannelSet) this.removeChainChannel(e);
      }
      get maybeHeight() {
        return this._maybeHeight;
      }
      get lastConsensusVersion() {
        return this._lastConsensusVersion;
      }
      get onMaybeHeightChanged() {
        return this._chainChannelEvents.on.bind(this._chainChannelEvents, "maybeHeightChanged");
      }
      get offMaybeHeightChanged() {
        return this._chainChannelEvents.off.bind(this._chainChannelEvents, "maybeHeightChanged");
      }
      _tryChangeMaybeHeight(e, t) {
        this._maybeHeight !== e && (this._maybeHeight = e, this._chainChannelEvents.emit("maybeHeightChanged", e, t));
      }
      _tryChangeConsensusVersion(e) {
        this._lastConsensusVersion !== e && (this._lastConsensusVersion = e, this._chainChannelEvents.emit("consensusVersionChanged", e));
      }
      _initMaybeHeightWatcher() {
        const e = (r, n) => (r.height > this._maybeHeight && this._tryChangeMaybeHeight(r.height, r.version), n());
        let t = this._maybeHeight;
        for (const r of this.chainChannelSet) t = Math.max(r.maybeHeight, t);
        this._tryChangeMaybeHeight(t), this._chainChannelEvents.on("addChainChannel", (r) => {
          this._maybeHeight < r.maybeHeight && this._tryChangeMaybeHeight(r.maybeHeight), this._lastConsensusVersion < r.lastConsensusVersion && this._tryChangeConsensusVersion(r.lastConsensusVersion), r.on("onNewBlock", e);
        }), this._chainChannelEvents.on("removeChainChannel", (r) => {
          if (r.off("onNewBlock", e), r.maybeHeight < this._maybeHeight) return;
          let n = 1;
          for (const s of this.chainChannelSet) if (n = Math.max(s.maybeHeight, n), n >= r.maybeHeight) return;
          this._tryChangeMaybeHeight(n);
        });
      }
    };
    l([D(Be), u("design:type", Be)], Ut.prototype, "baseHelper", void 0);
    l([D(ne), u("design:type", ne)], Ut.prototype, "config", void 0);
    l([D(ze), u("design:type", ze)], Ut.prototype, "moduleMap", void 0);
    l([D(Ft), u("design:type", Ft)], Ut.prototype, "timeHelper", void 0);
    l([D(Fe), u("design:type", Fe)], Ut.prototype, "helper", void 0);
    l([D(Ee), u("design:type", Ee)], Ut.prototype, "transactionHelper", void 0);
    l([D(Si), u("design:type", Si)], Ut.prototype, "blobHelper", void 0);
    l([De, u("design:type", Function), u("design:paramtypes", [Object, Object, Object, Object]), u("design:returntype", void 0)], Ut.prototype, "queryTransactions", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object, Object, Object, Sr]), u("design:returntype", void 0)], Ut.prototype, "indexTransactionsVerbose", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object, Object, Object, Object]), u("design:returntype", void 0)], Ut.prototype, "indexTransactions", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object, Object, Sr]), u("design:returntype", void 0)], Ut.prototype, "downloadTransactionsVerbose", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object, Object, Object]), u("design:returntype", void 0)], Ut.prototype, "downloadTransactions", null);
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Ut.prototype, "_chainChannelEvents", null);
    l([oe, u("design:type", Function), u("design:paramtypes", [])], Ut.prototype, "onAddChainChannel", null);
    l([oe, u("design:type", Function), u("design:paramtypes", [])], Ut.prototype, "onRemoveChainChannel", null);
    l([oe, u("design:type", Function), u("design:paramtypes", [])], Ut.prototype, "offRemoveChainChannel", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", void 0)], Ut.prototype, "_eventFollower", null);
    l([oe, u("design:type", Function), u("design:paramtypes", [])], Ut.prototype, "onMaybeHeightChanged", null);
    l([oe, u("design:type", Function), u("design:paramtypes", [])], Ut.prototype, "offMaybeHeightChanged", null);
    Ut = l([Oo(), be(0, D(Oc.CHANNEL_LIST)), be(1, D(Oc.GROUP_NAME, { optional: true })), be(2, D(Oc.OPTIONS, { optional: true })), u("design:paramtypes", [Object, Object, Object])], Ut);
    const Cc = class {
      constructor(e, t, r, n, s) {
        this.exmBuilder = e, this.data = t, this.requester = r, this.getChainChannelTimeout = n, this.resultPo = s;
      }
      get _exm() {
        return new wt((e) => new Tc(this.exmBuilder.timeout(this, e)));
      }
      timeoutException(e) {
        return this._exm.forceGet(e.chainChannel);
      }
      timeout(e) {
        return this.getChainChannelTimeout(e.chainChannel);
      }
      get rejected() {
        let e;
        return (e = this.resultPo) === null || e === void 0 ? void 0 : e.promise;
      }
    };
    l([oe, u("design:type", Object), u("design:paramtypes", [])], Cc.prototype, "_exm", null);
    l([De, u("design:type", Function), u("design:paramtypes", [Object]), u("design:returntype", void 0)], Cc.prototype, "timeoutException", null);
    let nd = class {
      constructor(e) {
        this.moduleMap = e, this._groupNameAcc = 1;
      }
      registryChannel(e, t = Us, r = this.moduleMap, n = 1e3) {
        return bt(t, new ze([[ch.ENDPOINT, e], [ch.REFUSETIME, n]], r));
      }
      groupChannel(e, t = `G${this._groupNameAcc++}`, r = Ut) {
        const { moduleMap: n } = this;
        return bt(r, new ze([[Oc.CHANNEL_LIST, e], [Oc.GROUP_NAME, t]], n));
      }
    };
    nd = l([J(), u("design:paramtypes", [ze])], nd);
    const je = Uint8Array;
    const gf = Uint16Array;
    const cu = Int32Array;
    const Ll = Float64Array;
    function pu(i, e, t, r) {
      const n = r[0] & 255 | (r[1] & 255) << 8 | (r[2] & 255) << 16 | (r[3] & 255) << 24, s = t[0] & 255 | (t[1] & 255) << 8 | (t[2] & 255) << 16 | (t[3] & 255) << 24, o = t[4] & 255 | (t[5] & 255) << 8 | (t[6] & 255) << 16 | (t[7] & 255) << 24, a = t[8] & 255 | (t[9] & 255) << 8 | (t[10] & 255) << 16 | (t[11] & 255) << 24, p = t[12] & 255 | (t[13] & 255) << 8 | (t[14] & 255) << 16 | (t[15] & 255) << 24, h = r[4] & 255 | (r[5] & 255) << 8 | (r[6] & 255) << 16 | (r[7] & 255) << 24, f = e[0] & 255 | (e[1] & 255) << 8 | (e[2] & 255) << 16 | (e[3] & 255) << 24, g = e[4] & 255 | (e[5] & 255) << 8 | (e[6] & 255) << 16 | (e[7] & 255) << 24, d = e[8] & 255 | (e[9] & 255) << 8 | (e[10] & 255) << 16 | (e[11] & 255) << 24, y = e[12] & 255 | (e[13] & 255) << 8 | (e[14] & 255) << 16 | (e[15] & 255) << 24, _ = r[8] & 255 | (r[9] & 255) << 8 | (r[10] & 255) << 16 | (r[11] & 255) << 24, I = t[16] & 255 | (t[17] & 255) << 8 | (t[18] & 255) << 16 | (t[19] & 255) << 24, S = t[20] & 255 | (t[21] & 255) << 8 | (t[22] & 255) << 16 | (t[23] & 255) << 24, w = t[24] & 255 | (t[25] & 255) << 8 | (t[26] & 255) << 16 | (t[27] & 255) << 24, N = t[28] & 255 | (t[29] & 255) << 8 | (t[30] & 255) << 16 | (t[31] & 255) << 24, B = r[12] & 255 | (r[13] & 255) << 8 | (r[14] & 255) << 16 | (r[15] & 255) << 24;
      let O = n, P = s, C = o, V = a, F = p, K = h, L = f, H = g, W = d, z = y, $ = _, q = I, ie = S, ge = w, Ae = N, he = B, x;
      for (let ce = 0; ce < 20; ce += 2) x = O + ie | 0, F ^= x << 7 | x >>> 32 - 7, x = F + O | 0, W ^= x << 9 | x >>> 32 - 9, x = W + F | 0, ie ^= x << 13 | x >>> 32 - 13, x = ie + W | 0, O ^= x << 18 | x >>> 32 - 18, x = K + P | 0, z ^= x << 7 | x >>> 32 - 7, x = z + K | 0, ge ^= x << 9 | x >>> 32 - 9, x = ge + z | 0, P ^= x << 13 | x >>> 32 - 13, x = P + ge | 0, K ^= x << 18 | x >>> 32 - 18, x = $ + L | 0, Ae ^= x << 7 | x >>> 32 - 7, x = Ae + $ | 0, C ^= x << 9 | x >>> 32 - 9, x = C + Ae | 0, L ^= x << 13 | x >>> 32 - 13, x = L + C | 0, $ ^= x << 18 | x >>> 32 - 18, x = he + q | 0, V ^= x << 7 | x >>> 32 - 7, x = V + he | 0, H ^= x << 9 | x >>> 32 - 9, x = H + V | 0, q ^= x << 13 | x >>> 32 - 13, x = q + H | 0, he ^= x << 18 | x >>> 32 - 18, x = O + V | 0, P ^= x << 7 | x >>> 32 - 7, x = P + O | 0, C ^= x << 9 | x >>> 32 - 9, x = C + P | 0, V ^= x << 13 | x >>> 32 - 13, x = V + C | 0, O ^= x << 18 | x >>> 32 - 18, x = K + F | 0, L ^= x << 7 | x >>> 32 - 7, x = L + K | 0, H ^= x << 9 | x >>> 32 - 9, x = H + L | 0, F ^= x << 13 | x >>> 32 - 13, x = F + H | 0, K ^= x << 18 | x >>> 32 - 18, x = $ + z | 0, q ^= x << 7 | x >>> 32 - 7, x = q + $ | 0, W ^= x << 9 | x >>> 32 - 9, x = W + q | 0, z ^= x << 13 | x >>> 32 - 13, x = z + W | 0, $ ^= x << 18 | x >>> 32 - 18, x = he + Ae | 0, ie ^= x << 7 | x >>> 32 - 7, x = ie + he | 0, ge ^= x << 9 | x >>> 32 - 9, x = ge + ie | 0, Ae ^= x << 13 | x >>> 32 - 13, x = Ae + ge | 0, he ^= x << 18 | x >>> 32 - 18;
      O = O + n | 0, P = P + s | 0, C = C + o | 0, V = V + a | 0, F = F + p | 0, K = K + h | 0, L = L + f | 0, H = H + g | 0, W = W + d | 0, z = z + y | 0, $ = $ + _ | 0, q = q + I | 0, ie = ie + S | 0, ge = ge + w | 0, Ae = Ae + N | 0, he = he + B | 0, i[0] = O >>> 0 & 255, i[1] = O >>> 8 & 255, i[2] = O >>> 16 & 255, i[3] = O >>> 24 & 255, i[4] = P >>> 0 & 255, i[5] = P >>> 8 & 255, i[6] = P >>> 16 & 255, i[7] = P >>> 24 & 255, i[8] = C >>> 0 & 255, i[9] = C >>> 8 & 255, i[10] = C >>> 16 & 255, i[11] = C >>> 24 & 255, i[12] = V >>> 0 & 255, i[13] = V >>> 8 & 255, i[14] = V >>> 16 & 255, i[15] = V >>> 24 & 255, i[16] = F >>> 0 & 255, i[17] = F >>> 8 & 255, i[18] = F >>> 16 & 255, i[19] = F >>> 24 & 255, i[20] = K >>> 0 & 255, i[21] = K >>> 8 & 255, i[22] = K >>> 16 & 255, i[23] = K >>> 24 & 255, i[24] = L >>> 0 & 255, i[25] = L >>> 8 & 255, i[26] = L >>> 16 & 255, i[27] = L >>> 24 & 255, i[28] = H >>> 0 & 255, i[29] = H >>> 8 & 255, i[30] = H >>> 16 & 255, i[31] = H >>> 24 & 255, i[32] = W >>> 0 & 255, i[33] = W >>> 8 & 255, i[34] = W >>> 16 & 255, i[35] = W >>> 24 & 255, i[36] = z >>> 0 & 255, i[37] = z >>> 8 & 255, i[38] = z >>> 16 & 255, i[39] = z >>> 24 & 255, i[40] = $ >>> 0 & 255, i[41] = $ >>> 8 & 255, i[42] = $ >>> 16 & 255, i[43] = $ >>> 24 & 255, i[44] = q >>> 0 & 255, i[45] = q >>> 8 & 255, i[46] = q >>> 16 & 255, i[47] = q >>> 24 & 255, i[48] = ie >>> 0 & 255, i[49] = ie >>> 8 & 255, i[50] = ie >>> 16 & 255, i[51] = ie >>> 24 & 255, i[52] = ge >>> 0 & 255, i[53] = ge >>> 8 & 255, i[54] = ge >>> 16 & 255, i[55] = ge >>> 24 & 255, i[56] = Ae >>> 0 & 255, i[57] = Ae >>> 8 & 255, i[58] = Ae >>> 16 & 255, i[59] = Ae >>> 24 & 255, i[60] = he >>> 0 & 255, i[61] = he >>> 8 & 255, i[62] = he >>> 16 & 255, i[63] = he >>> 24 & 255;
    }
    function Ly(i, e, t, r) {
      const n = r[0] & 255 | (r[1] & 255) << 8 | (r[2] & 255) << 16 | (r[3] & 255) << 24, s = t[0] & 255 | (t[1] & 255) << 8 | (t[2] & 255) << 16 | (t[3] & 255) << 24, o = t[4] & 255 | (t[5] & 255) << 8 | (t[6] & 255) << 16 | (t[7] & 255) << 24, a = t[8] & 255 | (t[9] & 255) << 8 | (t[10] & 255) << 16 | (t[11] & 255) << 24, p = t[12] & 255 | (t[13] & 255) << 8 | (t[14] & 255) << 16 | (t[15] & 255) << 24, h = r[4] & 255 | (r[5] & 255) << 8 | (r[6] & 255) << 16 | (r[7] & 255) << 24, f = e[0] & 255 | (e[1] & 255) << 8 | (e[2] & 255) << 16 | (e[3] & 255) << 24, g = e[4] & 255 | (e[5] & 255) << 8 | (e[6] & 255) << 16 | (e[7] & 255) << 24, d = e[8] & 255 | (e[9] & 255) << 8 | (e[10] & 255) << 16 | (e[11] & 255) << 24, y = e[12] & 255 | (e[13] & 255) << 8 | (e[14] & 255) << 16 | (e[15] & 255) << 24, _ = r[8] & 255 | (r[9] & 255) << 8 | (r[10] & 255) << 16 | (r[11] & 255) << 24, I = t[16] & 255 | (t[17] & 255) << 8 | (t[18] & 255) << 16 | (t[19] & 255) << 24, S = t[20] & 255 | (t[21] & 255) << 8 | (t[22] & 255) << 16 | (t[23] & 255) << 24, w = t[24] & 255 | (t[25] & 255) << 8 | (t[26] & 255) << 16 | (t[27] & 255) << 24, N = t[28] & 255 | (t[29] & 255) << 8 | (t[30] & 255) << 16 | (t[31] & 255) << 24, B = r[12] & 255 | (r[13] & 255) << 8 | (r[14] & 255) << 16 | (r[15] & 255) << 24;
      let O = n, P = s, C = o, V = a, F = p, K = h, L = f, H = g, W = d, z = y, $ = _, q = I, ie = S, ge = w, Ae = N, he = B, x;
      for (let ce = 0; ce < 20; ce += 2) x = O + ie | 0, F ^= x << 7 | x >>> 32 - 7, x = F + O | 0, W ^= x << 9 | x >>> 32 - 9, x = W + F | 0, ie ^= x << 13 | x >>> 32 - 13, x = ie + W | 0, O ^= x << 18 | x >>> 32 - 18, x = K + P | 0, z ^= x << 7 | x >>> 32 - 7, x = z + K | 0, ge ^= x << 9 | x >>> 32 - 9, x = ge + z | 0, P ^= x << 13 | x >>> 32 - 13, x = P + ge | 0, K ^= x << 18 | x >>> 32 - 18, x = $ + L | 0, Ae ^= x << 7 | x >>> 32 - 7, x = Ae + $ | 0, C ^= x << 9 | x >>> 32 - 9, x = C + Ae | 0, L ^= x << 13 | x >>> 32 - 13, x = L + C | 0, $ ^= x << 18 | x >>> 32 - 18, x = he + q | 0, V ^= x << 7 | x >>> 32 - 7, x = V + he | 0, H ^= x << 9 | x >>> 32 - 9, x = H + V | 0, q ^= x << 13 | x >>> 32 - 13, x = q + H | 0, he ^= x << 18 | x >>> 32 - 18, x = O + V | 0, P ^= x << 7 | x >>> 32 - 7, x = P + O | 0, C ^= x << 9 | x >>> 32 - 9, x = C + P | 0, V ^= x << 13 | x >>> 32 - 13, x = V + C | 0, O ^= x << 18 | x >>> 32 - 18, x = K + F | 0, L ^= x << 7 | x >>> 32 - 7, x = L + K | 0, H ^= x << 9 | x >>> 32 - 9, x = H + L | 0, F ^= x << 13 | x >>> 32 - 13, x = F + H | 0, K ^= x << 18 | x >>> 32 - 18, x = $ + z | 0, q ^= x << 7 | x >>> 32 - 7, x = q + $ | 0, W ^= x << 9 | x >>> 32 - 9, x = W + q | 0, z ^= x << 13 | x >>> 32 - 13, x = z + W | 0, $ ^= x << 18 | x >>> 32 - 18, x = he + Ae | 0, ie ^= x << 7 | x >>> 32 - 7, x = ie + he | 0, ge ^= x << 9 | x >>> 32 - 9, x = ge + ie | 0, Ae ^= x << 13 | x >>> 32 - 13, x = Ae + ge | 0, he ^= x << 18 | x >>> 32 - 18;
      i[0] = O >>> 0 & 255, i[1] = O >>> 8 & 255, i[2] = O >>> 16 & 255, i[3] = O >>> 24 & 255, i[4] = K >>> 0 & 255, i[5] = K >>> 8 & 255, i[6] = K >>> 16 & 255, i[7] = K >>> 24 & 255, i[8] = $ >>> 0 & 255, i[9] = $ >>> 8 & 255, i[10] = $ >>> 16 & 255, i[11] = $ >>> 24 & 255, i[12] = he >>> 0 & 255, i[13] = he >>> 8 & 255, i[14] = he >>> 16 & 255, i[15] = he >>> 24 & 255, i[16] = L >>> 0 & 255, i[17] = L >>> 8 & 255, i[18] = L >>> 16 & 255, i[19] = L >>> 24 & 255, i[20] = H >>> 0 & 255, i[21] = H >>> 8 & 255, i[22] = H >>> 16 & 255, i[23] = H >>> 24 & 255, i[24] = W >>> 0 & 255, i[25] = W >>> 8 & 255, i[26] = W >>> 16 & 255, i[27] = W >>> 24 & 255, i[28] = z >>> 0 & 255, i[29] = z >>> 8 & 255, i[30] = z >>> 16 & 255, i[31] = z >>> 24 & 255;
    }
    const go = new je([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function U0(i, e, t, r, n, s, o) {
      const a = new je(16), p = new je(64);
      let h, f;
      for (f = 0; f < 16; f++) a[f] = 0;
      for (f = 0; f < 8; f++) a[f] = s[f];
      for (; n >= 64; ) {
        for (pu(p, a, o, go), f = 0; f < 64; f++) i[e + f] = t[r + f] ^ p[f];
        for (h = 1, f = 8; f < 16; f++) h = h + (a[f] & 255) | 0, a[f] = h & 255, h >>>= 8;
        n -= 64, e += 64, r += 64;
      }
      if (n > 0) for (pu(p, a, o, go), f = 0; f < n; f++) i[e + f] = t[r + f] ^ p[f];
      return 0;
    }
    function V0(i, e, t, r, n) {
      const s = new je(16), o = new je(64);
      let a, p;
      for (p = 0; p < 16; p++) s[p] = 0;
      for (p = 0; p < 8; p++) s[p] = r[p];
      for (; t >= 64; ) {
        for (pu(o, s, n, go), p = 0; p < 64; p++) i[e + p] = o[p];
        for (a = 1, p = 8; p < 16; p++) a = a + (s[p] & 255) | 0, s[p] = a & 255, a >>>= 8;
        t -= 64, e += 64;
      }
      if (t > 0) for (pu(o, s, n, go), p = 0; p < t; p++) i[e + p] = o[p];
      return 0;
    }
    function G0(i, e, t, r, n) {
      const s = new je(32), o = new je(8);
      Ly(s, r, n, go);
      for (let a = 0; a < 8; a++) o[a] = r[a + 16];
      return V0(i, e, t, o, s);
    }
    function GA(i, e, t, r, n, s, o) {
      const a = new je(32), p = new je(8);
      Ly(a, s, o, go);
      for (let h = 0; h < 8; h++) p[h] = s[h + 16];
      return U0(i, e, t, r, n, p, a);
    }
    function K0(i) {
      const e = new gf(10), t = new gf(8);
      let r, n, s, o, a, p, h, f;
      return r = i[0] & 255 | (i[1] & 255) << 8, e[0] = r & 8191, n = i[2] & 255 | (i[3] & 255) << 8, e[1] = (r >>> 13 | n << 3) & 8191, s = i[4] & 255 | (i[5] & 255) << 8, e[2] = (n >>> 10 | s << 6) & 7939, o = i[6] & 255 | (i[7] & 255) << 8, e[3] = (s >>> 7 | o << 9) & 8191, a = i[8] & 255 | (i[9] & 255) << 8, e[4] = (o >>> 4 | a << 12) & 255, e[5] = a >>> 1 & 8190, p = i[10] & 255 | (i[11] & 255) << 8, e[6] = (a >>> 14 | p << 2) & 8191, h = i[12] & 255 | (i[13] & 255) << 8, e[7] = (p >>> 11 | h << 5) & 8065, f = i[14] & 255 | (i[15] & 255) << 8, e[8] = (h >>> 8 | f << 8) & 8191, e[9] = f >>> 5 & 127, t[0] = i[16] & 255 | (i[17] & 255) << 8, t[1] = i[18] & 255 | (i[19] & 255) << 8, t[2] = i[20] & 255 | (i[21] & 255) << 8, t[3] = i[22] & 255 | (i[23] & 255) << 8, t[4] = i[24] & 255 | (i[25] & 255) << 8, t[5] = i[26] & 255 | (i[27] & 255) << 8, t[6] = i[28] & 255 | (i[29] & 255) << 8, t[7] = i[30] & 255 | (i[31] & 255) << 8, { buffer: new je(16), r: e, h: new gf(10), pad: t, leftover: 0, fin: 0 };
    }
    function sd(i, e, t, r) {
      const n = i.fin ? 0 : 2048;
      let s, o, a, p, h, f, g, d, y, _, I, S, w, N, B, O, P, C, V;
      const { h: F, r: K } = i;
      let L = F[0], H = F[1], W = F[2], z = F[3], $ = F[4], q = F[5], ie = F[6], ge = F[7], Ae = F[8], he = F[9];
      const x = K[0], ce = K[1], de = K[2], ke = K[3], pe = K[4], j = K[5], re = K[6], se = K[7], ae = K[8], le = K[9];
      for (; r >= 16; ) s = e[t + 0] & 255 | (e[t + 1] & 255) << 8, L += s & 8191, o = e[t + 2] & 255 | (e[t + 3] & 255) << 8, H += (s >>> 13 | o << 3) & 8191, a = e[t + 4] & 255 | (e[t + 5] & 255) << 8, W += (o >>> 10 | a << 6) & 8191, p = e[t + 6] & 255 | (e[t + 7] & 255) << 8, z += (a >>> 7 | p << 9) & 8191, h = e[t + 8] & 255 | (e[t + 9] & 255) << 8, $ += (p >>> 4 | h << 12) & 8191, q += h >>> 1 & 8191, f = e[t + 10] & 255 | (e[t + 11] & 255) << 8, ie += (h >>> 14 | f << 2) & 8191, g = e[t + 12] & 255 | (e[t + 13] & 255) << 8, ge += (f >>> 11 | g << 5) & 8191, d = e[t + 14] & 255 | (e[t + 15] & 255) << 8, Ae += (g >>> 8 | d << 8) & 8191, he += d >>> 5 | n, y = 0, _ = y, _ += L * x, _ += H * (5 * le), _ += W * (5 * ae), _ += z * (5 * se), _ += $ * (5 * re), y = _ >>> 13, _ &= 8191, _ += q * (5 * j), _ += ie * (5 * pe), _ += ge * (5 * ke), _ += Ae * (5 * de), _ += he * (5 * ce), y += _ >>> 13, _ &= 8191, I = y, I += L * ce, I += H * x, I += W * (5 * le), I += z * (5 * ae), I += $ * (5 * se), y = I >>> 13, I &= 8191, I += q * (5 * re), I += ie * (5 * j), I += ge * (5 * pe), I += Ae * (5 * ke), I += he * (5 * de), y += I >>> 13, I &= 8191, S = y, S += L * de, S += H * ce, S += W * x, S += z * (5 * le), S += $ * (5 * ae), y = S >>> 13, S &= 8191, S += q * (5 * se), S += ie * (5 * re), S += ge * (5 * j), S += Ae * (5 * pe), S += he * (5 * ke), y += S >>> 13, S &= 8191, w = y, w += L * ke, w += H * de, w += W * ce, w += z * x, w += $ * (5 * le), y = w >>> 13, w &= 8191, w += q * (5 * ae), w += ie * (5 * se), w += ge * (5 * re), w += Ae * (5 * j), w += he * (5 * pe), y += w >>> 13, w &= 8191, N = y, N += L * pe, N += H * ke, N += W * de, N += z * ce, N += $ * x, y = N >>> 13, N &= 8191, N += q * (5 * le), N += ie * (5 * ae), N += ge * (5 * se), N += Ae * (5 * re), N += he * (5 * j), y += N >>> 13, N &= 8191, B = y, B += L * j, B += H * pe, B += W * ke, B += z * de, B += $ * ce, y = B >>> 13, B &= 8191, B += q * x, B += ie * (5 * le), B += ge * (5 * ae), B += Ae * (5 * se), B += he * (5 * re), y += B >>> 13, B &= 8191, O = y, O += L * re, O += H * j, O += W * pe, O += z * ke, O += $ * de, y = O >>> 13, O &= 8191, O += q * ce, O += ie * x, O += ge * (5 * le), O += Ae * (5 * ae), O += he * (5 * se), y += O >>> 13, O &= 8191, P = y, P += L * se, P += H * re, P += W * j, P += z * pe, P += $ * ke, y = P >>> 13, P &= 8191, P += q * de, P += ie * ce, P += ge * x, P += Ae * (5 * le), P += he * (5 * ae), y += P >>> 13, P &= 8191, C = y, C += L * ae, C += H * se, C += W * re, C += z * j, C += $ * pe, y = C >>> 13, C &= 8191, C += q * ke, C += ie * de, C += ge * ce, C += Ae * x, C += he * (5 * le), y += C >>> 13, C &= 8191, V = y, V += L * le, V += H * ae, V += W * se, V += z * re, V += $ * j, y = V >>> 13, V &= 8191, V += q * pe, V += ie * ke, V += ge * de, V += Ae * ce, V += he * x, y += V >>> 13, V &= 8191, y = (y << 2) + y | 0, y = y + _ | 0, _ = y & 8191, y = y >>> 13, I += y, L = _, H = I, W = S, z = w, $ = N, q = B, ie = O, ge = P, Ae = C, he = V, t += 16, r -= 16;
      F[0] = L, F[1] = H, F[2] = W, F[3] = z, F[4] = $, F[5] = q, F[6] = ie, F[7] = ge, F[8] = Ae, F[9] = he;
    }
    function z0(i, e, t) {
      const r = new je(10);
      let n, s, o, a;
      const { buffer: p, h, pad: f, leftover: g } = i;
      if (g) {
        for (a = g, p[a++] = 1; a < 16; a++) p[a] = 0;
        i.fin = 1, sd(i, p, 0, 16);
      }
      for (n = h[1] >>> 13, h[1] &= 8191, a = 2; a < 10; a++) h[a] += n, n = h[a] >>> 13, h[a] &= 8191;
      for (h[0] += n * 5, n = h[0] >>> 13, h[0] &= 8191, h[1] += n, n = h[1] >>> 13, h[1] &= 8191, h[2] += n, r[0] = h[0] + 5, n = r[0] >>> 13, r[0] &= 8191, a = 1; a < 10; a++) r[a] = h[a] + n, n = r[a] >>> 13, r[a] &= 8191;
      for (r[9] -= 8192, s = (n ^ 1) - 1, a = 0; a < 10; a++) r[a] &= s;
      for (s = ~s, a = 0; a < 10; a++) h[a] = h[a] & s | r[a];
      for (h[0] = (h[0] | h[1] << 13) & 65535, h[1] = (h[1] >>> 3 | h[2] << 10) & 65535, h[2] = (h[2] >>> 6 | h[3] << 7) & 65535, h[3] = (h[3] >>> 9 | h[4] << 4) & 65535, h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535, h[5] = (h[6] >>> 2 | h[7] << 11) & 65535, h[6] = (h[7] >>> 5 | h[8] << 8) & 65535, h[7] = (h[8] >>> 8 | h[9] << 5) & 65535, o = h[0] + f[0], h[0] = o & 65535, a = 1; a < 8; a++) o = (h[a] + f[a] | 0) + (o >>> 16) | 0, h[a] = o & 65535;
      e[t + 0] = h[0] >>> 0 & 255, e[t + 1] = h[0] >>> 8 & 255, e[t + 2] = h[1] >>> 0 & 255, e[t + 3] = h[1] >>> 8 & 255, e[t + 4] = h[2] >>> 0 & 255, e[t + 5] = h[2] >>> 8 & 255, e[t + 6] = h[3] >>> 0 & 255, e[t + 7] = h[3] >>> 8 & 255, e[t + 8] = h[4] >>> 0 & 255, e[t + 9] = h[4] >>> 8 & 255, e[t + 10] = h[5] >>> 0 & 255, e[t + 11] = h[5] >>> 8 & 255, e[t + 12] = h[6] >>> 0 & 255, e[t + 13] = h[6] >>> 8 & 255, e[t + 14] = h[7] >>> 0 & 255, e[t + 15] = h[7] >>> 8 & 255;
    }
    function j0(i, e, t, r) {
      let n, s;
      const { buffer: o } = i;
      if (i.leftover) {
        for (s = 16 - i.leftover, s > r && (s = r), n = 0; n < s; n++) o[i.leftover + n] = e[t + n];
        if (r -= s, t += s, i.leftover += s, i.leftover < 16) return;
        sd(i, o, 0, 16), i.leftover = 0;
      }
      if (r >= 16 && (s = r - r % 16, sd(i, e, t, s), t += s, r -= s), r) {
        for (n = 0; n < r; n++) o[i.leftover + n] = e[t + n];
        i.leftover += r;
      }
    }
    function J0(i, e, t) {
      sc(i, e, t), YA(t, e);
      const r = new je(32 + i.length), n = new je(r.length);
      for (let s = 0; s < i.length; s++) r[s + 32] = i[s];
      return Q0(n, r, r.length, e, t), n.subarray(16);
    }
    function Y0(i, e, t) {
      sc(i, e, t), YA(t, e);
      const r = new je(16 + i.length), n = new je(r.length);
      for (let s = 0; s < i.length; s++) r[s + 16] = i[s];
      if (!(r.length < 32 || W0(n, r, r.length, e, t) !== 0)) return n.subarray(32);
    }
    function Q0(i, e, t, r, n) {
      if (t < 32) return -1;
      GA(i, 0, e, 0, t, r, n), KA(i, 16, i, 32, t - 32, i);
      for (let s = 0; s < 16; s++) i[s] = 0;
      return 0;
    }
    function W0(i, e, t, r, n) {
      const s = new je(32);
      if (t < 32 || (G0(s, 0, 32, r, n), X0(e, 16, e, 32, t - 32, s) !== 0)) return -1;
      GA(i, 0, e, 0, t, r, n);
      for (let o = 0; o < 32; o++) i[o] = 0;
      return 0;
    }
    function KA(i, e, t, r, n, s) {
      const o = K0(s);
      return j0(o, t, r, n), z0(o, i, e), 0;
    }
    function X0(i, e, t, r, n, s) {
      const o = new je(16);
      return KA(o, 0, t, r, n, s), lS(i, e, o, 0);
    }
    function Oe(i) {
      const e = new Ll(16);
      return i && e.set(i), e;
    }
    const q0 = new je(16);
    const Z0 = new je(32);
    Z0[0] = 9;
    const id = Oe();
    const Ya = Oe([1]);
    const eS = Oe([56129, 1]);
    const tS = Oe([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]);
    const rS = Oe([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]);
    const x_ = Oe([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]);
    const O_ = Oe([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]);
    const nS = Oe([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function Ln(i, e, t) {
      for (let r = 0; r < 16; r++) i[r] = e[r] + t[r];
    }
    function vn(i, e, t) {
      for (let r = 0; r < 16; r++) i[r] = e[r] - t[r];
    }
    function Ye(i, e, t) {
      let r, n, s = 0, o = 0, a = 0, p = 0, h = 0, f = 0, g = 0, d = 0, y = 0, _ = 0, I = 0, S = 0, w = 0, N = 0, B = 0, O = 0, P = 0, C = 0, V = 0, F = 0, K = 0, L = 0, H = 0, W = 0, z = 0, $ = 0, q = 0, ie = 0, ge = 0, Ae = 0, he = 0, x = t[0], ce = t[1], de = t[2], ke = t[3], pe = t[4], j = t[5], re = t[6], se = t[7], ae = t[8], le = t[9], Pe = t[10], Ke = t[11], Qe = t[12], tt = t[13], yt = t[14], jt = t[15];
      r = e[0], s += r * x, o += r * ce, a += r * de, p += r * ke, h += r * pe, f += r * j, g += r * re, d += r * se, y += r * ae, _ += r * le, I += r * Pe, S += r * Ke, w += r * Qe, N += r * tt, B += r * yt, O += r * jt, r = e[1], o += r * x, a += r * ce, p += r * de, h += r * ke, f += r * pe, g += r * j, d += r * re, y += r * se, _ += r * ae, I += r * le, S += r * Pe, w += r * Ke, N += r * Qe, B += r * tt, O += r * yt, P += r * jt, r = e[2], a += r * x, p += r * ce, h += r * de, f += r * ke, g += r * pe, d += r * j, y += r * re, _ += r * se, I += r * ae, S += r * le, w += r * Pe, N += r * Ke, B += r * Qe, O += r * tt, P += r * yt, C += r * jt, r = e[3], p += r * x, h += r * ce, f += r * de, g += r * ke, d += r * pe, y += r * j, _ += r * re, I += r * se, S += r * ae, w += r * le, N += r * Pe, B += r * Ke, O += r * Qe, P += r * tt, C += r * yt, V += r * jt, r = e[4], h += r * x, f += r * ce, g += r * de, d += r * ke, y += r * pe, _ += r * j, I += r * re, S += r * se, w += r * ae, N += r * le, B += r * Pe, O += r * Ke, P += r * Qe, C += r * tt, V += r * yt, F += r * jt, r = e[5], f += r * x, g += r * ce, d += r * de, y += r * ke, _ += r * pe, I += r * j, S += r * re, w += r * se, N += r * ae, B += r * le, O += r * Pe, P += r * Ke, C += r * Qe, V += r * tt, F += r * yt, K += r * jt, r = e[6], g += r * x, d += r * ce, y += r * de, _ += r * ke, I += r * pe, S += r * j, w += r * re, N += r * se, B += r * ae, O += r * le, P += r * Pe, C += r * Ke, V += r * Qe, F += r * tt, K += r * yt, L += r * jt, r = e[7], d += r * x, y += r * ce, _ += r * de, I += r * ke, S += r * pe, w += r * j, N += r * re, B += r * se, O += r * ae, P += r * le, C += r * Pe, V += r * Ke, F += r * Qe, K += r * tt, L += r * yt, H += r * jt, r = e[8], y += r * x, _ += r * ce, I += r * de, S += r * ke, w += r * pe, N += r * j, B += r * re, O += r * se, P += r * ae, C += r * le, V += r * Pe, F += r * Ke, K += r * Qe, L += r * tt, H += r * yt, W += r * jt, r = e[9], _ += r * x, I += r * ce, S += r * de, w += r * ke, N += r * pe, B += r * j, O += r * re, P += r * se, C += r * ae, V += r * le, F += r * Pe, K += r * Ke, L += r * Qe, H += r * tt, W += r * yt, z += r * jt, r = e[10], I += r * x, S += r * ce, w += r * de, N += r * ke, B += r * pe, O += r * j, P += r * re, C += r * se, V += r * ae, F += r * le, K += r * Pe, L += r * Ke, H += r * Qe, W += r * tt, z += r * yt, $ += r * jt, r = e[11], S += r * x, w += r * ce, N += r * de, B += r * ke, O += r * pe, P += r * j, C += r * re, V += r * se, F += r * ae, K += r * le, L += r * Pe, H += r * Ke, W += r * Qe, z += r * tt, $ += r * yt, q += r * jt, r = e[12], w += r * x, N += r * ce, B += r * de, O += r * ke, P += r * pe, C += r * j, V += r * re, F += r * se, K += r * ae, L += r * le, H += r * Pe, W += r * Ke, z += r * Qe, $ += r * tt, q += r * yt, ie += r * jt, r = e[13], N += r * x, B += r * ce, O += r * de, P += r * ke, C += r * pe, V += r * j, F += r * re, K += r * se, L += r * ae, H += r * le, W += r * Pe, z += r * Ke, $ += r * Qe, q += r * tt, ie += r * yt, ge += r * jt, r = e[14], B += r * x, O += r * ce, P += r * de, C += r * ke, V += r * pe, F += r * j, K += r * re, L += r * se, H += r * ae, W += r * le, z += r * Pe, $ += r * Ke, q += r * Qe, ie += r * tt, ge += r * yt, Ae += r * jt, r = e[15], O += r * x, P += r * ce, C += r * de, V += r * ke, F += r * pe, K += r * j, L += r * re, H += r * se, W += r * ae, z += r * le, $ += r * Pe, q += r * Ke, ie += r * Qe, ge += r * tt, Ae += r * yt, he += r * jt, s += 38 * P, o += 38 * C, a += 38 * V, p += 38 * F, h += 38 * K, f += 38 * L, g += 38 * H, d += 38 * W, y += 38 * z, _ += 38 * $, I += 38 * q, S += 38 * ie, w += 38 * ge, N += 38 * Ae, B += 38 * he, n = 1, r = s + n + 65535, n = Math.floor(r / 65536), s = r - n * 65536, r = o + n + 65535, n = Math.floor(r / 65536), o = r - n * 65536, r = a + n + 65535, n = Math.floor(r / 65536), a = r - n * 65536, r = p + n + 65535, n = Math.floor(r / 65536), p = r - n * 65536, r = h + n + 65535, n = Math.floor(r / 65536), h = r - n * 65536, r = f + n + 65535, n = Math.floor(r / 65536), f = r - n * 65536, r = g + n + 65535, n = Math.floor(r / 65536), g = r - n * 65536, r = d + n + 65535, n = Math.floor(r / 65536), d = r - n * 65536, r = y + n + 65535, n = Math.floor(r / 65536), y = r - n * 65536, r = _ + n + 65535, n = Math.floor(r / 65536), _ = r - n * 65536, r = I + n + 65535, n = Math.floor(r / 65536), I = r - n * 65536, r = S + n + 65535, n = Math.floor(r / 65536), S = r - n * 65536, r = w + n + 65535, n = Math.floor(r / 65536), w = r - n * 65536, r = N + n + 65535, n = Math.floor(r / 65536), N = r - n * 65536, r = B + n + 65535, n = Math.floor(r / 65536), B = r - n * 65536, r = O + n + 65535, n = Math.floor(r / 65536), O = r - n * 65536, s += n - 1 + 37 * (n - 1), n = 1, r = s + n + 65535, n = Math.floor(r / 65536), s = r - n * 65536, r = o + n + 65535, n = Math.floor(r / 65536), o = r - n * 65536, r = a + n + 65535, n = Math.floor(r / 65536), a = r - n * 65536, r = p + n + 65535, n = Math.floor(r / 65536), p = r - n * 65536, r = h + n + 65535, n = Math.floor(r / 65536), h = r - n * 65536, r = f + n + 65535, n = Math.floor(r / 65536), f = r - n * 65536, r = g + n + 65535, n = Math.floor(r / 65536), g = r - n * 65536, r = d + n + 65535, n = Math.floor(r / 65536), d = r - n * 65536, r = y + n + 65535, n = Math.floor(r / 65536), y = r - n * 65536, r = _ + n + 65535, n = Math.floor(r / 65536), _ = r - n * 65536, r = I + n + 65535, n = Math.floor(r / 65536), I = r - n * 65536, r = S + n + 65535, n = Math.floor(r / 65536), S = r - n * 65536, r = w + n + 65535, n = Math.floor(r / 65536), w = r - n * 65536, r = N + n + 65535, n = Math.floor(r / 65536), N = r - n * 65536, r = B + n + 65535, n = Math.floor(r / 65536), B = r - n * 65536, r = O + n + 65535, n = Math.floor(r / 65536), O = r - n * 65536, s += n - 1 + 37 * (n - 1), i[0] = s, i[1] = o, i[2] = a, i[3] = p, i[4] = h, i[5] = f, i[6] = g, i[7] = d, i[8] = y, i[9] = _, i[10] = I, i[11] = S, i[12] = w, i[13] = N, i[14] = B, i[15] = O;
    }
    function Hn(i, e) {
      Ye(i, e, e);
    }
    const C_ = 65536;
    function sS(i, e) {
      for (let t = 0; t < e; t += C_) crypto.getRandomValues(i.subarray(t, t + Math.min(e - t, C_)));
    }
    function oi(i, e) {
      for (let t = 0; t < 16; t++) i[t] = e[t] | 0;
    }
    function df(i) {
      let e, t, r = 1;
      for (e = 0; e < 16; e++) t = i[e] + r + 65535, r = Math.floor(t / 65536), i[e] = t - r * 65536;
      i[0] += r - 1 + 37 * (r - 1);
    }
    function ra(i, e, t) {
      let r, n = ~(t - 1);
      for (let s = 0; s < 16; s++) r = n & (i[s] ^ e[s]), i[s] ^= r, e[s] ^= r;
    }
    function Qa(i, e) {
      const t = Oe(), r = Oe();
      let n, s, o;
      for (n = 0; n < 16; n++) r[n] = e[n];
      for (df(r), df(r), df(r), s = 0; s < 2; s++) {
        for (t[0] = r[0] - 65517, n = 1; n < 15; n++) t[n] = r[n] - 65535 - (t[n - 1] >> 16 & 1), t[n - 1] &= 65535;
        t[15] = r[15] - 32767 - (t[14] >> 16 & 1), o = t[15] >> 16 & 1, t[14] &= 65535, ra(r, t, 1 - o);
      }
      for (n = 0; n < 16; n++) i[2 * n] = r[n] & 255, i[2 * n + 1] = r[n] >> 8;
    }
    function R_(i, e) {
      const t = new je(32), r = new je(32);
      return Qa(t, i), Qa(r, e), WA(t, 0, r, 0);
    }
    function zA(i) {
      const e = new je(32);
      return Qa(e, i), e[0] & 1;
    }
    function jA(i, e) {
      for (let t = 0; t < 16; t++) i[t] = e[2 * t] + (e[2 * t + 1] << 8);
      i[15] &= 32767;
    }
    function Hy(i, e) {
      const t = Oe();
      let r;
      for (r = 0; r < 16; r++) t[r] = e[r];
      for (r = 253; r >= 0; r--) Hn(t, t), r !== 2 && r !== 4 && Ye(t, t, e);
      for (r = 0; r < 16; r++) i[r] = t[r];
    }
    function iS(i, e, t) {
      const r = new je(32), n = new Ll(80), s = Oe(), o = Oe(), a = Oe(), p = Oe(), h = Oe(), f = Oe();
      let g, d;
      for (d = 0; d < 31; d++) r[d] = e[d];
      for (r[31] = e[31] & 127 | 64, r[0] &= 248, jA(n, t), d = 0; d < 16; d++) o[d] = n[d], p[d] = s[d] = a[d] = 0;
      for (s[0] = p[0] = 1, d = 254; d >= 0; --d) g = r[d >>> 3] >>> (d & 7) & 1, ra(s, o, g), ra(a, p, g), Ln(h, s, a), vn(s, s, a), Ln(a, o, p), vn(o, o, p), Hn(p, h), Hn(f, s), Ye(s, a, s), Ye(a, o, h), Ln(h, s, a), vn(s, s, a), Hn(o, s), vn(a, p, f), Ye(s, a, eS), Ln(s, s, p), Ye(a, a, s), Ye(s, p, f), Ye(p, o, n), Hn(o, h), ra(s, o, g), ra(a, p, g);
      for (d = 0; d < 16; d++) n[d + 16] = s[d], n[d + 32] = a[d], n[d + 48] = o[d], n[d + 64] = p[d];
      const y = n.subarray(32), _ = n.subarray(16);
      return Hy(y, y), Ye(_, _, y), Qa(i, _), 0;
    }
    function oS(i, e, t, r) {
      const n = JA(t, r);
      return J0(i, e, n);
    }
    function JA(i, e) {
      sc(i, e), pS(i, e);
      const t = new je(32);
      return cS(t, i, e), t;
    }
    function aS(i, e, t, r) {
      const n = JA(t, r);
      return Y0(i, e, n);
    }
    function cS(i, e, t) {
      const r = new je(32);
      return iS(r, t, e), Ly(i, q0, r, go);
    }
    function YA(i, e) {
      if (i.length !== 32) throw new Error("bad key size");
      if (e.length !== 24) throw new Error("bad nonce size");
    }
    function pS(i, e) {
      if (i.length !== 32) throw new Error("bad public key size");
      if (e.length !== 32) throw new Error("bad secret key size");
    }
    function sc(...i) {
      for (const e of i) if (!(e instanceof Uint8Array)) throw new TypeError("unexpected type, use ByteArray");
    }
    function QA(i, e, t, r, n) {
      let s, o = 0;
      for (s = 0; s < n; s++) o |= i[e + s] ^ t[r + s];
      return (1 & o - 1 >>> 8) - 1;
    }
    function lS(i, e, t, r) {
      return QA(i, e, t, r, 16);
    }
    function WA(i, e, t, r) {
      return QA(i, e, t, r, 32);
    }
    function na(i, e, t) {
      const r = new cu(8), n = new cu(8), s = new je(256);
      let o, a = t;
      for (r[0] = 1779033703, r[1] = 3144134277, r[2] = 1013904242, r[3] = 2773480762, r[4] = 1359893119, r[5] = 2600822924, r[6] = 528734635, r[7] = 1541459225, n[0] = 4089235720, n[1] = 2227873595, n[2] = 4271175723, n[3] = 1595750129, n[4] = 2917565137, n[5] = 725511199, n[6] = 4215389547, n[7] = 327033209, P_(r, n, e, t), t %= 128, o = 0; o < t; o++) s[o] = e[a - t + o];
      for (s[t] = 128, t = 256 - 128 * (t < 112 ? 1 : 0), s[t - 9] = 0, M_(s, t - 8, a / 536870912 | 0, a << 3), P_(r, n, s, t), o = 0; o < 8; o++) M_(i, 8 * o, r[o], n[o]);
      return 0;
    }
    const B_ = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function P_(i, e, t, r) {
      const n = new cu(16), s = new cu(16);
      let o, a, p, h, f, g, d, y, _, I, S, w, N, B, O, P, C, V, F, K, L, H, W, z, $, q, ie = i[0], ge = i[1], Ae = i[2], he = i[3], x = i[4], ce = i[5], de = i[6], ke = i[7], pe = e[0], j = e[1], re = e[2], se = e[3], ae = e[4], le = e[5], Pe = e[6], Ke = e[7], Qe = 0;
      for (; r >= 128; ) {
        for (F = 0; F < 16; F++) K = 8 * F + Qe, n[F] = t[K + 0] << 24 | t[K + 1] << 16 | t[K + 2] << 8 | t[K + 3], s[F] = t[K + 4] << 24 | t[K + 5] << 16 | t[K + 6] << 8 | t[K + 7];
        for (F = 0; F < 80; F++) if (o = ie, a = ge, p = Ae, h = he, f = x, g = ce, d = de, y = ke, _ = pe, I = j, S = re, w = se, N = ae, B = le, O = Pe, P = Ke, L = ke, H = Ke, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = (x >>> 14 | ae << 32 - 14) ^ (x >>> 18 | ae << 32 - 18) ^ (ae >>> 41 - 32 | x << 32 - (41 - 32)), H = (ae >>> 14 | x << 32 - 14) ^ (ae >>> 18 | x << 32 - 18) ^ (x >>> 41 - 32 | ae << 32 - (41 - 32)), W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, L = x & ce ^ ~x & de, H = ae & le ^ ~ae & Pe, W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, L = B_[F * 2], H = B_[F * 2 + 1], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, L = n[F % 16], H = s[F % 16], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, C = $ & 65535 | q << 16, V = W & 65535 | z << 16, L = C, H = V, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = (ie >>> 28 | pe << 32 - 28) ^ (pe >>> 34 - 32 | ie << 32 - (34 - 32)) ^ (pe >>> 39 - 32 | ie << 32 - (39 - 32)), H = (pe >>> 28 | ie << 32 - 28) ^ (ie >>> 34 - 32 | pe << 32 - (34 - 32)) ^ (ie >>> 39 - 32 | pe << 32 - (39 - 32)), W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, L = ie & ge ^ ie & Ae ^ ge & Ae, H = pe & j ^ pe & re ^ j & re, W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, y = $ & 65535 | q << 16, P = W & 65535 | z << 16, L = h, H = w, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = C, H = V, W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, h = $ & 65535 | q << 16, w = W & 65535 | z << 16, ge = o, Ae = a, he = p, x = h, ce = f, de = g, ke = d, ie = y, j = _, re = I, se = S, ae = w, le = N, Pe = B, Ke = O, pe = P, F % 16 === 15) for (K = 0; K < 16; K++) L = n[K], H = s[K], W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = n[(K + 9) % 16], H = s[(K + 9) % 16], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, C = n[(K + 1) % 16], V = s[(K + 1) % 16], L = (C >>> 1 | V << 32 - 1) ^ (C >>> 8 | V << 32 - 8) ^ C >>> 7, H = (V >>> 1 | C << 32 - 1) ^ (V >>> 8 | C << 32 - 8) ^ (V >>> 7 | C << 32 - 7), W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, C = n[(K + 14) % 16], V = s[(K + 14) % 16], L = (C >>> 19 | V << 32 - 19) ^ (V >>> 61 - 32 | C << 32 - (61 - 32)) ^ C >>> 6, H = (V >>> 19 | C << 32 - 19) ^ (C >>> 61 - 32 | V << 32 - (61 - 32)) ^ (V >>> 6 | C << 32 - 6), W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, n[K] = $ & 65535 | q << 16, s[K] = W & 65535 | z << 16;
        L = ie, H = pe, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = i[0], H = e[0], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, i[0] = ie = $ & 65535 | q << 16, e[0] = pe = W & 65535 | z << 16, L = ge, H = j, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = i[1], H = e[1], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, i[1] = ge = $ & 65535 | q << 16, e[1] = j = W & 65535 | z << 16, L = Ae, H = re, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = i[2], H = e[2], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, i[2] = Ae = $ & 65535 | q << 16, e[2] = re = W & 65535 | z << 16, L = he, H = se, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = i[3], H = e[3], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, i[3] = he = $ & 65535 | q << 16, e[3] = se = W & 65535 | z << 16, L = x, H = ae, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = i[4], H = e[4], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, i[4] = x = $ & 65535 | q << 16, e[4] = ae = W & 65535 | z << 16, L = ce, H = le, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = i[5], H = e[5], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, i[5] = ce = $ & 65535 | q << 16, e[5] = le = W & 65535 | z << 16, L = de, H = Pe, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = i[6], H = e[6], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, i[6] = de = $ & 65535 | q << 16, e[6] = Pe = W & 65535 | z << 16, L = ke, H = Ke, W = H & 65535, z = H >>> 16, $ = L & 65535, q = L >>> 16, L = i[7], H = e[7], W += H & 65535, z += H >>> 16, $ += L & 65535, q += L >>> 16, z += W >>> 16, $ += z >>> 16, q += $ >>> 16, i[7] = ke = $ & 65535 | q << 16, e[7] = Ke = W & 65535 | z << 16, Qe += 128, r -= 128;
      }
      return r;
    }
    function M_(i, e, t, r) {
      i[e] = t >> 24 & 255, i[e + 1] = t >> 16 & 255, i[e + 2] = t >> 8 & 255, i[e + 3] = t & 255, i[e + 4] = r >> 24 & 255, i[e + 5] = r >> 16 & 255, i[e + 6] = r >> 8 & 255, i[e + 7] = r & 255;
    }
    function hS(i, e) {
      if (sc(i, e), e.length !== 64) throw new Error("bad secret key size");
      const t = new je(64 + i.length);
      return yS(t, i, i.length, e), t;
    }
    function uS(i, e) {
      const t = hS(i, e), r = new je(64);
      for (let n = 0; n < r.length; n++) r[n] = t[n];
      return r;
    }
    function fS(i, e, t) {
      if (sc(i, e, t), e.length !== 64) throw new Error("bad signature size");
      if (t.length !== 32) throw new Error("bad public key size");
      const r = new je(64 + i.length), n = new je(64 + i.length);
      return r.set(e), r.set(i, 64), mS(n, r, r.length, t) >= 0;
    }
    function gS(i) {
      if (sc(i), i.length !== 32) throw new Error("bad seed size");
      const e = new je(32), t = new je(64);
      for (let r = 0; r < 32; r++) t[r] = i[r];
      return dS(e, t, true), { publicKey: e, secretKey: t };
    }
    function dS(i, e, t) {
      const r = new je(64), n = [Oe(), Oe(), Oe(), Oe()];
      let s;
      for (t || sS(e, 32), na(r, e, 32), r[0] &= 248, r[31] &= 127, r[31] |= 64, vy(n, r), ky(i, n), s = 0; s < 32; s++) e[s + 32] = i[s];
      return 0;
    }
    function yS(i, e, t, r) {
      const n = new je(64), s = new je(64), o = new je(64), a = new Ll(64), p = [Oe(), Oe(), Oe(), Oe()];
      let h, f;
      na(n, r, 32), n[0] &= 248, n[31] &= 127, n[31] |= 64;
      const g = t + 64;
      for (h = 0; h < t; h++) i[64 + h] = e[h];
      for (h = 0; h < 32; h++) i[32 + h] = n[32 + h];
      for (na(o, i.subarray(32), t + 32), od(o), vy(p, o), ky(i, p), h = 32; h < 64; h++) i[h] = r[h];
      for (na(s, i, t + 64), od(s), h = 0; h < 64; h++) a[h] = 0;
      for (h = 0; h < 32; h++) a[h] = o[h];
      for (h = 0; h < 32; h++) for (f = 0; f < 32; f++) a[h + f] += s[h] * n[f];
      return ZA(i.subarray(32), a), g;
    }
    function mS(i, e, t, r) {
      const n = new je(32), s = new je(64), o = [Oe(), Oe(), Oe(), Oe()], a = [Oe(), Oe(), Oe(), Oe()];
      let p, h;
      if (h = -1, t < 64 || qA(a, r)) return -1;
      for (p = 0; p < t; p++) i[p] = e[p];
      for (p = 0; p < 32; p++) i[p + 32] = r[p];
      if (na(s, i, t), od(s), XA(o, a, s), vy(a, e.subarray(32)), ad(o, a), ky(n, o), t -= 64, WA(e, 0, n, 0)) {
        for (p = 0; p < t; p++) i[p] = 0;
        return -1;
      }
      for (p = 0; p < t; p++) i[p] = e[p + 64];
      return h = t, h;
    }
    function vy(i, e) {
      const t = [Oe(), Oe(), Oe(), Oe()];
      oi(t[0], x_), oi(t[1], O_), oi(t[2], Ya), Ye(t[3], x_, O_), XA(i, t, e);
    }
    function XA(i, e, t) {
      let r, n;
      for (oi(i[0], id), oi(i[1], Ya), oi(i[2], Ya), oi(i[3], id), n = 255; n >= 0; --n) r = t[n / 8 | 0] >> (n & 7) & 1, L_(i, e, r), ad(e, i), ad(i, i), L_(i, e, r);
    }
    function ky(i, e) {
      const t = Oe(), r = Oe(), n = Oe();
      Hy(n, e[2]), Ye(t, e[0], n), Ye(r, e[1], n), Qa(i, r), i[31] ^= zA(t) << 7;
    }
    function qA(i, e) {
      const t = Oe(), r = Oe(), n = Oe(), s = Oe(), o = Oe(), a = Oe(), p = Oe();
      return oi(i[2], Ya), jA(i[1], e), Hn(n, i[1]), Ye(s, n, tS), vn(n, n, i[2]), Ln(s, i[2], s), Hn(o, s), Hn(a, o), Ye(p, a, o), Ye(t, p, n), Ye(t, t, s), _S(t, t), Ye(t, t, n), Ye(t, t, s), Ye(t, t, s), Ye(i[0], t, s), Hn(r, i[0]), Ye(r, r, s), R_(r, n) && Ye(i[0], i[0], nS), Hn(r, i[0]), Ye(r, r, s), R_(r, n) ? -1 : (zA(i[0]) === e[31] >> 7 && vn(i[0], id, i[0]), Ye(i[3], i[0], i[1]), 0);
    }
    function od(i) {
      const e = new Ll(64);
      let t;
      for (t = 0; t < 64; t++) e[t] = i[t];
      for (t = 0; t < 64; t++) i[t] = 0;
      ZA(i, e);
    }
    const yf = new Ll([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function ZA(i, e) {
      let t, r, n, s;
      for (r = 63; r >= 32; --r) {
        for (t = 0, n = r - 32, s = r - 12; n < s; ++n) e[n] += t - 16 * e[r] * yf[n - (r - 32)], t = Math.floor((e[n] + 128) / 256), e[n] -= t * 256;
        e[n] += t, e[r] = 0;
      }
      for (t = 0, n = 0; n < 32; n++) e[n] += t - (e[31] >> 4) * yf[n], t = e[n] >> 8, e[n] &= 255;
      for (n = 0; n < 32; n++) e[n] -= t * yf[n];
      for (r = 0; r < 32; r++) e[r + 1] += e[r] >> 8, i[r] = e[r] & 255;
    }
    function ad(i, e) {
      const t = Oe(), r = Oe(), n = Oe(), s = Oe(), o = Oe(), a = Oe(), p = Oe(), h = Oe(), f = Oe();
      vn(t, i[1], i[0]), vn(f, e[1], e[0]), Ye(t, t, f), Ln(r, i[0], i[1]), Ln(f, e[0], e[1]), Ye(r, r, f), Ye(n, i[3], e[3]), Ye(n, n, rS), Ye(s, i[2], e[2]), Ln(s, s, s), vn(o, r, t), vn(a, s, n), Ln(p, s, n), Ln(h, r, t), Ye(i[0], o, a), Ye(i[1], h, p), Ye(i[2], p, a), Ye(i[3], o, h);
    }
    function L_(i, e, t) {
      for (let r = 0; r < 4; r++) ra(i[r], e[r], t);
    }
    function _S(i, e) {
      const t = Oe();
      let r;
      for (r = 0; r < 16; r++) t[r] = e[r];
      for (r = 250; r >= 0; r--) Hn(t, t), r !== 1 && Ye(t, t, e);
      for (r = 0; r < 16; r++) i[r] = t[r];
    }
    const AS = { create(i) {
      const e = gS(i);
      return { secretKey: wr.from(e.secretKey), publicKey: wr.from(e.publicKey) };
    }, detached_sign(i, e) {
      return wr.from(uS(i, e));
    }, detached_verify(i, e, t) {
      return fS(i, e, t);
    }, box(i, e, t, r = new Uint8Array(24)) {
      return { encryptedMessage: oS(i, r, e, t), nonce: r };
    }, open(i, e, t, r) {
      return aS(i, e, t, r) || false;
    } };
    function ES(i) {
      let e = new Uint8Array(32), t = [Oe(), Oe(), Oe(), Oe()], r = Oe(), n = Oe();
      if (qA(t, i)) throw new TypeError("invalid public key");
      let s = t[1];
      return Ln(r, Ya, s), vn(n, Ya, s), Hy(n, n), Ye(r, r, n), Qa(e, r), e;
    }
    function IS(i) {
      let e = new Uint8Array(64), t = new Uint8Array(32), r;
      for (na(e, i, 32), e[0] &= 248, e[31] &= 127, e[31] |= 64, r = 0; r < 32; r++) t[r] = e[r];
      for (r = 0; r < 64; r++) e[r] = 0;
      return t;
    }
    const TS = { convertPublicKey: ES, convertSecretKey: IS };
    let H_ = class {
      createRemark(e) {
        return Rc.fromObject({ remark: e });
      }
    };
    H_ = l([J()], H_);
    const SS = { CURRENT_HEIGHT: /* @__PURE__ */ Symbol("currentHeight") };
    let yo = class {
      constructor(e = 0) {
        this.currentHeight = e, this.emitter = new An(), this.emitter.on("height", (t) => {
          const r = this.currentHeight;
          this.currentHeight = t, this.emitter.emit("heightChanged", { oldHeight: r, newHeight: t });
        });
      }
      changeHeight(e) {
        this.emitter.emit("height", e);
      }
      onHeightChanged(e) {
        this.emitter.on("heightChanged", e);
      }
      planAfterHeight(e, t, r) {
        let n = 0;
        this.emitter.on("heightChanged", ({ newHeight: s, oldHeight: o }) => {
          s > o ? s >= e && n !== 1 && (t(), n = 1) : s < e && n !== 0 && (r(), n = 0);
        }), this.currentHeight >= e && (t(), n = 1);
      }
      get version() {
        return this._version;
      }
    };
    l([D(ne), u("design:type", ne)], yo.prototype, "config", void 0);
    l([D(dl), u("design:type", dl)], yo.prototype, "block", void 0);
    l([D("blockGetterHelper", { optional: true, dynamics: true }), u("design:type", Object)], yo.prototype, "blockGetterHelper", void 0);
    yo = l([J({ group: true }), be(0, D(SS.CURRENT_HEIGHT, { optional: true })), u("design:paramtypes", [Number])], yo);
    let cd = class extends eh {
      constructor(e, t) {
        super(), this.moduleMap = e, this.config = t, this._consensusVersionAndHeightMap = /* @__PURE__ */ new Map(), this._lastConsensusVersion = 1, this._lastPatchEffectiveHeight = 1, this._patchVersionMap = new wt(() => 0);
      }
      bfAfterInit() {
        this._isPatchReady = this._installPatchs().then(() => {
          this._isPatchReady = void 0;
        });
      }
      get lastConsensusVersion() {
        return this._lastConsensusVersion;
      }
      get lastPatchEffectiveHeight() {
        return this._lastPatchEffectiveHeight;
      }
      _installPatch(e) {
        bt(e, this.moduleMap);
      }
      async getPatchEffectiveAfterHeightByVersion(e) {
        let t = 0;
        if (e <= 1) return 0;
        await this._isPatchReady;
        for (const [r, n] of this._consensusVersionAndHeightMap.entries()) {
          if (e === r) return n;
          t = n;
        }
        return t;
      }
      async changeHeight(e) {
        await this._isPatchReady;
        const t = this.moduleMap.groupGet(yo);
        for (const r of t) r.changeHeight(e);
      }
      async _installPatchs() {
        const e = [...this.moduleMap.groupGet(yo)];
        e.sort((n, s) => n.version - s.version);
        const t = new wt((n) => e.filter((s) => s.name === n).toSorted((s, o) => o.version - s.version)[0].version), r = new An();
        this.config.version;
        try {
          for (const n of e) {
            r.emit("progress", n);
            const s = this._patchVersionMap.forceGet(n.name);
            if (s < n.version) {
              this._consensusVersionAndHeightMap.set(n.consensusVersion, n.patchEffectiveAfterHeight);
              const o = t.forceGet(n.name);
              await n.upgradeHandler(s, o), this._patchVersionMap.set(n.name, n.version), this._lastConsensusVersion < n.consensusVersion && (this._lastConsensusVersion = n.consensusVersion), this._lastPatchEffectiveHeight < n.patchEffectiveAfterHeight && (this._lastPatchEffectiveHeight = n.patchEffectiveAfterHeight);
            }
          }
          r.emit("done");
        } catch (n) {
          this.emit("error", n), r.emit("error", n);
        }
        this.config.version;
      }
    };
    cd = l([J(), u("design:paramtypes", [ze, ne])], cd);
    let Il = class {
      constructor(e, t, r, n, s, o, a, p, h, f, g, d, y, _, I, S, w, N, B, O, P, C, V, F, K, L, H, W) {
        this.config = e, this.cryptoHelper = t, this.keypairHelper = r, this.ed2curveHelper = n, this.Buffer = s, this.base58Helper = o, this.jsbiHelper = a, this.asymmetricHelper = p, this.accountBaseHelper = h, this.transactionHelper = f, this.blockHelper = g, this.parityBitHelper = d, this.baseHelper = y, this.chainAssetInfoHelper = _, this.migrateCertificateHelper = I, this.registerChainCertificateHelper = S, this.complexTransactionLogicHelper = w, this.configMap = N, this.block = B, this.blockLogicVerifier = O, this.blockTicker = P, this.transaction = C, this.transactionLogicVerifier = V, this.channel = F, this.time = K, this.moduleMap = L, this.patchInstaller = H, this.i18N = W, this.i18N.addErrorCodeList("BFCHAIN-CORE", c, _I);
      }
    };
    Il = l([J(), be(1, D("cryptoHelper")), be(2, D("keypairHelper")), be(3, D("ed2curveHelper")), be(4, D("Buffer")), u("design:paramtypes", [ne, Object, Object, Object, Object, _h, xt, Or, me, Ee, dt, mh, Be, ve, Fs, Eh, Cr, xr, dl, zg, Qg, $t, $s, nd, Ft, ze, cd, Nf])], Il);
    function eE(i, e = new ze(), t) {
      ["config", "Buffer", "cryptoHelper", "keypairHelper", "ed2curveHelper", "blockGetterHelper", "blobSha256Reader", "blobSha256Writer", "TIME_SPEED"].forEach((n) => {
        e.has(n) || e.set(n, i[n]);
      });
      let r = e.get("configMap");
      return r || (r = new xr(), e.set("configMap", r)), r.set(i.config.magic, i.config), t && t.forEach((n) => {
        bt(n, e);
      }), e.set("BFChainCoreFactory", eE), bt(Il, e);
    }
    let an = class {
      constructor() {
        this.defaultDiffHeight = 20;
      }
      async _createSomeTransaction(e, t, r, n, s) {
        const { transactionCore: o, timeHelper: a, config: p, accountBaseHelper: h } = this, f = await h.createSecretKeypair(t.mainSecret);
        let g;
        t.paySecret && (g = await this.accountBaseHelper.createSecondSecretKeypair(t.mainSecret, t.paySecret));
        const d = await this.transactionCore.getTransactionTypeFromTransactionFactoryConstructor(e), y = await h.getAddressFromPublicKey(f.publicKey), _ = f.publicKey.toString("hex"), I = r.applyBlockHeight || 1, S = g && g.publicKey.toString("hex"), w = r.fromMagic || p.magic, N = r.toMagic || p.magic, B = { ...this.customTrsRemark, ...r.remark };
        let O, P = 0;
        const C = [];
        r.recipientId && (typeof r.recipientId === "string" ? O = r.recipientId : (P = r.recipientId.type, C.push(...r.recipientId.range)));
        let V;
        r.effectiveBlockHeight ? V = await this.checkEffectiveBlockHeight(r.effectiveBlockHeight, I) : V = await this.calcEffectiveBlockHeight(I);
        const F = (H, W = true) => o.createTransaction(e, { version: this.config.version, type: d, senderId: y, senderPublicKey: _, senderSecondPublicKey: S, recipientId: O || void 0, range: C, rangeType: P, fee: H, timestamp: r.timestamp || (r.timestamp = a.getTimestamp()), dappid: r.dappid || void 0, lns: r.lns || void 0, sourceIP: r.sourceIP || void 0, fromMagic: w, toMagic: N, applyBlockHeight: I, effectiveBlockHeight: V, remark: B, storage: s }, n, f, g, this.config);
        let K = r.fee;
        if (K.startsWith("AUTO")) {
          const H = [];
          (r.fee.startsWith("AUTO:") ? r.fee.slice(5).split(",") : []).forEach((ie) => {
            const ge = ie[0];
            ge === "*" ? H.push({ type: "mul", rate: parseFloat(ie.slice(1)) || 1 }) : ge === ">" && H.push({ type: "max", value: BigInt(ie.slice(1)) });
          });
          let z = "1";
          const { maxTransactionSize: $, minTransactionFeePerByte: q } = this.config;
          if (d === this.transactionHelper.GIFT_ASSET) {
            const { totalGrabableTimes: ie } = n.giftAsset;
            z = this.jsbiHelper.multiplyCeilFraction($ * (ie + 1), q).toString();
          } else if (d === this.transactionHelper.TRUST_ASSET) {
            const { numberOfSignFor: ie } = n.trustAsset;
            z = this.jsbiHelper.multiplyCeilFraction($ * (ie + 1), q).toString();
          } else if (d === this.transactionHelper.GIFT_ANY) {
            const { totalGrabableTimes: ie } = n.giftAny;
            z = this.jsbiHelper.multiplyCeilFraction($ * (ie + 1), q).toString();
          }
          K = this.calcTransactionFee(await F(z, true), { modes: H });
        }
        return await F(K);
      }
      createSignatureTransaction(e, t, r) {
        return this._createSomeTransaction(Ih, e, t, r);
      }
      createTransferAssetTransaction(e, t, r) {
        return this._createSomeTransaction(Sh, e, t, r, { key: "assetType", value: r.transferAsset.assetType });
      }
      createTransferAnyTransaction(e, t, r, n = false) {
        return this._createSomeTransaction(wh, e, t, r, n ? void 0 : { key: "assetType", value: r.transferAny.assetType });
      }
      createIssueEntityFactoryTransaction(e, t, r) {
        return this._createSomeTransaction(Ph, e, t, r, { key: "factoryId", value: r.issueEntityFactory.factoryId });
      }
      createIssueEntityTransaction(e, t, r) {
        return this._createSomeTransaction(Mh, e, t, r, { key: "entityId", value: r.issueEntity.entityId });
      }
      createIssueEntityMultiTransaction(e, t, r) {
        return this._createSomeTransaction(Hh, e, t, r, { key: "factoryId", value: r.issueEntityMulti.entityFactory.factoryId });
      }
      createToExchangeAnyTransaction(e, t, r) {
        return this._createSomeTransaction(ul, e, t, r);
      }
      createBeExchangeAnyTransaction(e, t, r) {
        return this._createSomeTransaction(Lh, e, t, r, { key: "transactionSignature", value: r.beExchangeAny.transactionSignature });
      }
      createToExchangeAnyMultiTransaction(e, t, r) {
        return this._createSomeTransaction(vh, e, t, r);
      }
      createBeExchangeAnyMultiTransaction(e, t, r) {
        return this._createSomeTransaction(kh, e, t, r, { key: "transactionSignature", value: r.beExchangeAnyMulti.transactionSignature });
      }
      createGiftAnyTransaction(e, t, r) {
        return this._createSomeTransaction(hl, e, t, r, { key: "assetType", value: r.giftAny.assetType });
      }
      createGrabAnyTransaction(e, t, r) {
        return this._createSomeTransaction(Ch, e, t, r, { key: "transactionSignature", value: r.grabAny.transactionSignature });
      }
      createDestoryAssetTransaction(e, t, r) {
        return this._createSomeTransaction(bh, e, t, r, { key: "assetType", value: r.destroyAsset.assetType });
      }
      calcTransactionFee(e, t = {}) {
        const { minTransactionFeePerByte: r = this.config.minTransactionFeePerByte, modes: n } = t;
        let s = e.getBytes().length, o = e.fee;
        do {
          const a = this.jsbiHelper.multiplyCeilFraction(s, r), p = a.toString();
          if (p.length <= o.length) {
            let h = a;
            if (n) for (const g of n) g.type === "mul" ? h = this.jsbiHelper.multiplyCeil(h, g.rate) : g.type === "max" && g.value > h && (h = g.value);
            const f = BigInt(e.fee);
            return (f > h ? f > a ? f : a : h).toString();
          }
          s += p.length - o.length, o = p;
        } while (true);
      }
      calcEffectiveBlockHeight(e) {
        return this.checkEffectiveBlockHeight(e + this.defaultDiffHeight, e);
      }
      checkEffectiveBlockHeight(e, t) {
        const r = t + this.config.maxApplyAndConfirmedBlockHeightDiff, n = t + this.config.blockPerRound * 2;
        return e < n && (e = n), e > r ? r : e;
      }
    };
    l([D("customTrsRemark", { optional: true, dynamics: true }), u("design:type", Object)], an.prototype, "customTrsRemark", void 0);
    l([D($t), u("design:type", $t)], an.prototype, "transactionCore", void 0);
    l([D(Ee), u("design:type", Ee)], an.prototype, "transactionHelper", void 0);
    l([D(Ft), u("design:type", Ft)], an.prototype, "timeHelper", void 0);
    l([D(ne), u("design:type", ne)], an.prototype, "config", void 0);
    l([D(Fs), u("design:type", Fs)], an.prototype, "migrateCertificateHelper", void 0);
    l([D(xt), u("design:type", xt)], an.prototype, "jsbiHelper", void 0);
    l([D(uh), u("design:type", uh)], an.prototype, "flagsHelper", void 0);
    l([D(me), u("design:type", me)], an.prototype, "accountBaseHelper", void 0);
    an = l([J()], an);
    let lu = class extends an {
      async createTransferTransactionJSON(e) {
        const { secrets: t, transaction: r, assetInfo: n } = e, s = { fee: r.fee, recipientId: r.recipientId, remark: r.remark, applyBlockHeight: r.applyBlockHeight, timestamp: r.timestamp, effectiveBlockHeight: r.effectiveBlockHeight };
        return (await this.createTransferAssetTransaction(t, s, { transferAsset: { sourceChainName: n.sourceChainName || this.config.chainName, sourceChainMagic: n.sourceChainMagic, assetType: n.assetType, amount: n.amount } })).toJSON();
      }
      async getTransferTransactionMinFee(e) {
        const { transaction: t, assetInfo: r } = e, n = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, o = { fee: "1", recipientId: await this.accountBaseHelper.getAddressFromSecret(`secrets:${Date.now()}-getRecipientId`), remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight }, a = await this.createTransferAssetTransaction(n, o, { transferAsset: { sourceChainName: r.sourceChainName || this.config.chainName, sourceChainMagic: r.sourceChainMagic, assetType: r.assetType, amount: r.amount } }), p = (this.transactionHelper.calcTransactionMinFeeByBytes(a, a.getBytes().length) + this.transactionHelper.calcTransactionBlobFee(a)).toString();
        return String(BigInt(p) * BigInt(2));
      }
      async createSignatureTransactionJSON(e, t) {
        const r = await this.accountBaseHelper.getPublicKeyStringFromSecondSecret(e.mainSecret, t.newPaySecret);
        return (await this.createSignatureTransaction(e, { fee: t.fee, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight }, { signature: { publicKey: r } })).toJSON();
      }
      async getSignatureTransactionMinFee(e) {
        const t = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" + e.newPaySecret }, r = await this.accountBaseHelper.getPublicKeyStringFromSecondSecret(t.mainSecret, e.newPaySecret), n = await this.createSignatureTransaction(t, { fee: "1", applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight }, { signature: { publicKey: r } }), s = (this.transactionHelper.calcTransactionMinFeeByBytes(n, n.getBytes().length) + this.transactionHelper.calcTransactionBlobFee(n)).toString();
        return String(BigInt(s) * BigInt(2));
      }
      async createCertificateTransferTransactionJSON(e) {
        const { secrets: t, transaction: r, assetInfo: n } = e, s = { fee: r.fee, recipientId: r.recipientId, remark: r.remark, applyBlockHeight: r.applyBlockHeight, timestamp: r.timestamp, effectiveBlockHeight: r.effectiveBlockHeight };
        return (await this.createTransferAnyTransaction(t, s, { transferAny: { ...n, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName, parentAssetType: G.CERTIFICATE } })).toJSON();
      }
      async createEntityTransferTransactionJSON(e) {
        const { secrets: t, transaction: r, assetInfo: n } = e, s = { fee: r.fee, recipientId: r.recipientId, remark: r.remark, applyBlockHeight: r.applyBlockHeight, timestamp: r.timestamp, effectiveBlockHeight: r.effectiveBlockHeight };
        return (await this.createTransferAnyTransaction(t, s, { transferAny: { ...n, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName, parentAssetType: G.ENTITY } })).toJSON();
      }
      async createEntityTransferTransactionMinFee(e, t) {
        const r = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, s = { fee: "1", recipientId: await this.accountBaseHelper.getAddressFromSecret(`secrets:${Date.now()}-getRecipientId`), remark: e.remark, applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight }, o = await this.createTransferAnyTransaction(r, s, { transferAny: { ...t, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName, parentAssetType: G.ENTITY } }), a = (this.transactionHelper.calcTransactionMinFeeByBytes(o, o.getBytes().length) + this.transactionHelper.calcTransactionBlobFee(o)).toString();
        return String(BigInt(a) * BigInt(12) / BigInt(10));
      }
      async createDestoryAssetTransactionJSON(e) {
        const { secrets: t, transaction: r, assetInfo: n } = e, s = { fee: r.fee, recipientId: r.recipientId, remark: r.remark, applyBlockHeight: r.applyBlockHeight, timestamp: r.timestamp, effectiveBlockHeight: r.effectiveBlockHeight };
        return (await this.createDestoryAssetTransaction(t, s, { destroyAsset: { sourceChainName: n.sourceChainName || this.config.chainName, sourceChainMagic: n.sourceChainMagic, assetType: n.assetType, amount: n.amount } })).toJSON();
      }
      async getDestoryAssetTransactionMinFee(e) {
        const { transaction: t, assetInfo: r } = e, n = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, o = { fee: "1", recipientId: await this.accountBaseHelper.getAddressFromSecret(`secrets:${Date.now()}-getRecipientId`), remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight }, a = await this.createDestoryAssetTransaction(n, o, { destroyAsset: { sourceChainName: r.sourceChainName || this.config.chainName, sourceChainMagic: r.sourceChainMagic, assetType: r.assetType, amount: r.amount } }), p = (this.transactionHelper.calcTransactionMinFeeByBytes(a, a.getBytes().length) + this.transactionHelper.calcTransactionBlobFee(a)).toString();
        return String(BigInt(p) * BigInt(2));
      }
    };
    lu = l([J()], lu);
    let hu = class extends an {
      async createIssueEntityFactoryTransactionJSON(e, t, r) {
        const n = { fee: t.fee, remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight, recipientId: t.recipientId }, s = { ...r, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName };
        return (await this.createIssueEntityFactoryTransaction(e, n, { issueEntityFactory: s })).toJSON();
      }
      async getCreateIssueEntityFactoryTransactionMinFee(e, t) {
        const r = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, n = { fee: "1", remark: e.remark, applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight, recipientId: e.recipientId }, s = { ...t, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName }, o = await this.createIssueEntityFactoryTransaction(r, n, { issueEntityFactory: s }), a = (this.transactionHelper.calcTransactionMinFeeByBytes(o, o.getBytes().length) + this.transactionHelper.calcTransactionBlobFee(o)).toString();
        return String(BigInt(a) * BigInt(105) / BigInt(100));
      }
      async createIssueEntityTransactionJSON(e, t, r) {
        const n = { ...r.entityFactory, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName }, s = { ...r, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName, entityFactory: n }, o = { fee: t.fee, remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight, recipientId: t.recipientId };
        return (await this.createIssueEntityTransaction(e, o, { issueEntity: s })).toJSON();
      }
      async getCreateIssueEntityTransactionMinFee(e, t) {
        const r = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, n = { ...t.entityFactory, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName }, s = { ...t, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName, entityFactory: n }, o = { fee: "1", remark: e.remark, applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight, recipientId: e.recipientId }, a = await this.createIssueEntityTransaction(r, o, { issueEntity: s }), p = (this.transactionHelper.calcTransactionMinFeeByBytes(a, a.getBytes().length) + this.transactionHelper.calcTransactionBlobFee(a)).toString();
        return String(BigInt(p) * BigInt(105) / BigInt(100));
      }
      async createIssueEntityMultiTransactionJSON(e, t, r) {
        const n = { ...r.entityFactory, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName }, s = { ...r, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName, entityFactory: n }, o = { fee: t.fee, remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight, recipientId: t.recipientId };
        return (await this.createIssueEntityMultiTransaction(e, o, { issueEntityMulti: s })).toJSON();
      }
      async getCreateIssueEntityMultiTransactionMinFee(e, t) {
        const r = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, n = { ...t.entityFactory, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName }, s = { ...t, sourceChainMagic: this.config.magic, sourceChainName: this.config.chainName, entityFactory: n }, o = { fee: "1", remark: e.remark, applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight, recipientId: e.recipientId }, a = await this.createIssueEntityMultiTransaction(r, o, { issueEntityMulti: s }), p = (this.transactionHelper.calcTransactionMinFeeByMulti(a, a.asset.issueEntityMulti.entityStructList.length) + this.transactionHelper.calcTransactionBlobFee(a)).toString();
        return String(BigInt(p) * BigInt(105) / BigInt(100));
      }
      async createToExchangeAnyTransactionJSON(e, t, r) {
        const n = { fee: t.fee, remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight };
        return (await this.createToExchangeAnyTransaction(e, n, { toExchangeAny: { ...r, cipherPublicKeys: [] } })).toJSON();
      }
      async getCreateToExchangeAnyTransactionMinFee(e, t) {
        const r = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, n = { fee: "1", remark: e.remark, applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight }, s = await this.createToExchangeAnyTransaction(r, n, { toExchangeAny: { ...t, cipherPublicKeys: [] } }), o = (this.transactionHelper.calcTransactionMinFeeByBytes(s, s.getBytes().length) + this.transactionHelper.calcTransactionBlobFee(s)).toString();
        return String(BigInt(o) * BigInt(105) / BigInt(100));
      }
      async createBeExchangeAnyTransactionJSON(e, t, r, n) {
        const s = { fee: t.fee, recipientId: t.recipientId, remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight };
        return (await this.createBeExchangeAnyTransaction(e, s, { beExchangeAny: { ...r, exchangeAny: { ...n, cipherPublicKeys: [] } } })).toJSON();
      }
      async getCreateBeExchangeAnyTransactionMinFee(e, t, r) {
        const n = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, s = { fee: "1", recipientId: e.recipientId, remark: e.remark, applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight }, o = await this.createBeExchangeAnyTransaction(n, s, { beExchangeAny: { ...t, exchangeAny: { ...r, cipherPublicKeys: [] } } }), a = (this.transactionHelper.calcTransactionMinFeeByBytes(o, o.getBytes().length) + this.transactionHelper.calcTransactionBlobFee(o)).toString();
        return String(BigInt(a) * BigInt(105) / BigInt(100));
      }
      async createToExchangeAnyMultiTransactionJSON(e, t, r, n) {
        const s = { fee: t.fee, remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight };
        return (await this.createToExchangeAnyMultiTransaction(e, s, { toExchangeAnyMulti: { cipherPublicKeys: [], toExchangeAssets: r, beExchangeAsset: n } })).toJSON();
      }
      async getCreateToExchangeAnyMultiTransactionMinFee(e, t, r) {
        const n = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, s = { fee: "1", remark: e.remark, applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight }, o = await this.createToExchangeAnyMultiTransaction(n, s, { toExchangeAnyMulti: { cipherPublicKeys: [], toExchangeAssets: t, beExchangeAsset: r } }), a = (this.transactionHelper.calcTransactionMinFeeByMulti(o, o.asset.toExchangeAnyMulti.toExchangeAssets.length) + this.transactionHelper.calcTransactionBlobFee(o)).toString();
        return String(BigInt(a) * BigInt(105) / BigInt(100));
      }
      async createBeExchangeAnyMultiTransactionJSON(e, t, r, n) {
        const s = { fee: t.fee, recipientId: t.recipientId, remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight };
        return (await this.createBeExchangeAnyMultiTransaction(e, s, { beExchangeAnyMulti: { transactionSignature: t.transactionSignature, toExchangeAssets: r, beExchangeAsset: n } })).toJSON();
      }
      async getCreateBeExchangeAnyMultiTransactionMinFee(e, t, r) {
        const n = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, s = { fee: "1", recipientId: e.recipientId, remark: e.remark, applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight }, o = await this.createBeExchangeAnyMultiTransaction(n, s, { beExchangeAnyMulti: { transactionSignature: e.transactionSignature, toExchangeAssets: t, beExchangeAsset: r } }), a = (this.transactionHelper.calcTransactionMinFeeByMulti(o, o.asset.beExchangeAnyMulti.toExchangeAssets.length) + this.transactionHelper.calcTransactionBlobFee(o)).toString();
        return String(BigInt(a) * BigInt(105) / BigInt(100));
      }
      async createGiftAnyTransactionJSON(e, t, r) {
        const n = { recipientId: { type: 1, range: [t.recipientId] }, fee: t.fee, remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight };
        return (await this.createGiftAnyTransaction(e, n, { giftAny: { ...r, cipherPublicKeys: [] } })).toJSON();
      }
      async getCreateGiftAnyTransactionMinFee(e, t) {
        const r = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, n = { fee: "AUTO", recipientId: { type: 1, range: [e.recipientId] }, remark: e.remark, applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight }, s = await this.createGiftAnyTransaction(r, n, { giftAny: { ...t, cipherPublicKeys: [] } });
        let o = this.transactionHelper.calcTransactionMinFeeByBytes(s, s.getBytes().length) + this.transactionHelper.calcTransactionBlobFee(s);
        const a = BigInt(s.fee);
        return a > o && (o = a), String(o * BigInt(105) / BigInt(100));
      }
      async createGrabAnyTransactionJSON(e, t, r, n) {
        const s = { fee: t.fee, recipientId: t.recipientId, remark: t.remark, applyBlockHeight: t.applyBlockHeight, timestamp: t.timestamp, effectiveBlockHeight: t.effectiveBlockHeight };
        return (await this.createGrabAnyTransaction(e, s, { grabAny: { ...r, giftAny: { ...n, cipherPublicKeys: [] } } })).toJSON();
      }
      async getCreateGrabAnyTransactionMinFee(e, t, r) {
        const n = { mainSecret: `secrets:${Date.now()}`, paySecret: "1" }, s = { fee: "AUTO", recipientId: e.recipientId, remark: e.remark, applyBlockHeight: e.applyBlockHeight, timestamp: e.timestamp, effectiveBlockHeight: e.effectiveBlockHeight }, o = await this.createGrabAnyTransaction(n, s, { grabAny: { ...t, giftAny: { ...r, cipherPublicKeys: [] } } });
        let a = this.transactionHelper.calcTransactionMinFeeByBytes(o, o.getBytes().length) + this.transactionHelper.calcTransactionBlobFee(o);
        const p = BigInt(o.fee);
        return p > a && (a = p), String(a * BigInt(105) / BigInt(100));
      }
    };
    hu = l([J()], hu);
    const wS = "BTGMetaBundleCore";
    exports.BTGMetaBundleCore = class extends An {
      constructor(e) {
        super(), this.moduleMap = e, this._init_task = new Yt();
      }
      accountBaseHelper() {
        return this.bfchainCore.accountBaseHelper;
      }
      keypairHelper() {
        return this.bfchainCore.keypairHelper;
      }
      config() {
        return this.bfchainCore.config;
      }
      getMagic() {
        return this.bfchainCore.config.magic;
      }
      getAssetType() {
        return this.bfchainCore.config.assetType;
      }
      getChainName() {
        return this.bfchainCore.config.chainName;
      }
      afterInit() {
        return this._init_task.promise;
      }
      async bfOnInit() {
        try {
          this._init_task.resolve();
        } catch (e) {
          this._init_task.reject(e);
        }
      }
    };
    l([D(Il), u("design:type", Il)], exports.BTGMetaBundleCore.prototype, "bfchainCore", void 0);
    l([D(lu), u("design:type", lu)], exports.BTGMetaBundleCore.prototype, "transactionController", void 0);
    l([D(hu), u("design:type", hu)], exports.BTGMetaBundleCore.prototype, "exchangeTransactionCtrl", void 0);
    exports.BTGMetaBundleCore = l([J(wS), u("design:paramtypes", [ze])], exports.BTGMetaBundleCore);
    const v_ = /* @__PURE__ */ new Map();
    const bS = async (i, e, t = {}) => {
      const r = i.magic;
      let n = v_.get(r);
      if (n) return n;
      const s = new ze(), o = eE({ config: new ne(i, "bfchain-bundle"), Buffer: rs.Buffer, cryptoHelper: e, keypairHelper: AS, ed2curveHelper: TS }, s);
      return s.set("Buffer", rs.Buffer), s.set("customTrsRemark", t), v_.set(r, n = bt(exports.BTGMetaBundleCore, o.moduleMap)), n;
    };
    exports.setup = bS;
  }
});
export default require_bioforest_chain_bundle();
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*/
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
