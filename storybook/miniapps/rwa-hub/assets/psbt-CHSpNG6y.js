import{B as T,r as k}from"./bioforestChainBundle-B4tLCzTr.js";import{Z as un}from"./index-AshhoVut.js";import{g as Q,h as cn,t as an,b as We,c as De,a as be,e as Ge,d as Kt}from"./address-B2LfIEKg.js";import{g as Wt,h as H,B,k as R,l as je,m as $e,N as fn,S as Pe,n as Ue,c as hn,d as re,o as le,a as Dt,p as pn}from"./script-DijuLAta.js";import{hash256 as te,sha256 as ne,taggedHash as ln,hash160 as dn}from"./crypto-B0d8PDDp.js";import{b as Sn}from"./networks-ZN7vFv_C.js";import{p as Gt}from"./p2pk-1FI4sERP.js";import"./page-BnBmgj2e.js";import{OPS as gn}from"./ops-CO93g0rg.js";import"./typeforce-DQh4knDl.js";import"./index-BjnbLYBu.js";import"./sha256-Ckoyw2Ta.js";import"./WASMInterface-DAdCfnXY.js";import"./ripemd160-5KCgQPR7.js";import"./sha1-CsgZsmbN.js";const{typeforce:Mt}=Wt;function qt(r,e){if(typeof r!="number")throw new Error("cannot write a non-number as a number");if(r<0)throw new Error("specified a negative value for writing an unsigned value");if(r>e)throw new Error("RangeError: value out of range");if(Math.floor(r)!==r)throw new Error("value has a fractional component")}function En(r,e){const t=r.readUInt32LE(e);let s=r.readUInt32LE(e+4);return s*=4294967296,qt(s+t,9007199254740991),s+t}function wn(r,e,t){return qt(e,9007199254740991),r.writeInt32LE(e&-1,t),r.writeUInt32LE(Math.floor(e/4294967296),t+4),t+8}function Me(r){if(r.length<1)return r;let e=r.length-1,t=0;for(let s=0;s<r.length/2;s++)t=r[s],r[s]=r[e],r[e]=t,e--;return r}function Ye(r){const e=T.allocUnsafe(r.length);return r.copy(e),e}class N{static withCapacity(e){return new N(T.alloc(e))}constructor(e,t=0){this.buffer=e,this.offset=t,Mt(H(B,R),[e,t])}writeUInt8(e){this.offset=this.buffer.writeUInt8(e,this.offset)}writeInt32(e){this.offset=this.buffer.writeInt32LE(e,this.offset)}writeUInt32(e){this.offset=this.buffer.writeUInt32LE(e,this.offset)}writeUInt64(e){this.offset=wn(this.buffer,e,this.offset)}writeVarInt(e){Q.encode(e,this.buffer,this.offset),this.offset+=Q.encode.bytes}writeSlice(e){if(this.buffer.length<this.offset+e.length)throw new Error("Cannot write slice out of bounds");this.offset+=e.copy(this.buffer,this.offset)}writeVarSlice(e){this.writeVarInt(e.length),this.writeSlice(e)}writeVector(e){this.writeVarInt(e.length),e.forEach(t=>this.writeVarSlice(t))}end(){if(this.buffer.length===this.offset)return this.buffer;throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`)}}class yn{constructor(e,t=0){this.buffer=e,this.offset=t,Mt(H(B,R),[e,t])}readUInt8(){const e=this.buffer.readUInt8(this.offset);return this.offset++,e}readInt32(){const e=this.buffer.readInt32LE(this.offset);return this.offset+=4,e}readUInt32(){const e=this.buffer.readUInt32LE(this.offset);return this.offset+=4,e}readUInt64(){const e=En(this.buffer,this.offset);return this.offset+=8,e}readVarInt(){const e=Q.decode(this.buffer,this.offset);return this.offset+=Q.decode.bytes,e}readSlice(e){if(this.buffer.length<this.offset+e)throw new Error("Cannot read slice out of bounds");const t=this.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}readVarSlice(){return this.readSlice(this.readVarInt())}readVector(){const e=this.readVarInt(),t=[];for(let s=0;s<e;s++)t.push(this.readVarSlice());return t}}var de={},Se={},Oe={},ie={},se={},xe={},ze;function b(){return ze||(ze=1,(function(r){Object.defineProperty(r,"__esModule",{value:!0}),(function(e){e[e.UNSIGNED_TX=0]="UNSIGNED_TX",e[e.GLOBAL_XPUB=1]="GLOBAL_XPUB"})(r.GlobalTypes||(r.GlobalTypes={})),r.GLOBAL_TYPE_NAMES=["unsignedTx","globalXpub"],(function(e){e[e.NON_WITNESS_UTXO=0]="NON_WITNESS_UTXO",e[e.WITNESS_UTXO=1]="WITNESS_UTXO",e[e.PARTIAL_SIG=2]="PARTIAL_SIG",e[e.SIGHASH_TYPE=3]="SIGHASH_TYPE",e[e.REDEEM_SCRIPT=4]="REDEEM_SCRIPT",e[e.WITNESS_SCRIPT=5]="WITNESS_SCRIPT",e[e.BIP32_DERIVATION=6]="BIP32_DERIVATION",e[e.FINAL_SCRIPTSIG=7]="FINAL_SCRIPTSIG",e[e.FINAL_SCRIPTWITNESS=8]="FINAL_SCRIPTWITNESS",e[e.POR_COMMITMENT=9]="POR_COMMITMENT",e[e.TAP_KEY_SIG=19]="TAP_KEY_SIG",e[e.TAP_SCRIPT_SIG=20]="TAP_SCRIPT_SIG",e[e.TAP_LEAF_SCRIPT=21]="TAP_LEAF_SCRIPT",e[e.TAP_BIP32_DERIVATION=22]="TAP_BIP32_DERIVATION",e[e.TAP_INTERNAL_KEY=23]="TAP_INTERNAL_KEY",e[e.TAP_MERKLE_ROOT=24]="TAP_MERKLE_ROOT"})(r.InputTypes||(r.InputTypes={})),r.INPUT_TYPE_NAMES=["nonWitnessUtxo","witnessUtxo","partialSig","sighashType","redeemScript","witnessScript","bip32Derivation","finalScriptSig","finalScriptWitness","porCommitment","tapKeySig","tapScriptSig","tapLeafScript","tapBip32Derivation","tapInternalKey","tapMerkleRoot"],(function(e){e[e.REDEEM_SCRIPT=0]="REDEEM_SCRIPT",e[e.WITNESS_SCRIPT=1]="WITNESS_SCRIPT",e[e.BIP32_DERIVATION=2]="BIP32_DERIVATION",e[e.TAP_INTERNAL_KEY=5]="TAP_INTERNAL_KEY",e[e.TAP_TREE=6]="TAP_TREE",e[e.TAP_BIP32_DERIVATION=7]="TAP_BIP32_DERIVATION"})(r.OutputTypes||(r.OutputTypes={})),r.OUTPUT_TYPE_NAMES=["redeemScript","witnessScript","bip32Derivation","tapInternalKey","tapTree","tapBip32Derivation"]})(xe)),xe}var F={},Je;function _n(){if(Je)return F;Je=1;const{Buffer:r}=k();Object.defineProperty(F,"__esModule",{value:!0});const e=b(),t=o=>[...Array(o).keys()];function s(o){if(o.key[0]!==e.GlobalTypes.GLOBAL_XPUB)throw new Error("Decode Error: could not decode globalXpub with key 0x"+o.key.toString("hex"));if(o.key.length!==79||![2,3].includes(o.key[46]))throw new Error("Decode Error: globalXpub has invalid extended pubkey in key 0x"+o.key.toString("hex"));if(o.value.length/4%1!==0)throw new Error("Decode Error: Global GLOBAL_XPUB value length should be multiple of 4");const u=o.key.slice(1),a={masterFingerprint:o.value.slice(0,4),extendedPubkey:u,path:"m"};for(const f of t(o.value.length/4-1)){const h=o.value.readUInt32LE(f*4+4),S=!!(h&2147483648),y=h&2147483647;a.path+="/"+y.toString(10)+(S?"'":"")}return a}F.decode=s;function i(o){const u=r.from([e.GlobalTypes.GLOBAL_XPUB]),a=r.concat([u,o.extendedPubkey]),f=o.path.split("/"),h=r.allocUnsafe(f.length*4);o.masterFingerprint.copy(h,0);let S=4;return f.slice(1).forEach(y=>{const g=y.slice(-1)==="'";let d=2147483647&parseInt(g?y.slice(0,-1):y,10);g&&(d+=2147483648),h.writeUInt32LE(d,S),S+=4}),{key:a,value:h}}F.encode=i,F.expected="{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";function c(o){const u=o.extendedPubkey,a=o.masterFingerprint,f=o.path;return r.isBuffer(u)&&u.length===78&&[2,3].indexOf(u[45])>-1&&r.isBuffer(a)&&a.length===4&&typeof f=="string"&&!!f.match(/^m(\/\d+'?)*$/)}F.check=c;function n(o,u,a){const f=u.extendedPubkey.toString("hex");return a.has(f)?!1:(a.add(f),o.filter(h=>h.extendedPubkey.equals(u.extendedPubkey)).length===0)}return F.canAddToArray=n,F}var ge={},Qe;function In(){if(Qe)return ge;Qe=1;const{Buffer:r}=k();Object.defineProperty(ge,"__esModule",{value:!0});const e=b();function t(s){return{key:r.from([e.GlobalTypes.UNSIGNED_TX]),value:s.toBuffer()}}return ge.encode=t,ge}var K={},Ze;function Tn(){if(Ze)return K;Ze=1;const{Buffer:r}=k();Object.defineProperty(K,"__esModule",{value:!0});const e=b();function t(n){if(n.key[0]!==e.InputTypes.FINAL_SCRIPTSIG)throw new Error("Decode Error: could not decode finalScriptSig with key 0x"+n.key.toString("hex"));return n.value}K.decode=t;function s(n){return{key:r.from([e.InputTypes.FINAL_SCRIPTSIG]),value:n}}K.encode=s,K.expected="Buffer";function i(n){return r.isBuffer(n)}K.check=i;function c(n,o){return!!n&&!!o&&n.finalScriptSig===void 0}return K.canAdd=c,K}var W={},et;function An(){if(et)return W;et=1;const{Buffer:r}=k();Object.defineProperty(W,"__esModule",{value:!0});const e=b();function t(n){if(n.key[0]!==e.InputTypes.FINAL_SCRIPTWITNESS)throw new Error("Decode Error: could not decode finalScriptWitness with key 0x"+n.key.toString("hex"));return n.value}W.decode=t;function s(n){return{key:r.from([e.InputTypes.FINAL_SCRIPTWITNESS]),value:n}}W.encode=s,W.expected="Buffer";function i(n){return r.isBuffer(n)}W.check=i;function c(n,o){return!!n&&!!o&&n.finalScriptWitness===void 0}return W.canAdd=c,W}var D={},tt;function kn(){if(tt)return D;tt=1;const{Buffer:r}=k();Object.defineProperty(D,"__esModule",{value:!0});const e=b();function t(n){if(n.key[0]!==e.InputTypes.NON_WITNESS_UTXO)throw new Error("Decode Error: could not decode nonWitnessUtxo with key 0x"+n.key.toString("hex"));return n.value}D.decode=t;function s(n){return{key:r.from([e.InputTypes.NON_WITNESS_UTXO]),value:n}}D.encode=s,D.expected="Buffer";function i(n){return r.isBuffer(n)}D.check=i;function c(n,o){return!!n&&!!o&&n.nonWitnessUtxo===void 0}return D.canAdd=c,D}var G={},nt;function mn(){if(nt)return G;nt=1;const{Buffer:r}=k();Object.defineProperty(G,"__esModule",{value:!0});const e=b();function t(o){if(o.key[0]!==e.InputTypes.PARTIAL_SIG)throw new Error("Decode Error: could not decode partialSig with key 0x"+o.key.toString("hex"));if(!(o.key.length===34||o.key.length===66)||![2,3,4].includes(o.key[1]))throw new Error("Decode Error: partialSig has invalid pubkey in key 0x"+o.key.toString("hex"));return{pubkey:o.key.slice(1),signature:o.value}}G.decode=t;function s(o){const u=r.from([e.InputTypes.PARTIAL_SIG]);return{key:r.concat([u,o.pubkey]),value:o.signature}}G.encode=s,G.expected="{ pubkey: Buffer; signature: Buffer; }";function i(o){return r.isBuffer(o.pubkey)&&r.isBuffer(o.signature)&&[33,65].includes(o.pubkey.length)&&[2,3,4].includes(o.pubkey[0])&&c(o.signature)}G.check=i;function c(o){if(!r.isBuffer(o)||o.length<9||o[0]!==48||o.length!==o[1]+3||o[2]!==2)return!1;const u=o[3];if(u>33||u<1||o[3+u+1]!==2)return!1;const a=o[3+u+2];return!(a>33||a<1||o.length!==3+u+2+a+2)}function n(o,u,a){const f=u.pubkey.toString("hex");return a.has(f)?!1:(a.add(f),o.filter(h=>h.pubkey.equals(u.pubkey)).length===0)}return G.canAddToArray=n,G}var M={},rt;function bn(){if(rt)return M;rt=1;const{Buffer:r}=k();Object.defineProperty(M,"__esModule",{value:!0});const e=b();function t(n){if(n.key[0]!==e.InputTypes.POR_COMMITMENT)throw new Error("Decode Error: could not decode porCommitment with key 0x"+n.key.toString("hex"));return n.value.toString("utf8")}M.decode=t;function s(n){return{key:r.from([e.InputTypes.POR_COMMITMENT]),value:r.from(n,"utf8")}}M.encode=s,M.expected="string";function i(n){return typeof n=="string"}M.check=i;function c(n,o){return!!n&&!!o&&n.porCommitment===void 0}return M.canAdd=c,M}var q={},it;function vn(){if(it)return q;it=1;const{Buffer:r}=k();Object.defineProperty(q,"__esModule",{value:!0});const e=b();function t(n){if(n.key[0]!==e.InputTypes.SIGHASH_TYPE)throw new Error("Decode Error: could not decode sighashType with key 0x"+n.key.toString("hex"));return n.value.readUInt32LE(0)}q.decode=t;function s(n){const o=r.from([e.InputTypes.SIGHASH_TYPE]),u=r.allocUnsafe(4);return u.writeUInt32LE(n,0),{key:o,value:u}}q.encode=s,q.expected="number";function i(n){return typeof n=="number"}q.check=i;function c(n,o){return!!n&&!!o&&n.sighashType===void 0}return q.canAdd=c,q}var X={},st;function Nn(){if(st)return X;st=1;const{Buffer:r}=k();Object.defineProperty(X,"__esModule",{value:!0});const e=b();function t(n){if(n.key[0]!==e.InputTypes.TAP_KEY_SIG||n.key.length!==1)throw new Error("Decode Error: could not decode tapKeySig with key 0x"+n.key.toString("hex"));if(!i(n.value))throw new Error("Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature");return n.value}X.decode=t;function s(n){return{key:r.from([e.InputTypes.TAP_KEY_SIG]),value:n}}X.encode=s,X.expected="Buffer";function i(n){return r.isBuffer(n)&&(n.length===64||n.length===65)}X.check=i;function c(n,o){return!!n&&!!o&&n.tapKeySig===void 0}return X.canAdd=c,X}var V={},ot;function Cn(){if(ot)return V;ot=1;const{Buffer:r}=k();Object.defineProperty(V,"__esModule",{value:!0});const e=b();function t(n){if(n.key[0]!==e.InputTypes.TAP_LEAF_SCRIPT)throw new Error("Decode Error: could not decode tapLeafScript with key 0x"+n.key.toString("hex"));if((n.key.length-2)%32!==0)throw new Error("Decode Error: tapLeafScript has invalid control block in key 0x"+n.key.toString("hex"));const o=n.value[n.value.length-1];if((n.key[1]&254)!==o)throw new Error("Decode Error: tapLeafScript bad leaf version in key 0x"+n.key.toString("hex"));const u=n.value.slice(0,-1);return{controlBlock:n.key.slice(1),script:u,leafVersion:o}}V.decode=t;function s(n){const o=r.from([e.InputTypes.TAP_LEAF_SCRIPT]),u=r.from([n.leafVersion]);return{key:r.concat([o,n.controlBlock]),value:r.concat([n.script,u])}}V.encode=s,V.expected="{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";function i(n){return r.isBuffer(n.controlBlock)&&(n.controlBlock.length-1)%32===0&&(n.controlBlock[0]&254)===n.leafVersion&&r.isBuffer(n.script)}V.check=i;function c(n,o,u){const a=o.controlBlock.toString("hex");return u.has(a)?!1:(u.add(a),n.filter(f=>f.controlBlock.equals(o.controlBlock)).length===0)}return V.canAddToArray=c,V}var j={},ut;function Pn(){if(ut)return j;ut=1;const{Buffer:r}=k();Object.defineProperty(j,"__esModule",{value:!0});const e=b();function t(n){if(n.key[0]!==e.InputTypes.TAP_MERKLE_ROOT||n.key.length!==1)throw new Error("Decode Error: could not decode tapMerkleRoot with key 0x"+n.key.toString("hex"));if(!i(n.value))throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");return n.value}j.decode=t;function s(n){return{key:r.from([e.InputTypes.TAP_MERKLE_ROOT]),value:n}}j.encode=s,j.expected="Buffer";function i(n){return r.isBuffer(n)&&n.length===32}j.check=i;function c(n,o){return!!n&&!!o&&n.tapMerkleRoot===void 0}return j.canAdd=c,j}var $={},ct;function Un(){if(ct)return $;ct=1;const{Buffer:r}=k();Object.defineProperty($,"__esModule",{value:!0});const e=b();function t(n){if(n.key[0]!==e.InputTypes.TAP_SCRIPT_SIG)throw new Error("Decode Error: could not decode tapScriptSig with key 0x"+n.key.toString("hex"));if(n.key.length!==65)throw new Error("Decode Error: tapScriptSig has invalid key 0x"+n.key.toString("hex"));if(n.value.length!==64&&n.value.length!==65)throw new Error("Decode Error: tapScriptSig has invalid signature in key 0x"+n.key.toString("hex"));const o=n.key.slice(1,33),u=n.key.slice(33);return{pubkey:o,leafHash:u,signature:n.value}}$.decode=t;function s(n){const o=r.from([e.InputTypes.TAP_SCRIPT_SIG]);return{key:r.concat([o,n.pubkey,n.leafHash]),value:n.signature}}$.encode=s,$.expected="{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";function i(n){return r.isBuffer(n.pubkey)&&r.isBuffer(n.leafHash)&&r.isBuffer(n.signature)&&n.pubkey.length===32&&n.leafHash.length===32&&(n.signature.length===64||n.signature.length===65)}$.check=i;function c(n,o,u){const a=o.pubkey.toString("hex")+o.leafHash.toString("hex");return u.has(a)?!1:(u.add(a),n.filter(f=>f.pubkey.equals(o.pubkey)&&f.leafHash.equals(o.leafHash)).length===0)}return $.canAddToArray=c,$}var Y={},x={},oe={},at;function ue(){if(at)return oe;at=1;const{Buffer:r}=k();Object.defineProperty(oe,"__esModule",{value:!0});const e=9007199254740991;function t(n){if(n<0||n>e||n%1!==0)throw new RangeError("value out of range")}function s(n,o,u){if(t(n),o||(o=r.allocUnsafe(c(n))),!r.isBuffer(o))throw new TypeError("buffer must be a Buffer instance");return u||(u=0),n<253?(o.writeUInt8(n,u),Object.assign(s,{bytes:1})):n<=65535?(o.writeUInt8(253,u),o.writeUInt16LE(n,u+1),Object.assign(s,{bytes:3})):n<=4294967295?(o.writeUInt8(254,u),o.writeUInt32LE(n,u+1),Object.assign(s,{bytes:5})):(o.writeUInt8(255,u),o.writeUInt32LE(n>>>0,u+1),o.writeUInt32LE(n/4294967296|0,u+5),Object.assign(s,{bytes:9})),o}oe.encode=s;function i(n,o){if(!r.isBuffer(n))throw new TypeError("buffer must be a Buffer instance");o||(o=0);const u=n.readUInt8(o);if(u<253)return Object.assign(i,{bytes:1}),u;if(u===253)return Object.assign(i,{bytes:3}),n.readUInt16LE(o+1);if(u===254)return Object.assign(i,{bytes:5}),n.readUInt32LE(o+1);{Object.assign(i,{bytes:9});const a=n.readUInt32LE(o+1),h=n.readUInt32LE(o+5)*4294967296+a;return t(h),h}}oe.decode=i;function c(n){return t(n),n<253?1:n<=65535?3:n<=4294967295?5:9}return oe.encodingLength=c,oe}var ft;function qe(){if(ft)return x;ft=1;const{Buffer:r}=k();Object.defineProperty(x,"__esModule",{value:!0});const e=ue();x.range=u=>[...Array(u).keys()];function t(u){if(u.length<1)return u;let a=u.length-1,f=0;for(let h=0;h<u.length/2;h++)f=u[h],u[h]=u[a],u[a]=f,a--;return u}x.reverseBuffer=t;function s(u){const a=u.map(i);return a.push(r.from([0])),r.concat(a)}x.keyValsToBuffer=s;function i(u){const a=u.key.length,f=u.value.length,h=e.encodingLength(a),S=e.encodingLength(f),y=r.allocUnsafe(h+a+S+f);return e.encode(a,y,0),u.key.copy(y,h),e.encode(f,y,h+a),u.value.copy(y,h+a+S),y}x.keyValToBuffer=i;function c(u,a){if(typeof u!="number")throw new Error("cannot write a non-number as a number");if(u<0)throw new Error("specified a negative value for writing an unsigned value");if(u>a)throw new Error("RangeError: value out of range");if(Math.floor(u)!==u)throw new Error("value has a fractional component")}function n(u,a){const f=u.readUInt32LE(a);let h=u.readUInt32LE(a+4);return h*=4294967296,c(h+f,9007199254740991),h+f}x.readUInt64LE=n;function o(u,a,f){return c(a,9007199254740991),u.writeInt32LE(a&-1,f),u.writeUInt32LE(Math.floor(a/4294967296),f+4),f+8}return x.writeUInt64LE=o,x}var ht;function On(){if(ht)return Y;ht=1;const{Buffer:r}=k();Object.defineProperty(Y,"__esModule",{value:!0});const e=b(),t=qe(),s=ue();function i(u){if(u.key[0]!==e.InputTypes.WITNESS_UTXO)throw new Error("Decode Error: could not decode witnessUtxo with key 0x"+u.key.toString("hex"));const a=t.readUInt64LE(u.value,0);let f=8;const h=s.decode(u.value,f);f+=s.encodingLength(h);const S=u.value.slice(f);if(S.length!==h)throw new Error("Decode Error: WITNESS_UTXO script is not proper length");return{script:S,value:a}}Y.decode=i;function c(u){const{script:a,value:f}=u,h=s.encodingLength(a.length),S=r.allocUnsafe(8+h+a.length);return t.writeUInt64LE(S,f,0),s.encode(a.length,S,8),a.copy(S,8+h),{key:r.from([e.InputTypes.WITNESS_UTXO]),value:S}}Y.encode=c,Y.expected="{ script: Buffer; value: number; }";function n(u){return r.isBuffer(u.script)&&typeof u.value=="number"}Y.check=n;function o(u,a){return!!u&&!!a&&u.witnessUtxo===void 0}return Y.canAdd=o,Y}var z={},pt;function xn(){if(pt)return z;pt=1;const{Buffer:r}=k();Object.defineProperty(z,"__esModule",{value:!0});const e=b(),t=ue();function s(o){if(o.key[0]!==e.OutputTypes.TAP_TREE||o.key.length!==1)throw new Error("Decode Error: could not decode tapTree with key 0x"+o.key.toString("hex"));let u=0;const a=[];for(;u<o.value.length;){const f=o.value[u++],h=o.value[u++],S=t.decode(o.value,u);u+=t.encodingLength(S),a.push({depth:f,leafVersion:h,script:o.value.slice(u,u+S)}),u+=S}return{leaves:a}}z.decode=s;function i(o){const u=r.from([e.OutputTypes.TAP_TREE]),a=[].concat(...o.leaves.map(f=>[r.of(f.depth,f.leafVersion),t.encode(f.script.length),f.script]));return{key:u,value:r.concat(a)}}z.encode=i,z.expected="{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";function c(o){return Array.isArray(o.leaves)&&o.leaves.every(u=>u.depth>=0&&u.depth<=128&&(u.leafVersion&254)===u.leafVersion&&r.isBuffer(u.script))}z.check=c;function n(o,u){return!!o&&!!u&&o.tapTree===void 0}return z.canAdd=n,z}var Ee={},lt;function Xt(){if(lt)return Ee;lt=1;const{Buffer:r}=k();Object.defineProperty(Ee,"__esModule",{value:!0});const e=i=>[...Array(i).keys()],t=i=>i.length===33&&[2,3].includes(i[0])||i.length===65&&i[0]===4;function s(i,c=t){function n(h){if(h.key[0]!==i)throw new Error("Decode Error: could not decode bip32Derivation with key 0x"+h.key.toString("hex"));const S=h.key.slice(1);if(!c(S))throw new Error("Decode Error: bip32Derivation has invalid pubkey in key 0x"+h.key.toString("hex"));if(h.value.length/4%1!==0)throw new Error("Decode Error: Input BIP32_DERIVATION value length should be multiple of 4");const y={masterFingerprint:h.value.slice(0,4),pubkey:S,path:"m"};for(const g of e(h.value.length/4-1)){const d=h.value.readUInt32LE(g*4+4),E=!!(d&2147483648),_=d&2147483647;y.path+="/"+_.toString(10)+(E?"'":"")}return y}function o(h){const S=r.from([i]),y=r.concat([S,h.pubkey]),g=h.path.split("/"),d=r.allocUnsafe(g.length*4);h.masterFingerprint.copy(d,0);let E=4;return g.slice(1).forEach(_=>{const I=_.slice(-1)==="'";let p=2147483647&parseInt(I?_.slice(0,-1):_,10);I&&(p+=2147483648),d.writeUInt32LE(p,E),E+=4}),{key:y,value:d}}const u="{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";function a(h){return r.isBuffer(h.pubkey)&&r.isBuffer(h.masterFingerprint)&&typeof h.path=="string"&&c(h.pubkey)&&h.masterFingerprint.length===4}function f(h,S,y){const g=S.pubkey.toString("hex");return y.has(g)?!1:(y.add(g),h.filter(d=>d.pubkey.equals(S.pubkey)).length===0)}return{decode:n,encode:o,check:a,expected:u,canAddToArray:f}}return Ee.makeConverter=s,Ee}var we={},dt;function Hn(){if(dt)return we;dt=1,Object.defineProperty(we,"__esModule",{value:!0});function r(e){return t;function t(s){let i;if(e.includes(s.key[0])&&(i=s.key.slice(1),!(i.length===33||i.length===65)||![2,3,4].includes(i[0])))throw new Error("Format Error: invalid pubkey in key 0x"+s.key.toString("hex"));return i}}return we.makeChecker=r,we}var ye={},St;function Bn(){if(St)return ye;St=1;const{Buffer:r}=k();Object.defineProperty(ye,"__esModule",{value:!0});function e(t){function s(u){if(u.key[0]!==t)throw new Error("Decode Error: could not decode redeemScript with key 0x"+u.key.toString("hex"));return u.value}function i(u){return{key:r.from([t]),value:u}}const c="Buffer";function n(u){return r.isBuffer(u)}function o(u,a){return!!u&&!!a&&u.redeemScript===void 0}return{decode:s,encode:i,check:n,expected:c,canAdd:o}}return ye.makeConverter=e,ye}var _e={},gt;function Rn(){if(gt)return _e;gt=1;const{Buffer:r}=k();Object.defineProperty(_e,"__esModule",{value:!0});const e=ue(),t=Xt(),s=c=>c.length===32;function i(c){const n=t.makeConverter(c,s);function o(h){const S=e.decode(h.value),y=e.encodingLength(S),g=n.decode({key:h.key,value:h.value.slice(y+S*32)}),d=new Array(S);for(let E=0,_=y;E<S;E++,_+=32)d[E]=h.value.slice(_,_+32);return Object.assign({},g,{leafHashes:d})}function u(h){const S=n.encode(h),y=e.encodingLength(h.leafHashes.length),g=r.allocUnsafe(y);e.encode(h.leafHashes.length,g);const d=r.concat([g,...h.leafHashes,S.value]);return Object.assign({},S,{value:d})}const a="{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";function f(h){return Array.isArray(h.leafHashes)&&h.leafHashes.every(S=>r.isBuffer(S)&&S.length===32)&&n.check(h)}return{decode:o,encode:u,check:f,expected:a,canAddToArray:n.canAddToArray}}return _e.makeConverter=i,_e}var Ie={},Et;function Ln(){if(Et)return Ie;Et=1;const{Buffer:r}=k();Object.defineProperty(Ie,"__esModule",{value:!0});function e(t){function s(u){if(u.key[0]!==t||u.key.length!==1)throw new Error("Decode Error: could not decode tapInternalKey with key 0x"+u.key.toString("hex"));if(u.value.length!==32)throw new Error("Decode Error: tapInternalKey not a 32-byte x-only pubkey");return u.value}function i(u){return{key:r.from([t]),value:u}}const c="Buffer";function n(u){return r.isBuffer(u)&&u.length===32}function o(u,a){return!!u&&!!a&&u.tapInternalKey===void 0}return{decode:s,encode:i,check:n,expected:c,canAdd:o}}return Ie.makeConverter=e,Ie}var Te={},wt;function Fn(){if(wt)return Te;wt=1;const{Buffer:r}=k();Object.defineProperty(Te,"__esModule",{value:!0});function e(t){function s(u){if(u.key[0]!==t)throw new Error("Decode Error: could not decode witnessScript with key 0x"+u.key.toString("hex"));return u.value}function i(u){return{key:r.from([t]),value:u}}const c="Buffer";function n(u){return r.isBuffer(u)}function o(u,a){return!!u&&!!a&&u.witnessScript===void 0}return{decode:s,encode:i,check:n,expected:c,canAdd:o}}return Te.makeConverter=e,Te}var yt;function Xe(){if(yt)return se;yt=1,Object.defineProperty(se,"__esModule",{value:!0});const r=b(),e=_n(),t=In(),s=Tn(),i=An(),c=kn(),n=mn(),o=bn(),u=vn(),a=Nn(),f=Cn(),h=Pn(),S=Un(),y=On(),g=xn(),d=Xt(),E=Hn(),_=Bn(),I=Rn(),p=Ln(),l=Fn(),A={unsignedTx:t,globalXpub:e,checkPubkey:E.makeChecker([])};se.globals=A;const v={nonWitnessUtxo:c,partialSig:n,sighashType:u,finalScriptSig:s,finalScriptWitness:i,porCommitment:o,witnessUtxo:y,bip32Derivation:d.makeConverter(r.InputTypes.BIP32_DERIVATION),redeemScript:_.makeConverter(r.InputTypes.REDEEM_SCRIPT),witnessScript:l.makeConverter(r.InputTypes.WITNESS_SCRIPT),checkPubkey:E.makeChecker([r.InputTypes.PARTIAL_SIG,r.InputTypes.BIP32_DERIVATION]),tapKeySig:a,tapScriptSig:S,tapLeafScript:f,tapBip32Derivation:I.makeConverter(r.InputTypes.TAP_BIP32_DERIVATION),tapInternalKey:p.makeConverter(r.InputTypes.TAP_INTERNAL_KEY),tapMerkleRoot:h};se.inputs=v;const L={bip32Derivation:d.makeConverter(r.OutputTypes.BIP32_DERIVATION),redeemScript:_.makeConverter(r.OutputTypes.REDEEM_SCRIPT),witnessScript:l.makeConverter(r.OutputTypes.WITNESS_SCRIPT),checkPubkey:E.makeChecker([r.OutputTypes.BIP32_DERIVATION]),tapBip32Derivation:I.makeConverter(r.OutputTypes.TAP_BIP32_DERIVATION),tapTree:g,tapInternalKey:p.makeConverter(r.OutputTypes.TAP_INTERNAL_KEY)};return se.outputs=L,se}var _t;function Kn(){if(_t)return ie;_t=1;const{Buffer:r}=k();Object.defineProperty(ie,"__esModule",{value:!0});const e=Xe(),t=qe(),s=ue(),i=b();function c(u,a){let f=0;function h(){const m=s.decode(u,f);f+=s.encodingLength(m);const C=u.slice(f,f+m);return f+=m,C}function S(){const m=u.readUInt32BE(f);return f+=4,m}function y(){const m=u.readUInt8(f);return f+=1,m}function g(){const m=h(),C=h();return{key:m,value:C}}function d(){if(f>=u.length)throw new Error("Format Error: Unexpected End of PSBT");const m=u.readUInt8(f)===0;return m&&f++,m}if(S()!==1886610036)throw new Error("Format Error: Invalid Magic Number");if(y()!==255)throw new Error("Format Error: Magic Number must be followed by 0xff separator");const E=[],_={};for(;!d();){const m=g(),C=m.key.toString("hex");if(_[C])throw new Error("Format Error: Keys must be unique for global keymap: key "+C);_[C]=1,E.push(m)}const I=E.filter(m=>m.key[0]===i.GlobalTypes.UNSIGNED_TX);if(I.length!==1)throw new Error("Format Error: Only one UNSIGNED_TX allowed");const p=a(I[0].value),{inputCount:l,outputCount:A}=p.getInputOutputCounts(),v=[],L=[];for(const m of t.range(l)){const C={},Z=[];for(;!d();){const ae=g(),ee=ae.key.toString("hex");if(C[ee])throw new Error("Format Error: Keys must be unique for each input: input index "+m+" key "+ee);C[ee]=1,Z.push(ae)}v.push(Z)}for(const m of t.range(A)){const C={},Z=[];for(;!d();){const ae=g(),ee=ae.key.toString("hex");if(C[ee])throw new Error("Format Error: Keys must be unique for each output: output index "+m+" key "+ee);C[ee]=1,Z.push(ae)}L.push(Z)}return o(p,{globalMapKeyVals:E,inputKeyVals:v,outputKeyVals:L})}ie.psbtFromBuffer=c;function n(u,a,f){if(!a.equals(r.from([f])))throw new Error(`Format Error: Invalid ${u} key: ${a.toString("hex")}`)}ie.checkKeyBuffer=n;function o(u,{globalMapKeyVals:a,inputKeyVals:f,outputKeyVals:h}){const S={unsignedTx:u};let y=0;for(const I of a)switch(I.key[0]){case i.GlobalTypes.UNSIGNED_TX:if(n("global",I.key,i.GlobalTypes.UNSIGNED_TX),y>0)throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");y++;break;case i.GlobalTypes.GLOBAL_XPUB:S.globalXpub===void 0&&(S.globalXpub=[]),S.globalXpub.push(e.globals.globalXpub.decode(I));break;default:S.unknownKeyVals||(S.unknownKeyVals=[]),S.unknownKeyVals.push(I)}const g=f.length,d=h.length,E=[],_=[];for(const I of t.range(g)){const p={};for(const l of f[I])switch(e.inputs.checkPubkey(l),l.key[0]){case i.InputTypes.NON_WITNESS_UTXO:if(n("input",l.key,i.InputTypes.NON_WITNESS_UTXO),p.nonWitnessUtxo!==void 0)throw new Error("Format Error: Input has multiple NON_WITNESS_UTXO");p.nonWitnessUtxo=e.inputs.nonWitnessUtxo.decode(l);break;case i.InputTypes.WITNESS_UTXO:if(n("input",l.key,i.InputTypes.WITNESS_UTXO),p.witnessUtxo!==void 0)throw new Error("Format Error: Input has multiple WITNESS_UTXO");p.witnessUtxo=e.inputs.witnessUtxo.decode(l);break;case i.InputTypes.PARTIAL_SIG:p.partialSig===void 0&&(p.partialSig=[]),p.partialSig.push(e.inputs.partialSig.decode(l));break;case i.InputTypes.SIGHASH_TYPE:if(n("input",l.key,i.InputTypes.SIGHASH_TYPE),p.sighashType!==void 0)throw new Error("Format Error: Input has multiple SIGHASH_TYPE");p.sighashType=e.inputs.sighashType.decode(l);break;case i.InputTypes.REDEEM_SCRIPT:if(n("input",l.key,i.InputTypes.REDEEM_SCRIPT),p.redeemScript!==void 0)throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");p.redeemScript=e.inputs.redeemScript.decode(l);break;case i.InputTypes.WITNESS_SCRIPT:if(n("input",l.key,i.InputTypes.WITNESS_SCRIPT),p.witnessScript!==void 0)throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");p.witnessScript=e.inputs.witnessScript.decode(l);break;case i.InputTypes.BIP32_DERIVATION:p.bip32Derivation===void 0&&(p.bip32Derivation=[]),p.bip32Derivation.push(e.inputs.bip32Derivation.decode(l));break;case i.InputTypes.FINAL_SCRIPTSIG:n("input",l.key,i.InputTypes.FINAL_SCRIPTSIG),p.finalScriptSig=e.inputs.finalScriptSig.decode(l);break;case i.InputTypes.FINAL_SCRIPTWITNESS:n("input",l.key,i.InputTypes.FINAL_SCRIPTWITNESS),p.finalScriptWitness=e.inputs.finalScriptWitness.decode(l);break;case i.InputTypes.POR_COMMITMENT:n("input",l.key,i.InputTypes.POR_COMMITMENT),p.porCommitment=e.inputs.porCommitment.decode(l);break;case i.InputTypes.TAP_KEY_SIG:n("input",l.key,i.InputTypes.TAP_KEY_SIG),p.tapKeySig=e.inputs.tapKeySig.decode(l);break;case i.InputTypes.TAP_SCRIPT_SIG:p.tapScriptSig===void 0&&(p.tapScriptSig=[]),p.tapScriptSig.push(e.inputs.tapScriptSig.decode(l));break;case i.InputTypes.TAP_LEAF_SCRIPT:p.tapLeafScript===void 0&&(p.tapLeafScript=[]),p.tapLeafScript.push(e.inputs.tapLeafScript.decode(l));break;case i.InputTypes.TAP_BIP32_DERIVATION:p.tapBip32Derivation===void 0&&(p.tapBip32Derivation=[]),p.tapBip32Derivation.push(e.inputs.tapBip32Derivation.decode(l));break;case i.InputTypes.TAP_INTERNAL_KEY:n("input",l.key,i.InputTypes.TAP_INTERNAL_KEY),p.tapInternalKey=e.inputs.tapInternalKey.decode(l);break;case i.InputTypes.TAP_MERKLE_ROOT:n("input",l.key,i.InputTypes.TAP_MERKLE_ROOT),p.tapMerkleRoot=e.inputs.tapMerkleRoot.decode(l);break;default:p.unknownKeyVals||(p.unknownKeyVals=[]),p.unknownKeyVals.push(l)}E.push(p)}for(const I of t.range(d)){const p={};for(const l of h[I])switch(e.outputs.checkPubkey(l),l.key[0]){case i.OutputTypes.REDEEM_SCRIPT:if(n("output",l.key,i.OutputTypes.REDEEM_SCRIPT),p.redeemScript!==void 0)throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");p.redeemScript=e.outputs.redeemScript.decode(l);break;case i.OutputTypes.WITNESS_SCRIPT:if(n("output",l.key,i.OutputTypes.WITNESS_SCRIPT),p.witnessScript!==void 0)throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");p.witnessScript=e.outputs.witnessScript.decode(l);break;case i.OutputTypes.BIP32_DERIVATION:p.bip32Derivation===void 0&&(p.bip32Derivation=[]),p.bip32Derivation.push(e.outputs.bip32Derivation.decode(l));break;case i.OutputTypes.TAP_INTERNAL_KEY:n("output",l.key,i.OutputTypes.TAP_INTERNAL_KEY),p.tapInternalKey=e.outputs.tapInternalKey.decode(l);break;case i.OutputTypes.TAP_TREE:n("output",l.key,i.OutputTypes.TAP_TREE),p.tapTree=e.outputs.tapTree.decode(l);break;case i.OutputTypes.TAP_BIP32_DERIVATION:p.tapBip32Derivation===void 0&&(p.tapBip32Derivation=[]),p.tapBip32Derivation.push(e.outputs.tapBip32Derivation.decode(l));break;default:p.unknownKeyVals||(p.unknownKeyVals=[]),p.unknownKeyVals.push(l)}_.push(p)}return{globalMap:S,inputs:E,outputs:_}}return ie.psbtFromKeyVals=o,ie}var fe={},It;function Wn(){if(It)return fe;It=1;const{Buffer:r}=k();Object.defineProperty(fe,"__esModule",{value:!0});const e=Xe(),t=qe();function s({globalMap:o,inputs:u,outputs:a}){const{globalKeyVals:f,inputKeyVals:h,outputKeyVals:S}=n({globalMap:o,inputs:u,outputs:a}),y=t.keyValsToBuffer(f),g=I=>I.length===0?[r.from([0])]:I.map(t.keyValsToBuffer),d=g(h),E=g(S),_=r.allocUnsafe(5);return _.writeUIntBE(482972169471,0,5),r.concat([_,y].concat(d,E))}fe.psbtToBuffer=s;const i=(o,u)=>o.key.compare(u.key);function c(o,u){const a=new Set,f=Object.entries(o).reduce((S,[y,g])=>{if(y==="unknownKeyVals")return S;const d=u[y];if(d===void 0)return S;const E=(Array.isArray(g)?g:[g]).map(d.encode);return E.map(I=>I.key.toString("hex")).forEach(I=>{if(a.has(I))throw new Error("Serialize Error: Duplicate key: "+I);a.add(I)}),S.concat(E)},[]),h=o.unknownKeyVals?o.unknownKeyVals.filter(S=>!a.has(S.key.toString("hex"))):[];return f.concat(h).sort(i)}function n({globalMap:o,inputs:u,outputs:a}){return{globalKeyVals:c(o,e.globals),inputKeyVals:u.map(f=>c(f,e.inputs)),outputKeyVals:a.map(f=>c(f,e.outputs))}}return fe.psbtToKeyVals=n,fe}var Tt;function Vt(){return Tt||(Tt=1,(function(r){function e(t){for(var s in t)r.hasOwnProperty(s)||(r[s]=t[s])}Object.defineProperty(r,"__esModule",{value:!0}),e(Kn()),e(Wn())})(Oe)),Oe}var At;function Dn(){if(At)return Se;At=1,Object.defineProperty(Se,"__esModule",{value:!0});const r=Vt();function e(c){const n=c[0],o=r.psbtToKeyVals(n),u=c.slice(1);if(u.length===0)throw new Error("Combine: Nothing to combine");const a=s(n);if(a===void 0)throw new Error("Combine: Self missing transaction");const f=i(o.globalKeyVals),h=o.inputKeyVals.map(i),S=o.outputKeyVals.map(i);for(const y of u){const g=s(y);if(g===void 0||!g.toBuffer().equals(a.toBuffer()))throw new Error("Combine: One of the Psbts does not have the same transaction.");const d=r.psbtToKeyVals(y);i(d.globalKeyVals).forEach(t(f,o.globalKeyVals,d.globalKeyVals)),d.inputKeyVals.map(i).forEach((p,l)=>p.forEach(t(h[l],o.inputKeyVals[l],d.inputKeyVals[l]))),d.outputKeyVals.map(i).forEach((p,l)=>p.forEach(t(S[l],o.outputKeyVals[l],d.outputKeyVals[l])))}return r.psbtFromKeyVals(a,{globalMapKeyVals:o.globalKeyVals,inputKeyVals:o.inputKeyVals,outputKeyVals:o.outputKeyVals})}Se.combine=e;function t(c,n,o){return u=>{if(c.has(u))return;const a=o.filter(f=>f.key.toString("hex")===u)[0];n.push(a),c.add(u)}}function s(c){return c.globalMap.unsignedTx}function i(c){const n=new Set;return c.forEach(o=>{const u=o.key.toString("hex");if(n.has(u))throw new Error("Combine: KeyValue Map keys should be unique");n.add(u)}),n}return Se}var He={},kt;function jt(){return kt||(kt=1,(function(r){const{Buffer:e}=k();Object.defineProperty(r,"__esModule",{value:!0});const t=Xe();function s(g,d){const E=g[d];if(E===void 0)throw new Error(`No input #${d}`);return E}r.checkForInput=s;function i(g,d){const E=g[d];if(E===void 0)throw new Error(`No output #${d}`);return E}r.checkForOutput=i;function c(g,d,E){if(g.key[0]<E)throw new Error("Use the method for your specific key instead of addUnknownKeyVal*");if(d&&d.filter(_=>_.key.equals(g.key)).length!==0)throw new Error(`Duplicate Key: ${g.key.toString("hex")}`)}r.checkHasKey=c;function n(g){let d=0;return Object.keys(g).forEach(E=>{Number(isNaN(Number(E)))&&d++}),d}r.getEnumLength=n;function o(g,d){let E=!1;if(d.nonWitnessUtxo||d.witnessUtxo){const _=!!d.redeemScript,I=!!d.witnessScript,p=!_||!!d.finalScriptSig,l=!I||!!d.finalScriptWitness,A=!!d.finalScriptSig||!!d.finalScriptWitness;E=p&&l&&A}if(E===!1)throw new Error(`Input #${g} has too much or too little data to clean`)}r.inputCheckUncleanFinalized=o;function u(g,d,E,_){throw new Error(`Data for ${g} key ${d} is incorrect: Expected ${E} and got ${JSON.stringify(_)}`)}function a(g){return(d,E)=>{for(const _ of Object.keys(d)){const I=d[_],{canAdd:p,canAddToArray:l,check:A,expected:v}=t[g+"s"][_]||{},L=!!l;if(A)if(L){if(!Array.isArray(I)||E[_]&&!Array.isArray(E[_]))throw new Error(`Key type ${_} must be an array`);I.every(A)||u(g,_,v,I);const m=E[_]||[],C=new Set;if(!I.every(Z=>l(m,Z,C)))throw new Error("Can not add duplicate data to array");E[_]=m.concat(I)}else{if(A(I)||u(g,_,v,I),!p(E,I))throw new Error(`Can not add duplicate data to ${g}`);E[_]=I}}}}r.updateGlobal=a("global"),r.updateInput=a("input"),r.updateOutput=a("output");function f(g,d){const E=g.length-1,_=s(g,E);r.updateInput(d,_)}r.addInputAttributes=f;function h(g,d){const E=g.length-1,_=i(g,E);r.updateOutput(d,_)}r.addOutputAttributes=h;function S(g,d){if(!e.isBuffer(d)||d.length<4)throw new Error("Set Version: Invalid Transaction");return d.writeUInt32LE(g,0),d}r.defaultVersionSetter=S;function y(g,d){if(!e.isBuffer(d)||d.length<4)throw new Error("Set Locktime: Invalid Transaction");return d.writeUInt32LE(g,d.length-4),d}r.defaultLocktimeSetter=y})(He)),He}var mt;function Gn(){if(mt)return de;mt=1;const{Buffer:r}=k();Object.defineProperty(de,"__esModule",{value:!0});const e=Dn(),t=Vt(),s=b(),i=jt();class c{constructor(o){this.inputs=[],this.outputs=[],this.globalMap={unsignedTx:o}}static fromBase64(o,u){const a=r.from(o,"base64");return this.fromBuffer(a,u)}static fromHex(o,u){const a=r.from(o,"hex");return this.fromBuffer(a,u)}static fromBuffer(o,u){const a=t.psbtFromBuffer(o,u),f=new this(a.globalMap.unsignedTx);return Object.assign(f,a),f}toBase64(){return this.toBuffer().toString("base64")}toHex(){return this.toBuffer().toString("hex")}toBuffer(){return t.psbtToBuffer(this)}updateGlobal(o){return i.updateGlobal(o,this.globalMap),this}updateInput(o,u){const a=i.checkForInput(this.inputs,o);return i.updateInput(u,a),this}updateOutput(o,u){const a=i.checkForOutput(this.outputs,o);return i.updateOutput(u,a),this}addUnknownKeyValToGlobal(o){return i.checkHasKey(o,this.globalMap.unknownKeyVals,i.getEnumLength(s.GlobalTypes)),this.globalMap.unknownKeyVals||(this.globalMap.unknownKeyVals=[]),this.globalMap.unknownKeyVals.push(o),this}addUnknownKeyValToInput(o,u){const a=i.checkForInput(this.inputs,o);return i.checkHasKey(u,a.unknownKeyVals,i.getEnumLength(s.InputTypes)),a.unknownKeyVals||(a.unknownKeyVals=[]),a.unknownKeyVals.push(u),this}addUnknownKeyValToOutput(o,u){const a=i.checkForOutput(this.outputs,o);return i.checkHasKey(u,a.unknownKeyVals,i.getEnumLength(s.OutputTypes)),a.unknownKeyVals||(a.unknownKeyVals=[]),a.unknownKeyVals.push(u),this}addInput(o){this.globalMap.unsignedTx.addInput(o),this.inputs.push({unknownKeyVals:[]});const u=o.unknownKeyVals||[],a=this.inputs.length-1;if(!Array.isArray(u))throw new Error("unknownKeyVals must be an Array");return u.forEach(f=>this.addUnknownKeyValToInput(a,f)),i.addInputAttributes(this.inputs,o),this}addOutput(o){this.globalMap.unsignedTx.addOutput(o),this.outputs.push({unknownKeyVals:[]});const u=o.unknownKeyVals||[],a=this.outputs.length-1;if(!Array.isArray(u))throw new Error("unknownKeyVals must be an Array");return u.forEach(f=>this.addUnknownKeyValToInput(a,f)),i.addOutputAttributes(this.outputs,o),this}clearFinalizedInput(o){const u=i.checkForInput(this.inputs,o);i.inputCheckUncleanFinalized(o,u);for(const a of Object.keys(u))["witnessUtxo","nonWitnessUtxo","finalScriptSig","finalScriptWitness","unknownKeyVals"].includes(a)||delete u[a];return this}combine(...o){const u=e.combine([this].concat(o));return Object.assign(this,u),this}getTransaction(){return this.globalMap.unsignedTx.toBuffer()}}return de.Psbt=c,de}var Be,bt;function Mn(){return bt||(bt=1,Be=Gn()),Be}var vt=Mn(),qn=ue();const Xn=un(qn);var O=jt();const ke=Xn,{typeforce:P}=Wt;function U(r){const e=r.length;return Q.encodingLength(e)+e}function Vn(r){const e=r.length;return Q.encodingLength(e)+r.reduce((t,s)=>t+U(s),0)}const J=T.allocUnsafe(0),Nt=[],Re=T.from("0000000000000000000000000000000000000000000000000000000000000000","hex"),Ct=T.from("0000000000000000000000000000000000000000000000000000000000000001","hex"),jn=T.from("ffffffffffffffff","hex"),$n={script:J,valueBuffer:jn};function Yn(r){return r.value!==void 0}class w{constructor(){this.version=1,this.locktime=0,this.ins=[],this.outs=[]}static fromBuffer(e,t){const s=new yn(e),i=new w;i.version=s.readInt32();const c=s.readUInt8(),n=s.readUInt8();let o=!1;c===w.ADVANCED_TRANSACTION_MARKER&&n===w.ADVANCED_TRANSACTION_FLAG?o=!0:s.offset-=2;const u=s.readVarInt();for(let f=0;f<u;++f)i.ins.push({hash:s.readSlice(32),index:s.readUInt32(),script:s.readVarSlice(),sequence:s.readUInt32(),witness:Nt});const a=s.readVarInt();for(let f=0;f<a;++f)i.outs.push({value:s.readUInt64(),script:s.readVarSlice()});if(o){for(let f=0;f<u;++f)i.ins[f].witness=s.readVector();if(!i.hasWitnesses())throw new Error("Transaction has superfluous witness data")}if(i.locktime=s.readUInt32(),t)return i;if(s.offset!==e.length)throw new Error("Transaction has unexpected data");return i}static fromHex(e){return w.fromBuffer(T.from(e,"hex"),!1)}static isCoinbaseHash(e){P(je,e);for(let t=0;t<32;++t)if(e[t]!==0)return!1;return!0}isCoinbase(){return this.ins.length===1&&w.isCoinbaseHash(this.ins[0].hash)}addInput(e,t,s,i){return P(H(je,R,$e(R),$e(B)),arguments),fn(s)&&(s=w.DEFAULT_SEQUENCE),this.ins.push({hash:e,index:t,script:i||J,sequence:s,witness:Nt})-1}addOutput(e,t){return P(H(B,Pe),arguments),this.outs.push({script:e,value:t})-1}hasWitnesses(){return this.ins.some(e=>e.witness.length!==0)}weight(){const e=this.byteLength(!1),t=this.byteLength(!0);return e*3+t}virtualSize(){return Math.ceil(this.weight()/4)}byteLength(e=!0){const t=e&&this.hasWitnesses();return(t?10:8)+Q.encodingLength(this.ins.length)+Q.encodingLength(this.outs.length)+this.ins.reduce((s,i)=>s+40+U(i.script),0)+this.outs.reduce((s,i)=>s+8+U(i.script),0)+(t?this.ins.reduce((s,i)=>s+Vn(i.witness),0):0)}clone(){const e=new w;return e.version=this.version,e.locktime=this.locktime,e.ins=this.ins.map(t=>({hash:t.hash,index:t.index,script:t.script,sequence:t.sequence,witness:t.witness})),e.outs=this.outs.map(t=>({script:t.script,value:t.value})),e}hashForSignature(e,t,s){if(P(H(R,B,Ue),arguments),e>=this.ins.length)return Ct;const i=hn(re(t).filter(o=>o!==gn.OP_CODESEPARATOR)),c=this.clone();if((s&31)===w.SIGHASH_NONE)c.outs=[],c.ins.forEach((o,u)=>{u!==e&&(o.sequence=0)});else if((s&31)===w.SIGHASH_SINGLE){if(e>=this.outs.length)return Ct;c.outs.length=e+1;for(let o=0;o<e;o++)c.outs[o]=$n;c.ins.forEach((o,u)=>{u!==e&&(o.sequence=0)})}s&w.SIGHASH_ANYONECANPAY?(c.ins=[c.ins[e]],c.ins[0].script=i):(c.ins.forEach(o=>{o.script=J}),c.ins[e].script=i);const n=T.allocUnsafe(c.byteLength(!1)+4);return n.writeInt32LE(s,n.length-4),c.__toBuffer(n,0,!1),te(n)}hashForWitnessV1(e,t,s,i,c,n){if(P(H(R,P.arrayOf(B),P.arrayOf(Pe),R),arguments),s.length!==this.ins.length||t.length!==this.ins.length)throw new Error("Must supply prevout script and value for all inputs");const o=i===w.SIGHASH_DEFAULT?w.SIGHASH_ALL:i&w.SIGHASH_OUTPUT_MASK,a=(i&w.SIGHASH_INPUT_MASK)===w.SIGHASH_ANYONECANPAY,f=o===w.SIGHASH_NONE,h=o===w.SIGHASH_SINGLE;let S=J,y=J,g=J,d=J,E=J;if(!a){let l=N.withCapacity(36*this.ins.length);this.ins.forEach(A=>{l.writeSlice(A.hash),l.writeUInt32(A.index)}),S=ne(l.end()),l=N.withCapacity(8*this.ins.length),s.forEach(A=>l.writeUInt64(A)),y=ne(l.end()),l=N.withCapacity(t.map(U).reduce((A,v)=>A+v)),t.forEach(A=>l.writeVarSlice(A)),g=ne(l.end()),l=N.withCapacity(4*this.ins.length),this.ins.forEach(A=>l.writeUInt32(A.sequence)),d=ne(l.end())}if(f||h){if(h&&e<this.outs.length){const l=this.outs[e],A=N.withCapacity(8+U(l.script));A.writeUInt64(l.value),A.writeVarSlice(l.script),E=ne(A.end())}}else{const l=this.outs.map(v=>8+U(v.script)).reduce((v,L)=>v+L),A=N.withCapacity(l);this.outs.forEach(v=>{A.writeUInt64(v.value),A.writeVarSlice(v.script)}),E=ne(A.end())}const _=(c?2:0)+(n?1:0),I=174-(a?49:0)-(f?32:0)+(n?32:0)+(c?37:0),p=N.withCapacity(I);if(p.writeUInt8(i),p.writeInt32(this.version),p.writeUInt32(this.locktime),p.writeSlice(S),p.writeSlice(y),p.writeSlice(g),p.writeSlice(d),f||h||p.writeSlice(E),p.writeUInt8(_),a){const l=this.ins[e];p.writeSlice(l.hash),p.writeUInt32(l.index),p.writeUInt64(s[e]),p.writeVarSlice(t[e]),p.writeUInt32(l.sequence)}else p.writeUInt32(e);if(n){const l=N.withCapacity(U(n));l.writeVarSlice(n),p.writeSlice(ne(l.end()))}return h&&p.writeSlice(E),c&&(p.writeSlice(c),p.writeUInt8(0),p.writeUInt32(4294967295)),ln("TapSighash",T.concat([T.of(0),p.end()]))}hashForWitnessV0(e,t,s,i){P(H(R,B,Pe,R),arguments);let c=T.from([]),n,o=Re,u=Re,a=Re;if(i&w.SIGHASH_ANYONECANPAY||(c=T.allocUnsafe(36*this.ins.length),n=new N(c,0),this.ins.forEach(h=>{n.writeSlice(h.hash),n.writeUInt32(h.index)}),u=te(c)),!(i&w.SIGHASH_ANYONECANPAY)&&(i&31)!==w.SIGHASH_SINGLE&&(i&31)!==w.SIGHASH_NONE&&(c=T.allocUnsafe(4*this.ins.length),n=new N(c,0),this.ins.forEach(h=>{n.writeUInt32(h.sequence)}),a=te(c)),(i&31)!==w.SIGHASH_SINGLE&&(i&31)!==w.SIGHASH_NONE){const h=this.outs.reduce((S,y)=>S+8+U(y.script),0);c=T.allocUnsafe(h),n=new N(c,0),this.outs.forEach(S=>{n.writeUInt64(S.value),n.writeVarSlice(S.script)}),o=te(c)}else if((i&31)===w.SIGHASH_SINGLE&&e<this.outs.length){const h=this.outs[e];c=T.allocUnsafe(8+U(h.script)),n=new N(c,0),n.writeUInt64(h.value),n.writeVarSlice(h.script),o=te(c)}c=T.allocUnsafe(156+U(t)),n=new N(c,0);const f=this.ins[e];return n.writeInt32(this.version),n.writeSlice(u),n.writeSlice(a),n.writeSlice(f.hash),n.writeUInt32(f.index),n.writeVarSlice(t),n.writeUInt64(s),n.writeUInt32(f.sequence),n.writeSlice(o),n.writeUInt32(this.locktime),n.writeUInt32(i),te(c)}getHash(e){return e&&this.isCoinbase()?T.alloc(32,0):te(this.__toBuffer(void 0,void 0,e))}getId(){return Me(this.getHash(!1)).toString("hex")}toBuffer(e,t){return this.__toBuffer(e,t,!0)}toHex(){return this.toBuffer(void 0,void 0).toString("hex")}setInputScript(e,t){P(H(Ue,B),arguments),this.ins[e].script=t}setWitness(e,t){P(H(Ue,[B]),arguments),this.ins[e].witness=t}__toBuffer(e,t,s=!1){e||(e=T.allocUnsafe(this.byteLength(s)));const i=new N(e,t||0);i.writeInt32(this.version);const c=s&&this.hasWitnesses();return c&&(i.writeUInt8(w.ADVANCED_TRANSACTION_MARKER),i.writeUInt8(w.ADVANCED_TRANSACTION_FLAG)),i.writeVarInt(this.ins.length),this.ins.forEach(n=>{i.writeSlice(n.hash),i.writeUInt32(n.index),i.writeVarSlice(n.script),i.writeUInt32(n.sequence)}),i.writeVarInt(this.outs.length),this.outs.forEach(n=>{Yn(n)?i.writeUInt64(n.value):i.writeSlice(n.valueBuffer),i.writeVarSlice(n.script)}),c&&this.ins.forEach(n=>{i.writeVector(n.witness)}),i.writeUInt32(this.locktime),t!==void 0?e.slice(t,i.offset):e}}w.DEFAULT_SEQUENCE=4294967295;w.SIGHASH_DEFAULT=0;w.SIGHASH_ALL=1;w.SIGHASH_NONE=2;w.SIGHASH_SINGLE=3;w.SIGHASH_ANYONECANPAY=128;w.SIGHASH_OUTPUT_MASK=3;w.SIGHASH_INPUT_MASK=128;w.ADVANCED_TRANSACTION_MARKER=0;w.ADVANCED_TRANSACTION_FLAG=1;const zn={network:Sn,maximumFeeRate:5e3};class Fe{static fromBase64(e,t={}){const s=T.from(e,"base64");return this.fromBuffer(s,t)}static fromHex(e,t={}){const s=T.from(e,"hex");return this.fromBuffer(s,t)}static fromBuffer(e,t={}){const s=vt.Psbt.fromBuffer(e,Jn),i=new Fe(t,s);return sr(i.__CACHE.__TX,i.__CACHE),i}constructor(e={},t=new vt.Psbt(new $t)){this.data=t,this.opts=Object.assign({},zn,e),this.__CACHE={__NON_WITNESS_UTXO_TX_CACHE:[],__NON_WITNESS_UTXO_BUF_CACHE:[],__TX_IN_CACHE:{},__TX:this.data.globalMap.unsignedTx.tx,__UNSAFE_SIGN_NONSEGWIT:!1},this.data.inputs.length===0&&this.setVersion(2);const s=(i,c,n,o)=>Object.defineProperty(i,c,{enumerable:n,writable:o});s(this,"__CACHE",!1,!0),s(this,"opts",!1,!0)}get inputCount(){return this.data.inputs.length}get version(){return this.__CACHE.__TX.version}set version(e){this.setVersion(e)}get locktime(){return this.__CACHE.__TX.locktime}set locktime(e){this.setLocktime(e)}get txInputs(){return this.__CACHE.__TX.ins.map(e=>({hash:Ye(e.hash),index:e.index,sequence:e.sequence}))}get txOutputs(){return this.__CACHE.__TX.outs.map(e=>{let t;try{t=cn(e.script,this.opts.network)}catch{}return{script:Ye(e.script),value:e.value,address:t}})}combine(...e){return this.data.combine(...e.map(t=>t.data)),this}clone(){const e=Fe.fromBuffer(this.data.toBuffer());return e.opts=JSON.parse(JSON.stringify(this.opts)),e}setMaximumFeeRate(e){Ae(e),this.opts.maximumFeeRate=e}setVersion(e){Ae(e),he(this.data.inputs,"setVersion");const t=this.__CACHE;return t.__TX.version=e,t.__EXTRACTED_TX=void 0,this}setLocktime(e){Ae(e),he(this.data.inputs,"setLocktime");const t=this.__CACHE;return t.__TX.locktime=e,t.__EXTRACTED_TX=void 0,this}setInputSequence(e,t){Ae(t),he(this.data.inputs,"setInputSequence");const s=this.__CACHE;if(s.__TX.ins.length<=e)throw new Error("Input index too high");return s.__TX.ins[e].sequence=t,s.__EXTRACTED_TX=void 0,this}addInputs(e){return e.forEach(t=>this.addInput(t)),this}addInput(e){if(arguments.length>1||!e||e.hash===void 0||e.index===void 0)throw new Error("Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]");he(this.data.inputs,"addInput"),e.witnessScript&&me(e.witnessScript);const t=this.__CACHE;this.data.addInput(e);const s=t.__TX.ins[t.__TX.ins.length-1];Qt(t,s);const i=this.data.inputs.length-1,c=this.data.inputs[i];return c.nonWitnessUtxo&&Ke(this.__CACHE,c,i),t.__FEE=void 0,t.__FEE_RATE=void 0,t.__EXTRACTED_TX=void 0,this}addOutputs(e){return e.forEach(t=>this.addOutput(t)),this}addOutput(e){if(arguments.length>1||!e||e.value===void 0||e.address===void 0&&e.script===void 0)throw new Error("Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]");he(this.data.inputs,"addOutput");const{address:t}=e;if(typeof t=="string"){const{network:i}=this.opts,c=an(t,i);e=Object.assign(e,{script:c})}const s=this.__CACHE;return this.data.addOutput(e),s.__FEE=void 0,s.__FEE_RATE=void 0,s.__EXTRACTED_TX=void 0,this}extractTransaction(e){if(!this.data.inputs.every(Yt))throw new Error("Not finalized");const t=this.__CACHE;if(e||nr(this,t,this.opts),t.__EXTRACTED_TX)return t.__EXTRACTED_TX;const s=t.__TX.clone();return nn(this.data.inputs,s,t,!0),s}getFeeRate(){return Bt("__FEE_RATE","fee rate",this.data.inputs,this.__CACHE)}getFee(){return Bt("__FEE","fee",this.data.inputs,this.__CACHE)}finalizeAllInputs(){return O.checkForInput(this.data.inputs,0),pe(this.data.inputs.length).forEach(e=>this.finalizeInput(e)),this}finalizeInput(e,t=or){const s=O.checkForInput(this.data.inputs,e),{script:i,isP2SH:c,isP2WSH:n,isSegwit:o}=fr(e,s,this.__CACHE);if(!i)throw new Error(`No script found for input #${e}`);rr(s);const{finalScriptSig:u,finalScriptWitness:a}=t(e,s,i,o,c,n);if(u&&this.data.updateInput(e,{finalScriptSig:u}),a&&this.data.updateInput(e,{finalScriptWitness:a}),!u&&!a)throw new Error(`Unknown error finalizing input #${e}`);return this.data.clearFinalizedInput(e),this}getInputType(e){const t=O.checkForInput(this.data.inputs,e),s=rn(e,t,this.__CACHE),i=Ce(s,e,"input",t.redeemScript||Sr(t.finalScriptSig),t.witnessScript||gr(t.finalScriptWitness)),c=i.type==="raw"?"":i.type+"-",n=on(i.meaningfulScript);return c+n}inputHasPubkey(e,t){const s=O.checkForInput(this.data.inputs,e);return lr(t,s,e,this.__CACHE)}inputHasHDKey(e,t){const s=O.checkForInput(this.data.inputs,e),i=Ot(t);return!!s.bip32Derivation&&s.bip32Derivation.some(i)}outputHasPubkey(e,t){const s=O.checkForOutput(this.data.outputs,e);return dr(t,s,e,this.__CACHE)}outputHasHDKey(e,t){const s=O.checkForOutput(this.data.outputs,e),i=Ot(t);return!!s.bip32Derivation&&s.bip32Derivation.some(i)}validateSignaturesOfAllInputs(e){return O.checkForInput(this.data.inputs,0),pe(this.data.inputs.length).map(s=>this.validateSignaturesOfInput(s,e)).reduce((s,i)=>i===!0&&s,!0)}validateSignaturesOfInput(e,t,s){const i=this.data.inputs[e],c=(i||{}).partialSig;if(!i||!c||c.length<1)throw new Error("No signatures to validate");if(typeof t!="function")throw new Error("Need validator function to validate signatures");const n=s?c.filter(h=>h.pubkey.equals(s)):c;if(n.length<1)throw new Error("No signatures for this pubkey");const o=[];let u,a,f;for(const h of n){const S=le.decode(h.signature),{hash:y,script:g}=f!==S.hashType?en(e,Object.assign({},i,{sighashType:S.hashType}),this.__CACHE,!0):{hash:u,script:a};f=S.hashType,u=y,a=g,Jt(h.pubkey,g,"verify"),o.push(t(h.pubkey,y,S.signature))}return o.every(h=>h===!0)}signAllInputsHD(e,t=[w.SIGHASH_ALL]){if(!e||!e.publicKey||!e.fingerprint)throw new Error("Need HDSigner to sign input");const s=[];for(const i of pe(this.data.inputs.length))try{this.signInputHD(i,e,t),s.push(!0)}catch{s.push(!1)}if(s.every(i=>i===!1))throw new Error("No inputs were signed");return this}signAllInputsHDAsync(e,t=[w.SIGHASH_ALL]){return new Promise((s,i)=>{if(!e||!e.publicKey||!e.fingerprint)return i(new Error("Need HDSigner to sign input"));const c=[],n=[];for(const o of pe(this.data.inputs.length))n.push(this.signInputHDAsync(o,e,t).then(()=>{c.push(!0)},()=>{c.push(!1)}));return Promise.all(n).then(()=>{if(c.every(o=>o===!1))return i(new Error("No inputs were signed"));s()})})}signInputHD(e,t,s=[w.SIGHASH_ALL]){if(!t||!t.publicKey||!t.fingerprint)throw new Error("Need HDSigner to sign input");return Lt(e,this.data.inputs,t).forEach(c=>this.signInput(e,c,s)),this}signInputHDAsync(e,t,s=[w.SIGHASH_ALL]){return new Promise((i,c)=>{if(!t||!t.publicKey||!t.fingerprint)return c(new Error("Need HDSigner to sign input"));const o=Lt(e,this.data.inputs,t).map(u=>this.signInputAsync(e,u,s));return Promise.all(o).then(()=>{i()}).catch(c)})}signAllInputs(e,t=[w.SIGHASH_ALL]){if(!e||!e.publicKey)throw new Error("Need Signer to sign input");const s=[];for(const i of pe(this.data.inputs.length))try{this.signInput(i,e,t),s.push(!0)}catch{s.push(!1)}if(s.every(i=>i===!1))throw new Error("No inputs were signed");return this}signAllInputsAsync(e,t=[w.SIGHASH_ALL]){return new Promise((s,i)=>{if(!e||!e.publicKey)return i(new Error("Need Signer to sign input"));const c=[],n=[];for(const[o]of this.data.inputs.entries())n.push(this.signInputAsync(o,e,t).then(()=>{c.push(!0)},()=>{c.push(!1)}));return Promise.all(n).then(()=>{if(c.every(o=>o===!1))return i(new Error("No inputs were signed"));s()})})}signInput(e,t,s=[w.SIGHASH_ALL]){if(!t||!t.publicKey)throw new Error("Need Signer to sign input");const{hash:i,sighashType:c}=Rt(this.data.inputs,e,T.from(t.publicKey),this.__CACHE,s),n=[{pubkey:T.from(t.publicKey),signature:le.encode(T.from(t.sign(i)),c)}];return this.data.updateInput(e,{partialSig:n}),this}signInputAsync(e,t,s=[w.SIGHASH_ALL]){return Promise.resolve().then(()=>{if(!t||!t.publicKey)throw new Error("Need Signer to sign input");const{hash:i,sighashType:c}=Rt(this.data.inputs,e,t.publicKey,this.__CACHE,s);return Promise.resolve(t.sign(i)).then(n=>{const o=[{pubkey:t.publicKey,signature:le.encode(n,c)}];this.data.updateInput(e,{partialSig:o})})})}toBuffer(){return Le(this.__CACHE),this.data.toBuffer()}toHex(){return Le(this.__CACHE),this.data.toHex()}toBase64(){return Le(this.__CACHE),this.data.toBase64()}updateGlobal(e){return this.data.updateGlobal(e),this}updateInput(e,t){return t.witnessScript&&me(t.witnessScript),this.data.updateInput(e,t),t.nonWitnessUtxo&&Ke(this.__CACHE,this.data.inputs[e],e),this}updateOutput(e,t){return this.data.updateOutput(e,t),this}addUnknownKeyValToGlobal(e){return this.data.addUnknownKeyValToGlobal(e),this}addUnknownKeyValToInput(e,t){return this.data.addUnknownKeyValToInput(e,t),this}addUnknownKeyValToOutput(e,t){return this.data.addUnknownKeyValToOutput(e,t),this}clearFinalizedInput(e){return this.data.clearFinalizedInput(e),this}}const Jn=r=>new $t(r);class $t{constructor(e=T.from([2,0,0,0,0,0,0,0,0,0])){this.tx=w.fromBuffer(e),ir(this.tx),Object.defineProperty(this,"tx",{enumerable:!1,writable:!0})}getInputOutputCounts(){return{inputCount:this.tx.ins.length,outputCount:this.tx.outs.length}}addInput(e){if(e.hash===void 0||e.index===void 0||!T.isBuffer(e.hash)&&typeof e.hash!="string"||typeof e.index!="number")throw new Error("Error adding input.");const t=typeof e.hash=="string"?Me(T.from(e.hash,"hex")):e.hash;this.tx.addInput(t,e.index,e.sequence)}addOutput(e){if(e.script===void 0||e.value===void 0||!T.isBuffer(e.script)||typeof e.value!="number")throw new Error("Error adding output.");this.tx.addOutput(e.script,e.value)}toBuffer(){return this.tx.toBuffer()}}function Qn(r,e,t){switch(t){case"pubkey":case"pubkeyhash":case"witnesspubkeyhash":return Pt(1,r.partialSig);case"multisig":const s=be({output:e});return Pt(s.m,r.partialSig,s.pubkeys);default:return!1}}function Le(r){if(r.__UNSAFE_SIGN_NONSEGWIT!==!1)throw new Error("Not BIP174 compliant, can not export")}function Pt(r,e,t){if(!e)return!1;let s;if(t?s=t.map(i=>{const c=Er(i);return e.find(n=>n.pubkey.equals(c))}).filter(i=>!!i):s=e,s.length>r)throw new Error("Too many signatures");return s.length===r}function Yt(r){return!!r.finalScriptSig||!!r.finalScriptWitness}function ce(r){return e=>{try{return r({output:e}),!0}catch{return!1}}}const Zn=ce(be),er=ce(Gt),tr=ce(We),ve=ce(Kt),Ut=ce(Ge),zt=ce(De);function Ot(r){return e=>!(!e.masterFingerprint.equals(r.fingerprint)||!r.derivePath(e.path).publicKey.equals(e.pubkey))}function Ae(r){if(typeof r!="number"||r!==Math.floor(r)||r>4294967295||r<0)throw new Error("Invalid 32 bit integer")}function nr(r,e,t){const s=e.__FEE_RATE||r.getFeeRate(),i=e.__EXTRACTED_TX.virtualSize(),c=s*i;if(s>=t.maximumFeeRate)throw new Error(`Warning: You are paying around ${(c/1e8).toFixed(8)} in fees, which is ${s} satoshi per byte for a transaction with a VSize of ${i} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`)}function he(r,e){r.forEach(t=>{let s=!1,i=[];if((t.partialSig||[]).length===0){if(!t.finalScriptSig&&!t.finalScriptWitness)return;i=ar(t)}else i=t.partialSig;if(i.forEach(c=>{const{hashType:n}=le.decode(c.signature),o=[];switch(n&w.SIGHASH_ANYONECANPAY&&o.push("addInput"),n&31){case w.SIGHASH_ALL:break;case w.SIGHASH_SINGLE:case w.SIGHASH_NONE:o.push("addOutput"),o.push("setInputSequence");break}o.indexOf(e)===-1&&(s=!0)}),s)throw new Error("Can not modify transaction, signatures exist.")})}function rr(r){if(!r.sighashType||!r.partialSig)return;const{partialSig:e,sighashType:t}=r;e.forEach(s=>{const{hashType:i}=le.decode(s.signature);if(t!==i)throw new Error("Signature sighash does not match input sighash type")})}function Jt(r,e,t){if(!Ve(r,e))throw new Error(`Can not ${t} for this input with the key ${r.toString("hex")}`)}function ir(r){if(!r.ins.every(t=>t.script&&t.script.length===0&&t.witness&&t.witness.length===0))throw new Error("Format Error: Transaction ScriptSigs are not empty")}function sr(r,e){r.ins.forEach(t=>{Qt(e,t)})}function Qt(r,e){const t=Me(T.from(e.hash)).toString("hex")+":"+e.index;if(r.__TX_IN_CACHE[t])throw new Error("Duplicate input detected.");r.__TX_IN_CACHE[t]=1}function Zt(r,e){return(t,s,i,c)=>{const n=r({redeem:{output:i}}).output;if(!s.equals(n))throw new Error(`${e} for ${c} #${t} doesn't match the scriptPubKey in the prevout`)}}const xt=Zt(De,"Redeem script"),Ht=Zt(Ge,"Witness script");function Bt(r,e,t,s){if(!t.every(Yt))throw new Error(`PSBT must be finalized to calculate ${e}`);if(r==="__FEE_RATE"&&s.__FEE_RATE)return s.__FEE_RATE;if(r==="__FEE"&&s.__FEE)return s.__FEE;let i,c=!0;if(s.__EXTRACTED_TX?(i=s.__EXTRACTED_TX,c=!1):i=s.__TX.clone(),nn(t,i,s,c),r==="__FEE_RATE")return s.__FEE_RATE;if(r==="__FEE")return s.__FEE}function or(r,e,t,s,i,c){const n=on(t);if(!Qn(e,t,n))throw new Error(`Can not finalize input #${r}`);return ur(t,n,e.partialSig,s,i,c)}function ur(r,e,t,s,i,c){let n,o;const u=cr(r,e,t),a=c?Ge({redeem:u}):null,f=i?De({redeem:a||u}):null;return s?(a?o=Ft(a.witness):o=Ft(u.witness),f&&(n=f.input)):f?n=f.input:n=u.input,{finalScriptSig:n,finalScriptWitness:o}}function Rt(r,e,t,s,i){const c=O.checkForInput(r,e),{hash:n,sighashType:o,script:u}=en(e,c,s,!1,i);return Jt(t,u,"sign"),{hash:n,sighashType:o}}function en(r,e,t,s,i){const c=t.__TX,n=e.sighashType||w.SIGHASH_ALL;if(i&&i.indexOf(n)<0){const h=pr(n);throw new Error(`Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${h}`)}let o,u;if(e.nonWitnessUtxo){const h=Ne(t,e,r),S=c.ins[r].hash,y=h.getHash();if(!S.equals(y))throw new Error(`Non-witness UTXO hash for input #${r} doesn't match the hash specified in the prevout`);const g=c.ins[r].index;u=h.outs[g]}else if(e.witnessUtxo)u=e.witnessUtxo;else throw new Error("Need a Utxo input item for signing");const{meaningfulScript:a,type:f}=Ce(u.script,r,"input",e.redeemScript,e.witnessScript);if(["p2sh-p2wsh","p2wsh"].indexOf(f)>=0)o=c.hashForWitnessV0(r,a,u.value,n);else if(ve(a)){const h=We({hash:a.slice(2)}).output;o=c.hashForWitnessV0(r,h,u.value,n)}else{if(e.nonWitnessUtxo===void 0&&t.__UNSAFE_SIGN_NONSEGWIT===!1)throw new Error(`Input #${r} has witnessUtxo but non-segwit script: ${a.toString("hex")}`);!s&&t.__UNSAFE_SIGN_NONSEGWIT!==!1&&console.warn(`Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecesor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`),o=c.hashForSignature(r,a,n)}return{script:a,sighashType:n,hash:o}}function cr(r,e,t){let s;switch(e){case"multisig":const i=hr(r,t);s=be({output:r,signatures:i});break;case"pubkey":s=Gt({output:r,signature:t[0].signature});break;case"pubkeyhash":s=We({output:r,pubkey:t[0].pubkey,signature:t[0].signature});break;case"witnesspubkeyhash":s=Kt({output:r,pubkey:t[0].pubkey,signature:t[0].signature});break}return s}function ar(r){const e=r.finalScriptSig?re(r.finalScriptSig)||[]:[],t=r.finalScriptWitness?re(r.finalScriptWitness)||[]:[];return e.concat(t).filter(s=>T.isBuffer(s)&&Dt(s)).map(s=>({signature:s}))}function fr(r,e,t){const s=t.__TX,i={script:null,isSegwit:!1,isP2SH:!1,isP2WSH:!1};if(i.isP2SH=!!e.redeemScript,i.isP2WSH=!!e.witnessScript,e.witnessScript)i.script=e.witnessScript;else if(e.redeemScript)i.script=e.redeemScript;else if(e.nonWitnessUtxo){const c=Ne(t,e,r),n=s.ins[r].index;i.script=c.outs[n].script}else e.witnessUtxo&&(i.script=e.witnessUtxo.script);return(e.witnessScript||ve(i.script))&&(i.isSegwit=!0),i}function Lt(r,e,t){const s=O.checkForInput(e,r);if(!s.bip32Derivation||s.bip32Derivation.length===0)throw new Error("Need bip32Derivation to sign with HD");const i=s.bip32Derivation.map(n=>{if(n.masterFingerprint.equals(t.fingerprint))return n}).filter(n=>!!n);if(i.length===0)throw new Error("Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint");return i.map(n=>{const o=t.derivePath(n.path);if(!n.pubkey.equals(o.publicKey))throw new Error("pubkey did not match bip32Derivation");return o})}function hr(r,e){return be({output:r}).pubkeys.map(s=>(e.filter(i=>i.pubkey.equals(s))[0]||{}).signature).filter(s=>!!s)}function tn(r){let e=0;function t(n){return e+=n,r.slice(e-n,e)}function s(){const n=ke.decode(r,e);return e+=ke.decode.bytes,n}function i(){return t(s())}function c(){const n=s(),o=[];for(let u=0;u<n;u++)o.push(i());return o}return c()}function pr(r){let e=r&w.SIGHASH_ANYONECANPAY?"SIGHASH_ANYONECANPAY | ":"";switch(r&31){case w.SIGHASH_ALL:e+="SIGHASH_ALL";break;case w.SIGHASH_SINGLE:e+="SIGHASH_SINGLE";break;case w.SIGHASH_NONE:e+="SIGHASH_NONE";break}return e}function Ft(r){let e=T.allocUnsafe(0);function t(n){e=T.concat([e,T.from(n)])}function s(n){const o=e.length,u=ke.encodingLength(n);e=T.concat([e,T.allocUnsafe(u)]),ke.encode(n,e,o)}function i(n){s(n.length),t(n)}function c(n){s(n.length),n.forEach(i)}return c(r),e}function Ke(r,e,t){r.__NON_WITNESS_UTXO_BUF_CACHE[t]=e.nonWitnessUtxo;const s=w.fromBuffer(e.nonWitnessUtxo);r.__NON_WITNESS_UTXO_TX_CACHE[t]=s;const i=r,c=t;delete e.nonWitnessUtxo,Object.defineProperty(e,"nonWitnessUtxo",{enumerable:!0,get(){const n=i.__NON_WITNESS_UTXO_BUF_CACHE[c],o=i.__NON_WITNESS_UTXO_TX_CACHE[c];if(n!==void 0)return n;{const u=o.toBuffer();return i.__NON_WITNESS_UTXO_BUF_CACHE[c]=u,u}},set(n){i.__NON_WITNESS_UTXO_BUF_CACHE[c]=n}})}function nn(r,e,t,s){let i=0;r.forEach((u,a)=>{if(s&&u.finalScriptSig&&(e.ins[a].script=u.finalScriptSig),s&&u.finalScriptWitness&&(e.ins[a].witness=tn(u.finalScriptWitness)),u.witnessUtxo)i+=u.witnessUtxo.value;else if(u.nonWitnessUtxo){const f=Ne(t,u,a),h=e.ins[a].index,S=f.outs[h];i+=S.value}});const c=e.outs.reduce((u,a)=>u+a.value,0),n=i-c;if(n<0)throw new Error("Outputs are spending more than Inputs");const o=e.virtualSize();t.__FEE=n,t.__EXTRACTED_TX=e,t.__FEE_RATE=Math.floor(n/o)}function Ne(r,e,t){const s=r.__NON_WITNESS_UTXO_TX_CACHE;return s[t]||Ke(r,e,t),s[t]}function rn(r,e,t){if(e.witnessUtxo!==void 0)return e.witnessUtxo.script;if(e.nonWitnessUtxo!==void 0)return Ne(t,e,r).outs[t.__TX.ins[r].index].script;throw new Error("Can't find pubkey in input without Utxo data")}function lr(r,e,t,s){const i=rn(t,e,s),{meaningfulScript:c}=Ce(i,t,"input",e.redeemScript,e.witnessScript);return Ve(r,c)}function dr(r,e,t,s){const i=s.__TX.outs[t].script,{meaningfulScript:c}=Ce(i,t,"output",e.redeemScript,e.witnessScript);return Ve(r,c)}function Sr(r){if(!r)return;const e=re(r);if(!e)return;const t=e[e.length-1];if(!(!T.isBuffer(t)||sn(t)||wr(t)||!re(t)))return t}function gr(r){if(!r)return;const e=tn(r),t=e[e.length-1];if(!(sn(t)||!re(t)))return t}function Er(r){if(r.length===65){const e=r[64]&1,t=r.slice(0,33);return t[0]=2|e,t}return r.slice()}function sn(r){return r.length===33&&pn(r)}function wr(r){return Dt(r)}function Ce(r,e,t,s,i){const c=zt(r),n=c&&s&&Ut(s),o=Ut(r);if(c&&s===void 0)throw new Error("scriptPubkey is P2SH but redeemScript missing");if((o||n)&&i===void 0)throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");let u;return n?(u=i,xt(e,r,s,t),Ht(e,s,i,t),me(u)):o?(u=i,Ht(e,r,i,t),me(u)):c?(u=s,xt(e,r,s,t)):u=r,{meaningfulScript:u,type:n?"p2sh-p2wsh":c?"p2sh":o?"p2wsh":"raw"}}function me(r){if(ve(r)||zt(r))throw new Error("P2WPKH or P2SH can not be contained within P2WSH")}function Ve(r,e){const t=dn(r),s=re(e);if(s===null)throw new Error("Unknown script error");return s.some(i=>typeof i=="number"?!1:i.equals(r)||i.equals(t))}function on(r){return ve(r)?"witnesspubkeyhash":tr(r)?"pubkeyhash":Zn(r)?"multisig":er(r)?"pubkey":"nonstandard"}function pe(r){return[...Array(r).keys()]}export{Fe as Psbt};
