import{g as N}from"./address-CwlnRuVT.js";import{a as O,$ as B,g as H}from"./signature-MTDex1F4.js";import{a as c}from"./page-C3-Jo2og.js";import{b as d}from"./bridge-DyWekW1m.js";import{b as P,c as U,d as $,f as q,g as W,a as M}from"./noop-ChEnm3CV.js";import"./index-CQoRotV0.js";async function g(e,t,n,o){return d("bio_requestCryptoToken",{actions:e,duration:t,address:n,chainId:o})}async function A(e,t){return d("bio_getCryptoTokenInfo",{tokenId:e,sessionSecret:t})}async function w(e,t,n,o){return d("bio_cryptoExecute",{tokenId:e,sessionSecret:t,action:"asymmetricEncrypt",params:{data:n,recipientPublicKey:o}})}const u="bio_crypto_token_cache";function T(){try{const e=localStorage.getItem(u);return e?JSON.parse(e):null}catch{return null}}function x(e){localStorage.setItem(u,JSON.stringify(e))}function E(){localStorage.removeItem(u)}function k(e){if(typeof e=="string")return e;if(e&&typeof e=="object"&&"type"in e&&"data"in e){const t=e;if(t.type==="Buffer"&&Array.isArray(t.data))return c.from(t.data).toString("hex")}if(Array.isArray(e)||e instanceof Uint8Array)return c.from(e).toString("hex");if(c.isBuffer(e))return e.toString("hex");throw new Error(`Invalid input format: ${typeof e}`)}async function I(e){const t=k(e),n=["bfmeta","bfchainv2","bioforest","bfmchain","bfchain"],o=await d("bio_requestAccounts",{chain:"bfmeta"});if(!o||o.length===0)throw new Error("No accounts available");const s=o.find(r=>{const y=r.chain.toLowerCase();return n.includes(y)});if(!s){const r=o.map(y=>y.chain).join(", ");throw new Error(`BFMeta account not found. Available chains: ${r}`)}let i,f;const a=T();let l=!0;if(a&&a.address===s.address&&a.expiresAt>Date.now())try{const r=await A(a.tokenId,a.sessionSecret);r.valid&&r.address===s.address&&(i=a.tokenId,f=a.sessionSecret,l=!1)}catch{}if(l){E();const r=await g(["asymmetricEncrypt"],"1day",s.address,s.chain);i=r.tokenId,f=r.sessionSecret,x({tokenId:i,sessionSecret:f,address:r.address,expiresAt:r.expiresAt})}const m=Date.now().toString(),{result:p,publicKey:h,address:b}=await w(i,f,m,t);return{address:b,publicKey:c.from(h,"hex"),signcode:c.from(p,"hex")}}export{O as $WALLET_PLAOC_PATH,B as $WALLET_SIGNATURE_TYPE,P as appVersionUpdate,w as asymmetricEncrypt,U as canOpenUrl,$ as dwebAppConfig,q as focusWindow,W as getDwebAppDownUrl,H as getExternalAppData,N as getWalleterAddresss,M as gotoDwebAppMarketDownLoad,g as requestCryptoToken,I as rwaLogin};
