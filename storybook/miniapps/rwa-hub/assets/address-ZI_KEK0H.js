import{b as U}from"./networks-ZN7vFv_C.js";import{i as N,a as L,d as k,c as v,b as we,t as Ne,e as Be,f as Ue,s as He,T as X,g as Ae,h as qe,H as Re,U as je,j as Ve}from"./script-FDeERxxs.js";import{t}from"./typeforce-Dwy2dsyn.js";import{OPS as R}from"./ops-CO93g0rg.js";import{b as q}from"./index-BB9FVBrc.js";import{hash160 as B,sha256 as se,taggedHash as ee}from"./crypto-D1spmEbK.js";import{B as w,r as Ce}from"./bioforestChainBundle-D4MYt0oV.js";import{Z as Le}from"./index-Dk9SKzm0.js";import"./page-BOxexyJV.js";function d(e,i,u){Object.defineProperty(e,i,{configurable:!0,enumerable:!0,get(){const s=u.call(this);return this[i]=s,s},set(s){Object.defineProperty(this,i,{configurable:!0,enumerable:!0,value:s,writable:!0})}})}function O(e){let i;return()=>(i!==void 0||(i=e()),i)}const A=R,F=A.OP_RESERVED;function ie(e,i){return e.length!==i.length?!1:e.every((u,s)=>u.equals(i[s]))}function dt(e,i){if(!e.input&&!e.output&&!(e.pubkeys&&e.m!==void 0)&&!e.signatures)throw new TypeError("Not enough data");i=Object.assign({validate:!0},i||{});function u(a){return L(a)||(i.allowIncomplete&&a===A.OP_0)!==void 0}t({network:t.maybe(t.Object),m:t.maybe(t.Number),n:t.maybe(t.Number),output:t.maybe(t.Buffer),pubkeys:t.maybe(t.arrayOf(N)),signatures:t.maybe(t.arrayOf(u)),input:t.maybe(t.Buffer)},e);const o={network:e.network||U};let h=[],n=!1;function r(a){n||(n=!0,h=k(a),o.m=h[0]-F,o.n=h[h.length-2]-F,o.pubkeys=h.slice(1,-2))}if(d(o,"output",()=>{if(e.m&&o.n&&e.pubkeys)return v([].concat(F+e.m,e.pubkeys,F+o.n,A.OP_CHECKMULTISIG))}),d(o,"m",()=>{if(o.output)return r(o.output),o.m}),d(o,"n",()=>{if(o.pubkeys)return o.pubkeys.length}),d(o,"pubkeys",()=>{if(e.output)return r(e.output),o.pubkeys}),d(o,"signatures",()=>{if(e.input)return k(e.input).slice(1)}),d(o,"input",()=>{if(e.signatures)return v([A.OP_0].concat(e.signatures))}),d(o,"witness",()=>{if(o.input)return[]}),d(o,"name",()=>{if(!(!o.m||!o.n))return`p2ms(${o.m} of ${o.n})`}),i.validate){if(e.output){if(r(e.output),!t.Number(h[0]))throw new TypeError("Output is invalid");if(!t.Number(h[h.length-2]))throw new TypeError("Output is invalid");if(h[h.length-1]!==A.OP_CHECKMULTISIG)throw new TypeError("Output is invalid");if(o.m<=0||o.n>16||o.m>o.n||o.n!==h.length-3)throw new TypeError("Output is invalid");if(!o.pubkeys.every(a=>N(a)))throw new TypeError("Output is invalid");if(e.m!==void 0&&e.m!==o.m)throw new TypeError("m mismatch");if(e.n!==void 0&&e.n!==o.n)throw new TypeError("n mismatch");if(e.pubkeys&&!ie(e.pubkeys,o.pubkeys))throw new TypeError("Pubkeys mismatch")}if(e.pubkeys){if(e.n!==void 0&&e.n!==e.pubkeys.length)throw new TypeError("Pubkey count mismatch");if(o.n=e.pubkeys.length,o.n<o.m)throw new TypeError("Pubkey count cannot be less than m")}if(e.signatures){if(e.signatures.length<o.m)throw new TypeError("Not enough signatures provided");if(e.signatures.length>o.m)throw new TypeError("Too many signatures provided")}if(e.input){if(e.input[0]!==A.OP_0)throw new TypeError("Input is invalid");if(o.signatures.length===0||!o.signatures.every(u))throw new TypeError("Input has invalid signature(s)");if(e.signatures&&!ie(e.signatures,o.signatures))throw new TypeError("Signature mismatch");if(e.m!==void 0&&e.m!==e.signatures.length)throw new TypeError("Signature count mismatch")}}return Object.assign(o,e)}const S=R;function me(e,i){if(!e.address&&!e.hash&&!e.output&&!e.pubkey&&!e.input)throw new TypeError("Not enough data");i=Object.assign({validate:!0},i||{}),t({network:t.maybe(t.Object),address:t.maybe(t.String),hash:t.maybe(t.BufferN(20)),output:t.maybe(t.BufferN(25)),pubkey:t.maybe(N),signature:t.maybe(L),input:t.maybe(t.Buffer)},e);const u=O(()=>{const n=q.decode(e.address),r=n.readUInt8(0),a=n.slice(1);return{version:r,hash:a}}),s=O(()=>k(e.input)),o=e.network||U,h={name:"p2pkh",network:o};if(d(h,"address",()=>{if(!h.hash)return;const n=w.allocUnsafe(21);return n.writeUInt8(o.pubKeyHash,0),h.hash.copy(n,1),q.encode(n)}),d(h,"hash",()=>{if(e.output)return e.output.slice(3,23);if(e.address)return u().hash;if(e.pubkey||h.pubkey)return B(e.pubkey||h.pubkey)}),d(h,"output",()=>{if(h.hash)return v([S.OP_DUP,S.OP_HASH160,h.hash,S.OP_EQUALVERIFY,S.OP_CHECKSIG])}),d(h,"pubkey",()=>{if(e.input)return s()[1]}),d(h,"signature",()=>{if(e.input)return s()[0]}),d(h,"input",()=>{if(e.pubkey&&e.signature)return v([e.signature,e.pubkey])}),d(h,"witness",()=>{if(h.input)return[]}),i.validate){let n=w.from([]);if(e.address){if(u().version!==o.pubKeyHash)throw new TypeError("Invalid version or Network mismatch");if(u().hash.length!==20)throw new TypeError("Invalid address");n=u().hash}if(e.hash){if(n.length>0&&!n.equals(e.hash))throw new TypeError("Hash mismatch");n=e.hash}if(e.output){if(e.output.length!==25||e.output[0]!==S.OP_DUP||e.output[1]!==S.OP_HASH160||e.output[2]!==20||e.output[23]!==S.OP_EQUALVERIFY||e.output[24]!==S.OP_CHECKSIG)throw new TypeError("Output is invalid");const r=e.output.slice(3,23);if(n.length>0&&!n.equals(r))throw new TypeError("Hash mismatch");n=r}if(e.pubkey){const r=B(e.pubkey);if(n.length>0&&!n.equals(r))throw new TypeError("Hash mismatch");n=r}if(e.input){const r=s();if(r.length!==2)throw new TypeError("Input is invalid");if(!L(r[0]))throw new TypeError("Input has invalid signature");if(!N(r[1]))throw new TypeError("Input has invalid pubkey");if(e.signature&&!e.signature.equals(r[0]))throw new TypeError("Signature mismatch");if(e.pubkey&&!e.pubkey.equals(r[1]))throw new TypeError("Pubkey mismatch");const a=B(r[1]);if(n.length>0&&!n.equals(a))throw new TypeError("Hash mismatch")}}return Object.assign(h,e)}const V=R;function We(e,i){return e.length!==i.length?!1:e.every((u,s)=>u.equals(i[s]))}function ye(e,i){if(!e.address&&!e.hash&&!e.output&&!e.redeem&&!e.input)throw new TypeError("Not enough data");i=Object.assign({validate:!0},i||{}),t({network:t.maybe(t.Object),address:t.maybe(t.String),hash:t.maybe(t.BufferN(20)),output:t.maybe(t.BufferN(23)),redeem:t.maybe({network:t.maybe(t.Object),output:t.maybe(t.Buffer),input:t.maybe(t.Buffer),witness:t.maybe(t.arrayOf(t.Buffer))}),input:t.maybe(t.Buffer),witness:t.maybe(t.arrayOf(t.Buffer))},e);let u=e.network;u||(u=e.redeem&&e.redeem.network||U);const s={network:u},o=O(()=>{const r=q.decode(e.address),a=r.readUInt8(0),f=r.slice(1);return{version:a,hash:f}}),h=O(()=>k(e.input)),n=O(()=>{const r=h(),a=r[r.length-1];return{network:u,output:a===V.OP_FALSE?w.from([]):a,input:v(r.slice(0,-1)),witness:e.witness||[]}});if(d(s,"address",()=>{if(!s.hash)return;const r=w.allocUnsafe(21);return r.writeUInt8(s.network.scriptHash,0),s.hash.copy(r,1),q.encode(r)}),d(s,"hash",()=>{if(e.output)return e.output.slice(2,22);if(e.address)return o().hash;if(s.redeem&&s.redeem.output)return B(s.redeem.output)}),d(s,"output",()=>{if(s.hash)return v([V.OP_HASH160,s.hash,V.OP_EQUAL])}),d(s,"redeem",()=>{if(e.input)return n()}),d(s,"input",()=>{if(!(!e.redeem||!e.redeem.input||!e.redeem.output))return v([].concat(k(e.redeem.input),e.redeem.output))}),d(s,"witness",()=>{if(s.redeem&&s.redeem.witness)return s.redeem.witness;if(s.input)return[]}),d(s,"name",()=>{const r=["p2sh"];return s.redeem!==void 0&&s.redeem.name!==void 0&&r.push(s.redeem.name),r.join("-")}),i.validate){let r=w.from([]);if(e.address){if(o().version!==u.scriptHash)throw new TypeError("Invalid version or Network mismatch");if(o().hash.length!==20)throw new TypeError("Invalid address");r=o().hash}if(e.hash){if(r.length>0&&!r.equals(e.hash))throw new TypeError("Hash mismatch");r=e.hash}if(e.output){if(e.output.length!==23||e.output[0]!==V.OP_HASH160||e.output[1]!==20||e.output[22]!==V.OP_EQUAL)throw new TypeError("Output is invalid");const f=e.output.slice(2,22);if(r.length>0&&!r.equals(f))throw new TypeError("Hash mismatch");r=f}const a=f=>{if(f.output){const c=k(f.output);if(!c||c.length<1)throw new TypeError("Redeem.output too short");const p=B(f.output);if(r.length>0&&!r.equals(p))throw new TypeError("Hash mismatch");r=p}if(f.input){const c=f.input.length>0,p=f.witness&&f.witness.length>0;if(!c&&!p)throw new TypeError("Empty input");if(c&&p)throw new TypeError("Input and witness provided");if(c){const y=k(f.input);if(!we(y))throw new TypeError("Non push-only scriptSig")}}};if(e.input){const f=h();if(!f||f.length<1)throw new TypeError("Input too short");if(!w.isBuffer(n().output))throw new TypeError("Input is invalid");a(n())}if(e.redeem){if(e.redeem.network&&e.redeem.network!==u)throw new TypeError("Network mismatch");if(e.input){const f=n();if(e.redeem.output&&!e.redeem.output.equals(f.output))throw new TypeError("Redeem.output mismatch");if(e.redeem.input&&!e.redeem.input.equals(f.input))throw new TypeError("Redeem.input mismatch")}a(e.redeem)}if(e.witness&&e.redeem&&e.redeem.witness&&!We(e.redeem.witness,e.witness))throw new TypeError("Witness and redeem.witness mismatch")}return Object.assign(s,e)}var H={},oe;function Fe(){if(oe)return H;oe=1,Object.defineProperty(H,"__esModule",{value:!0}),H.bech32m=H.bech32=void 0;const e="qpzry9x8gf2tvdw0s3jn54khce6mua7l",i={};for(let f=0;f<e.length;f++){const c=e.charAt(f);i[c]=f}function u(f){const c=f>>25;return(f&33554431)<<5^-(c>>0&1)&996825010^-(c>>1&1)&642813549^-(c>>2&1)&513874426^-(c>>3&1)&1027748829^-(c>>4&1)&705979059}function s(f){let c=1;for(let p=0;p<f.length;++p){const y=f.charCodeAt(p);if(y<33||y>126)return"Invalid prefix ("+f+")";c=u(c)^y>>5}c=u(c);for(let p=0;p<f.length;++p){const y=f.charCodeAt(p);c=u(c)^y&31}return c}function o(f,c,p,y){let _=0,E=0;const l=(1<<p)-1,g=[];for(let m=0;m<f.length;++m)for(_=_<<c|f[m],E+=c;E>=p;)E-=p,g.push(_>>E&l);if(y)E>0&&g.push(_<<p-E&l);else{if(E>=c)return"Excess padding";if(_<<p-E&l)return"Non-zero padding"}return g}function h(f){return o(f,8,5,!0)}function n(f){const c=o(f,5,8,!1);if(Array.isArray(c))return c}function r(f){const c=o(f,5,8,!1);if(Array.isArray(c))return c;throw new Error(c)}function a(f){let c;f==="bech32"?c=1:c=734539939;function p(l,g,m){if(m=m||90,l.length+7+g.length>m)throw new TypeError("Exceeds length limit");l=l.toLowerCase();let P=s(l);if(typeof P=="string")throw new Error(P);let x=l+"1";for(let b=0;b<g.length;++b){const I=g[b];if(I>>5!==0)throw new Error("Non 5-bit word");P=u(P)^I,x+=e.charAt(I)}for(let b=0;b<6;++b)P=u(P);P^=c;for(let b=0;b<6;++b){const I=P>>(5-b)*5&31;x+=e.charAt(I)}return x}function y(l,g){if(g=g||90,l.length<8)return l+" too short";if(l.length>g)return"Exceeds length limit";const m=l.toLowerCase(),P=l.toUpperCase();if(l!==m&&l!==P)return"Mixed-case string "+l;l=m;const x=l.lastIndexOf("1");if(x===-1)return"No separator character for "+l;if(x===0)return"Missing prefix for "+l;const b=l.slice(0,x),I=l.slice(x+1);if(I.length<6)return"Data too short";let j=s(b);if(typeof j=="string")return j;const re=[];for(let W=0;W<I.length;++W){const ne=I.charAt(W),D=i[ne];if(D===void 0)return"Unknown character "+ne;j=u(j)^D,!(W+6>=I.length)&&re.push(D)}return j!==c?"Invalid checksum for "+l:{prefix:b,words:re}}function _(l,g){const m=y(l,g);if(typeof m=="object")return m}function E(l,g){const m=y(l,g);if(typeof m=="object")return m;throw new Error(m)}return{decodeUnsafe:_,decode:E,encode:p,toWords:h,fromWordsUnsafe:n,fromWords:r}}return H.bech32=a("bech32"),H.bech32m=a("bech32m"),H}var $e=Fe();const ge=Le($e),T=ge.bech32,M=ge.bech32m,ue=R,Ge=w.alloc(0);function be(e,i){if(!e.address&&!e.hash&&!e.output&&!e.pubkey&&!e.witness)throw new TypeError("Not enough data");i=Object.assign({validate:!0},i||{}),t({address:t.maybe(t.String),hash:t.maybe(t.BufferN(20)),input:t.maybe(t.BufferN(0)),network:t.maybe(t.Object),output:t.maybe(t.BufferN(22)),pubkey:t.maybe(N),signature:t.maybe(L),witness:t.maybe(t.arrayOf(t.Buffer))},e);const u=O(()=>{const h=T.decode(e.address),n=h.words.shift(),r=T.fromWords(h.words);return{version:n,prefix:h.prefix,data:w.from(r)}}),s=e.network||U,o={name:"p2wpkh",network:s};if(d(o,"address",()=>{if(!o.hash)return;const h=T.toWords(o.hash);return h.unshift(0),T.encode(s.bech32,h)}),d(o,"hash",()=>{if(e.output)return e.output.slice(2,22);if(e.address)return u().data;if(e.pubkey||o.pubkey)return B(e.pubkey||o.pubkey)}),d(o,"output",()=>{if(o.hash)return v([ue.OP_0,o.hash])}),d(o,"pubkey",()=>{if(e.pubkey)return e.pubkey;if(e.witness)return e.witness[1]}),d(o,"signature",()=>{if(e.witness)return e.witness[0]}),d(o,"input",()=>{if(o.witness)return Ge}),d(o,"witness",()=>{if(e.pubkey&&e.signature)return[e.signature,e.pubkey]}),i.validate){let h=w.from([]);if(e.address){if(s&&s.bech32!==u().prefix)throw new TypeError("Invalid prefix or Network mismatch");if(u().version!==0)throw new TypeError("Invalid address version");if(u().data.length!==20)throw new TypeError("Invalid address data");h=u().data}if(e.hash){if(h.length>0&&!h.equals(e.hash))throw new TypeError("Hash mismatch");h=e.hash}if(e.output){if(e.output.length!==22||e.output[0]!==ue.OP_0||e.output[1]!==20)throw new TypeError("Output is invalid");if(h.length>0&&!h.equals(e.output.slice(2)))throw new TypeError("Hash mismatch");h=e.output.slice(2)}if(e.pubkey){const n=B(e.pubkey);if(h.length>0&&!h.equals(n))throw new TypeError("Hash mismatch");if(h=n,!N(e.pubkey)||e.pubkey.length!==33)throw new TypeError("Invalid pubkey for p2wpkh")}if(e.witness){if(e.witness.length!==2)throw new TypeError("Witness is invalid");if(!L(e.witness[0]))throw new TypeError("Witness has invalid signature");if(!N(e.witness[1])||e.witness[1].length!==33)throw new TypeError("Witness has invalid pubkey");if(e.signature&&!e.signature.equals(e.witness[0]))throw new TypeError("Signature mismatch");if(e.pubkey&&!e.pubkey.equals(e.witness[1]))throw new TypeError("Pubkey mismatch");const n=B(e.witness[1]);if(h.length>0&&!h.equals(n))throw new TypeError("Hash mismatch")}}return Object.assign(o,e)}const he=R,z=w.alloc(0);function Me(e,i){return e.length!==i.length?!1:e.every((u,s)=>u.equals(i[s]))}function $(e){return!!(w.isBuffer(e)&&e.length===65&&e[0]===4&&N(e))}function Ee(e,i){if(!e.address&&!e.hash&&!e.output&&!e.redeem&&!e.witness)throw new TypeError("Not enough data");i=Object.assign({validate:!0},i||{}),t({network:t.maybe(t.Object),address:t.maybe(t.String),hash:t.maybe(t.BufferN(32)),output:t.maybe(t.BufferN(34)),redeem:t.maybe({input:t.maybe(t.Buffer),network:t.maybe(t.Object),output:t.maybe(t.Buffer),witness:t.maybe(t.arrayOf(t.Buffer))}),input:t.maybe(t.BufferN(0)),witness:t.maybe(t.arrayOf(t.Buffer))},e);const u=O(()=>{const n=T.decode(e.address),r=n.words.shift(),a=T.fromWords(n.words);return{version:r,prefix:n.prefix,data:w.from(a)}}),s=O(()=>k(e.redeem.input));let o=e.network;o||(o=e.redeem&&e.redeem.network||U);const h={network:o};if(d(h,"address",()=>{if(!h.hash)return;const n=T.toWords(h.hash);return n.unshift(0),T.encode(o.bech32,n)}),d(h,"hash",()=>{if(e.output)return e.output.slice(2);if(e.address)return u().data;if(h.redeem&&h.redeem.output)return se(h.redeem.output)}),d(h,"output",()=>{if(h.hash)return v([he.OP_0,h.hash])}),d(h,"redeem",()=>{if(e.witness)return{output:e.witness[e.witness.length-1],input:z,witness:e.witness.slice(0,-1)}}),d(h,"input",()=>{if(h.witness)return z}),d(h,"witness",()=>{if(e.redeem&&e.redeem.input&&e.redeem.input.length>0&&e.redeem.output&&e.redeem.output.length>0){const n=Ne(s());return h.redeem=Object.assign({witness:n},e.redeem),h.redeem.input=z,[].concat(n,e.redeem.output)}if(e.redeem&&e.redeem.output&&e.redeem.witness)return[].concat(e.redeem.witness,e.redeem.output)}),d(h,"name",()=>{const n=["p2wsh"];return h.redeem!==void 0&&h.redeem.name!==void 0&&n.push(h.redeem.name),n.join("-")}),i.validate){let n=w.from([]);if(e.address){if(u().prefix!==o.bech32)throw new TypeError("Invalid prefix or Network mismatch");if(u().version!==0)throw new TypeError("Invalid address version");if(u().data.length!==32)throw new TypeError("Invalid address data");n=u().data}if(e.hash){if(n.length>0&&!n.equals(e.hash))throw new TypeError("Hash mismatch");n=e.hash}if(e.output){if(e.output.length!==34||e.output[0]!==he.OP_0||e.output[1]!==32)throw new TypeError("Output is invalid");const r=e.output.slice(2);if(n.length>0&&!n.equals(r))throw new TypeError("Hash mismatch");n=r}if(e.redeem){if(e.redeem.network&&e.redeem.network!==o)throw new TypeError("Network mismatch");if(e.redeem.input&&e.redeem.input.length>0&&e.redeem.witness&&e.redeem.witness.length>0)throw new TypeError("Ambiguous witness source");if(e.redeem.output){if(k(e.redeem.output).length===0)throw new TypeError("Redeem.output is invalid");const r=se(e.redeem.output);if(n.length>0&&!n.equals(r))throw new TypeError("Hash mismatch");n=r}if(e.redeem.input&&!we(s()))throw new TypeError("Non push-only scriptSig");if(e.witness&&e.redeem.witness&&!Me(e.witness,e.redeem.witness))throw new TypeError("Witness and redeem.witness mismatch");if(e.redeem.input&&s().some($)||e.redeem.output&&(k(e.redeem.output)||[]).some($))throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey")}if(e.witness&&e.witness.length>0){const r=e.witness[e.witness.length-1];if(e.redeem&&e.redeem.output&&!e.redeem.output.equals(r))throw new TypeError("Witness and redeem.output mismatch");if(e.witness.some($)||(k(r)||[]).some($))throw new TypeError("Witness contains uncompressed pubkey")}}return Object.assign(h,e)}const fe={};function Q(){if(!fe.eccLib)throw new Error("No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance");return fe.eccLib}var Y,ce;function Ke(){if(ce)return Y;ce=1;var e=Ce().Buffer,i=9007199254740991;function u(n){if(n<0||n>i||n%1!==0)throw new RangeError("value out of range")}function s(n,r,a){if(u(n),r||(r=e.allocUnsafe(h(n))),!e.isBuffer(r))throw new TypeError("buffer must be a Buffer instance");return a||(a=0),n<253?(r.writeUInt8(n,a),s.bytes=1):n<=65535?(r.writeUInt8(253,a),r.writeUInt16LE(n,a+1),s.bytes=3):n<=4294967295?(r.writeUInt8(254,a),r.writeUInt32LE(n,a+1),s.bytes=5):(r.writeUInt8(255,a),r.writeUInt32LE(n>>>0,a+1),r.writeUInt32LE(n/4294967296|0,a+5),s.bytes=9),r}function o(n,r){if(!e.isBuffer(n))throw new TypeError("buffer must be a Buffer instance");r||(r=0);var a=n.readUInt8(r);if(a<253)return o.bytes=1,a;if(a===253)return o.bytes=3,n.readUInt16LE(r+1);if(a===254)return o.bytes=5,n.readUInt32LE(r+1);o.bytes=9;var f=n.readUInt32LE(r+1),c=n.readUInt32LE(r+5),p=c*4294967296+f;return u(p),p}function h(n){return u(n),n<253?1:n<=65535?3:n<=4294967295?5:9}return Y={encode:s,decode:o,encodingLength:h},Y}var ae=Ke();const ke=192,De=e=>"left"in e&&"right"in e;function de(e,i){if(e.length<33)throw new TypeError(`The control-block length is too small. Got ${e.length}, expected min 33.`);const u=(e.length-33)/32;let s=i;for(let o=0;o<u;o++){const h=e.slice(33+32*o,65+32*o);s.compare(h)<0?s=J(s,h):s=J(h,s)}return s}function Z(e){if(Be(e))return{hash:C(e)};const i=[Z(e[0]),Z(e[1])];i.sort((o,h)=>o.hash.compare(h.hash));const[u,s]=i;return{hash:J(u.hash,s.hash),left:u,right:s}}function K(e,i){if(De(e)){const u=K(e.left,i);if(u!==void 0)return[...u,e.right.hash];const s=K(e.right,i);if(s!==void 0)return[...s,e.left.hash]}else if(e.hash.equals(i))return[]}function C(e){const i=e.version||ke;return ee("TapLeaf",w.concat([w.from([i]),ze(e.output)]))}function Xe(e,i){return ee("TapTweak",w.concat(i?[e,i]:[e]))}function G(e,i){if(!w.isBuffer(e)||e.length!==32||i&&i.length!==32)return null;const u=Xe(e,i),s=Q().xOnlyPointAddTweak(e,u);return!s||s.xOnlyPubkey===null?null:{parity:s.parity,x:w.from(s.xOnlyPubkey)}}function J(e,i){return ee("TapBranch",w.concat([e,i]))}function ze(e){const i=ae.encodingLength(e.length),u=w.allocUnsafe(i);return ae.encode(e.length,u),w.concat([u,e])}const pe=R,le=1,Ye=80;function Qe(e,i){if(!e.address&&!e.output&&!e.pubkey&&!e.internalPubkey&&!(e.witness&&e.witness.length>1))throw new TypeError("Not enough data");i=Object.assign({validate:!0},i||{}),t({address:t.maybe(t.String),input:t.maybe(t.BufferN(0)),network:t.maybe(t.Object),output:t.maybe(t.BufferN(34)),internalPubkey:t.maybe(t.BufferN(32)),hash:t.maybe(t.BufferN(32)),pubkey:t.maybe(t.BufferN(32)),signature:t.maybe(t.anyOf(t.BufferN(64),t.BufferN(65))),witness:t.maybe(t.arrayOf(t.Buffer)),scriptTree:t.maybe(Ue),redeem:t.maybe({output:t.maybe(t.Buffer),redeemVersion:t.maybe(t.Number),witness:t.maybe(t.arrayOf(t.Buffer))}),redeemVersion:t.maybe(t.Number)},e);const u=O(()=>te(e.address)),s=O(()=>{if(!(!e.witness||!e.witness.length))return e.witness.length>=2&&e.witness[e.witness.length-1][0]===Ye?e.witness.slice(0,-1):e.witness.slice()}),o=O(()=>{if(e.scriptTree)return Z(e.scriptTree);if(e.hash)return{hash:e.hash}}),h=e.network||U,n={name:"p2tr",network:h};if(d(n,"address",()=>{if(!n.pubkey)return;const r=M.toWords(n.pubkey);return r.unshift(le),M.encode(h.bech32,r)}),d(n,"hash",()=>{const r=o();if(r)return r.hash;const a=s();if(a&&a.length>1){const f=a[a.length-1],c=f[0]&X,p=a[a.length-2],y=C({output:p,version:c});return de(f,y)}return null}),d(n,"output",()=>{if(n.pubkey)return v([pe.OP_1,n.pubkey])}),d(n,"redeemVersion",()=>e.redeemVersion?e.redeemVersion:e.redeem&&e.redeem.redeemVersion!==void 0&&e.redeem.redeemVersion!==null?e.redeem.redeemVersion:ke),d(n,"redeem",()=>{const r=s();if(!(!r||r.length<2))return{output:r[r.length-2],witness:r.slice(0,-2),redeemVersion:r[r.length-1][0]&X}}),d(n,"pubkey",()=>{if(e.pubkey)return e.pubkey;if(e.output)return e.output.slice(2);if(e.address)return u().data;if(n.internalPubkey){const r=G(n.internalPubkey,n.hash);if(r)return r.x}}),d(n,"internalPubkey",()=>{if(e.internalPubkey)return e.internalPubkey;const r=s();if(r&&r.length>1)return r[r.length-1].slice(1,33)}),d(n,"signature",()=>{if(e.signature)return e.signature;const r=s();if(!(!r||r.length!==1))return r[0]}),d(n,"witness",()=>{if(e.witness)return e.witness;const r=o();if(r&&e.redeem&&e.redeem.output&&e.internalPubkey){const a=C({output:e.redeem.output,version:n.redeemVersion}),f=K(r,a);if(!f)return;const c=G(e.internalPubkey,r.hash);if(!c)return;const p=w.concat([w.from([n.redeemVersion|c.parity]),e.internalPubkey].concat(f));return[e.redeem.output,p]}if(e.signature)return[e.signature]}),i.validate){let r=w.from([]);if(e.address){if(h&&h.bech32!==u().prefix)throw new TypeError("Invalid prefix or Network mismatch");if(u().version!==le)throw new TypeError("Invalid address version");if(u().data.length!==32)throw new TypeError("Invalid address data");r=u().data}if(e.pubkey){if(r.length>0&&!r.equals(e.pubkey))throw new TypeError("Pubkey mismatch");r=e.pubkey}if(e.output){if(e.output.length!==34||e.output[0]!==pe.OP_1||e.output[1]!==32)throw new TypeError("Output is invalid");if(r.length>0&&!r.equals(e.output.slice(2)))throw new TypeError("Pubkey mismatch");r=e.output.slice(2)}if(e.internalPubkey){const c=G(e.internalPubkey,n.hash);if(r.length>0&&!r.equals(c.x))throw new TypeError("Pubkey mismatch");r=c.x}if(r&&r.length&&!Q().isXOnlyPoint(r))throw new TypeError("Invalid pubkey for p2tr");const a=o();if(e.hash&&a&&!e.hash.equals(a.hash))throw new TypeError("Hash mismatch");if(e.redeem&&e.redeem.output&&a){const c=C({output:e.redeem.output,version:n.redeemVersion});if(!K(a,c))throw new TypeError("Redeem script not in tree")}const f=s();if(e.redeem&&n.redeem){if(e.redeem.redeemVersion&&e.redeem.redeemVersion!==n.redeem.redeemVersion)throw new TypeError("Redeem.redeemVersion and witness mismatch");if(e.redeem.output){if(k(e.redeem.output).length===0)throw new TypeError("Redeem.output is invalid");if(n.redeem.output&&!e.redeem.output.equals(n.redeem.output))throw new TypeError("Redeem.output and witness mismatch")}if(e.redeem.witness&&n.redeem.witness&&!He(e.redeem.witness,n.redeem.witness))throw new TypeError("Redeem.witness and witness mismatch")}if(f&&f.length)if(f.length===1){if(e.signature&&!e.signature.equals(f[0]))throw new TypeError("Signature mismatch")}else{const c=f[f.length-1];if(c.length<33)throw new TypeError(`The control-block length is too small. Got ${c.length}, expected min 33.`);if((c.length-33)%32!==0)throw new TypeError(`The control-block length of ${c.length} is incorrect!`);const p=(c.length-33)/32;if(p>128)throw new TypeError(`The script path is too long. Got ${p}, expected max 128.`);const y=c.slice(1,33);if(e.internalPubkey&&!e.internalPubkey.equals(y))throw new TypeError("Internal pubkey mismatch");if(!Q().isXOnlyPoint(y))throw new TypeError("Invalid internalPubkey for p2tr witness");const _=c[0]&X,E=f[f.length-2],l=C({output:E,version:_}),g=de(c,l),m=G(y,g);if(!m)throw new TypeError("Invalid outputKey for p2tr witness");if(r.length&&!r.equals(m.x))throw new TypeError("Pubkey mismatch for p2tr witness");if(m.parity!==(c[0]&1))throw new Error("Incorrect parity")}}return Object.assign(n,e)}const{typeforce:Ze}=Ae,Te=40,ve=2,Oe=16,Pe=1,Ie=80,_e="WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";function Je(e,i){const u=e.slice(2);if(u.length<ve||u.length>Te)throw new TypeError("Invalid program length for segwit address");const s=e[0]-Ie;if(s<Pe||s>Oe)throw new TypeError("Invalid version for segwit address");if(e[1]!==u.length)throw new TypeError("Invalid script for segwit address");return console.warn(_e),Se(u,s,i.bech32)}function xe(e){const i=q.decode(e);if(i.length<21)throw new TypeError(e+" is too short");if(i.length>21)throw new TypeError(e+" is too long");const u=i.readUInt8(0),s=i.slice(1);return{version:u,hash:s}}function te(e){let i,u;try{i=T.decode(e)}catch{}if(i){if(u=i.words[0],u!==0)throw new TypeError(e+" uses wrong encoding")}else if(i=M.decode(e),u=i.words[0],u===0)throw new TypeError(e+" uses wrong encoding");const s=T.fromWords(i.words.slice(1));return{version:u,prefix:i.prefix,data:w.from(s)}}function et(e,i){Ze(qe(Re,je),arguments);const u=w.allocUnsafe(21);return u.writeUInt8(i,0),e.copy(u,1),q.encode(u)}function Se(e,i,u){const s=T.toWords(e);return s.unshift(i),i===0?T.encode(u,s):M.encode(u,s)}function tt(e,i){i=i||U;try{return me({output:e,network:i}).address}catch{}try{return ye({output:e,network:i}).address}catch{}try{return be({output:e,network:i}).address}catch{}try{return Ee({output:e,network:i}).address}catch{}try{return Qe({output:e,network:i}).address}catch{}try{return Je(e,i)}catch{}throw new Error(Ve(e)+" has no matching Address")}function rt(e,i){i=i||U;let u,s;try{u=xe(e)}catch{}if(u){if(u.version===i.pubKeyHash)return me({hash:u.hash}).output;if(u.version===i.scriptHash)return ye({hash:u.hash}).output}else{try{s=te(e)}catch{}if(s){if(s.prefix!==i.bech32)throw new Error(e+" has an invalid prefix");if(s.version===0){if(s.data.length===20)return be({hash:s.data}).output;if(s.data.length===32)return Ee({hash:s.data}).output}else if(s.version>=Pe&&s.version<=Oe&&s.data.length>=ve&&s.data.length<=Te)return console.warn(_e),v([s.version+Ie,s.data])}}throw new Error(e+" has no matching Script")}const pt=Object.freeze(Object.defineProperty({__proto__:null,fromBase58Check:xe,fromBech32:te,fromOutputScript:tt,toBase58Check:et,toBech32:Se,toOutputScript:rt},Symbol.toStringTag,{value:"Module"}));export{dt as a,me as b,ye as c,be as d,Ee as e,Qe as f,ae as g,tt as h,pt as i,d as p,rt as t,O as v};
