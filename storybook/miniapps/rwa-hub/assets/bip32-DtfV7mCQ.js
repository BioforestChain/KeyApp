import{B as a}from"./bioforestChainBundle-D4MYt0oV.js";import{c as S}from"./sha512-B7foNgh_.js";import{c as x}from"./hmac-V5N88g4C.js";import{hash160 as F}from"./crypto-D1spmEbK.js";import{b as E}from"./index-BB9FVBrc.js";import{t as h}from"./typeforce-Dwy2dsyn.js";import{e as H}from"./index-C0jlrNaS.js";import"./page-BOxexyJV.js";import"./index-Dk9SKzm0.js";import"./WASMInterface-BB6uMQo8.js";import"./ripemd160-BKeyKI6w.js";import"./sha1-DE6TSCkr.js";import"./sha256-DkPRHwlh.js";function K(o,f){return a.from(x(S(),o).update(f).digest())}function j(o){const f=h.BufferN(32),P=h.compile({wif:h.UInt8,bip32:{public:h.UInt32,private:h.UInt32}}),d={messagePrefix:`Bitcoin Signed Message:
`,bech32:"bc",bip32:{public:76067358,private:76066276},pubKeyHash:0,scriptHash:5,wif:128},m=2147483648,_=Math.pow(2,31)-1;function T(i){return h.String(i)&&i.match(/^(m\/)?(\d+'?\/)*\d+'?$/)!==null}function B(i){return h.UInt32(i)&&i<=_}function I(i){return i.length===32?i:i.slice(1,33)}class y{constructor(e,t){this.__D=e,this.__Q=t,this.lowR=!1}get publicKey(){return this.__Q===void 0&&(this.__Q=a.from(o.pointFromScalar(this.__D,!0))),this.__Q}get privateKey(){return this.__D}sign(e,t){if(!this.privateKey)throw new Error("Missing private key");if(t===void 0&&(t=this.lowR),t===!1)return a.from(o.sign(e,this.privateKey));{let r=a.from(o.sign(e,this.privateKey));const n=a.alloc(32,0);let s=0;for(;r[0]>127;)s++,n.writeUIntLE(s,0,6),r=a.from(o.sign(e,this.privateKey,n));return r}}signSchnorr(e){if(!this.privateKey)throw new Error("Missing private key");if(!o.signSchnorr)throw new Error("signSchnorr not supported by ecc library");return a.from(o.signSchnorr(e,this.privateKey))}verify(e,t){return o.verify(e,this.publicKey,t)}verifySchnorr(e,t){if(!o.verifySchnorr)throw new Error("verifySchnorr not supported by ecc library");return o.verifySchnorr(e,this.publicKey.subarray(1,33),t)}}class b extends y{constructor(e,t,r,n,s=0,u=0,c=0){super(e,t),this.chainCode=r,this.network=n,this.__DEPTH=s,this.__INDEX=u,this.__PARENT_FINGERPRINT=c,h(P,n)}get depth(){return this.__DEPTH}get index(){return this.__INDEX}get parentFingerprint(){return this.__PARENT_FINGERPRINT}get identifier(){return F(this.publicKey)}get fingerprint(){return this.identifier.slice(0,4)}get compressed(){return!0}isNeutered(){return this.__D===void 0}neutered(){return l(this.publicKey,this.chainCode,this.network,this.depth,this.index,this.parentFingerprint)}toBase58(){const e=this.network,t=this.isNeutered()?e.bip32.public:e.bip32.private,r=a.allocUnsafe(78);return r.writeUInt32BE(t,0),r.writeUInt8(this.depth,4),r.writeUInt32BE(this.parentFingerprint,5),r.writeUInt32BE(this.index,9),this.chainCode.copy(r,13),this.isNeutered()?this.publicKey.copy(r,45):(r.writeUInt8(0,45),this.privateKey.copy(r,46)),E.encode(r)}toWIF(){if(!this.privateKey)throw new TypeError("Missing private key");return H(this.network.wif,this.privateKey,!0)}derive(e){h(h.UInt32,e);const t=e>=m,r=a.allocUnsafe(37);if(t){if(this.isNeutered())throw new TypeError("Missing private key for hardened child key");r[0]=0,this.privateKey.copy(r,1),r.writeUInt32BE(e,33)}else this.publicKey.copy(r,0),r.writeUInt32BE(e,33);const n=K(this.chainCode,r),s=n.slice(0,32),u=n.slice(32);if(!o.isPrivate(s))return this.derive(e+1);let c;if(this.isNeutered()){const p=a.from(o.pointAddScalar(this.publicKey,s,!0));if(p===null)return this.derive(e+1);c=l(p,u,this.network,this.depth+1,e,this.fingerprint.readUInt32BE(0))}else{const p=a.from(o.privateAdd(this.privateKey,s));if(p==null)return this.derive(e+1);c=v(p,u,this.network,this.depth+1,e,this.fingerprint.readUInt32BE(0))}return c}deriveHardened(e){return h(B,e),this.derive(e+m)}derivePath(e){h(T,e);let t=e.split("/");if(t[0]==="m"){if(this.parentFingerprint)throw new TypeError("Expected master, got child");t=t.slice(1)}return t.reduce((r,n)=>{let s;return n.slice(-1)==="'"?(s=parseInt(n.slice(0,-1),10),r.deriveHardened(s)):(s=parseInt(n,10),r.derive(s))},this)}tweak(e){return this.privateKey?this.tweakFromPrivateKey(e):this.tweakFromPublicKey(e)}tweakFromPublicKey(e){const t=I(this.publicKey),r=o.xOnlyPointAddTweak(t,e);if(!r||r.xOnlyPubkey===null)throw new Error("Cannot tweak public key!");const n=a.from([r.parity===0?2:3]),s=a.concat([n,r.xOnlyPubkey]);return new y(void 0,s)}tweakFromPrivateKey(e){const r=this.publicKey[0]===3||this.publicKey[0]===4&&(this.publicKey[64]&1)===1?o.privateNegate(this.privateKey):this.privateKey,n=o.privateAdd(r,e);if(!n)throw new Error("Invalid tweaked private key!");return new y(a.from(n),void 0)}}function U(i,e){const t=E.decode(i);if(t.length!==78)throw new TypeError("Invalid buffer length");e=e||d;const r=t.readUInt32BE(0);if(r!==e.bip32.private&&r!==e.bip32.public)throw new TypeError("Invalid network version");const n=t[4],s=t.readUInt32BE(5);if(n===0&&s!==0)throw new TypeError("Invalid parent fingerprint");const u=t.readUInt32BE(9);if(n===0&&u!==0)throw new TypeError("Invalid index");const c=t.slice(13,45);let p;if(r===e.bip32.private){if(t.readUInt8(45)!==0)throw new TypeError("Invalid private key");const w=t.slice(46,78);p=v(w,c,e,n,u,s)}else{const w=t.slice(45,78);p=l(w,c,e,n,u,s)}return p}function g(i,e,t){return v(i,e,t)}function v(i,e,t,r,n,s){if(h({privateKey:f,chainCode:f},{privateKey:i,chainCode:e}),t=t||d,!o.isPrivate(i))throw new TypeError("Private key not in range [1, n)");return new b(i,void 0,e,t,r,n,s)}function k(i,e,t){return l(i,e,t)}function l(i,e,t,r,n,s){if(h({publicKey:h.BufferN(33),chainCode:f},{publicKey:i,chainCode:e}),t=t||d,!o.isPoint(i))throw new TypeError("Point is not on the curve");return new b(void 0,i,e,t,r,n,s)}function N(i,e){if(h(h.Buffer,i),i.length<16)throw new TypeError("Seed should be at least 128 bits");if(i.length>64)throw new TypeError("Seed should be at most 512 bits");e=e||d;const t=K(a.from("Bitcoin seed","utf8"),i),r=t.slice(0,32),n=t.slice(32);return g(r,n,e)}return{fromSeed:N,fromBase58:U,fromPublicKey:k,fromPrivateKey:g,toXOnly:I}}export{j as BIP32Factory};
