const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./web-BPP2v312.js","./user-profile-BBxMf48y.js","./preload-helper-PPVm8Dsz.js","./index-D0E7N0oa.js","./bioforest-cU8m0mjs.js","./iframe-Cr_UN5ps.js","./iframe-C8gzpSAu.css","./schemas-B18CumQY.js","./avatar-codec-BFrRl5jW.js","./breakpoint-C1BNOfKS.js","./nacl-fast-Datnq1Kn.js","./nacl-fast-z7EH-Ygu.js","./ed2curve-DTbQc9XX.js"])))=>i.map(i=>d[i]);
import{W as pt,I as gt,c as ft}from"./wujie-container-BpGev3xb.js";import{t as ht}from"./web-BPP2v312.js";import{S as ye,q as N,r as _e}from"./iframe-Cr_UN5ps.js";import{_ as y}from"./preload-helper-PPVm8Dsz.js";import{g as X}from"./index-C0kkUY8Z.js";import{w as be,o as mt,b as wt}from"./user-profile-BBxMf48y.js";import{A as At}from"./amount-BQsqQYGO.js";import{e as L,f as Et,b as St}from"./index-COveLHHP.js";import{j as yt,k as _t,l as Re,p as Te,e as bt,g as Rt,m as Tt,n as v,s as It}from"./bioforest-cU8m0mjs.js";import"./index-D0E7N0oa.js";import{p as Ot,g as Dt,t as kt,E as vt}from"./index-DRQXAVdd.js";const Ie={motion:{timeScale:1,layoutDuration:.45,uiFastDuration:.15,layoutEase:[.4,0,.1,1],spring:{stiffness:220,damping:28,mass:.85}},css:{}};function Y(e){return!Number.isFinite(e)||e<=0?1:e}function P(e,t){const n=Y(t);return e/n}function fe(e,t,n){const s=Y(t);return e*Math.pow(s,n)}function Nt(e,t){return t?{motion:{...e.motion,...t.motion,spring:{...e.motion.spring,...t.motion?.spring}},css:{...e.css,...t.css}}:e}const he=new WeakMap,me=new WeakMap;function yr(e){const t=he.get(e);if(t)return t;const{motion:n}=e,s={type:"spring",stiffness:fe(n.spring.stiffness,n.timeScale,2),damping:fe(n.spring.damping,n.timeScale,1),mass:n.spring.mass},i={layout:{duration:P(n.layoutDuration,n.timeScale),ease:n.layoutEase}},o={duration:P(n.uiFastDuration,n.timeScale),ease:"easeOut"},c={motionConfig:s,sharedLayout:i,uiFast:o};return he.set(e,c),c}function _r(e){const t=me.get(e);if(t)return t;const{motion:n}=e,s={"--miniapp-motion-time-scale":String(Y(n.timeScale)),"--miniapp-motion-layout-duration":`${P(n.layoutDuration,n.timeScale)}s`,"--miniapp-motion-ui-fast-duration":`${P(n.uiFastDuration,n.timeScale)}s`,"--miniapp-motion-layout-ease":`cubic-bezier(${n.layoutEase.join(",")})`};return me.set(e,s),s}const Pt={iframe:new gt,wujie:new pt};function Mt(e){return Pt[e]}async function Ct(e,t){return Mt(e).create(t)}const br={bio_requestAccounts:{risk:"low"},bio_selectAccount:{risk:"low"},bio_pickWallet:{risk:"low"},bio_createTransaction:{risk:"low"},bio_signMessage:{risk:"medium"},bio_signTypedData:{risk:"medium"},bio_signTransaction:{risk:"high"},bio_sendTransaction:{risk:"high"},bio_destroyAsset:{risk:"high"},bio_requestCryptoToken:{risk:"high"},bio_cryptoExecute:{risk:"low"},bio_getCryptoTokenInfo:{risk:"low"},bio_accounts:{risk:"low"},bio_chainId:{risk:"low"},bio_getBalance:{risk:"low"}},a={USER_REJECTED:4001,UNAUTHORIZED:4100,UNSUPPORTED_METHOD:4200,INTERNAL_ERROR:-32603,INVALID_PARAMS:-32602,METHOD_NOT_FOUND:-32601};function we(e,t,n,s){return{type:"bio_response",id:e,success:!1,error:{code:t,message:n,data:s}}}const Oe="ecosystem_my_apps",jt={teleport:"xin.dweb.teleport",forge:"xin.dweb.forge"};function I(e){return jt[e]??e}function Ae(){try{const e=localStorage.getItem(Oe),t=e?JSON.parse(e):[],n=t.map(s=>({...s,appId:I(s.appId)}));return JSON.stringify(t)!==JSON.stringify(n)&&De(n),n}catch{return[]}}function De(e){localStorage.setItem(Oe,JSON.stringify(e))}const B=["discover","mine"],ke="ecosystem_store";function Ut(e,t){return e.length===t.length&&e.every((n,s)=>n===t[s])}function Lt(){try{const e=localStorage.getItem(ke);if(e){const t=JSON.parse(e),n=Array.isArray(t.availableSubPages)&&t.availableSubPages.length>0?t.availableSubPages:B,s=t.activeSubPage??"discover",r=n.includes(s)?n:[...n,s];return{permissions:t.permissions??[],sources:t.sources??[{url:"./miniapps/ecosystem.json",name:"Bio 官方生态",lastUpdated:new Date().toISOString(),enabled:!0,status:"idle"}],myApps:Ae(),availableSubPages:r,activeSubPage:s,swiperProgress:0,syncSource:null}}}catch{}return{permissions:[],sources:[{url:"./miniapps/ecosystem.json",name:"Bio 官方生态",lastUpdated:new Date().toISOString(),enabled:!0,status:"idle"}],myApps:Ae(),availableSubPages:B,activeSubPage:"discover",swiperProgress:0,syncSource:null}}function xt(e){try{localStorage.setItem(ke,JSON.stringify({permissions:e.permissions,sources:e.sources,availableSubPages:e.availableSubPages,activeSubPage:e.activeSubPage})),De(e.myApps)}catch{}}const f=new ye(Lt());f.subscribe(()=>{xt(f.state)});const ve={getGrantedPermissions:(e,t)=>e.permissions.find(n=>n.appId===t)?.granted??[],hasPermission:(e,t,n)=>ve.getGrantedPermissions(e,t).includes(n),getEnabledSources:e=>e.sources.filter(t=>t.enabled),isAppInstalled:(e,t)=>{const n=I(t);return e.myApps.some(s=>s.appId===n)}},Ht={installApp:e=>{f.setState(t=>{const n=I(e);return t.myApps.some(s=>s.appId===n)?t:{...t,myApps:[{appId:n,installedAt:Date.now(),lastUsedAt:Date.now()},...t.myApps]}})},uninstallApp:e=>{f.setState(t=>{const n=I(e);return{...t,myApps:t.myApps.filter(s=>s.appId!==n)}})},updateAppLastUsed:e=>{f.setState(t=>{const n=I(e);return t.myApps.find(r=>r.appId===n)?{...t,myApps:t.myApps.map(r=>r.appId===n?{...r,lastUsedAt:Date.now()}:r)}:t})},grantPermissions:(e,t)=>{f.setState(n=>{const s=n.permissions.find(r=>r.appId===e);if(s){const r=[...new Set([...s.granted,...t])];return{...n,permissions:n.permissions.map(i=>i.appId===e?{...i,granted:r,grantedAt:Date.now()}:i)}}else return{...n,permissions:[...n.permissions,{appId:e,granted:t,grantedAt:Date.now()}]}})},revokePermissions:(e,t)=>{f.setState(n=>t?{...n,permissions:n.permissions.map(s=>s.appId===e?{...s,granted:s.granted.filter(r=>!t.includes(r))}:s)}:{...n,permissions:n.permissions.filter(s=>s.appId!==e)})},addSource:(e,t)=>{f.setState(n=>n.sources.some(s=>s.url===e)?n:{...n,sources:[...n.sources,{url:e,name:t,lastUpdated:new Date().toISOString(),enabled:!0,status:"idle"}]})},removeSource:e=>{f.setState(t=>({...t,sources:t.sources.filter(n=>n.url!==e)}))},toggleSource:e=>{f.setState(t=>({...t,sources:t.sources.map(n=>n.url===e?{...n,enabled:!n.enabled}:n)}))},updateSourceTimestamp:e=>{f.setState(t=>({...t,sources:t.sources.map(n=>n.url===e?{...n,lastUpdated:new Date().toISOString()}:n)}))},updateSourceStatus:(e,t,n)=>{f.setState(s=>({...s,sources:s.sources.map(r=>r.url===e?{...r,status:t,errorMessage:t==="error"?n:void 0,...t==="success"?{lastUpdated:new Date().toISOString()}:{}}:r)}))},setActiveSubPage:e=>{f.setState(t=>({...t,activeSubPage:e}))},setAvailableSubPages:e=>{f.setState(t=>{const n=e.length>0?e:B;if(Ut(t.availableSubPages,n))return t;const s=n.includes(t.activeSubPage)?t.activeSubPage:n[0]??"mine";return{...t,availableSubPages:n,activeSubPage:s}})},setSwiperProgress:e=>{f.setState(t=>({...t,swiperProgress:e}))},setSyncSource:e=>{f.setState(t=>({...t,syncSource:e}))}},Bt=["bio_requestAccounts","bio_signMessage","bio_signTypedData","bio_signTransaction","bio_sendTransaction"];function Z(e){return Bt.includes(e)}function Kt(e,t){return Z(t)?ve.hasPermission(f.state,e,t):!0}function Vt(e,t){Ht.grantPermissions(e,t)}function Rr(e){const t=N.t.bind(N),s=["bio_requestAccounts","bio_accounts","bio_selectAccount","bio_pickWallet","bio_chainId","bio_getBalance","bio_createTransaction","bio_signMessage","bio_signTypedData","bio_signTransaction","bio_sendTransaction","bio_destroyAsset","bio_requestCryptoToken","bio_cryptoExecute","bio_getCryptoTokenInfo"].includes(e);return{label:s?t(`ecosystem:permissions.${e}.name`):e,description:t(s?`ecosystem:permissions.${e}.description`:"ecosystem:permissions.defaultDescription"),sensitive:Z(e)}}class qt{handlers=new Map;iframe=null;appId="";appName="";origin="*";manifestPermissions=[];messageHandler=null;permissionRequestCallback=null;registerHandler(t,n){this.handlers.set(t,n)}setPermissionRequestCallback(t){this.permissionRequestCallback=t}attach(t,n,s,r=[]){this.detach(),this.iframe=t,this.appId=n,this.appName=s,this.manifestPermissions=r;try{const i=new URL(t.src,window.location.origin);this.origin=i.origin}catch{this.origin="*"}this.messageHandler=this.handleMessage.bind(this),window.addEventListener("message",this.messageHandler)}detach(){this.messageHandler&&(window.removeEventListener("message",this.messageHandler),this.messageHandler=null),this.iframe=null,this.appId="",this.appName="",this.manifestPermissions=[]}emit(t,...n){this.emitTo("bio",t,...n)}emitEth(t,...n){this.emitTo("eth",t,...n)}emitTron(t,...n){this.emitTo("tron",t,...n)}emitTo(t,n,...s){if(!this.iframe?.contentWindow)return;const r={type:`${t}_event`,event:n,args:s};this.iframe.contentWindow.postMessage(r,this.origin)}handleMessage(t){const n=t.data;if(!n||typeof n!="object"||!("type"in n)||!(n.type==="bio_request"||n.type==="eth_request"||n.type==="tron_request"))return;console.log("[BioBridge] Received bio message:",{origin:t.origin,expectedOrigin:this.origin,type:n.type,method:n.method});const r=this.origin.includes("localhost")&&t.origin.includes("localhost");if(!(this.origin==="*"||t.origin===this.origin||r)){console.warn("[BioBridge] Origin mismatch, ignoring message");return}if(!(t.source===this.iframe?.contentWindow||r&&t.source instanceof Window)){console.warn("[BioBridge] Source mismatch, ignoring message");return}console.log("[BioBridge] Processing message:",n.type),n.type==="bio_request"?this.processRequest(n,"bio"):n.type==="eth_request"?this.processRequest(n,"eth"):n.type==="tron_request"&&this.processRequest(n,"tron")}async processRequest(t,n){const{id:s,method:r,params:i}=t,o=this.handlers.get(r);if(!o){this.sendResponse(n,{type:`${n}_response`,id:s,success:!1,error:{code:a.METHOD_NOT_FOUND,message:`Method not found: ${r}`}});return}if(!(n!=="bio"||["bio_connect","bio_closeSplashScreen"].includes(r))){const g=["bio_accounts","bio_selectAccount","bio_pickWallet"].includes(r)&&this.manifestPermissions.includes("bio_requestAccounts"),d=g?"bio_requestAccounts":r;if(!(this.manifestPermissions.includes(r)||r==="bio_requestAccounts"||g)){this.sendResponse(n,we(s,a.UNAUTHORIZED,`Permission not declared in manifest: ${r}`));return}if(Z(d)&&!Kt(this.appId,d)&&!await this.requestPermission([d])){this.sendResponse(n,we(s,a.USER_REJECTED,"Permission denied by user"));return}}try{const g=l.state.apps.get(this.appId)?.manifest;let d=g?.icon;if(d&&!d.startsWith("http")&&!d.startsWith("data:"))try{const T=new URL(g?.url??"",window.location.origin);d=new URL(d,T).href}catch{}const h={appId:this.appId,appName:this.appName,appIcon:d,origin:this.origin,permissions:this.manifestPermissions},S=await o(i?.[0],h);this.sendResponse(n,{type:`${n}_response`,id:s,success:!0,result:S})}catch(u){const g=u instanceof Error?u.message:"Unknown error",d=u.code??a.INTERNAL_ERROR;this.sendResponse(n,{type:`${n}_response`,id:s,success:!1,error:{code:d,message:g}})}}async requestPermission(t){if(!this.permissionRequestCallback)return!1;try{const n=await this.permissionRequestCallback(this.appId,this.appName,t);return n&&Vt(this.appId,t),n}catch{return!1}}sendResponse(t,n){this.iframe?.contentWindow&&this.iframe.contentWindow.postMessage(n,this.origin)}}const p=new qt,_=new Map,m={register(e,t){_.set(e,t)},unregister(e){_.delete(e)},get(e){return _.get(e)},has(e){return _.has(e)},getRegisteredApps(){return Array.from(_.keys())},clear(){_.clear()}},zt=async(e,t)=>{lt(t.appId)};let Ne=null,Pe=null;function Tr(e){Ne=e}function Ir(e){Pe=e}function Q(e){return m.get(e)?.showWalletPicker??Ne}function Wt(e){return m.get(e)?.getConnectedAccounts??Pe}const $t=async(e,t)=>({connected:!0}),Ft=async(e,t)=>{const n=Q(t.appId);if(!n)throw Object.assign(new Error("Wallet picker not available"),{code:a.INTERNAL_ERROR});const r=await n({chain:e?.chain,app:{name:t.appName,icon:t.appIcon}});if(!r)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return[r]},Jt=async(e,t)=>{const n=Wt(t.appId);return n?n():[]},Gt=async(e,t)=>{const n=Q(t.appId);if(!n)throw Object.assign(new Error("Wallet picker not available"),{code:a.INTERNAL_ERROR});const r=await n({...e,app:{name:t.appName,icon:t.appIcon}});if(!r)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return r},Xt=async(e,t)=>{const n=Q(t.appId);if(!n)throw Object.assign(new Error("Wallet picker not available"),{code:a.INTERNAL_ERROR});const r=await n({...e,app:{name:t.appName,icon:t.appIcon}});if(!r)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return r},Yt=async(e,t)=>be.state.selectedChain,Zt=async(e,t)=>{const n=e;if(!n?.address||!n?.chain)throw Object.assign(new Error("Missing address or chain"),{code:a.INVALID_PARAMS});const s=X(n.chain);try{return(await s.nativeBalance.fetch({address:n.address}))?.amount.toRawString()??"0"}catch{return"0"}};let Me=null;function Or(e){Me=e}function Ce(e){return m.get(e)?.showSigningDialog??Me}const Qt=async(e,t)=>{const n=e;if(!n?.message||!n?.address)throw Object.assign(new Error("Missing message or address"),{code:a.INVALID_PARAMS});const s=Ce(t.appId);if(!s)throw Object.assign(new Error("Signing dialog not available"),{code:a.INTERNAL_ERROR});const r=await s({message:n.message,address:n.address,app:{name:t.appName}});if(!r)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return r},en=async(e,t)=>{const n=e;if(!n?.data||!n?.address)throw Object.assign(new Error("Missing data or address"),{code:a.INVALID_PARAMS});const s=Ce(t.appId);if(!s)throw Object.assign(new Error("Signing dialog not available"),{code:a.INTERNAL_ERROR});const r=JSON.stringify(n.data,null,2),i=await s({message:r,address:n.address,app:{name:t.appName}});if(!i)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return i};let je=null;function Dr(e){je=e}function tn(e){return m.get(e)?.showTransferDialog??je}const nn=async(e,t)=>{const n=e;if(!n?.from||!n?.to||!n?.amount||!n?.chain)throw Object.assign(new Error("Missing required parameters: from, to, amount, chain"),{code:a.INVALID_PARAMS});const s=tn(t.appId);if(!s)throw Object.assign(new Error("Transfer dialog not available"),{code:a.INTERNAL_ERROR});const r={from:n.from,to:n.to,amount:n.amount,chain:n.chain,app:{name:t.appName}};n.asset&&(r.asset=n.asset);const i=await s(r);if(!i)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return i};let sn=null;function rn(e){return m.get(e)?.showDestroyDialog??sn}const an=async(e,t)=>{const n=e;if(!n?.from||!n?.amount||!n?.chain||!n?.asset)throw Object.assign(new Error("Missing required parameters: from, amount, chain, asset"),{code:a.INVALID_PARAMS});const s=rn(t.appId);if(!s)throw Object.assign(new Error("Destroy dialog not available"),{code:a.INTERNAL_ERROR});const r={from:n.from,amount:n.amount,chain:n.chain,asset:n.asset,app:{name:t.appName}},i=await s(r);if(!i)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return i};function on(e,t){const n=be.state.wallets,s=t.startsWith("0x"),r=s?t.toLowerCase():t;for(const i of n)if(i.chainAddresses.find(c=>c.chain!==e?!1:s||c.address.startsWith("0x")?c.address.toLowerCase()===r:c.address===r))return i.id;return null}async function Ue(e){if(L.state.snapshot||await Et.initialize(),!L.state.snapshot)throw Object.assign(new Error("Chain configs not initialized"),{code:a.INTERNAL_ERROR});const n=St.getChainById(L.state,e);if(!n)throw Object.assign(new Error(`Unsupported chain: ${e}`),{code:a.INVALID_PARAMS});return n}const cn=async(e,t)=>{const n=e;if(!n?.from||!n?.to||!n?.amount||!n?.chain)throw Object.assign(new Error("Missing required parameters: from, to, amount, chain"),{code:a.INVALID_PARAMS});if(!on(n.chain,n.from))throw Object.assign(new Error("From address is not owned by current user"),{code:a.UNAUTHORIZED});const r=await Ue(n.chain),i=At.parse(n.amount,r.decimals,r.symbol),o=X(r.id);if(!o.supportsBuildTransaction)throw Object.assign(new Error(`Chain ${r.id} does not support transaction building`),{code:a.UNSUPPORTED_METHOD});const c=await o.buildTransaction({type:"transfer",from:n.from,to:n.to,amount:i});return{chainId:c.chainId,intentType:c.intentType,data:c.data}};let Le=null;function kr(e){Le=e}function ln(e){return m.get(e)?.showSignTransactionDialog??Le}const dn=async(e,t)=>{const n=e;if(!n?.from||!n?.chain||!n?.unsignedTx)throw Object.assign(new Error("Missing required parameters: from, chain, unsignedTx"),{code:a.INVALID_PARAMS});const s=ln(t.appId);if(!s)throw Object.assign(new Error("SignTransaction dialog not available"),{code:a.INTERNAL_ERROR});const r=await s({from:n.from,chain:n.chain,unsignedTx:n.unsignedTx,app:{name:t.appName}});if(!r)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return r};async function vr(e){const t=await Ue(e.chainId),n=X(t.id);if(!n.supportsSignTransaction)throw Object.assign(new Error(`Chain ${t.id} does not support transaction signing`),{code:a.UNSUPPORTED_METHOD});const s=await(await y(async()=>{const{walletStorageService:o}=await import("./web-BPP2v312.js").then(c=>c.i);return{walletStorageService:o}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]),import.meta.url)).walletStorageService.getMnemonic(e.walletId,e.password);let r;if(t.chainKind==="evm"){const o=yt(s,"ethereum",0,0);if(o.address.toLowerCase()!==e.from.toLowerCase())throw Object.assign(new Error("Signing address mismatch"),{code:a.INVALID_PARAMS});r=_t(o.privateKey)}else if(t.chainKind==="bioforest"){const o=Re(s);if(Te(o.publicKey,t.prefix??"b")!==e.from)throw Object.assign(new Error("Signing address mismatch"),{code:a.INVALID_PARAMS});r=o.secretKey}else throw Object.assign(new Error(`Unsupported chain kind: ${t.chainKind}`),{code:a.UNSUPPORTED_METHOD});const i=await n.signTransaction({chainId:e.unsignedTx.chainId,intentType:e.unsignedTx.intentType??"transfer",data:e.unsignedTx.data},t.chainKind==="bioforest"?{bioSecret:s,privateKey:r}:{privateKey:r});return{chainId:i.chainId,data:i.data,signature:i.signature}}const xe=new Map,He=new Map;let Be=null,K=null,Ke=null,Ve=null;function Nr(e){Be=e}function Pr(e){K=e}function Mr(e){Ke=e}function Cr(e){Ve=e}function un(e){return m.get(e)?.showEvmWalletPicker??Be}function qe(e){return m.get(e)?.showEvmSigningDialog??Ke}function pn(e){return m.get(e)?.showEvmTransactionDialog??Ve}function k(e){return xe.get(e)??kt(vt.binance)}function gn(e,t){xe.set(e,t)}function fn(e){return He.get(e)??[]}function hn(e,t){He.set(e,t)}const mn=async(e,t)=>k(t.appId),wn=async(e,t)=>{const n=un(t.appId);if(!n)throw Object.assign(new Error("Wallet picker not available"),{code:a.INTERNAL_ERROR});const s=k(t.appId),r=await n({chainId:s,app:{name:t.appName,icon:t.appIcon}});if(!r)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});const i=[r.address];return hn(t.appId,i),i},An=async(e,t)=>fn(t.appId),En=async(e,t)=>{const n=e;if(!n?.chainId)throw Object.assign(new Error("Missing chainId"),{code:a.INVALID_PARAMS});const s=n.chainId;if(!Dt(s))throw Object.assign(new Error(`Chain ${s} not supported`),{code:4902});const i=k(t.appId);if(i===s)return null;if(K&&!await K({fromChainId:i,toChainId:s,appName:t.appName,appIcon:t.appIcon}))throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return gn(t.appId,s),null},Sn=async(e,t)=>{throw Object.assign(new Error("Adding custom chains is not supported"),{code:a.UNSUPPORTED_METHOD})},ze=async(e,t)=>{const[n,s]=e;if(!n||!s)throw Object.assign(new Error("Missing message or address"),{code:a.INVALID_PARAMS});const r=qe(t.appId);if(!r)throw Object.assign(new Error("Signing dialog not available"),{code:a.INTERNAL_ERROR});const i=await r({message:n,address:s,appName:t.appName});if(!i)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return i.signature},yn=async(e,t)=>{const[n,s]=e;return ze([s,n],t)},_n=async(e,t)=>{const[n,s]=e;if(!n||!s)throw Object.assign(new Error("Missing address or typedData"),{code:a.INVALID_PARAMS});const r=typeof s=="string"?JSON.parse(s):s,i=qe(t.appId);if(!i)throw Object.assign(new Error("Signing dialog not available"),{code:a.INTERNAL_ERROR});const o=JSON.stringify(r,null,2),c=await i({message:o,address:n,appName:t.appName});if(!c)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return c.signature},bn=async(e,t)=>{const n=e;if(!n?.from)throw Object.assign(new Error("Missing transaction data"),{code:a.INVALID_PARAMS});const s=pn(t.appId);if(!s)throw Object.assign(new Error("Transaction dialog not available"),{code:a.INTERNAL_ERROR});n.chainId||(n.chainId=k(t.appId));const r=await s({tx:n,appName:t.appName});if(!r)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return r.txHash},Rn=async(e,t)=>{throw e?.from?Object.assign(new Error("eth_signTransaction not yet supported, use eth_sendTransaction"),{code:a.UNSUPPORTED_METHOD}):Object.assign(new Error("Missing transaction data"),{code:a.INVALID_PARAMS})},Tn=async(e,t)=>{const[n]=e;if(!n)throw Object.assign(new Error("Missing address"),{code:a.INVALID_PARAMS});return"0x0"},In=async(e,t)=>{const n=k(t.appId),s=Ot(n);return String(s)},On=async(e,t)=>"0x0",Dn=async(e,t)=>"KeyApp/1.0.0",kn={eth_chainId:mn,eth_requestAccounts:wn,eth_accounts:An,wallet_switchEthereumChain:En,wallet_addEthereumChain:Sn,personal_sign:ze,eth_sign:yn,eth_signTypedData_v4:_n,eth_sendTransaction:bn,eth_signTransaction:Rn,eth_getBalance:Tn,net_version:In,eth_blockNumber:On,web3_clientVersion:Dn};function vn(e){for(const[t,n]of Object.entries(kn))e(t,n)}const We=new Map;let $e=null,Nn=null;function jr(e){$e=e}function Pn(e){return m.get(e)?.showTronWalletPicker??$e}function Mn(e){return m.get(e)?.showTronSigningDialog??Nn}function Fe(e){return We.get(e)??null}function Cn(e,t){We.set(e,t)}function jn(e){return{base58:e.address,hex:e.address}}const Un=async(e,t)=>{const n=Pn(t.appId);if(!n)throw Object.assign(new Error("Wallet picker not available"),{code:a.INTERNAL_ERROR});const s=await n({app:{name:t.appName,icon:t.appIcon}});if(!s)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});const r=jn(s);return Cn(t.appId,r),{code:200,message:"ok",data:r}},Ln=async(e,t)=>{const n=Fe(t.appId);return n?{code:200,message:"ok",data:n}:{code:4e3,message:"Not connected",data:null}},xn=async(e,t)=>Fe(t.appId),Hn=async(e,t)=>{const n=e;if(!n?.txID)throw Object.assign(new Error("Invalid transaction"),{code:a.INVALID_PARAMS});const s=Mn(t.appId);if(!s)throw Object.assign(new Error("Signing dialog not available"),{code:a.INTERNAL_ERROR});const r=await s({transaction:n,appName:t.appName});if(!r)throw Object.assign(new Error("User rejected"),{code:a.USER_REJECTED});return r.signedTransaction},Bn=async(e,t)=>{const n=e;if(!n?.txID||!n.signature)throw Object.assign(new Error("Invalid signed transaction"),{code:a.INVALID_PARAMS});return{result:!0,txid:n.txID}},Kn=async(e,t)=>{if(!e)throw Object.assign(new Error("Missing address"),{code:a.INVALID_PARAMS});return 0},Vn=async(e,t)=>{const n=e;if(!n)throw Object.assign(new Error("Missing address"),{code:a.INVALID_PARAMS});return{address:n,balance:0}},qn={tron_requestAccounts:Un,tron_accounts:Ln,tron_getDefaultAddress:xn,tron_signTransaction:Hn,tron_sendRawTransaction:Bn,tron_getBalance:Kn,tron_getAccount:Vn};function zn(e){for(const[t,n]of Object.entries(qn))e(t,n)}const Wn="crypto-box-db",$n=2,w="tokens";class Fn{db=null;initialized=!1;async initialize(){this.initialized||(this.db=await mt(Wn,$n,{upgrade(t,n){t.objectStoreNames.contains(w)&&t.deleteObjectStore(w);const s=t.createObjectStore(w,{keyPath:"tokenId"});s.createIndex("by-miniapp","miniappId"),s.createIndex("by-wallet","walletId"),s.createIndex("by-expires","expiresAt")}}),this.initialized=!0,await this.cleanupExpired())}ensureInitialized(){if(!this.initialized||!this.db)throw new Error("TokenStore not initialized")}generateTokenId(){return crypto.randomUUID()}async sha256(t){const s=new TextEncoder().encode(t),r=await crypto.subtle.digest("SHA-256",s);return Array.from(new Uint8Array(r)).map(o=>o.toString(16).padStart(2,"0")).join("")}async deriveSessionSecret(t,n,s,r){return this.sha256(`${t}:${n}:${s}:${r}`)}async createToken(t){this.ensureInitialized();const{TOKEN_DURATION_MS:n}=await y(async()=>{const{TOKEN_DURATION_MS:S}=await Promise.resolve().then(()=>V);return{TOKEN_DURATION_MS:S}},void 0,import.meta.url),s=Date.now(),r=this.generateTokenId(),i=s+n[t.duration],o=await this.deriveSessionSecret(t.walletId,t.patternKey,t.miniappId,r),c={patternKey:t.patternKey,miniappId:t.miniappId,walletId:t.walletId,address:t.address,actions:t.actions,expiresAt:i},u=JSON.stringify(await bt(JSON.stringify(c),o)),g={tokenId:r,miniappId:t.miniappId,walletId:t.walletId,address:t.address,actions:t.actions,expiresAt:i,createdAt:s,encryptedPayload:u};await this.db.put(w,g);const{encryptedPayload:d,...h}=g;return{token:h,sessionSecret:o}}async decryptPayload(t,n){try{const s=JSON.parse(t.encryptedPayload),r=await Rt(s,n);return JSON.parse(r)}catch{return null}}async getToken(t){return this.ensureInitialized(),await this.db.get(w,t)??null}async deleteToken(t){this.ensureInitialized(),await this.db.delete(w,t)}async validateToken(t,n,s,r){this.ensureInitialized();const i=await this.getToken(t);if(!i)return{valid:!1,error:"TOKEN_NOT_FOUND"};const o=await this.decryptPayload(i,n);return o?o.miniappId!==s?{valid:!1,error:"MINIAPP_MISMATCH"}:Date.now()>o.expiresAt?(await this.deleteToken(t),{valid:!1,error:"TOKEN_EXPIRED"}):o.actions.includes(r)?{valid:!0,token:i,payload:o}:{valid:!1,error:"ACTION_NOT_PERMITTED"}:{valid:!1,error:"INVALID_SESSION_SECRET"}}async getTokenInfo(t,n,s){this.ensureInitialized();const r=await this.getToken(t);if(!r)return{valid:!1,address:"",expiresAt:0,actions:[],invalidReason:"TOKEN_NOT_FOUND"};const i=await this.decryptPayload(r,n);return i?i.miniappId!==s?{valid:!1,address:"",expiresAt:0,actions:[],invalidReason:"MINIAPP_MISMATCH"}:Date.now()>i.expiresAt?(await this.deleteToken(t),{valid:!1,address:i.address,expiresAt:i.expiresAt,actions:i.actions,invalidReason:"TOKEN_EXPIRED"}):{valid:!0,address:i.address,expiresAt:i.expiresAt,actions:i.actions}:{valid:!1,address:"",expiresAt:0,actions:[],invalidReason:"INVALID_SESSION_SECRET"}}async cleanupExpired(){this.ensureInitialized();const t=Date.now(),n=this.db.transaction(w,"readwrite"),s=n.store.index("by-expires");let r=0,i=await s.openCursor(IDBKeyRange.upperBound(t));for(;i;)await i.delete(),r++,i=await i.continue();return await n.done,r}async getTokensByMiniapp(t){this.ensureInitialized();const n=Date.now();return(await this.db.getAllFromIndex(w,"by-miniapp",t)).filter(r=>r.expiresAt>n).map(({encryptedPayload:r,...i})=>i)}close(){this.db&&(this.db.close(),this.db=null,this.initialized=!1)}}const R=new Fn;class Jn{async execute(t,n){const s=await R.validateToken(t.tokenId,t.sessionSecret,n,t.action);if(!s.valid){const{CryptoBoxErrorCodes:c}=await y(async()=>{const{CryptoBoxErrorCodes:g}=await Promise.resolve().then(()=>V);return{CryptoBoxErrorCodes:g}},void 0,import.meta.url),u={TOKEN_NOT_FOUND:c.TOKEN_NOT_FOUND,MINIAPP_MISMATCH:c.MINIAPP_MISMATCH,TOKEN_EXPIRED:c.TOKEN_EXPIRED,ACTION_NOT_PERMITTED:c.ACTION_NOT_PERMITTED,INVALID_SESSION_SECRET:c.INVALID_SESSION_SECRET,ADDRESS_MISMATCH:c.ADDRESS_MISMATCH};throw Object.assign(new Error(`Token validation failed: ${s.error}`),{code:u[s.error]})}const{payload:r}=s;if(t.address&&t.address!==r.address){const{CryptoBoxErrorCodes:c}=await y(async()=>{const{CryptoBoxErrorCodes:u}=await Promise.resolve().then(()=>V);return{CryptoBoxErrorCodes:u}},void 0,import.meta.url);throw Object.assign(new Error(`Address mismatch: requested ${t.address} but token is for ${r.address}`),{code:c.ADDRESS_MISMATCH})}const i=await this.getKeypairForWallet(r.walletId,r.address,r.patternKey);let o;switch(t.action){case"asymmetricEncrypt":o=await this.executeAsymmetricEncrypt(t.params,i);break;case"sign":o=await this.executeSign(t.params,i);break;default:throw new Error(`Unknown action: ${t.action}`)}return{...o,address:r.address}}async getKeypairForWallet(t,n,s){try{const r=await wt.getMnemonic(t,s),i=Re(r),o=n.charAt(0);if(Te(i.publicKey,o)!==n)throw new Error(`Address mismatch: token address ${n} does not match wallet`);return i}catch(r){throw r instanceof Error&&r.message.includes("Address mismatch")?r:new Error(`Failed to get keypair for wallet ${t}: invalid patternKey or wallet not found`)}}normalizePublicKey(t){if(typeof t=="string")return t;if(t&&typeof t=="object"&&"type"in t&&"data"in t){const n=t;if(n.type==="Buffer"&&Array.isArray(n.data))return n.data.map(s=>s.toString(16).padStart(2,"0")).join("")}if(Array.isArray(t)||t instanceof Uint8Array)return Array.from(t).map(n=>n.toString(16).padStart(2,"0")).join("");throw new Error(`Invalid publicKey format: ${typeof t}`)}async executeAsymmetricEncrypt(t,n){const s=Tt(this.normalizePublicKey(t.recipientPublicKey)),r=new TextEncoder().encode(t.data),i=await y(()=>import("./nacl-fast-Datnq1Kn.js").then(h=>h.n),__vite__mapDeps([10,5,2,6,11]),import.meta.url),o=await y(()=>import("./ed2curve-DTbQc9XX.js").then(h=>h.e),__vite__mapDeps([12,5,2,6,11]),import.meta.url),c=o.convertPublicKey(s),u=o.convertSecretKey(n.secretKey);if(!c||!u)throw new Error("Failed to convert Ed25519 keys to X25519");const g=new Uint8Array(24),d=i.box(r,g,c,u);return{result:v(d),publicKey:v(n.publicKey)}}async executeSign(t,n){const s=new TextEncoder().encode(t.data),r=It(s,n.secretKey);return{result:v(r),publicKey:v(n.publicKey)}}}const Gn=new Jn,Xn={"5min":300*1e3,"30min":1800*1e3,"2hour":7200*1e3,"1day":1440*60*1e3},Yn=["5min","30min","2hour","1day"],A={TOKEN_NOT_FOUND:4100,MINIAPP_MISMATCH:4101,TOKEN_EXPIRED:4102,ACTION_NOT_PERMITTED:4103,INVALID_SESSION_SECRET:4104,ADDRESS_MISMATCH:4105,USER_REJECTED:4001,INTERNAL_ERROR:-32603},Zn={asymmetricEncrypt:{name:"非对称加密",description:"使用您的私钥进行非对称加密"},sign:{name:"数据签名",description:"使用您的私钥进行签名"}},Qn={"5min":"5 分钟","30min":"30 分钟","2hour":"2 小时","1day":"1 天"},V=Object.freeze(Object.defineProperty({__proto__:null,CRYPTO_ACTION_LABELS:Zn,CryptoBoxErrorCodes:A,TOKEN_DURATION_LABELS:Qn,TOKEN_DURATION_MS:Xn,TOKEN_DURATION_OPTIONS:Yn},Symbol.toStringTag,{value:"Module"}));let q=null;function Ur(e){q=e}const es=async(e,t)=>{const n=e;if(!n?.actions||!n?.duration||!n?.address)throw Object.assign(new Error("Missing required parameters: actions, duration, address"),{code:A.INTERNAL_ERROR});const s=["asymmetricEncrypt","sign"];for(const d of n.actions)if(!s.includes(d))throw Object.assign(new Error(`Invalid action: ${d}`),{code:A.INTERNAL_ERROR});if(!q)throw Object.assign(new Error("Crypto authorize dialog not available"),{code:A.INTERNAL_ERROR});const r=q(t.appId);if(!r)throw Object.assign(new Error("Crypto authorize dialog not available"),{code:A.INTERNAL_ERROR});const i=await r({actions:n.actions,duration:n.duration,address:n.address,chainId:n.chainId,app:{name:t.appName,icon:t.appIcon}});if(!i.approved||!i.patternKey||!i.walletId)throw Object.assign(new Error("User rejected"),{code:A.USER_REJECTED});const o=i.selectedDuration||n.duration;await R.initialize();const{token:c,sessionSecret:u}=await R.createToken({miniappId:t.appId,walletId:i.walletId,address:n.address,actions:n.actions,duration:o,patternKey:i.patternKey});return{tokenId:c.tokenId,sessionSecret:u,expiresAt:c.expiresAt,grantedActions:c.actions,address:c.address}},ts=async(e,t)=>{const n=e;if(!n?.tokenId||!n?.sessionSecret||!n?.action||!n?.params)throw Object.assign(new Error("Missing required parameters: tokenId, sessionSecret, action, params"),{code:A.INTERNAL_ERROR});return await R.initialize(),await Gn.execute(n,t.appId)},ns=async(e,t)=>{const n=e;if(!n?.tokenId||!n?.sessionSecret)throw Object.assign(new Error("Missing required parameters: tokenId, sessionSecret"),{code:A.INTERNAL_ERROR});await R.initialize();const s=await R.getTokenInfo(n.tokenId,n.sessionSecret,t.appId);return{valid:s.valid,address:s.address,expiresAt:s.expiresAt,actions:s.actions,invalidReason:s.invalidReason}};let Ee=!1;function ss(){Ee||(Ee=!0,p.registerHandler("bio_connect",$t),p.registerHandler("bio_closeSplashScreen",zt),p.registerHandler("bio_requestAccounts",Ft),p.registerHandler("bio_accounts",Jt),p.registerHandler("bio_selectAccount",Gt),p.registerHandler("bio_pickWallet",Xt),p.registerHandler("bio_chainId",Yt),p.registerHandler("bio_getBalance",Zt),p.registerHandler("bio_signMessage",Qt),p.registerHandler("bio_signTypedData",en),p.registerHandler("bio_createTransaction",cn),p.registerHandler("bio_signTransaction",dn),p.registerHandler("bio_sendTransaction",nn),p.registerHandler("bio_destroyAsset",an),p.registerHandler("bio_requestCryptoToken",es),p.registerHandler("bio_cryptoExecute",ts),p.registerHandler("bio_getCryptoTokenInfo",ns),vn((e,t)=>p.registerHandler(e,t)),zn((e,t)=>p.registerHandler(e,t)))}ss();function ee(){return p}const te=new Map,z=new Set;function W(e,t){const n=`${e}:${t}`;return te.get(n)??null}function Je(e){return z.add(e),()=>z.delete(e)}function Ge(){z.forEach(e=>e())}const ne=new Map,se=new Map,re=new Map,ie=new Map;let Xe=null,Ye=null;const ae=new Map,oe=new Map,O=new Map;function rs(e,t){ne.set(e,t)}function is(e,t){se.set(e,t)}function as(e){ne.delete(e),se.delete(e)}function ce(e){return ne.get(e)??null}function os(e){return se.get(e)??null}function cs(e,t){re.set(e,t)}function ls(e){re.delete(e)}function ds(e){return re.get(e)??null}function us(e,t){ie.set(e,t)}function ps(e){ie.delete(e)}function gs(e){return ie.get(e)??null}function fs(e){Xe=e}function hs(){return Xe}function ms(e){Ye=e}function ws(){return Ye}function Ze(e,t){ae.set(e,t)}function Qe(e){ae.delete(e)}function le(e){return ae.get(e)??null}function et(e){const t=le(e);if(!t)return null;const n=t.closest(".swiper-slide");if(n&&!n.classList.contains("swiper-slide-active"))return null;const s=t.getBoundingClientRect();return s.width<=0||s.height<=0?null:s}function As(e,t){oe.set(e,t)}function Es(e){oe.delete(e)}function Ss(e){return oe.get(e)??null}function ys(e,t,n){const s=O.get(e)??new Map;s.set(t,n),O.set(e,s);const r=`${e}:${t}`;te.set(r,"ready"),Ge()}function _s(e,t){const n=O.get(e);if(!n)return;n.delete(t),n.size===0&&O.delete(e);const s=`${e}:${t}`;te.set(s,"lost"),Ge()}function tt(e,t){return O.get(e)?.get(t)??null}function nt(e,t){const n=tt(e,t);if(!n)return null;const s=n.closest(".swiper-slide");if(s&&!s.classList.contains("swiper-slide-active"))return null;const r=n.getBoundingClientRect();return r.width<=0||r.height<=0?null:r}function bs(e){Ze("stack",e)}function Rs(){Qe("stack")}function Ts(){return le("stack")}function Is(){return et("stack")}async function Os(){return y(()=>Promise.resolve().then(()=>lr),void 0,import.meta.url)}function Ds(){_e.useEffect(()=>{Os().then(({miniappRuntimeStore:e,activateApp:t})=>{const{activeAppId:n}=e.state;n&&t(n)})})}function ks(e,t){return _e.useSyncExternalStore(Je,()=>W(e,t),()=>W(e,t))}const x=N.t.bind(N),vs={apps:new Map,visualConfig:Ie,activeAppId:null,focusedAppId:null,presentations:new Map,zOrderSeed:1,isStackViewOpen:!1,maxBackgroundApps:4};function st(e){const t=l.state.apps.get(e);if(!t)return;const n=t.containerHandle?.getIframe()??t.iframeRef;n&&ee().attach(n,e,t.manifest.name,t.manifest.permissions??[])}function Ns(e,t,n){const s=t.getIframe();s&&(ee().attach(s,e,n.name,n.permissions??[]),Ms(s))}function Ps(){const e=document.createElement("div");e.style.cssText="position:fixed;top:env(safe-area-inset-top,0px);visibility:hidden;",document.body.appendChild(e);const t=e.offsetTop;return document.body.removeChild(e),Math.max(t,8)+32+8}function Ms(e){const t=Ps(),s={type:"keyapp:context-update",payload:{theme:{colorMode:document.documentElement.classList.contains("dark")?"dark":"light"},env:{platform:"web",safeAreaInsets:{top:t,bottom:0,left:0,right:0}}}};e.contentWindow?.postMessage(s,"*")}const l=new ye(vs);function rt(e){l.setState(t=>({...t,visualConfig:Nt(t.visualConfig,e)}))}function Cs(e){rt({motion:{timeScale:e}})}function js(){l.setState(e=>({...e,visualConfig:Ie}))}const $=new Set;function E(e){$.forEach(t=>t(e))}let Se=0;function it(e,t){return Se+=1,{id:`${e}:${t}:${Date.now()}:${Se}`,kind:e,status:"requested",startedAt:Date.now()}}function Us(e){const t=e.splashScreen;return t?typeof t=="object"&&typeof t.timeout=="number"?t.timeout:5e3:null}function Ls(e,t){if(!e||e==="preparing"){if(t==="launching")return"opening";if(t==="splash")return"splash";if(t==="active")return"opened"}return e==="launching"&&t==="splash"?"splash":(e==="launching"||e==="splash")&&t==="active"?"opened":e==="active"&&t==="background"?"backgrounding":e==="background"&&t==="active"?"foregrounding":t==="closing"?"closing":t==="preparing"?"closed":t==="launching"?"opening":t==="splash"?"splash":t==="active"?"opened":t==="background"?"backgrounded":"closed"}function D(e,t){l.setState(n=>{const s=n.apps.get(e);if(!s)return n;const r=Ls(s.state,t),i=new Map(n.apps);return i.set(e,{...s,state:t,flow:r}),{...n,apps:i}}),E({type:"app:state-change",appId:e,state:t})}function xs(e,t){l.setState(n=>{const s=n.apps.get(e);if(!s||s.processStatus===t)return n;const r=new Map(n.apps);return r.set(e,{...s,processStatus:t}),{...n,apps:r}})}function Hs(e,t){l.setState(n=>{const s=n.apps.get(e);if(!s||s.readiness===t)return n;const r=new Map(n.apps);return r.set(e,{...s,readiness:t}),{...n,apps:r}})}function at(e){Hs(e,"ready");const t=l.state.apps.get(e);t&&!t.manifest.splashScreen&&(t.state==="launching"||t.state==="splash")&&U(e)}function Bs(e){switch(e){case"opening":return"opened";case"backgrounding":return"backgrounded";case"foregrounding":return"opened";default:return e}}function Ks(e){l.setState(t=>{const n=t.apps.get(e);if(!n)return t;const s=Bs(n.flow);if(s===n.flow)return t;const r=new Map(t.apps);return r.set(e,{...n,flow:s}),{...t,apps:r}})}const Vs={launchToSplash:100},M=new Map,F=new Map,J=new Map,qs=3e4,zs=2500,G=new Map;function b(e){const t=G.get(e);t&&(t.cancelled=!0,t.rafId!==null&&cancelAnimationFrame(t.rafId),G.delete(e))}function Ws(e){if(!e)return!1;const t=e.getBoundingClientRect();return t.width>0&&t.height>0}function $s(e){return e.containerHandle?.isConnected()??!1}function C(e){const t=F.get(e);t&&(clearTimeout(t),F.delete(e))}function de(e,t,n){l.setState(s=>{const i=s.presentations.get(e)??{appId:e,desktop:t,state:"hidden",zOrder:s.zOrderSeed,transitionId:null,transitionKind:null},o={...i,...n,appId:e,desktop:n.desktop??i.desktop},c=new Map(s.presentations);return c.set(e,o),{...s,presentations:c}})}function ot(e){l.setState(t=>{const n=t.presentations.get(e),s=t.zOrderSeed+1,r=new Map(t.presentations);return n&&r.set(e,{...n,zOrder:s}),{...t,activeAppId:e,focusedAppId:e,presentations:r,zOrderSeed:s}})}function Fs(e,t){const n=l.state.presentations.get(e);n&&(n.transitionKind!=="present"||n.transitionId!==t||de(e,n.desktop,{state:"presented",transitionId:null,transitionKind:null}))}function Js(e,t){const n=l.state.presentations.get(e);n&&(n.transitionKind!=="dismiss"||n.transitionId!==t||j(e))}function ue(e){C(e),at(e),U(e)}function H(e,t){b(e);const n=l.state.apps.get(e);n?.containerHandle&&n.containerHandle.destroy(),l.setState(s=>{const r=new Map(s.apps);r.delete(e);const i=new Map(s.presentations);return i.delete(e),{...s,apps:r,presentations:i,activeAppId:s.activeAppId===e?null:s.activeAppId,focusedAppId:s.focusedAppId===e?null:s.focusedAppId}}),ht.show({message:t,duration:2e3})}function Gs(e,t){if(D(e,"launching"),pe(e),t){const n=setTimeout(()=>{const s=l.state.apps.get(e);if(!s||s.state!=="launching")return;D(e,"splash"),C(e);const r=Us(s.manifest);r!==null&&F.set(e,setTimeout(()=>{const i=l.state.apps.get(e);i&&i.state==="splash"&&ue(e)},r))},Vs.launchToSplash);M.set(e,[n]);return}M.set(e,[])}function Xs(e,t,n){b(e);const s={cancelled:!1,rafId:null};G.set(e,s);const r=performance.now(),i=()=>{if(s.cancelled)return;const o=l.state.apps.get(e);if(!o||o.state!=="preparing"){b(e);return}const c=Ws(ce(e)),u=!!nt(t,e),g=$s(o);if(c&&u&&g){b(e),Gs(e,n);return}if(performance.now()-r>zs){u?c?H(e,x("error:miniapp.launchFailed.containerNotReady")):H(e,x("error:miniapp.launchFailed.iconNotReady")):H(e,x("error:miniapp.launchFailed.stayOnDesktop"));return}s.rafId=requestAnimationFrame(i)};s.rafId=requestAnimationFrame(i)}function pe(e){const t=M.get(e);t&&(t.forEach(n=>clearTimeout(n)),M.delete(e))}function ct(e){const t=J.get(e);t&&(clearTimeout(t),J.delete(e))}function j(e){pe(e),ct(e),C(e),b(e),l.setState(t=>{const n=t.apps.get(e);if(!n)return t;n.containerHandle&&n.containerHandle.destroy();const s=new Map(t.apps);s.delete(e);const r=new Map(t.presentations);return r.delete(e),{...t,apps:s,presentations:r,activeAppId:t.activeAppId===e?null:t.activeAppId,focusedAppId:t.focusedAppId===e?null:t.focusedAppId}}),l.state.apps.size===0&&ee().detach()}function lt(e){ue(e)}function dt(e,t,n){const r=l.state.apps.get(e);if(r){st(e);const d=r.manifest.targetDesktop??"stack";return de(e,d,{state:"presented",transitionId:null,transitionKind:null}),ot(e),U(e),r}const i=!!t.splashScreen,o=t.runtime??"iframe",c={appId:e,manifest:t,state:"preparing",flow:"closed",ctx:{capsuleTheme:t.capsuleTheme??"auto"},processStatus:"loading",readiness:"notReady",launchedAt:Date.now(),lastActiveAt:Date.now(),containerType:o,containerHandle:null,iframeRef:null,iconRef:ce(e)};Ct(o,{appId:e,url:t.url,mountTarget:document.body,contextParams:n,wujieConfig:t.wujieConfig,onLoad:()=>{xs(e,"loaded"),t.splashScreen||at(e)}}).then(d=>{c.containerHandle=d,d.type==="iframe"&&(c.iframeRef=d.element),Ns(e,d,t)});const u=t.targetDesktop??"stack",g=it("present",e);return l.setState(d=>{const h=d.zOrderSeed+1,S=new Map(d.apps);S.set(e,c);const T=new Map(d.presentations);return T.set(e,{appId:e,desktop:u,state:"presenting",zOrder:h,transitionId:g.id,transitionKind:"present"}),{...d,apps:S,presentations:T,activeAppId:e,focusedAppId:e,zOrderSeed:h}}),E({type:"app:launch",appId:e,manifest:t}),Xs(e,u,i),c}function Ys(e,t,n){return dt(e,t,n)}function U(e){const t=l.state,n=t.apps.get(e);n&&n.state!=="preparing"&&(t.activeAppId&&t.activeAppId!==e&&ut(t.activeAppId),n.containerHandle&&n.state==="background"&&n.containerHandle.moveToForeground(),D(e,"active"),st(e),l.setState(s=>{const r=new Map(s.apps),i=r.get(e);return i&&r.set(e,{...i,lastActiveAt:Date.now()}),{...s,apps:r,activeAppId:e,focusedAppId:e}}),E({type:"app:activate",appId:e}))}function ut(e){const t=l.state,n=t.apps.get(e);n&&n.state!=="preparing"&&(n.containerHandle&&n.containerHandle.moveToBackground(),D(e,"background"),Zs(t.maxBackgroundApps),E({type:"app:deactivate",appId:e}))}function Zs(e){const t=l.state,n=Array.from(t.apps.values()).filter(s=>s.appId!==t.activeAppId&&s.state==="background").toSorted((s,r)=>s.lastActiveAt-r.lastActiveAt);for(;n.length>e;){const s=n.shift();s?.containerHandle&&(s.containerHandle.destroy(),s.containerHandle=null)}}function ge(e){const n=l.state.apps.get(e);if(!n)return;pe(e),ct(e),b(e),D(e,"closing"),C(e);const s=n.manifest.targetDesktop??"stack",r=it("dismiss",e);de(e,s,{state:"dismissing",transitionId:r.id,transitionKind:"dismiss"}),J.set(e,setTimeout(()=>{const i=l.state.presentations.get(e);i&&(i.transitionKind!=="dismiss"||i.transitionId!==r.id||j(e))},qs)),E({type:"app:close",appId:e})}function Qs(e){ge(e)}function er(e,t){const s=l.state.apps.get(e);if(!s)return;const r={...s.ctx,...t};l.setState(i=>{const o=new Map(i.apps),c=o.get(e);return c&&o.set(e,{...c,ctx:r}),{...i,apps:o}}),E({type:"app:ctx-change",appId:e,ctx:r})}function tr(){l.state.apps.forEach((t,n)=>{ge(n),j(n)}),ft()}function nr(){l.setState(e=>({...e,isStackViewOpen:!0})),E({type:"stack-view:open"})}function sr(){l.setState(e=>({...e,isStackViewOpen:!1})),E({type:"stack-view:close"})}function rr(e){return $.add(e),()=>$.delete(e)}function ir(){return Array.from(l.state.apps.values())}function ar(){const e=l.state;return e.activeAppId?e.apps.get(e.activeAppId)??null:null}function or(){return l.state.apps.size>0}const cr={getApps:e=>Array.from(e.apps.values()),getVisualConfig:e=>e.visualConfig,getActiveApp:e=>e.activeAppId?e.apps.get(e.activeAppId)??null:null,getFocusedAppId:e=>e.focusedAppId??e.activeAppId,getFocusedApp:e=>{const t=e.focusedAppId??e.activeAppId;return t?e.apps.get(t)??null:null},getPresentations:e=>Array.from(e.presentations.values()).sort((t,n)=>t.zOrder-n.zOrder),getPresentation:(e,t)=>e.presentations.get(t)??null,hasPresentations:e=>e.presentations.size>0,hasRunningApps:e=>e.apps.size>0,hasRunningStackApps:e=>Array.from(e.apps.values()).some(t=>(t.manifest.targetDesktop??"stack")==="stack"),isStackViewOpen:e=>e.isStackViewOpen,getBackgroundApps:e=>Array.from(e.apps.values()).filter(t=>t.state==="background"),isLaunchOverlayVisible:e=>{const t=e.focusedAppId??e.activeAppId?e.apps.get(e.focusedAppId??e.activeAppId):null;return t?.state==="launching"||t?.state==="splash"},isShowingSplash:e=>(e.focusedAppId??e.activeAppId?e.apps.get(e.focusedAppId??e.activeAppId):null)?.state==="splash",isAnimating:e=>{const t=e.focusedAppId??e.activeAppId?e.apps.get(e.focusedAppId??e.activeAppId):null;return t?.state==="launching"||t?.state==="splash"||t?.state==="closing"}},lr=Object.freeze(Object.defineProperty({__proto__:null,activateApp:U,closeAllApps:tr,closeApp:ge,closeStackView:sr,deactivateApp:ut,didDismiss:Js,didPresent:Fs,dismissSplash:lt,finalizeCloseApp:j,getActiveApp:ar,getDesktopAppSlotRect:nt,getDesktopAppSlotRef:tt,getDesktopContainerRef:le,getDesktopGridHostRef:Ss,getDesktopRect:et,getIconInnerRef:os,getIconRef:ce,getRunningApps:ir,getSlotStatus:W,getSplashBgRef:ds,getSplashIconRef:gs,getStackContainerRef:Ts,getStackRect:Is,getWindowInnerRef:ws,getWindowRef:hs,hasRunningApps:or,launchApp:dt,miniappRuntimeSelectors:cr,miniappRuntimeStore:l,openStackView:nr,registerDesktopAppSlotRef:ys,registerDesktopContainerRef:Ze,registerDesktopGridHostRef:As,registerIconInnerRef:is,registerIconRef:rs,registerSplashBgRef:cs,registerSplashIconRef:us,registerStackContainerRef:bs,registerWindowInnerRef:ms,registerWindowRef:fs,requestDismiss:Qs,requestDismissSplash:ue,requestFocus:ot,requestPresent:Ys,resetMiniappVisualConfig:js,setMiniappMotionTimeScale:Cs,setMiniappVisualConfig:rt,settleFlow:Ks,subscribe:rr,subscribeSlotStatus:Je,unregisterDesktopAppSlotRef:_s,unregisterDesktopContainerRef:Qe,unregisterDesktopGridHostRef:Es,unregisterIconRef:as,unregisterSplashBgRef:ls,unregisterSplashIconRef:ps,unregisterStackContainerRef:Rs,updateAppContext:er,useMiniappVisibilityRestore:Ds,useSlotStatus:ks},Symbol.toStringTag,{value:"Module"}));export{Rr as $,ue as A,Js as B,As as C,Ie as D,Es as E,ys as F,_s as G,Ht as H,ve as I,vr as J,Zn as K,Qn as L,ss as M,ee as N,Tr as O,Ir as P,Or as Q,Dr as R,kr as S,Yn as T,Nr as U,Mr as V,Cr as W,jr as X,Pr as Y,Ur as Z,br as _,_r as a,cr as b,tr as c,l as d,f as e,Ze as f,yr as g,Qe as h,rs as i,is as j,as as k,dt as l,Nt as m,bs as n,nr as o,Rs as p,ks as q,js as r,Cs as s,tt as t,Ds as u,Fs as v,Ks as w,fs as x,ms as y,Qs as z};
