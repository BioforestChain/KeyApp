import{g as f}from"./index-BgynVEcu.js";import{c as M,e as y,b as D,f as K}from"./index-BgynVEcu.js";import"./schemas-B18CumQY.js";import"./iframe-DP2WwkEK.js";import"./preload-helper-PPVm8Dsz.js";import"./index-C9Fec6lp.js";import"./amount-BQsqQYGO.js";import"./index-D0E7N0oa.js";import"./user-profile-BcdT9kbr.js";import"./bioforest-B8KXXzKH.js";import"./avatar-codec-sXKPhKHq.js";async function P(s){const{mnemonic:t,chainConfigs:d,selectedChainIds:a,accountIndex:c=0}=s,p=new Map(d.map(r=>[r.id,r])),h=new TextEncoder().encode(t),e=[];for(const r of a){const o=p.get(r);if(!o)continue;const i=f(r);if(!i.supportsDeriveAddress)throw new Error(`Chain "${r}" (${o.chainKind}) does not support address derivation`);const n=i.deriveAddress;if(!n)throw new Error(`Chain "${r}" deriveAddress method not available`);const m=await n(h,c);e.push({chainId:r,address:m})}return e}export{M as ChainErrorCodes,y as ChainProvider,D as ChainServiceError,K as createChainProvider,P as deriveWalletChainAddresses,f as getChainProvider};
