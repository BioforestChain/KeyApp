import{v as Et}from"./iframe-CW0HKnfK.js";const fn=1e5,lr=16,un=12,xe=256,dn=Et.t.bind(Et);async function ln(e,t){const r=new TextEncoder().encode(e),o=await crypto.subtle.importKey("raw",r,"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:fn,hash:"SHA-256"},o,{name:"AES-GCM",length:xe},!1,["encrypt","decrypt"])}async function as(e,t){const r=new TextEncoder().encode(e),o=crypto.getRandomValues(new Uint8Array(lr)),s=crypto.getRandomValues(new Uint8Array(un)),i=await ln(t,o),c=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},i,r);return{ciphertext:Ot(c),salt:Ot(o),iv:Ot(s),iterations:fn}}async function hr(e,t){const n=kt(e.salt),r=kt(e.iv),o=kt(e.ciphertext),s=await ln(t,n);try{const i=await crypto.subtle.decrypt({name:"AES-GCM",iv:r},s,o);return new TextDecoder().decode(i)}catch{throw new Error(dn("error:crypto.decryptFailed"))}}async function fs(e,t){try{return await hr(e,t),!0}catch{return!1}}async function us(e,t){const r=new TextEncoder().encode(e),o=crypto.getRandomValues(new Uint8Array(un)),s=await crypto.subtle.importKey("raw",t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength),{name:"AES-GCM",length:xe},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},s,r);return{ciphertext:Ot(i),salt:"",iv:Ot(o),iterations:0}}async function ds(e,t){const n=kt(e.iv),r=kt(e.ciphertext),o=await crypto.subtle.importKey("raw",t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength),{name:"AES-GCM",length:xe},!1,["decrypt"]);try{const s=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},o,r);return new TextDecoder().decode(s)}catch{throw new Error(dn("error:crypto.decryptKeyFailed"))}}function Ot(e){const t=e instanceof Uint8Array?e:new Uint8Array(e);let n="";for(let r=0;r<t.byteLength;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function kt(e){const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t.charCodeAt(r);return n}const br=()=>{const e=self.navigator.userAgent.includes("Dweb"),t=self.__native_close_watcher_kit__!==void 0;if(e||t)return!0;const n=self.navigator.userAgentData;if(!n)return!1;const r=n.brands.filter(o=>o.brand==="DwebBrowser");return Array.isArray(r)&&r.length>0};Et.t.bind(Et);function ls(){try{return br()}catch{return!1}}function me(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function J(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function L(e,t,n=""){const r=me(e),o=e?.length,s=t!==void 0;if(!r||s&&o!==t){const i=n&&`"${n}" `,c=s?` of length ${t}`:"",a=r?`length=${o}`:`type=${typeof e}`;throw new Error(i+"expected Uint8Array"+c+", got "+a)}return e}function Ee(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");J(e.outputLen),J(e.blockLen)}function vt(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function hn(e,t){L(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function wr(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function P(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function pt(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function et(e,t){return e<<32-t|e>>>t}function It(e,t){return e<<t|e>>>32-t>>>0}const yr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function pr(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function gr(e){for(let t=0;t<e.length;t++)e[t]=pr(e[t]);return e}const Ce=yr?e=>e:gr,bn=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",xr=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function nt(e){if(L(e),bn)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=xr[e[n]];return t}const ot={_0:48,_9:57,A:65,F:70,a:97,f:102};function $e(e){if(e>=ot._0&&e<=ot._9)return e-ot._0;if(e>=ot.A&&e<=ot.F)return e-(ot.A-10);if(e>=ot.a&&e<=ot.f)return e-(ot.a-10)}function zt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(bn)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const i=$e(e.charCodeAt(s)),c=$e(e.charCodeAt(s+1));if(i===void 0||c===void 0){const a=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+s)}r[o]=i*16+c}return r}function mr(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function De(e,t=""){return typeof e=="string"?mr(e):L(e,void 0,t)}function W(...e){let t=0;for(let r=0;r<e.length;r++){const o=e[r];L(o),t+=o.length}const n=new Uint8Array(t);for(let r=0,o=0;r<e.length;r++){const s=e[r];n.set(s,o),o+=s.length}return n}function Er(e,t){if(t!==void 0&&{}.toString.call(t)!=="[object Object]")throw new Error("options must be object or undefined");return Object.assign(e,t)}function Nt(e,t={}){const n=(o,s)=>e(s).update(o).digest(),r=e(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=o=>e(o),Object.assign(n,t),Object.freeze(n)}function wn(e=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}const yn=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function he(e,t,n){return e&t^~e&n}function vr(e,t,n){return e&t^e&n^t&n}class ee{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(t,n,r,o){this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.buffer=new Uint8Array(t),this.view=pt(this.buffer)}update(t){vt(this),L(t);const{view:n,buffer:r,blockLen:o}=this,s=t.length;for(let i=0;i<s;){const c=Math.min(o-this.pos,s-i);if(c===o){const a=pt(t);for(;o<=s-i;i+=o)this.process(a,i);continue}r.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){vt(this),hn(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:i}=this;n[i++]=128,P(this.buffer.subarray(i)),this.padOffset>o-i&&(this.process(r,0),i=0);for(let u=i;u<o;u++)n[u]=0;r.setBigUint64(o-8,BigInt(this.length*8),s),this.process(r,0);const c=pt(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const f=a/4,d=this.get();if(f>d.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)c.setUint32(4*u,d[u],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||=new this.constructor,t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:i,pos:c}=this;return t.destroyed=i,t.finished=s,t.length=o,t.pos=c,o%n&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const ct=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),F=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Dt=BigInt(2**32-1),qe=BigInt(32);function Ar(e,t=!1){return t?{h:Number(e&Dt),l:Number(e>>qe&Dt)}:{h:Number(e>>qe&Dt)|0,l:Number(e&Dt)|0}}function pn(e,t=!1){const n=e.length;let r=new Uint32Array(n),o=new Uint32Array(n);for(let s=0;s<n;s++){const{h:i,l:c}=Ar(e[s],t);[r[s],o[s]]=[i,c]}return[r,o]}const Me=(e,t,n)=>e>>>n,Ze=(e,t,n)=>e<<32-n|t>>>n,gt=(e,t,n)=>e>>>n|t<<32-n,xt=(e,t,n)=>e<<32-n|t>>>n,qt=(e,t,n)=>e<<64-n|t>>>n-32,Mt=(e,t,n)=>e>>>n-32|t<<64-n,Br=(e,t,n)=>e<<n|t>>>32-n,_r=(e,t,n)=>t<<n|e>>>32-n,Sr=(e,t,n)=>t<<n-32|e>>>64-n,Kr=(e,t,n)=>e<<n-32|t>>>64-n;function st(e,t,n,r){const o=(t>>>0)+(r>>>0);return{h:e+n+(o/2**32|0)|0,l:o|0}}const Ir=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),Rr=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,Or=(e,t,n,r)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0),kr=(e,t,n,r,o)=>t+n+r+o+(e/2**32|0)|0,Lr=(e,t,n,r,o)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0)+(o>>>0),Hr=(e,t,n,r,o,s)=>t+n+r+o+s+(e/2**32|0)|0,Ur=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),at=new Uint32Array(64);class Tr extends ee{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:n,C:r,D:o,E:s,F:i,G:c,H:a}=this;return[t,n,r,o,s,i,c,a]}set(t,n,r,o,s,i,c,a){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=a|0}process(t,n){for(let u=0;u<16;u++,n+=4)at[u]=t.getUint32(n,!1);for(let u=16;u<64;u++){const b=at[u-15],h=at[u-2],p=et(b,7)^et(b,18)^b>>>3,m=et(h,17)^et(h,19)^h>>>10;at[u]=m+at[u-7]+p+at[u-16]|0}let{A:r,B:o,C:s,D:i,E:c,F:a,G:f,H:d}=this;for(let u=0;u<64;u++){const b=et(c,6)^et(c,11)^et(c,25),h=d+b+he(c,a,f)+Ur[u]+at[u]|0,m=(et(r,2)^et(r,13)^et(r,22))+vr(r,o,s)|0;d=f,f=a,a=c,c=i+h|0,i=s,s=o,o=r,r=h+m|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,a=a+this.F|0,f=f+this.G|0,d=d+this.H|0,this.set(r,o,s,i,c,a,f,d)}roundClean(){P(at)}destroy(){this.set(0,0,0,0,0,0,0,0),P(this.buffer)}}class gn extends Tr{A=ct[0]|0;B=ct[1]|0;C=ct[2]|0;D=ct[3]|0;E=ct[4]|0;F=ct[5]|0;G=ct[6]|0;H=ct[7]|0;constructor(){super(32)}}const xn=pn(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),Nr=xn[0],Cr=xn[1],ft=new Uint32Array(80),ut=new Uint32Array(80);class $r extends ee{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:n,Bh:r,Bl:o,Ch:s,Cl:i,Dh:c,Dl:a,Eh:f,El:d,Fh:u,Fl:b,Gh:h,Gl:p,Hh:m,Hl:x}=this;return[t,n,r,o,s,i,c,a,f,d,u,b,h,p,m,x]}set(t,n,r,o,s,i,c,a,f,d,u,b,h,p,m,x){this.Ah=t|0,this.Al=n|0,this.Bh=r|0,this.Bl=o|0,this.Ch=s|0,this.Cl=i|0,this.Dh=c|0,this.Dl=a|0,this.Eh=f|0,this.El=d|0,this.Fh=u|0,this.Fl=b|0,this.Gh=h|0,this.Gl=p|0,this.Hh=m|0,this.Hl=x|0}process(t,n){for(let K=0;K<16;K++,n+=4)ft[K]=t.getUint32(n),ut[K]=t.getUint32(n+=4);for(let K=16;K<80;K++){const U=ft[K-15]|0,H=ut[K-15]|0,Z=gt(U,H,1)^gt(U,H,8)^Me(U,H,7),ht=xt(U,H,1)^xt(U,H,8)^Ze(U,H,7),j=ft[K-2]|0,I=ut[K-2]|0,rt=gt(j,I,19)^qt(j,I,61)^Me(j,I,6),Q=xt(j,I,19)^Mt(j,I,61)^Ze(j,I,6),O=Or(ht,Q,ut[K-7],ut[K-16]),y=kr(O,Z,rt,ft[K-7],ft[K-16]);ft[K]=y|0,ut[K]=O|0}let{Ah:r,Al:o,Bh:s,Bl:i,Ch:c,Cl:a,Dh:f,Dl:d,Eh:u,El:b,Fh:h,Fl:p,Gh:m,Gl:x,Hh:S,Hl:N}=this;for(let K=0;K<80;K++){const U=gt(u,b,14)^gt(u,b,18)^qt(u,b,41),H=xt(u,b,14)^xt(u,b,18)^Mt(u,b,41),Z=u&h^~u&m,ht=b&p^~b&x,j=Lr(N,H,ht,Cr[K],ut[K]),I=Hr(j,S,U,Z,Nr[K],ft[K]),rt=j|0,Q=gt(r,o,28)^qt(r,o,34)^qt(r,o,39),O=xt(r,o,28)^Mt(r,o,34)^Mt(r,o,39),y=r&s^r&c^s&c,w=o&i^o&a^i&a;S=m|0,N=x|0,m=h|0,x=p|0,h=u|0,p=b|0,{h:u,l:b}=st(f|0,d|0,I|0,rt|0),f=c|0,d=a|0,c=s|0,a=i|0,s=r|0,i=o|0;const l=Ir(rt,O,w);r=Rr(l,I,Q,y),o=l|0}({h:r,l:o}=st(this.Ah|0,this.Al|0,r|0,o|0)),{h:s,l:i}=st(this.Bh|0,this.Bl|0,s|0,i|0),{h:c,l:a}=st(this.Ch|0,this.Cl|0,c|0,a|0),{h:f,l:d}=st(this.Dh|0,this.Dl|0,f|0,d|0),{h:u,l:b}=st(this.Eh|0,this.El|0,u|0,b|0),{h,l:p}=st(this.Fh|0,this.Fl|0,h|0,p|0),{h:m,l:x}=st(this.Gh|0,this.Gl|0,m|0,x|0),{h:S,l:N}=st(this.Hh|0,this.Hl|0,S|0,N|0),this.set(r,o,s,i,c,a,f,d,u,b,h,p,m,x,S,N)}roundClean(){P(ft,ut)}destroy(){P(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class mn extends $r{Ah=F[0]|0;Al=F[1]|0;Bh=F[2]|0;Bl=F[3]|0;Ch=F[4]|0;Cl=F[5]|0;Dh=F[6]|0;Dl=F[7]|0;Eh=F[8]|0;El=F[9]|0;Fh=F[10]|0;Fl=F[11]|0;Gh=F[12]|0;Gl=F[13]|0;Hh=F[14]|0;Hl=F[15]|0;constructor(){super(64)}}const G=Nt(()=>new gn,yn(1)),Xt=Nt(()=>new mn,yn(3)),hs=Object.freeze(Object.defineProperty({__proto__:null,_SHA256:gn,_SHA512:mn,sha256:G,sha512:Xt},Symbol.toStringTag,{value:"Module"}));const ve=BigInt(0),be=BigInt(1);function Wt(e,t=""){if(typeof e!="boolean"){const n=t&&`"${t}" `;throw new Error(n+"expected boolean, got type="+typeof e)}return e}function En(e){if(typeof e=="bigint"){if(!Yt(e))throw new Error("positive bigint expected, got "+e)}else J(e);return e}function Zt(e){const t=En(e).toString(16);return t.length&1?"0"+t:t}function vn(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?ve:BigInt("0x"+e)}function ne(e){return vn(nt(e))}function An(e){return vn(nt(Dr(L(e)).reverse()))}function Ae(e,t){J(t),e=En(e);const n=zt(e.toString(16).padStart(t*2,"0"));if(n.length!==t)throw new Error("number too large");return n}function Bn(e,t){return Ae(e,t).reverse()}function Dr(e){return Uint8Array.from(e)}const Yt=e=>typeof e=="bigint"&&ve<=e;function qr(e,t,n){return Yt(e)&&Yt(t)&&Yt(n)&&t<=e&&e<n}function Mr(e,t,n,r){if(!qr(t,n,r))throw new Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}function Zr(e){let t;for(t=0;e>ve;e>>=be,t+=1);return t}const Be=e=>(be<<BigInt(e))-be;function Vr(e,t,n){if(J(e,"hashLen"),J(t,"qByteLen"),typeof n!="function")throw new Error("hmacFn must be a function");const r=x=>new Uint8Array(x),o=Uint8Array.of(),s=Uint8Array.of(0),i=Uint8Array.of(1),c=1e3;let a=r(e),f=r(e),d=0;const u=()=>{a.fill(1),f.fill(0),d=0},b=(...x)=>n(f,W(a,...x)),h=(x=o)=>{f=b(s,x),a=b(),x.length!==0&&(f=b(i,x),a=b())},p=()=>{if(d++>=c)throw new Error("drbg: tried max amount of iterations");let x=0;const S=[];for(;x<t;){a=b();const N=a.slice();S.push(N),x+=a.length}return W(...S)};return(x,S)=>{u(),h(x);let N;for(;!(N=S(p()));)h();return u(),N}}function _e(e,t={},n={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(s,i,c){const a=e[s];if(c&&a===void 0)return;const f=typeof a;if(f!==i||a===null)throw new Error(`param "${s}" is invalid: expected ${i}, got ${f}`)}const o=(s,i)=>Object.entries(s).forEach(([c,a])=>r(c,a,i));o(t,!1),o(n,!0)}function Ve(e){const t=new WeakMap;return(n,...r)=>{const o=t.get(n);if(o!==void 0)return o;const s=e(n,...r);return t.set(n,s),s}}const Y=BigInt(0),M=BigInt(1),wt=BigInt(2),_n=BigInt(3),Sn=BigInt(4),Kn=BigInt(5),Fr=BigInt(7),In=BigInt(8),jr=BigInt(9),Rn=BigInt(16);function X(e,t){const n=e%t;return n>=Y?n:t+n}function z(e,t,n){let r=e;for(;t-- >Y;)r*=r,r%=n;return r}function Fe(e,t){if(e===Y)throw new Error("invert: expected non-zero number");if(t<=Y)throw new Error("invert: expected positive modulus, got "+t);let n=X(e,t),r=t,o=Y,s=M;for(;n!==Y;){const c=r/n,a=r%n,f=o-s*c;r=n,n=a,o=s,s=f}if(r!==M)throw new Error("invert: does not exist");return X(o,t)}function Se(e,t,n){if(!e.eql(e.sqr(t),n))throw new Error("Cannot find square root")}function On(e,t){const n=(e.ORDER+M)/Sn,r=e.pow(t,n);return Se(e,r,t),r}function Gr(e,t){const n=(e.ORDER-Kn)/In,r=e.mul(t,wt),o=e.pow(r,n),s=e.mul(t,o),i=e.mul(e.mul(s,wt),o),c=e.mul(s,e.sub(i,e.ONE));return Se(e,c,t),c}function Yr(e){const t=re(e),n=kn(e),r=n(t,t.neg(t.ONE)),o=n(t,r),s=n(t,t.neg(r)),i=(e+Fr)/Rn;return(c,a)=>{let f=c.pow(a,i),d=c.mul(f,r);const u=c.mul(f,o),b=c.mul(f,s),h=c.eql(c.sqr(d),a),p=c.eql(c.sqr(u),a);f=c.cmov(f,d,h),d=c.cmov(b,u,p);const m=c.eql(c.sqr(d),a),x=c.cmov(f,d,m);return Se(c,x,a),x}}function kn(e){if(e<_n)throw new Error("sqrt is not defined for small field");let t=e-M,n=0;for(;t%wt===Y;)t/=wt,n++;let r=wt;const o=re(e);for(;je(o,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return On;let s=o.pow(r,t);const i=(t+M)/wt;return function(a,f){if(a.is0(f))return f;if(je(a,f)!==1)throw new Error("Cannot find square root");let d=n,u=a.mul(a.ONE,s),b=a.pow(f,t),h=a.pow(f,i);for(;!a.eql(b,a.ONE);){if(a.is0(b))return a.ZERO;let p=1,m=a.sqr(b);for(;!a.eql(m,a.ONE);)if(p++,m=a.sqr(m),p===d)throw new Error("Cannot find square root");const x=M<<BigInt(d-p-1),S=a.pow(u,x);d=p,u=a.sqr(S),b=a.mul(b,u),h=a.mul(h,S)}return h}}function Pr(e){return e%Sn===_n?On:e%In===Kn?Gr:e%Rn===jr?Yr(e):kn(e)}const bs=(e,t)=>(X(e,t)&M)===M,zr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Xr(e){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},n=zr.reduce((r,o)=>(r[o]="function",r),t);return _e(e,n),e}function Wr(e,t,n){if(n<Y)throw new Error("invalid exponent, negatives unsupported");if(n===Y)return e.ONE;if(n===M)return t;let r=e.ONE,o=t;for(;n>Y;)n&M&&(r=e.mul(r,o)),o=e.sqr(o),n>>=M;return r}function Ln(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),o=t.reduce((i,c,a)=>e.is0(c)?i:(r[a]=i,e.mul(i,c)),e.ONE),s=e.inv(o);return t.reduceRight((i,c,a)=>e.is0(c)?i:(r[a]=e.mul(i,r[a]),e.mul(i,c)),s),r}function je(e,t){const n=(e.ORDER-M)/wt,r=e.pow(t,n),o=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),i=e.eql(r,e.neg(e.ONE));if(!o&&!s&&!i)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function Jr(e,t){t!==void 0&&J(t);const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}class Qr{ORDER;BITS;BYTES;isLE;ZERO=Y;ONE=M;_lengths;_sqrt;_mod;constructor(t,n={}){if(t<=Y)throw new Error("invalid field: expected ORDER > 0, got "+t);let r;this.isLE=!1,n!=null&&typeof n=="object"&&(typeof n.BITS=="number"&&(r=n.BITS),typeof n.sqrt=="function"&&(this.sqrt=n.sqrt),typeof n.isLE=="boolean"&&(this.isLE=n.isLE),n.allowedLengths&&(this._lengths=n.allowedLengths?.slice()),typeof n.modFromBytes=="boolean"&&(this._mod=n.modFromBytes));const{nBitLength:o,nByteLength:s}=Jr(t,r);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=o,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return X(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return Y<=t&&t<this.ORDER}is0(t){return t===Y}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&M)===M}neg(t){return X(-t,this.ORDER)}eql(t,n){return t===n}sqr(t){return X(t*t,this.ORDER)}add(t,n){return X(t+n,this.ORDER)}sub(t,n){return X(t-n,this.ORDER)}mul(t,n){return X(t*n,this.ORDER)}pow(t,n){return Wr(this,t,n)}div(t,n){return X(t*Fe(n,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,n){return t+n}subN(t,n){return t-n}mulN(t,n){return t*n}inv(t){return Fe(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Pr(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Bn(t,this.BYTES):Ae(t,this.BYTES)}fromBytes(t,n=!1){L(t);const{_lengths:r,BYTES:o,isLE:s,ORDER:i,_mod:c}=this;if(r){if(!r.includes(t.length)||t.length>o)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+t.length);const f=new Uint8Array(o);f.set(t,s?0:f.length-t.length),t=f}if(t.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+t.length);let a=s?An(t):ne(t);if(c&&(a=X(a,i)),!n&&!this.isValid(a))throw new Error("invalid field element: outside of range 0..ORDER");return a}invertBatch(t){return Ln(this,t)}cmov(t,n,r){return r?n:t}}function re(e,t={}){return new Qr(e,t)}function Hn(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Un(e){const t=Hn(e);return t+Math.ceil(t/2)}function to(e,t,n=!1){L(e);const r=e.length,o=Hn(t),s=Un(t);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const i=n?An(e):ne(e),c=X(i,t-M)+M;return n?Bn(c,o):Ae(c,o)}const At=BigInt(0),yt=BigInt(1);function Jt(e,t){const n=t.negate();return e?n:t}function Ge(e,t){const n=Ln(e.Fp,t.map(r=>r.Z));return t.map((r,o)=>e.fromAffine(r.toAffine(n[o])))}function Tn(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function oe(e,t){Tn(e,t);const n=Math.ceil(t/e)+1,r=2**(e-1),o=2**e,s=Be(e),i=BigInt(e);return{windows:n,windowSize:r,mask:s,maxNumber:o,shiftBy:i}}function Ye(e,t,n){const{windowSize:r,mask:o,maxNumber:s,shiftBy:i}=n;let c=Number(e&o),a=e>>i;c>r&&(c-=s,a+=yt);const f=t*r,d=f+Math.abs(c)-1,u=c===0,b=c<0,h=t%2!==0;return{nextN:a,offset:d,isZero:u,isNeg:b,isNegF:h,offsetF:f}}const se=new WeakMap,Nn=new WeakMap;function ie(e){return Nn.get(e)||1}function Pe(e){if(e!==At)throw new Error("invalid wNAF")}class eo{BASE;ZERO;Fn;bits;constructor(t,n){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=n}_unsafeLadder(t,n,r=this.ZERO){let o=t;for(;n>At;)n&yt&&(r=r.add(o)),o=o.double(),n>>=yt;return r}precomputeWindow(t,n){const{windows:r,windowSize:o}=oe(n,this.bits),s=[];let i=t,c=i;for(let a=0;a<r;a++){c=i,s.push(c);for(let f=1;f<o;f++)c=c.add(i),s.push(c);i=c.double()}return s}wNAF(t,n,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE;const i=oe(t,this.bits);for(let c=0;c<i.windows;c++){const{nextN:a,offset:f,isZero:d,isNeg:u,isNegF:b,offsetF:h}=Ye(r,c,i);r=a,d?s=s.add(Jt(b,n[h])):o=o.add(Jt(u,n[f]))}return Pe(r),{p:o,f:s}}wNAFUnsafe(t,n,r,o=this.ZERO){const s=oe(t,this.bits);for(let i=0;i<s.windows&&r!==At;i++){const{nextN:c,offset:a,isZero:f,isNeg:d}=Ye(r,i,s);if(r=c,!f){const u=n[a];o=o.add(d?u.negate():u)}}return Pe(r),o}getPrecomputes(t,n,r){let o=se.get(n);return o||(o=this.precomputeWindow(n,t),t!==1&&(typeof r=="function"&&(o=r(o)),se.set(n,o))),o}cached(t,n,r){const o=ie(t);return this.wNAF(o,this.getPrecomputes(o,t,r),n)}unsafe(t,n,r,o){const s=ie(t);return s===1?this._unsafeLadder(t,n,o):this.wNAFUnsafe(s,this.getPrecomputes(s,t,r),n,o)}createCache(t,n){Tn(n,this.bits),Nn.set(t,n),se.delete(t)}hasCache(t){return ie(t)!==1}}function no(e,t,n,r){let o=t,s=e.ZERO,i=e.ZERO;for(;n>At||r>At;)n&yt&&(s=s.add(o)),r&yt&&(i=i.add(o)),o=o.double(),n>>=yt,r>>=yt;return{p1:s,p2:i}}function ze(e,t,n){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Xr(t),t}else return re(e,{isLE:n})}function ro(e,t,n={},r){if(r===void 0&&(r=e==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${e} CURVE object`);for(const a of["p","n","h"]){const f=t[a];if(!(typeof f=="bigint"&&f>At))throw new Error(`CURVE.${a} must be positive bigint`)}const o=ze(t.p,n.Fp,r),s=ze(t.n,n.Fn,r),c=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const a of c)if(!o.isValid(t[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:o,Fn:s}}function oo(e,t){return function(r){const o=e(r);return{secretKey:o,publicKey:t(o)}}}class Cn{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(t,n){if(Ee(t),L(n,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,o=new Uint8Array(r);o.set(n.length>r?t.create().update(n).digest():n);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=t.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),P(o)}update(t){return vt(this),this.iHash.update(t),this}digestInto(t){vt(this),L(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||=Object.create(Object.getPrototypeOf(this),{});const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=i,t.outputLen=c,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Lt=(e,t,n)=>new Cn(e,t).update(n).digest();Lt.create=(e,t)=>new Cn(e,t);const Xe=(e,t)=>(e+(e>=0?t:-t)/$n)/t;function so(e,t,n){const[[r,o],[s,i]]=t,c=Xe(i*e,n),a=Xe(-o*e,n);let f=e-c*r-a*s,d=-c*o-a*i;const u=f<it,b=d<it;u&&(f=-f),b&&(d=-d);const h=Be(Math.ceil(Zr(n)/2))+mt;if(f<it||f>=h||d<it||d>=h)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:u,k1:f,k2neg:b,k2:d}}function we(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function ce(e,t){const n={};for(let r of Object.keys(t))n[r]=e[r]===void 0?t[r]:e[r];return Wt(n.lowS,"lowS"),Wt(n.prehash,"prehash"),n.format!==void 0&&we(n.format),n}class io extends Error{constructor(t=""){super(t)}}const dt={Err:io,_tlv:{encode:(e,t)=>{const{Err:n}=dt;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length&1)throw new n("tlv.encode: unpadded data");const r=t.length/2,o=Zt(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const s=r>127?Zt(o.length/2|128):"";return Zt(e)+s+o+t},decode(e,t){const{Err:n}=dt;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const o=t[r++],s=!!(o&128);let i=0;if(!s)i=o;else{const a=o&127;if(!a)throw new n("tlv.decode(long): indefinite length not supported");if(a>4)throw new n("tlv.decode(long): byte length is too big");const f=t.subarray(r,r+a);if(f.length!==a)throw new n("tlv.decode: length bytes not complete");if(f[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const d of f)i=i<<8|d;if(r+=a,i<128)throw new n("tlv.decode(long): not minimal encoding")}const c=t.subarray(r,r+i);if(c.length!==i)throw new n("tlv.decode: wrong value length");return{v:c,l:t.subarray(r+i)}}},_int:{encode(e){const{Err:t}=dt;if(e<it)throw new t("integer: negative integers are not allowed");let n=Zt(e);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=dt;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return ne(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=dt,o=L(e,void 0,"signature"),{v:s,l:i}=r.decode(48,o);if(i.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:a}=r.decode(2,s),{v:f,l:d}=r.decode(2,a);if(d.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(f)}},hexFromSig(e){const{_tlv:t,_int:n}=dt,r=t.encode(2,n.encode(e.r)),o=t.encode(2,n.encode(e.s)),s=r+o;return t.encode(48,s)}},it=BigInt(0),mt=BigInt(1),$n=BigInt(2),Vt=BigInt(3),co=BigInt(4);function ao(e,t={}){const n=ro("weierstrass",e,t),{Fp:r,Fn:o}=n;let s=n.CURVE;const{h:i,n:c}=s;_e(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:a}=t;if(a&&(!r.is0(s.a)||typeof a.beta!="bigint"||!Array.isArray(a.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const f=qn(r,o);function d(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function u(O,y,w){const{x:l,y:g}=y.toAffine(),v=r.toBytes(l);if(Wt(w,"isCompressed"),w){d();const B=!r.isOdd(g);return W(Dn(B),v)}else return W(Uint8Array.of(4),v,r.toBytes(g))}function b(O){L(O,void 0,"Point");const{publicKey:y,publicKeyUncompressed:w}=f,l=O.length,g=O[0],v=O.subarray(1);if(l===y&&(g===2||g===3)){const B=r.fromBytes(v);if(!r.isValid(B))throw new Error("bad point: is not on curve, wrong x");const A=m(B);let E;try{E=r.sqrt(A)}catch(D){const T=D instanceof Error?": "+D.message:"";throw new Error("bad point: is not on curve, sqrt error"+T)}d();const _=r.isOdd(E);return(g&1)===1!==_&&(E=r.neg(E)),{x:B,y:E}}else if(l===w&&g===4){const B=r.BYTES,A=r.fromBytes(v.subarray(0,B)),E=r.fromBytes(v.subarray(B,B*2));if(!x(A,E))throw new Error("bad point: is not on curve");return{x:A,y:E}}else throw new Error(`bad point: got length ${l}, expected compressed=${y} or uncompressed=${w}`)}const h=t.toBytes||u,p=t.fromBytes||b;function m(O){const y=r.sqr(O),w=r.mul(y,O);return r.add(r.add(w,r.mul(O,s.a)),s.b)}function x(O,y){const w=r.sqr(y),l=m(O);return r.eql(w,l)}if(!x(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const S=r.mul(r.pow(s.a,Vt),co),N=r.mul(r.sqr(s.b),BigInt(27));if(r.is0(r.add(S,N)))throw new Error("bad curve params: a or b");function K(O,y,w=!1){if(!r.isValid(y)||w&&r.is0(y))throw new Error(`bad point coordinate ${O}`);return y}function U(O){if(!(O instanceof I))throw new Error("Weierstrass Point expected")}function H(O){if(!a||!a.basises)throw new Error("no endo");return so(O,a.basises,o.ORDER)}const Z=Ve((O,y)=>{const{X:w,Y:l,Z:g}=O;if(r.eql(g,r.ONE))return{x:w,y:l};const v=O.is0();y==null&&(y=v?r.ONE:r.inv(g));const B=r.mul(w,y),A=r.mul(l,y),E=r.mul(g,y);if(v)return{x:r.ZERO,y:r.ZERO};if(!r.eql(E,r.ONE))throw new Error("invZ was invalid");return{x:B,y:A}}),ht=Ve(O=>{if(O.is0()){if(t.allowInfinityPoint&&!r.is0(O.Y))return;throw new Error("bad point: ZERO")}const{x:y,y:w}=O.toAffine();if(!r.isValid(y)||!r.isValid(w))throw new Error("bad point: x or y not field elements");if(!x(y,w))throw new Error("bad point: equation left != right");if(!O.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function j(O,y,w,l,g){return w=new I(r.mul(w.X,O),w.Y,w.Z),y=Jt(l,y),w=Jt(g,w),y.add(w)}class I{static BASE=new I(s.Gx,s.Gy,r.ONE);static ZERO=new I(r.ZERO,r.ONE,r.ZERO);static Fp=r;static Fn=o;X;Y;Z;constructor(y,w,l){this.X=K("x",y),this.Y=K("y",w,!0),this.Z=K("z",l),Object.freeze(this)}static CURVE(){return s}static fromAffine(y){const{x:w,y:l}=y||{};if(!y||!r.isValid(w)||!r.isValid(l))throw new Error("invalid affine point");if(y instanceof I)throw new Error("projective point not allowed");return r.is0(w)&&r.is0(l)?I.ZERO:new I(w,l,r.ONE)}static fromBytes(y){const w=I.fromAffine(p(L(y,void 0,"point")));return w.assertValidity(),w}static fromHex(y){return I.fromBytes(zt(y))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(y=8,w=!0){return Q.createCache(this,y),w||this.multiply(Vt),this}assertValidity(){ht(this)}hasEvenY(){const{y}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(y)}equals(y){U(y);const{X:w,Y:l,Z:g}=this,{X:v,Y:B,Z:A}=y,E=r.eql(r.mul(w,A),r.mul(v,g)),_=r.eql(r.mul(l,A),r.mul(B,g));return E&&_}negate(){return new I(this.X,r.neg(this.Y),this.Z)}double(){const{a:y,b:w}=s,l=r.mul(w,Vt),{X:g,Y:v,Z:B}=this;let A=r.ZERO,E=r.ZERO,_=r.ZERO,R=r.mul(g,g),D=r.mul(v,v),T=r.mul(B,B),k=r.mul(g,v);return k=r.add(k,k),_=r.mul(g,B),_=r.add(_,_),A=r.mul(y,_),E=r.mul(l,T),E=r.add(A,E),A=r.sub(D,E),E=r.add(D,E),E=r.mul(A,E),A=r.mul(k,A),_=r.mul(l,_),T=r.mul(y,T),k=r.sub(R,T),k=r.mul(y,k),k=r.add(k,_),_=r.add(R,R),R=r.add(_,R),R=r.add(R,T),R=r.mul(R,k),E=r.add(E,R),T=r.mul(v,B),T=r.add(T,T),R=r.mul(T,k),A=r.sub(A,R),_=r.mul(T,D),_=r.add(_,_),_=r.add(_,_),new I(A,E,_)}add(y){U(y);const{X:w,Y:l,Z:g}=this,{X:v,Y:B,Z:A}=y;let E=r.ZERO,_=r.ZERO,R=r.ZERO;const D=s.a,T=r.mul(s.b,Vt);let k=r.mul(w,v),C=r.mul(l,B),q=r.mul(g,A),tt=r.add(w,l),$=r.add(v,B);tt=r.mul(tt,$),$=r.add(k,C),tt=r.sub(tt,$),$=r.add(w,g);let V=r.add(v,A);return $=r.mul($,V),V=r.add(k,q),$=r.sub($,V),V=r.add(l,g),E=r.add(B,A),V=r.mul(V,E),E=r.add(C,q),V=r.sub(V,E),R=r.mul(D,$),E=r.mul(T,q),R=r.add(E,R),E=r.sub(C,R),R=r.add(C,R),_=r.mul(E,R),C=r.add(k,k),C=r.add(C,k),q=r.mul(D,q),$=r.mul(T,$),C=r.add(C,q),q=r.sub(k,q),q=r.mul(D,q),$=r.add($,q),k=r.mul(C,$),_=r.add(_,k),k=r.mul(V,$),E=r.mul(tt,E),E=r.sub(E,k),k=r.mul(tt,C),R=r.mul(V,R),R=r.add(R,k),new I(E,_,R)}subtract(y){return this.add(y.negate())}is0(){return this.equals(I.ZERO)}multiply(y){const{endo:w}=t;if(!o.isValidNot0(y))throw new Error("invalid scalar: out of range");let l,g;const v=B=>Q.cached(this,B,A=>Ge(I,A));if(w){const{k1neg:B,k1:A,k2neg:E,k2:_}=H(y),{p:R,f:D}=v(A),{p:T,f:k}=v(_);g=D.add(k),l=j(w.beta,R,T,B,E)}else{const{p:B,f:A}=v(y);l=B,g=A}return Ge(I,[l,g])[0]}multiplyUnsafe(y){const{endo:w}=t,l=this;if(!o.isValid(y))throw new Error("invalid scalar: out of range");if(y===it||l.is0())return I.ZERO;if(y===mt)return l;if(Q.hasCache(this))return this.multiply(y);if(w){const{k1neg:g,k1:v,k2neg:B,k2:A}=H(y),{p1:E,p2:_}=no(I,l,v,A);return j(w.beta,E,_,g,B)}else return Q.unsafe(l,y)}toAffine(y){return Z(this,y)}isTorsionFree(){const{isTorsionFree:y}=t;return i===mt?!0:y?y(I,this):Q.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:y}=t;return i===mt?this:y?y(I,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(y=!0){return Wt(y,"isCompressed"),this.assertValidity(),h(I,this,y)}toHex(y=!0){return nt(this.toBytes(y))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const rt=o.BITS,Q=new eo(I,t.endo?Math.ceil(rt/2):rt);return I.BASE.precompute(8),I}function Dn(e){return Uint8Array.of(e?2:3)}function qn(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function fo(e,t={}){const{Fn:n}=e,r=t.randomBytes||wn,o=Object.assign(qn(e.Fp,n),{seed:Un(n.ORDER)});function s(h){try{const p=n.fromBytes(h);return n.isValidNot0(p)}catch{return!1}}function i(h,p){const{publicKey:m,publicKeyUncompressed:x}=o;try{const S=h.length;return p===!0&&S!==m||p===!1&&S!==x?!1:!!e.fromBytes(h)}catch{return!1}}function c(h=r(o.seed)){return to(L(h,o.seed,"seed"),n.ORDER)}function a(h,p=!0){return e.BASE.multiply(n.fromBytes(h)).toBytes(p)}function f(h){const{secretKey:p,publicKey:m,publicKeyUncompressed:x}=o;if(!me(h)||"_lengths"in n&&n._lengths||p===m)return;const S=L(h,void 0,"key").length;return S===m||S===x}function d(h,p,m=!0){if(f(h)===!0)throw new Error("first arg must be private key");if(f(p)===!1)throw new Error("second arg must be public key");const x=n.fromBytes(h);return e.fromBytes(p).multiply(x).toBytes(m)}const u={isValidSecretKey:s,isValidPublicKey:i,randomSecretKey:c},b=oo(c,a);return Object.freeze({getPublicKey:a,getSharedSecret:d,keygen:b,Point:e,utils:u,lengths:o})}function uo(e,t,n={}){Ee(t),_e(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),n=Object.assign({},n);const r=n.randomBytes||wn,o=n.hmac||((w,l)=>Lt(t,w,l)),{Fp:s,Fn:i}=e,{ORDER:c,BITS:a}=i,{keygen:f,getPublicKey:d,getSharedSecret:u,utils:b,lengths:h}=fo(e,n),p={prehash:!0,lowS:typeof n.lowS=="boolean"?n.lowS:!0,format:"compact",extraEntropy:!1},m=c*$n<s.ORDER;function x(w){const l=c>>mt;return w>l}function S(w,l){if(!i.isValidNot0(l))throw new Error(`invalid signature ${w}: out of range 1..Point.Fn.ORDER`);return l}function N(){if(m)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function K(w,l){we(l);const g=h.signature,v=l==="compact"?g:l==="recovered"?g+1:void 0;return L(w,v)}class U{r;s;recovery;constructor(l,g,v){if(this.r=S("r",l),this.s=S("s",g),v!=null){if(N(),![0,1,2,3].includes(v))throw new Error("invalid recovery id");this.recovery=v}Object.freeze(this)}static fromBytes(l,g=p.format){K(l,g);let v;if(g==="der"){const{r:_,s:R}=dt.toSig(L(l));return new U(_,R)}g==="recovered"&&(v=l[0],g="compact",l=l.subarray(1));const B=h.signature/2,A=l.subarray(0,B),E=l.subarray(B,B*2);return new U(i.fromBytes(A),i.fromBytes(E),v)}static fromHex(l,g){return this.fromBytes(zt(l),g)}assertRecovery(){const{recovery:l}=this;if(l==null)throw new Error("invalid recovery id: must be present");return l}addRecoveryBit(l){return new U(this.r,this.s,l)}recoverPublicKey(l){const{r:g,s:v}=this,B=this.assertRecovery(),A=B===2||B===3?g+c:g;if(!s.isValid(A))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const E=s.toBytes(A),_=e.fromBytes(W(Dn((B&1)===0),E)),R=i.inv(A),D=Z(L(l,void 0,"msgHash")),T=i.create(-D*R),k=i.create(v*R),C=e.BASE.multiplyUnsafe(T).add(_.multiplyUnsafe(k));if(C.is0())throw new Error("invalid recovery: point at infinify");return C.assertValidity(),C}hasHighS(){return x(this.s)}toBytes(l=p.format){if(we(l),l==="der")return zt(dt.hexFromSig(this));const{r:g,s:v}=this,B=i.toBytes(g),A=i.toBytes(v);return l==="recovered"?(N(),W(Uint8Array.of(this.assertRecovery()),B,A)):W(B,A)}toHex(l){return nt(this.toBytes(l))}}const H=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const g=ne(l),v=l.length*8-a;return v>0?g>>BigInt(v):g},Z=n.bits2int_modN||function(l){return i.create(H(l))},ht=Be(a);function j(w){return Mr("num < 2^"+a,w,it,ht),i.toBytes(w)}function I(w,l){return L(w,void 0,"message"),l?L(t(w),void 0,"prehashed message"):w}function rt(w,l,g){const{lowS:v,prehash:B,extraEntropy:A}=ce(g,p);w=I(w,B);const E=Z(w),_=i.fromBytes(l);if(!i.isValidNot0(_))throw new Error("invalid private key");const R=[j(_),j(E)];if(A!=null&&A!==!1){const C=A===!0?r(h.secretKey):A;R.push(L(C,void 0,"extraEntropy"))}const D=W(...R),T=E;function k(C){const q=H(C);if(!i.isValidNot0(q))return;const tt=i.inv(q),$=e.BASE.multiply(q).toAffine(),V=i.create($.x);if(V===it)return;const $t=i.create(tt*i.create(T+V*_));if($t===it)return;let Te=($.x===V?0:2)|Number($.y&mt),Ne=$t;return v&&x($t)&&(Ne=i.neg($t),Te^=1),new U(V,Ne,m?void 0:Te)}return{seed:D,k2sig:k}}function Q(w,l,g={}){const{seed:v,k2sig:B}=rt(w,l,g);return Vr(t.outputLen,i.BYTES,o)(v,B).toBytes(g.format)}function O(w,l,g,v={}){const{lowS:B,prehash:A,format:E}=ce(v,p);if(g=L(g,void 0,"publicKey"),l=I(l,A),!me(w)){const _=w instanceof U?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+_)}K(w,E);try{const _=U.fromBytes(w,E),R=e.fromBytes(g);if(B&&_.hasHighS())return!1;const{r:D,s:T}=_,k=Z(l),C=i.inv(T),q=i.create(k*C),tt=i.create(D*C),$=e.BASE.multiplyUnsafe(q).add(R.multiplyUnsafe(tt));return $.is0()?!1:i.create($.x)===D}catch{return!1}}function y(w,l,g={}){const{prehash:v}=ce(g,p);return l=I(l,v),U.fromBytes(w,"recovered").recoverPublicKey(l).toBytes()}return Object.freeze({keygen:f,getPublicKey:d,getSharedSecret:u,utils:b,lengths:h,Point:e,sign:Q,verify:O,recoverPublicKey:y,Signature:U,hash:t})}const Ke={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},lo={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},We=BigInt(2);function ho(e){const t=Ke.p,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),c=BigInt(44),a=BigInt(88),f=e*e*e%t,d=f*f*e%t,u=z(d,n,t)*d%t,b=z(u,n,t)*d%t,h=z(b,We,t)*f%t,p=z(h,o,t)*h%t,m=z(p,s,t)*p%t,x=z(m,c,t)*m%t,S=z(x,a,t)*x%t,N=z(S,c,t)*m%t,K=z(N,n,t)*d%t,U=z(K,i,t)*p%t,H=z(U,r,t)*f%t,Z=z(H,We,t);if(!ye.eql(ye.sqr(Z),e))throw new Error("Cannot find square root");return Z}const ye=re(Ke.p,{sqrt:ho}),bo=ao(Ke,{Fp:ye,endo:lo}),lt=uo(bo,G),wo=Uint32Array.from([1732584193,4023233417,2562383102,271733878,3285377520]),yo=Math.pow(2,32),po=Array.from({length:64},(e,t)=>Math.floor(yo*Math.abs(Math.sin(t+1)))),Ft=wo.slice(0,4),ae=new Uint32Array(16);class Mn extends ee{A=Ft[0]|0;B=Ft[1]|0;C=Ft[2]|0;D=Ft[3]|0;constructor(){super(64,16,8,!0)}get(){const{A:t,B:n,C:r,D:o}=this;return[t,n,r,o]}set(t,n,r,o){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0}process(t,n){for(let c=0;c<16;c++,n+=4)ae[c]=t.getUint32(n,!0);let{A:r,B:o,C:s,D:i}=this;for(let c=0;c<64;c++){let a,f,d;c<16?(a=he(o,s,i),f=c,d=[7,12,17,22]):c<32?(a=he(i,o,s),f=(5*c+1)%16,d=[5,9,14,20]):c<48?(a=o^s^i,f=(3*c+5)%16,d=[4,11,16,23]):(a=s^(o|~i),f=7*c%16,d=[6,10,15,21]),a=a+r+po[c]+ae[f],r=i,i=s,s=o,o=o+It(a,d[c%4])}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,this.set(r,o,s,i)}roundClean(){P(ae)}destroy(){this.set(0,0,0,0),P(this.buffer)}}const go=Nt(()=>new Mn),xo=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Zn=Uint8Array.from(new Array(16).fill(0).map((e,t)=>t)),mo=Zn.map(e=>(9*e+5)%16),Vn=(()=>{const n=[[Zn],[mo]];for(let r=0;r<4;r++)for(let o of n)o.push(o[r].map(s=>xo[s]));return n})(),Fn=Vn[0],jn=Vn[1],Gn=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(e=>Uint8Array.from(e)),Eo=Fn.map((e,t)=>e.map(n=>Gn[t][n])),vo=jn.map((e,t)=>e.map(n=>Gn[t][n])),Ao=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),Bo=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function Je(e,t,n,r){return e===0?t^n^r:e===1?t&n|~t&r:e===2?(t|~n)^r:e===3?t&r|n&~r:t^(n|~r)}const jt=new Uint32Array(16);class Yn extends ee{h0=1732584193;h1=-271733879;h2=-1732584194;h3=271733878;h4=-1009589776;constructor(){super(64,20,8,!0)}get(){const{h0:t,h1:n,h2:r,h3:o,h4:s}=this;return[t,n,r,o,s]}set(t,n,r,o,s){this.h0=t|0,this.h1=n|0,this.h2=r|0,this.h3=o|0,this.h4=s|0}process(t,n){for(let h=0;h<16;h++,n+=4)jt[h]=t.getUint32(n,!0);let r=this.h0|0,o=r,s=this.h1|0,i=s,c=this.h2|0,a=c,f=this.h3|0,d=f,u=this.h4|0,b=u;for(let h=0;h<5;h++){const p=4-h,m=Ao[h],x=Bo[h],S=Fn[h],N=jn[h],K=Eo[h],U=vo[h];for(let H=0;H<16;H++){const Z=It(r+Je(h,s,c,f)+jt[S[H]]+m,K[H])+u|0;r=u,u=f,f=It(c,10)|0,c=s,s=Z}for(let H=0;H<16;H++){const Z=It(o+Je(p,i,a,d)+jt[N[H]]+x,U[H])+b|0;o=b,b=d,d=It(a,10)|0,a=i,i=Z}}this.set(this.h1+c+d|0,this.h2+f+b|0,this.h3+u+o|0,this.h4+r+i|0,this.h0+s+a|0)}roundClean(){P(jt)}destroy(){this.destroyed=!0,P(this.buffer),this.set(0,0,0,0,0)}}const Bt=Nt(()=>new Yn),ws=Object.freeze(Object.defineProperty({__proto__:null,_MD5:Mn,_RIPEMD160:Yn,md5:go,ripemd160:Bt},Symbol.toStringTag,{value:"Module"}));function Ht(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Pn(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(n=>typeof n=="string"):t.every(n=>Number.isSafeInteger(n)):!1}function zn(e){if(typeof e!="function")throw new Error("function expected");return!0}function Ut(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function Ct(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function Qt(e){if(!Array.isArray(e))throw new Error("array expected")}function Xn(e,t){if(!Pn(!0,t))throw new Error(`${e}: array of strings expected`)}function Ie(e,t){if(!Pn(!1,t))throw new Error(`${e}: array of numbers expected`)}function Re(...e){const t=s=>s,n=(s,i)=>c=>s(i(c)),r=e.map(s=>s.encode).reduceRight(n,t),o=e.map(s=>s.decode).reduce(n,t);return{encode:r,decode:o}}function Wn(e){const t=typeof e=="string"?e.split(""):e,n=t.length;Xn("alphabet",t);const r=new Map(t.map((o,s)=>[o,s]));return{encode:o=>(Qt(o),o.map(s=>{if(!Number.isSafeInteger(s)||s<0||s>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${e}`);return t[s]})),decode:o=>(Qt(o),o.map(s=>{Ut("alphabet.decode",s);const i=r.get(s);if(i===void 0)throw new Error(`Unknown letter: "${s}". Allowed: ${e}`);return i}))}}function Jn(e=""){return Ut("join",e),{encode:t=>(Xn("join.decode",t),t.join(e)),decode:t=>(Ut("join.decode",t),t.split(e))}}function Qe(e,t,n){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(Qt(e),!e.length)return[];let r=0;const o=[],s=Array.from(e,c=>{if(Ct(c),c<0||c>=t)throw new Error(`invalid integer: ${c}`);return c}),i=s.length;for(;;){let c=0,a=!0;for(let f=r;f<i;f++){const d=s[f],u=t*c,b=u+d;if(!Number.isSafeInteger(b)||u/t!==c||b-d!==u)throw new Error("convertRadix: carry overflow");const h=b/n;c=b%n;const p=Math.floor(h);if(s[f]=p,!Number.isSafeInteger(p)||p*n+c!==b)throw new Error("convertRadix: carry overflow");if(a)p?a=!1:r=f;else continue}if(o.push(c),a)break}for(let c=0;c<e.length-1&&e[c]===0;c++)o.push(0);return o.reverse()}const Qn=(e,t)=>t===0?e:Qn(t,e%t),te=(e,t)=>e+(t-Qn(e,t)),Pt=(()=>{let e=[];for(let t=0;t<40;t++)e.push(2**t);return e})();function pe(e,t,n,r){if(Qt(e),t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(te(t,n)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${te(t,n)}`);let o=0,s=0;const i=Pt[t],c=Pt[n]-1,a=[];for(const f of e){if(Ct(f),f>=i)throw new Error(`convertRadix2: invalid data word=${f} from=${t}`);if(o=o<<t|f,s+t>32)throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);for(s+=t;s>=n;s-=n)a.push((o>>s-n&c)>>>0);const d=Pt[s];if(d===void 0)throw new Error("invalid carry");o&=d-1}if(o=o<<n-s&c,!r&&s>=t)throw new Error("Excess padding");if(!r&&o>0)throw new Error(`Non-zero padding: ${o}`);return r&&s>0&&a.push(o>>>0),a}function _o(e){Ct(e);const t=2**8;return{encode:n=>{if(!Ht(n))throw new Error("radix.encode input should be Uint8Array");return Qe(Array.from(n),t,e)},decode:n=>(Ie("radix.decode",n),Uint8Array.from(Qe(n,e,t)))}}function So(e,t=!1){if(Ct(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(te(8,e)>32||te(e,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!Ht(n))throw new Error("radix2.encode input should be Uint8Array");return pe(Array.from(n),8,e,!t)},decode:n=>(Ie("radix2.decode",n),Uint8Array.from(pe(n,e,8,t)))}}function tn(e){return zn(e),function(...t){try{return e.apply(null,t)}catch{}}}function Ko(e,t){return Ct(e),zn(t),{encode(n){if(!Ht(n))throw new Error("checksum.encode: input should be Uint8Array");const r=t(n).slice(0,e),o=new Uint8Array(n.length+e);return o.set(n),o.set(r,n.length),o},decode(n){if(!Ht(n))throw new Error("checksum.decode: input should be Uint8Array");const r=n.slice(0,-e),o=n.slice(-e),s=t(r).slice(0,e);for(let i=0;i<e;i++)if(s[i]!==o[i])throw new Error("Invalid checksum");return r}}}const Io=e=>Re(_o(58),Wn(e),Jn("")),Ro=Io("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),tr=e=>Re(Ko(4,t=>e(e(t))),Ro),ys=tr,ge=Re(Wn("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),Jn("")),en=[996825010,642813549,513874426,1027748829,705979059];function _t(e){const t=e>>25;let n=(e&33554431)<<5;for(let r=0;r<en.length;r++)(t>>r&1)===1&&(n^=en[r]);return n}function nn(e,t,n=1){const r=e.length;let o=1;for(let s=0;s<r;s++){const i=e.charCodeAt(s);if(i<33||i>126)throw new Error(`Invalid prefix (${e})`);o=_t(o)^i>>5}o=_t(o);for(let s=0;s<r;s++)o=_t(o)^e.charCodeAt(s)&31;for(let s of t)o=_t(o)^s;for(let s=0;s<6;s++)o=_t(o);return o^=n,ge.encode(pe([o%Pt[30]],30,5,!1))}function er(e){const t=e==="bech32"?1:734539939,n=So(5),r=n.decode,o=n.encode,s=tn(r);function i(u,b,h=90){Ut("bech32.encode prefix",u),Ht(b)&&(b=Array.from(b)),Ie("bech32.encode",b);const p=u.length;if(p===0)throw new TypeError(`Invalid prefix length ${p}`);const m=p+7+b.length;if(h!==!1&&m>h)throw new TypeError(`Length ${m} exceeds limit ${h}`);const x=u.toLowerCase(),S=nn(x,b,t);return`${x}1${ge.encode(b)}${S}`}function c(u,b=90){Ut("bech32.decode input",u);const h=u.length;if(h<8||b!==!1&&h>b)throw new TypeError(`invalid string length: ${h} (${u}). Expected (8..${b})`);const p=u.toLowerCase();if(u!==p&&u!==u.toUpperCase())throw new Error("String must be lowercase or uppercase");const m=p.lastIndexOf("1");if(m===0||m===-1)throw new Error('Letter "1" must be present between prefix and data only');const x=p.slice(0,m),S=p.slice(m+1);if(S.length<6)throw new Error("Data must be at least 6 characters long");const N=ge.decode(S).slice(0,-6),K=nn(x,N,t);if(!S.endsWith(K))throw new Error(`Invalid checksum in ${u}: expected "${K}"`);return{prefix:x,words:N}}const a=tn(c);function f(u){const{prefix:b,words:h}=c(u,!1);return{prefix:b,words:h,bytes:r(h)}}function d(u,b){return i(u,o(b))}return{encode:i,decode:c,encodeFromBytes:d,decodeToBytes:f,decodeUnsafe:a,fromWords:r,fromWordsUnsafe:s,toWords:o}}const ps=er("bech32"),gs=er("bech32m");const Rt=lt.Point,{Fn:St}=Rt,fe=tr(G),Oo=Uint8Array.from("Bitcoin seed".split(""),e=>e.charCodeAt(0)),ue={private:76066276,public:76067358},de=2147483648,ko=e=>Bt(G(e)),Lo=e=>pt(e).getUint32(0,!1),Gt=e=>{if(!Number.isSafeInteger(e)||e<0||e>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+e);const t=new Uint8Array(4);return pt(t).setUint32(0,e,!1),t};class bt{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Lo(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const t=this._privateKey;if(!t)throw new Error("No private key");return fe.encode(this.serialize(this.versions.private,W(Uint8Array.of(0),t)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return fe.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(t,n=ue){if(L(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const r=Lt(Xt,Oo,t),o=r.slice(0,32),s=r.slice(32);return new bt({versions:n,chainCode:s,privateKey:o})}static fromExtendedKey(t,n=ue){const r=fe.decode(t),o=pt(r),s=o.getUint32(0,!1),i={versions:n,depth:r[4],parentFingerprint:o.getUint32(5,!1),index:o.getUint32(9,!1),chainCode:r.slice(13,45)},c=r.slice(45),a=c[0]===0;if(s!==n[a?"private":"public"])throw new Error("Version mismatch");return a?new bt({...i,privateKey:c.slice(1)}):new bt({...i,publicKey:c})}static fromJSON(t){return bt.fromExtendedKey(t.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(t){if(!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||ue,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!lt.utils.isValidSecretKey(t.privateKey))throw new Error("Invalid private key");this._privateKey=t.privateKey,this._publicKey=lt.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this._publicKey=Rt.fromBytes(t.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=ko(this._publicKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const n=t.replace(/^[mM]'?\//,"").split("/");let r=this;for(const o of n){const s=/^(\d+)('?)$/.exec(o),i=s&&s[1];if(!s||s.length!==3||typeof i!="string")throw new Error("invalid child index: "+o);let c=+i;if(!Number.isSafeInteger(c)||c>=de)throw new Error("Invalid index");s[2]==="'"&&(c+=de),r=r.deriveChild(c)}return r}deriveChild(t){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let n=Gt(t);if(t>=de){const a=this._privateKey;if(!a)throw new Error("Could not derive hardened child key");n=W(Uint8Array.of(0),a,n)}else n=W(this._publicKey,n);const r=Lt(Xt,this.chainCode,n),o=r.slice(0,32),s=r.slice(32);if(!lt.utils.isValidSecretKey(o))throw new Error("Tweak bigger than curve order");const i={versions:this.versions,chainCode:s,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t},c=St.fromBytes(o);try{if(this._privateKey){const a=St.create(St.fromBytes(this._privateKey)+c);if(!St.isValidNot0(a))throw new Error("The tweak was out of range or the resulted private key is invalid");i.privateKey=St.toBytes(a)}else{const a=Rt.fromBytes(this._publicKey).add(Rt.BASE.multiply(c));if(a.equals(Rt.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");i.publicKey=a.toBytes(!0)}return new bt(i)}catch{return this.deriveChild(t+1)}}sign(t){if(!this._privateKey)throw new Error("No privateKey set!");return L(t,32),lt.sign(t,this._privateKey,{prehash:!1})}verify(t,n){if(L(t,32),L(n,64),!this._publicKey)throw new Error("No publicKey set!");return lt.verify(n,t,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,n){if(!this.chainCode)throw new Error("No chainCode set");return L(n,33),W(Gt(t),new Uint8Array([this.depth]),Gt(this.parentFingerprint),Gt(this.index),this.chainCode,n)}}function Ho(e,t,n,r){Ee(e);const o=Er({dkLen:32,asyncTick:10},r),{c:s,dkLen:i,asyncTick:c}=o;if(J(s,"c"),J(i,"dkLen"),J(c,"asyncTick"),s<1)throw new Error("iterations (c) must be >= 1");const a=De(t,"password"),f=De(n,"salt"),d=new Uint8Array(i),u=Lt.create(e,a),b=u._cloneInto().update(f);return{c:s,dkLen:i,asyncTick:c,DK:d,PRF:u,PRFSalt:b}}function Uo(e,t,n,r,o){return e.destroy(),t.destroy(),r&&r.destroy(),P(o),n}function To(e,t,n,r){const{c:o,dkLen:s,DK:i,PRF:c,PRFSalt:a}=Ho(e,t,n,r);let f;const d=new Uint8Array(4),u=pt(d),b=new Uint8Array(c.outputLen);for(let h=1,p=0;p<s;h++,p+=c.outputLen){const m=i.subarray(p,p+c.outputLen);u.setInt32(0,h,!1),(f=a._cloneInto(f)).update(d).digestInto(b),m.set(b.subarray(0,m.length));for(let x=1;x<o;x++){c._cloneInto(f).update(b).digestInto(b);for(let S=0;S<m.length;S++)m[S]^=b[S]}}return Uo(c,a,i,f,b)}function nr(e){if(typeof e!="string")throw new TypeError("invalid mnemonic type: "+typeof e);return e.normalize("NFKD")}function No(e){const t=nr(e),n=t.split(" ");if(![12,15,18,21,24].includes(n.length))throw new Error("Invalid mnemonic");return{nfkd:t,words:n}}const Co=e=>nr("mnemonic"+e);function $o(e,t=""){return To(Xt,No(e).nfkd,Co(t),{c:2048,dkLen:64})}const Do=BigInt(0),Kt=BigInt(1),qo=BigInt(2),Mo=BigInt(7),Zo=BigInt(256),Vo=BigInt(113),rr=[],or=[],sr=[];for(let e=0,t=Kt,n=1,r=0;e<24;e++){[n,r]=[r,(2*n+3*r)%5],rr.push(2*(5*r+n)),or.push((e+1)*(e+2)/2%64);let o=Do;for(let s=0;s<7;s++)t=(t<<Kt^(t>>Mo)*Vo)%Zo,t&qo&&(o^=Kt<<(Kt<<BigInt(s))-Kt);sr.push(o)}const ir=pn(sr,!0),Fo=ir[0],jo=ir[1],rn=(e,t,n)=>n>32?Sr(e,t,n):Br(e,t,n),on=(e,t,n)=>n>32?Kr(e,t,n):_r(e,t,n);function Go(e,t=24){const n=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let i=0;i<10;i++)n[i]=e[i]^e[i+10]^e[i+20]^e[i+30]^e[i+40];for(let i=0;i<10;i+=2){const c=(i+8)%10,a=(i+2)%10,f=n[a],d=n[a+1],u=rn(f,d,1)^n[c],b=on(f,d,1)^n[c+1];for(let h=0;h<50;h+=10)e[i+h]^=u,e[i+h+1]^=b}let o=e[2],s=e[3];for(let i=0;i<24;i++){const c=or[i],a=rn(o,s,c),f=on(o,s,c),d=rr[i];o=e[d],s=e[d+1],e[d]=a,e[d+1]=f}for(let i=0;i<50;i+=10){for(let c=0;c<10;c++)n[c]=e[i+c];for(let c=0;c<10;c++)e[i+c]^=~n[(c+2)%10]&n[(c+4)%10]}e[0]^=Fo[r],e[1]^=jo[r]}P(n)}class Oe{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(t,n,r,o=!1,s=24){if(this.blockLen=t,this.suffix=n,this.outputLen=r,this.enableXOF=o,this.rounds=s,J(r,"outputLen"),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=wr(this.state)}clone(){return this._cloneInto()}keccak(){Ce(this.state32),Go(this.state32,this.rounds),Ce(this.state32),this.posOut=0,this.pos=0}update(t){vt(this),L(t);const{blockLen:n,state:r}=this,o=t.length;for(let s=0;s<o;){const i=Math.min(n-this.pos,o-s);for(let c=0;c<i;c++)r[this.pos++]^=t[s++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:r,blockLen:o}=this;t[r]^=n,(n&128)!==0&&r===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){vt(this,!1),L(t),this.finish();const n=this.state,{blockLen:r}=this;for(let o=0,s=t.length;o<s;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,s-o);t.set(n.subarray(this.posOut,this.posOut+i),o),this.posOut+=i,o+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return J(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(hn(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,P(this.state)}_cloneInto(t){const{blockLen:n,suffix:r,outputLen:o,rounds:s,enableXOF:i}=this;return t||=new Oe(n,r,o,i,s),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=r,t.outputLen=o,t.enableXOF=i,t.destroyed=this.destroyed,t}}const Yo=(e,t,n,r={})=>Nt(()=>new Oe(t,e,n),r),ke=Yo(1,136,32),Tt=Et.t.bind(Et),cr={ethereum:60,bitcoin:0,tron:195,bfmeta:9999};function Le(e,t){const n=$o(e,t);return bt.fromMasterSeed(n)}function Po(e,t=0,n=0,r=0){return`m/44'/${cr[e]}'/${t}'/${n}/${r}`}function zo(e,t,n=0,r=0,o=0){return`m/${e}'/${t}'/${n}'/${r}/${o}`}function He(e,t){return e.derive(t)}function sn(e){const n=lt.getPublicKey(e,!1).slice(1),o=ke(n).slice(-20);return"0x"+nt(o)}function cn(e){const t=e.toLowerCase().replace("0x",""),n=new TextEncoder,r=nt(ke(n.encode(t)));let o="0x";for(let s=0;s<t.length;s++)parseInt(r[s],16)>=8?o+=t[s].toUpperCase():o+=t[s];return o}function ar(e,t="mainnet"){const n=G(e),r=Bt(n),o=t==="mainnet"?0:111,s=new Uint8Array([o,...r]),i=G(G(s)).slice(0,4),c=new Uint8Array([...s,...i]);return Ue(c)}function Xo(e,t="mainnet"){const n=G(e),r=Bt(n),o=new Uint8Array([0,20,...r]),s=G(o),i=Bt(s),c=t==="mainnet"?5:196,a=new Uint8Array([c,...i]),f=G(G(a)).slice(0,4),d=new Uint8Array([...a,...f]);return Ue(d)}function Wo(e,t="mainnet"){const n=G(e),r=Bt(n);return rs(t==="mainnet"?"bc":"tb",0,r)}function Jo(e,t="mainnet"){const n=e.length===33?e.slice(1):e.slice(1,33);return os(t==="mainnet"?"bc":"tb",1,n)}function Qo(e){const n=lt.getPublicKey(e,!1).slice(1),o=ke(n).slice(-20),s=new Uint8Array([65,...o]),i=G(G(s)).slice(0,4),c=new Uint8Array([...s,...i]);return Ue(c)}const an="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";function Ue(e){const t=[0];for(const r of e){let o=r;for(let s=0;s<t.length;s++)o+=t[s]<<8,t[s]=o%58,o=o/58|0;for(;o>0;)t.push(o%58),o=o/58|0}let n="";for(const r of e)if(r===0)n+=an[0];else break;for(let r=t.length-1;r>=0;r--)n+=an[t[r]];return n}const fr="qpzry9x8gf2tvdw0s3jn54khce6mua7l",ts=[996825010,642813549,513874426,1027748829,705979059];function es(e){let t=1;for(const n of e){const r=t>>25;t=(t&33554431)<<5^n;for(let o=0;o<5;o++)r>>o&1&&(t^=ts[o])}return t}function ns(e){const t=[];for(const n of e)t.push(n.charCodeAt(0)>>5);t.push(0);for(const n of e)t.push(n.charCodeAt(0)&31);return t}function ur(e,t,n){const r=[...ns(e),...t],o=n?734539939:1,s=es([...r,0,0,0,0,0,0])^o,i=[];for(let c=0;c<6;c++)i.push(s>>5*(5-c)&31);return i}function dr(e,t,n,r){let o=0,s=0;const i=[],c=(1<<n)-1;for(const a of e)for(o=o<<t|a,s+=t;s>=n;)s-=n,i.push(o>>s&c);return s>0&&i.push(o<<n-s&c),i}function rs(e,t,n){const r=dr(n,8,5),o=[t,...r],s=ur(e,o,!1),i=[...o,...s].map(c=>fr[c]).join("");return`${e}1${i}`}function os(e,t,n){const r=dr(n,8,5),o=[t,...r],s=ur(e,o,!0),i=[...o,...s].map(c=>fr[c]).join("");return`${e}1${i}`}function le(e,t,n=0,r=0){const o=Le(e),s=Po(t,r,0,n),i=He(o,s);if(!i.privateKey||!i.publicKey)throw new Error(Tt("error:crypto.keyDerivationFailed"));const c=nt(i.privateKey),a=nt(i.publicKey);let f;switch(t){case"ethereum":f=cn(sn(i.privateKey));break;case"bitcoin":f=ar(i.publicKey);break;case"tron":f=Qo(i.privateKey);break;case"bfmeta":f=cn(sn(i.privateKey));break;default:throw new Error(Tt("error:chain.unsupportedType",{chain:t}))}return{privateKey:c,publicKey:a,address:f,path:s,chain:t}}function ss(e,t=44,n=0,r=0,o="mainnet"){const s=Le(e),i=zo(t,cr.bitcoin,r,0,n),c=He(s,i);if(!c.privateKey||!c.publicKey)throw new Error(Tt("error:crypto.keyDerivationFailed"));const a=nt(c.privateKey),f=nt(c.publicKey);let d;switch(t){case 44:d=ar(c.publicKey,o);break;case 49:d=Xo(c.publicKey,o);break;case 84:d=Wo(c.publicKey,o);break;case 86:d=Jo(c.publicKey,o);break;default:throw new Error(Tt("error:crypto.unsupportedBitcoinPurpose",{purpose:String(t)}))}return{privateKey:a,publicKey:f,address:d,path:i,chain:"bitcoin",purpose:t}}function is(e,t=0,n=0,r="mainnet"){return[44,49,84,86].map(s=>ss(e,s,t,n,r))}function xs(e,t=0,n=0){const r=[];return r.push(le(e,"ethereum",t,n)),r.push(le(e,"bfmeta",t,n)),r.push(le(e,"tron",t,n)),r.push(...is(e,t,n)),r}function ms(e){const t=Le(e),r=He(t,"m/44'/9999'/0'/1/0");if(!r.privateKey)throw new Error(Tt("error:crypto.keyDerivationFailed"));return r.privateKey}function Es(e){const n=new TextEncoder().encode(`KeyApp:EncryptionKey:${e}`);return G(n)}function vs(e,t){switch(t){case"ethereum":case"bfmeta":return/^0x[a-fA-F0-9]{40}$/.test(e);case"bitcoin":return/^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(e)||/^bc1q[a-z0-9]{38,}$/.test(e)||/^bc1p[a-z0-9]{58}$/.test(e);case"tron":return/^T[a-zA-Z0-9]{33}$/.test(e);default:return!1}}export{us as A,hr as B,ds as C,le as D,ls as E,vs as F,ke as G,lt as H,ys as I,ss as J,ps as K,gs as L,fs as M,xs as N,hs as O,ws as P,Wt as a,L as b,oo as c,An as d,W as e,ro as f,Dr as g,Mr as h,me as i,zt as j,nt as k,X as l,Ve as m,Ge as n,bs as o,z as p,G as q,wn as r,Xt as s,Bt as t,cn as u,_e as v,eo as w,as as x,ms as y,Es as z};
