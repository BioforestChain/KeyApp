import{g as ae,Z as re,o as N,c as k,a as z,n as w,s as c,l as it,h as ie,i as m,u as X,r as J,b as _,j as _t}from"./schemas-BX8BzOgD.js";import{g as ce,b as le,f as Y,l as ue,t as de,m as q,s as F,n as dt,o as he,p as ht,q as ft}from"./chain-config-CJhdu2xl.js";import{A as g}from"./amount-BQsqQYGO.js";import{o as x,h as U,G as B,c as fe,p as me,a as pe,X as Bt,Y as mt}from"./bioforest-uXX5qE5N.js";import"./index-D0E7N0oa.js";import{_ as st}from"./preload-helper-PPVm8Dsz.js";function ge(r){return ae(re,r)}class ye{getConfig(t){return ce.getChainById(le.state,t)}getApi(t){return this.getConfig(t)?.apis??[]}getApiByType(t,e){return this.getApi(t).find(n=>n.type===e)??null}getApiByPattern(t,e){const s=this.getApi(t),n=new RegExp("^"+e.replace("*",".*")+"$");return s.find(o=>n.test(o.type))??null}getRpcUrl(t){return this.getApiByPattern(t,"*-rpc")?.endpoint??""}getBiowalletApi(t){const e=this.getApiByPattern(t,"biowallet-*");if(!e)return null;const s=e.config?.path??t;return{endpoint:e.endpoint,path:s}}getEtherscanApi(t){return(this.getApiByPattern(t,"etherscan-*")??this.getApiByPattern(t,"*scan-*"))?.endpoint??null}getMempoolApi(t){return this.getApiByPattern(t,"mempool-*")?.endpoint??null}getDecimals(t){return this.getConfig(t)?.decimals??18}getSymbol(t){return this.getConfig(t)?.symbol??""}getExplorerUrl(t){return this.getConfig(t)?.explorer?.url??null}getTxQueryUrl(t,e){const n=this.getConfig(t)?.explorer?.queryTx;return n?n.replace(":hash",e).replace(":signature",e):null}getAddressQueryUrl(t,e){const n=this.getConfig(t)?.explorer?.queryAddress;return n?n.replace(":address",e):null}}const y=new ye;function $(r){return{supported:!0,data:r}}function E(r,t){return{supported:!1,data:r,reason:t}}function we(r){return r.supported===!0}z(["native","token","nft"]);const Ct=z(["transfer","swap","exchange","approve","revoke","signature","stake","unstake","claim","mint","burn","gift","grab","trust","signFor","emigrate","immigrate","issueAsset","increaseAsset","destroyAsset","issueEntity","destroyEntity","locationName","dapp","certificate","mark","contract","unknown"]),$t=z(["in","out","self"]),be=z(["pending","confirmed","failed"]),Te=N({assetType:it("native"),value:c(),symbol:c(),decimals:w()}),ve=N({assetType:it("token"),value:c(),symbol:c(),decimals:w(),contractAddress:c(),name:c().optional(),logoUrl:c().optional()}),Ie=N({assetType:it("nft"),tokenId:c(),contractAddress:c(),name:c().optional(),imageUrl:c().optional(),collection:c().optional()}),Pt=ie("assetType",[Te,ve,Ie]),Se=N({value:c(),symbol:c(),decimals:w()}),Ae=N({address:c(),method:c().optional(),methodId:c().optional()}),nt=N({hash:c(),from:c(),to:c(),timestamp:w(),status:be,blockNumber:ge().optional(),action:Ct,direction:$t,assets:k(Pt).min(1),fee:Se.optional(),contract:Ae.optional()});class Rt extends Error{source;chainId;method;issues;constructor(t){super(`[InvalidData] ${t.source}:${t.chainId}:${t.method}`,{cause:t.cause instanceof Error?t.cause:void 0}),this.name="InvalidDataError",this.source=t.source,this.chainId=t.chainId,this.method=t.method,this.issues=t.issues??[]}}const ke=new Set(["isValidAddress","normalizeAddress"]);class xt{chainId;providers;constructor(t,e){this.chainId=t,this.providers=e}supports(t){return this.getCandidates(t).length>0}getCandidates(t){return this.providers.filter(e=>{if(typeof e[t]!="function")return!1;const s=t.startsWith("get")?t.slice(3):t,n=`supports${s.charAt(0).toUpperCase()}${s.slice(1)}`,o=e[n];return typeof o=="boolean"?o:!0})}getMethod(t){const e=this.providers.filter(a=>typeof a[t]=="function");if(e.length===0)return;const s=e[0],n=s[t];return typeof n!="function"?void 0:ke.has(t)?n.bind(s):(async(...a)=>{let i=null;for(const l of e){const u=l[t];if(typeof u=="function")try{return await u.apply(l,a)}catch(d){i=d}}throw i instanceof Error?i:new Error("All providers failed")})}getDefaultBalance(){const t=y.getDecimals(this.chainId),e=y.getSymbol(this.chainId);return{amount:g.zero(t,e),symbol:e}}getDefaultTransactionStatus(){return{status:"pending",confirmations:0,requiredConfirmations:1}}get supportsNativeBalance(){return this.supports("getNativeBalance")}get supportsTokenBalances(){return this.supports("getTokenBalances")}get supportsTransactionHistory(){return this.supports("getTransactionHistory")}get supportsTransaction(){return this.supports("getTransaction")}get supportsBlockHeight(){return this.supports("getBlockHeight")}get supportsFeeEstimate(){return this.supports("estimateFee")}get supportsBuildTransaction(){return this.supports("buildTransaction")}get supportsSignTransaction(){return this.supports("signTransaction")}get supportsBroadcast(){return this.supports("broadcastTransaction")}get supportsFullTransaction(){return this.supportsBuildTransaction&&this.supportsSignTransaction&&this.supportsBroadcast}get supportsDeriveAddress(){return this.supports("deriveAddress")}get supportsAddressValidation(){return this.supports("isValidAddress")}async getNativeBalance(t){const e=this.providers.filter(o=>typeof o.getNativeBalance=="function");if(e.length===0)return E(this.getDefaultBalance(),"No provider implements getNativeBalance");let s=null;for(const o of e)try{const a=await o.getNativeBalance(t);return $(a)}catch(a){s=a}const n=s instanceof Error?s.message:"Unknown error";return E(this.getDefaultBalance(),`All ${e.length} provider(s) failed. Last error: ${n}`)}async getTokenBalances(t){const e=this.providers.filter(o=>typeof o.getTokenBalances=="function");if(e.length===0)return E([],"No provider implements getTokenBalances");let s=null;for(const o of e)try{const a=await o.getTokenBalances(t);return $(a)}catch(a){s=a}const n=s instanceof Error?s.message:"Unknown error";return E([],`All ${e.length} provider(s) failed. Last error: ${n}`)}async getTransactionHistory(t,e=20){const s=this.getCandidates("getTransactionHistory");if(s.length===0)return E([],"No provider implements getTransactionHistory");let n=null;for(const a of s)try{const i=await a.getTransactionHistory(t,e);if(!Array.isArray(i)){console.warn("[ChainProvider] Invalid transaction history payload (not array)",{chainId:this.chainId,method:"getTransactionHistory"});continue}const l=[];let u=0,d=null;for(const h of i){const f=nt.safeParse(h);f.success?l.push(f.data):(u+=1,d||(d=f.error.issues[0]))}return u>0&&console.warn("[ChainProvider] Dropped invalid transactions from history",{chainId:this.chainId,method:"getTransactionHistory",invalidCount:u,totalCount:i.length,firstIssue:d}),$(l)}catch(i){n=i}const o=n instanceof Error?n.message:"Unknown error";return E([],`All ${s.length} provider(s) failed. Last error: ${o}`)}async getTransaction(t){const e=this.providers.filter(o=>typeof o.getTransaction=="function");if(e.length===0)return E(null,"No provider implements getTransaction");let s=null;for(const o of e)try{const a=await o.getTransaction(t);if(a==null)return $(null);const i=nt.safeParse(a);if(!i.success)throw new Rt({source:"provider",chainId:this.chainId,method:"getTransaction",issues:i.error.issues});return $(i.data)}catch(a){s=a}const n=s instanceof Error?s.message:"Unknown error";return E(null,`All ${e.length} provider(s) failed. Last error: ${n}`)}async getTransactionStatus(t){const e=this.providers.filter(o=>typeof o.getTransactionStatus=="function");if(e.length===0)return E(this.getDefaultTransactionStatus(),"No provider implements getTransactionStatus");let s=null;for(const o of e)try{const a=await o.getTransactionStatus(t);return $(a)}catch(a){s=a}const n=s instanceof Error?s.message:"Unknown error";return E(this.getDefaultTransactionStatus(),`All ${e.length} provider(s) failed. Last error: ${n}`)}async getBlockHeight(){const t=this.providers.filter(n=>typeof n.getBlockHeight=="function");if(t.length===0)return E(0n,"No provider implements getBlockHeight");let e=null;for(const n of t)try{const o=await n.getBlockHeight();return $(o)}catch(o){e=o}const s=e instanceof Error?e.message:"Unknown error";return E(0n,`All ${t.length} provider(s) failed. Last error: ${s}`)}get estimateFee(){return this.getMethod("estimateFee")}get buildTransaction(){return this.getMethod("buildTransaction")}get signTransaction(){return this.getMethod("signTransaction")}get broadcastTransaction(){return this.getMethod("broadcastTransaction")}get deriveAddress(){return this.getMethod("deriveAddress")}get deriveAddresses(){return this.getMethod("deriveAddresses")}get isValidAddress(){return this.getMethod("isValidAddress")}get normalizeAddress(){return this.getMethod("normalizeAddress")}getProviders(){return this.providers}getProviderByType(t){return this.providers.find(e=>e.type===t)}}const Z=new Map;function ct(r,t){if(!r||r.trim()==="")return;if(Z.has(t))return Z.get(t);const e=r.split(",").map(n=>n.trim()).filter(n=>n.length>0);if(e.length===0)return;const s=e[Math.floor(Math.random()*e.length)];return Z.set(t,s),s}const Q=new Map,ot=new Map,G=new Map,pt=new Map;function Ee(r,t){const e=(t?.method??"GET").toUpperCase(),s=typeof t?.body=="string"?t.body:"";return`${e}:${r}:${s}`}function Ne(r,t){for(const e of t){const s=G.get(e)??new Set;s.add(r),G.set(e,s)}}function _e(r){for(const t of r){const e=G.get(t);if(e){for(const s of e)ot.delete(s);G.delete(t)}}}function P(r){const t=pt.get(r.key);pt.set(r.key,r.value),t!==void 0&&t!==r.value&&_e(r.invalidateTags)}async function A(r,t,e){const s=e?.ttlMs??0,n=e?.cacheKey??Ee(r,t);if(s>0){const i=ot.get(n);if(i&&i.expiresAt>Date.now())return i.value}const o=Q.get(n);if(o)return await o;const a=(async()=>{const i=await fetch(r,t);if(!i.ok)throw new Error(`HTTP ${i.status}`);return await i.json()})();Q.set(n,a);try{const i=await a;return s>0&&(ot.set(n,{value:i,expiresAt:Date.now()+s}),e?.tags?.length&&Ne(n,e.tags)),i}finally{Q.delete(n)}}var gt={TRONGRID_API_KEY:"",ETHERSCAN_API_KEY:""},Be={};function Ce(r){try{const t=Be?.[r];if(typeof t=="string"&&t.length>0)return t}catch{}if(typeof gt<"u"){const t=gt[r];if(typeof t=="string"&&t.length>0)return t}}const $e={ethereum:1,binance:56,"ethereum-sepolia":11155111,"bsc-testnet":97},Pe=m({hash:c(),from:c(),to:c(),value:c(),timeStamp:c(),isError:c(),blockNumber:c(),input:c().optional(),methodId:c().optional(),functionName:c().optional()}),Re=m({hash:c(),from:c(),to:c(),value:c(),timeStamp:c(),blockNumber:c(),tokenSymbol:c(),tokenName:c(),tokenDecimal:c(),contractAddress:c()}),yt=m({status:c(),message:c(),result:X()}),xe=5;class Ot{type;endpoint;config;chainId;evmChainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.evmChainId=$e[e]??1,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}get supportsTransactionHistory(){return!0}get supportsNativeBalance(){return!0}getApiKey(){let t;const e=this.config?.apiKey;if(typeof e=="string"&&e.length>0)t=e;else{const s=this.config?.apiKeyEnv;typeof s=="string"&&s.length>0&&(t=Ce(s))}return ct(t,`etherscan:${this.chainId}`)}async getNativeBalance(t){const e=new URLSearchParams({module:"account",action:"balance",address:t});this.endpoint.includes("etherscan.io/v2")&&e.set("chainid",this.evmChainId.toString());const s=this.getApiKey();s&&e.set("apikey",s);const n=`${this.endpoint}?${e.toString()}`,o=await A(n,void 0,{cacheKey:`balance:${this.chainId}:${t}`,ttlMs:3e4,tags:[`balance:${this.chainId}:${t}`]}),a=yt.safeParse(o);if(!a.success)throw new Error("Invalid API response for balance");if(a.data.status!=="1")throw new Error(`API error: ${a.data.message}`);const i=a.data.result;if(typeof i!="string")throw new Error("Invalid balance result");return{amount:Amount.fromRaw(i,this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){const s=e*xe,[n,o]=await Promise.all([this.fetchNativeTransactions(t,s),this.fetchTokenTransactions(t,s)]),a=t.toLowerCase();return this.aggregateByHash(n,o,a).sort((l,u)=>u.timestamp-l.timestamp).slice(0,e)}aggregateByHash(t,e,s){const n=new Map;for(const i of e){const l=i.hash.toLowerCase(),u=n.get(l)??[];u.push(i),n.set(l,u)}const o=[],a=new Set;for(const i of t){const l=i.hash.toLowerCase();if(a.has(l))continue;a.add(l);const u=n.get(l)??[],d=this.buildAggregatedTransaction(i,u,s);o.push(d)}for(const[i,l]of n){if(a.has(i))continue;a.add(i);const u=this.buildOrphanTokenTransaction(l,s);o.push(u)}return o}buildOrphanTokenTransaction(t,e){const s=this.selectPrimaryToken(t,e),n=this.getDirection(s.from,s.to,e),o=t.slice(0,3).map(a=>({assetType:"token",value:a.value,symbol:a.tokenSymbol,decimals:parseInt(a.tokenDecimal,10),contractAddress:a.contractAddress,name:a.tokenName}));return{hash:s.hash,from:s.from,to:s.to,timestamp:parseInt(s.timeStamp,10)*1e3,status:"confirmed",blockNumber:BigInt(s.blockNumber),action:"transfer",direction:n,assets:o}}buildAggregatedTransaction(t,e,s){const n=e.length>0,o=this.isContractCall(t),a=o?this.getMethodId(t):null;let i=this.detectAction(t);i==="contract"&&n&&(i="transfer");const l=this.selectPrimaryToken(e,s);let u,d;l?(u=l.from,d=l.to):(u=t.from,d=t.to);const h=this.getDirection(u,d,s),f=[];for(const p of e.slice(0,3))f.push({assetType:"token",value:p.value,symbol:p.tokenSymbol,decimals:parseInt(p.tokenDecimal,10),contractAddress:p.contractAddress,name:p.tokenName});return(t.value!=="0"||f.length===0)&&f.push({assetType:"native",value:t.value,symbol:this.symbol,decimals:this.decimals}),i==="swap"&&f.length>1&&f.sort((p,b)=>p.assetType==="token"&&b.assetType!=="token"?-1:p.assetType!=="token"&&b.assetType==="token"?1:0),{hash:t.hash,from:u,to:d,timestamp:parseInt(t.timeStamp,10)*1e3,status:t.isError==="0"?"confirmed":"failed",blockNumber:BigInt(t.blockNumber),action:i,direction:h,assets:f,contract:o?{address:t.to,method:t.functionName??void 0,methodId:a??void 0}:void 0}}selectPrimaryToken(t,e){if(t.length===0)return null;if(t.length===1)return t[0];const s=t.filter(o=>o.from.toLowerCase()===e||o.to.toLowerCase()===e);return(s.length>0?s:t).reduce((o,a)=>{const i=BigInt(o.value);return BigInt(a.value)>i?a:o})}async fetchNativeTransactions(t,e){const s=this.buildParams("txlist",t,e);return(await this.fetchApi(s,`etherscan:${this.type}:txlist:${t}:${e}`)).map(o=>Pe.safeParse(o)).filter(o=>o.success).map(o=>o.data)}async fetchTokenTransactions(t,e){const s=this.buildParams("tokentx",t,e);return(await this.fetchApi(s,`etherscan:${this.type}:tokentx:${t}:${e}`)).map(o=>Re.safeParse(o)).filter(o=>o.success).map(o=>o.data)}buildParams(t,e,s){const n=new URLSearchParams({module:"account",action:t,address:e,startblock:"0",endblock:"99999999",page:"1",offset:s.toString(),sort:"desc"});this.endpoint.includes("etherscan.io/v2")&&n.set("chainid",this.evmChainId.toString());const o=this.getApiKey();return o&&n.set("apikey",o),n}async fetchApi(t,e){const s=`${this.endpoint}?${t.toString()}`,n=t.get("address")??"",o=await A(s,void 0,{cacheKey:e,ttlMs:5*6e4,tags:n?[`txhistory:${this.chainId}:${n}`]:void 0}),a=yt.safeParse(o);if(!a.success)throw new Error("Invalid API response");const i=a.data.status,l=a.data.message.toLowerCase();if(i==="0"&&l.includes("no transactions"))return[];if(i!=="1")throw new Error("Upstream API error");const u=a.data.result;if(!Array.isArray(u))throw new Error("Invalid API result");return u}getDirection(t,e,s){const n=t.toLowerCase(),o=e.toLowerCase();return n===s&&o===s?"self":n===s?"out":"in"}detectAction(t){if(this.isContractCall(t)){const e=this.getMethodId(t);return e?{"0xa9059cbb":"transfer","0x095ea7b3":"approve","0x23b872dd":"transfer","0x38ed1739":"swap","0x7ff36ab5":"swap","0x18cbafe5":"swap","0xa694fc3a":"stake","0x2e1a7d4d":"unstake","0x3ccfd60b":"claim","0x4e71d92d":"claim","0x40c10f19":"mint","0x42966c68":"burn"}[e]??"contract":"contract"}return"transfer"}isContractCall(t){const e=t.input??"";return e!=="0x"&&e!=="0x0"&&e!=="0x00"&&e.length>2}getMethodId(t){const e=(t.methodId??"").toLowerCase();if(e&&e!=="0x"&&e!=="0x0"&&e!=="0x00"){if(e.startsWith("0x")&&e.length===10)return e;if(!e.startsWith("0x")&&e.length===8)return`0x${e}`}const s=(t.input??"").toLowerCase();return s.startsWith("0x")&&s.length>=10?s.slice(0,10):!s.startsWith("0x")&&s.length>=8?`0x${s.slice(0,8)}`:null}}function Ut(r,t){return r.type.includes("etherscan")||r.type.includes("blockscout")||r.type.includes("scan")?new Ot(r,t):null}const Oe=m({result:X().optional(),error:m({message:c()}).optional()});class Dt{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}async rpc(t,e,s=[]){const n=JSON.stringify({jsonrpc:"2.0",id:1,method:t,params:s}),o=t==="eth_getBalance"||t==="eth_blockNumber",a=await A(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json"},body:n},{cacheKey:`evm-rpc:${this.endpoint}:${t}:${JSON.stringify(s)}`,ttlMs:o?1e4:0}),i=Oe.safeParse(a);if(!i.success)throw new Error("Invalid JSON-RPC response");if(i.data.error)throw new Error(i.data.error.message);const l=e.safeParse(i.data.result);if(!l.success)throw new Error("Invalid JSON-RPC result");return l.data}async getNativeBalance(t){const e=await this.rpc("eth_getBalance",c(),[t,"latest"]),s=BigInt(e);return{amount:g.fromRaw(s.toString(),this.decimals,this.symbol),symbol:this.symbol}}async getBlockHeight(){const t=await this.rpc("eth_blockNumber",c());return BigInt(t)}}function Lt(r,t){return r.type.endsWith("-rpc")&&(r.type.includes("ethereum")||r.type.includes("bsc"))?new Dt(r,t):null}const Ue=m({assetNumber:c(),assetType:c()}),wt=m({success:_(),result:m({address:c(),assets:J(c(),J(c(),Ue))}).optional()}),De=m({height:w(),signature:c(),transaction:m({type:c(),senderId:c(),recipientId:c().optional().default(""),timestamp:w(),asset:m({transferAsset:m({assetType:c(),amount:c()}).optional(),giftAsset:m({totalAmount:c(),assetType:c()}).optional(),grabAsset:m({transactionSignature:c()}).optional(),trustAsset:m({trustees:k(c()),numberOfSignFor:w(),assetType:c(),amount:c()}).optional(),signature:m({publicKey:c().optional()}).optional(),destroyAsset:m({assetType:c(),amount:c()}).optional(),issueEntity:m({entityId:c().optional()}).optional(),issueEntityFactory:m({factoryId:c().optional()}).optional()}).optional()})}),Le=m({success:_(),result:m({trs:k(De),count:w()}).optional()}),bt=m({success:_(),result:m({height:w()}).optional()});class Mt{type;endpoint;config;chainId;path;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.path=t.config?.path??e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}get baseUrl(){return`${this.endpoint}/wallet/${this.path}`}async getNativeBalance(t){const e=`${this.baseUrl}/address/asset`,s=await A(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:t})},{cacheKey:`biowallet:${this.path}:assets:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),n=wt.safeParse(s);if(!n.success||!n.data.success||!n.data.result)throw new Error("Upstream API error");for(const o of Object.values(n.data.result.assets))for(const a of Object.values(o))if(a.assetType===this.symbol)return P({key:`balance:${this.chainId}:${t}`,value:a.assetNumber,invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(a.assetNumber,this.decimals,this.symbol),symbol:this.symbol};return P({key:`balance:${this.chainId}:${t}`,value:"0",invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.zero(this.decimals,this.symbol),symbol:this.symbol}}async getTokenBalances(t){const e=`${this.baseUrl}/address/asset`,s=await A(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:t})},{cacheKey:`biowallet:${this.path}:assets:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),n=wt.safeParse(s);if(!n.success||!n.data.success||!n.data.result)throw new Error("Upstream API error");const o=[];for(const a of Object.values(n.data.result.assets))for(const i of Object.values(a)){const l=i.assetType===this.symbol;o.push({symbol:i.assetType,name:i.assetType,amount:g.fromRaw(i.assetNumber,this.decimals,i.assetType),isNative:l})}return o.sort((a,i)=>a.isNative&&!i.isNative?-1:!a.isNative&&i.isNative?1:i.amount.toNumber()-a.amount.toNumber()),o}async getTransactionHistory(t,e=20){const s=await A(`${this.baseUrl}/lastblock`,void 0,{cacheKey:`biowallet:${this.path}:lastblock`,ttlMs:1e4}),n=bt.safeParse(s);if(!n.success||!n.data.success||!n.data.result)throw new Error("Upstream API error");const o=n.data.result.height,a=await A(`${this.baseUrl}/transactions/query`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({maxHeight:o,address:t,limit:e})},{cacheKey:`biowallet:${this.path}:txs:${t}:${e}:${o}`,ttlMs:5*6e4,tags:[`txhistory:${this.chainId}:${t}`]}),i=Le.safeParse(a);if(!i.success||!i.data.success||!i.data.result?.trs)throw new Error("Upstream API error");const l=t.toLowerCase();return i.data.result.trs.map(u=>{const d=u.transaction,h=this.detectAction(d.type),f=this.getDirection(d.senderId,d.recipientId,l),{value:p,assetType:b}=this.extractAssetInfo(d);return p===null?null:{hash:u.signature,from:d.senderId,to:d.recipientId,timestamp:d.timestamp*1e3,status:"confirmed",blockNumber:BigInt(u.height),action:h,direction:f,assets:[{assetType:"native",value:p,symbol:b,decimals:this.decimals}]}}).filter(u=>u!==null)}detectAction(t){const e={"AST-01":"transfer","AST-02":"transfer","AST-03":"destroyAsset","BSE-01":"signature","ETY-01":"issueEntity","ETY-02":"issueEntity","GFT-01":"gift","GFT-02":"gift","GRB-01":"grab","GRB-02":"grab","TRS-01":"trust","TRS-02":"trust","SGN-01":"signFor","SGN-02":"signFor","EMI-01":"emigrate","EMI-02":"emigrate","IMI-01":"immigrate","IMI-02":"immigrate","ISA-01":"issueAsset","ICA-01":"increaseAsset","DSA-01":"destroyAsset","ISE-01":"issueEntity","DSE-01":"destroyEntity","LNS-01":"locationName","DAP-01":"dapp","CRT-01":"certificate","MRK-01":"mark"},s=t.split("-");if(s.length>=4){const n=`${s[s.length-2]}-${s[s.length-1]}`;return e[n]??"unknown"}return"unknown"}getDirection(t,e,s){const n=t.toLowerCase(),o=e.toLowerCase();return o&&n===s&&o===s?"self":n===s?"out":"in"}extractAssetInfo(t){const e=t.asset;return e?.transferAsset?{value:e.transferAsset.amount,assetType:e.transferAsset.assetType}:e?.giftAsset?{value:e.giftAsset.totalAmount,assetType:e.giftAsset.assetType}:e?.trustAsset?{value:e.trustAsset.amount,assetType:e.trustAsset.assetType}:e?.grabAsset?{value:"0",assetType:this.symbol}:e?.destroyAsset?{value:e.destroyAsset.amount,assetType:e.destroyAsset.assetType}:e?.issueEntity||e?.issueEntityFactory?{value:"0",assetType:this.symbol}:e?.signature?{value:"0",assetType:this.symbol}:e?.destroyAsset?{value:e.destroyAsset.amount,assetType:e.destroyAsset.assetType}:e?.issueEntity||e?.issueEntityFactory?{value:"0",assetType:this.symbol}:e?.signature?{value:"0",assetType:this.symbol}:{value:null,assetType:this.symbol}}async getBlockHeight(){const t=await A(`${this.baseUrl}/lastblock`,void 0,{cacheKey:`biowallet:${this.path}:lastblock`,ttlMs:1e4}),e=bt.safeParse(t);if(!e.success||!e.data.success||!e.data.result)throw new Error("Upstream API error");return BigInt(e.data.result.height)}}function Ht(r,t){return r.type.startsWith("biowallet-")?new Mt(r,t):null}const Me=m({success:_(),result:c()}),He=m({hash:c(),from:c(),to:c(),value:c(),timeStamp:c(),blockNumber:c(),isError:c().optional()}),Fe=m({success:_(),result:m({status:c(),result:k(He)})});class Ft{type;endpoint;decimals;symbol;chainId;constructor(t,e,s,n){this.type=t.type,this.endpoint=t.endpoint.replace(/\/$/,""),this.chainId=e,this.decimals=s,this.symbol=n}get supportsNativeBalance(){return!0}get supportsTransactionHistory(){return!0}async getNativeBalance(t){const e=`${this.endpoint}/balance?address=${t}`,s=await A(e,void 0,{cacheKey:`bscwallet:balance:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),n=Me.safeParse(s);if(!n.success||!n.data.success)throw new Error("Upstream API error");return P({key:`balance:${this.chainId}:${t}`,value:n.data.result,invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(n.data.result,this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){const s=`${this.endpoint}/trans/normal/history`,n=await A(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:t,page:1,offset:e})},{cacheKey:`bscwallet:txs:${t}:${e}`,ttlMs:5*6e4,tags:[`txhistory:${this.chainId}:${t}`]}),o=Fe.safeParse(n);if(!o.success||!o.data.success)throw new Error("Upstream API error");if(o.data.result.status!=="1")return[];const a=t.toLowerCase();return o.data.result.result.map(i=>{const l=i.from,u=i.to,d=this.getDirection(l,u,a);return{hash:i.hash,from:l,to:u,timestamp:Number(i.timeStamp)*1e3,status:i.isError==="1"?"failed":"confirmed",blockNumber:BigInt(i.blockNumber),action:"transfer",direction:d,assets:[{assetType:"native",value:i.value,symbol:this.symbol,decimals:this.decimals}]}})}getDirection(t,e,s){const n=t.toLowerCase(),o=e.toLowerCase();return n===s&&o===s?"self":n===s?"out":"in"}}function Kt(r,t){if(r.type!=="bscwallet-v1")return null;const e=y.getDecimals(t),s=y.getSymbol(t);return new Ft(r,t,e,s)}var Tt={TRONGRID_API_KEY:"",ETHERSCAN_API_KEY:""},Ke={};function je(r){try{const t=Ke?.[r];if(typeof t=="string"&&t.length>0)return t}catch{}if(typeof Tt<"u"){const t=Tt[r];if(typeof t=="string"&&t.length>0)return t}}const We=m({balance:w().optional(),address:c().optional()}),Ve=m({block_header:m({raw_data:m({number:w().optional()}).optional()}).optional()}),qe=m({txID:c(),raw_data:m({contract:k(m({parameter:m({value:m({amount:w().optional(),owner_address:c().optional(),to_address:c().optional()}).optional()}).optional(),type:c().optional()})).optional(),timestamp:w().optional()}).optional(),ret:k(m({contractRet:c().optional()})).optional()}),Je=m({success:_(),data:k(qe).optional()}),Ye=m({transaction_id:c(),token_info:m({symbol:c(),address:c(),decimals:w(),name:c().optional()}),block_timestamp:w(),from:c(),to:c(),type:c(),value:c()}),Ge=m({success:_(),data:k(Ye).optional()}),ze=5;class jt{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}async api(t,e,s,n){const o=`${this.endpoint}${t}`,a={};s!==void 0&&(a["Content-Type"]="application/json");let i;const l=this.config?.apiKey;if(typeof l=="string"&&l.length>0)i=l;else{const p=this.config?.apiKeyEnv;typeof p=="string"&&p.length>0&&(i=je(p))}const u=ct(i,`trongrid:${this.chainId}`);u&&(a["TRON-PRO-API-KEY"]=u);const d=s!==void 0?{method:"POST",headers:a,body:JSON.stringify(s)}:{method:"GET",headers:a},h=await A(o,d,{cacheKey:`tron:${this.type}:${o}:${typeof d.body=="string"?d.body:""}`,ttlMs:n?.ttlMs??0,tags:n?.ttlMs?n?.tags:void 0}),f=e.safeParse(h);if(!f.success)throw new Error("Invalid API response");return f.data}async getNativeBalance(t){const s=(await this.api("/wallet/getaccount",We,{address:t,visible:!0},{ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]})).balance??0;return P({key:`balance:${this.chainId}:${t}`,value:s.toString(),invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(s.toString(),this.decimals,this.symbol),symbol:this.symbol}}async getBlockHeight(){const e=(await this.api("/wallet/getnowblock",Ve,void 0,{ttlMs:1e4})).block_header?.raw_data?.number??0;return BigInt(e)}async getTransactionHistory(t,e=20){const s=e*ze,[n,o]=await Promise.all([this.fetchNativeTransactions(t,s),this.fetchTrc20Transactions(t,s)]),a=t.toLowerCase();return this.aggregateByTxId(n,o,a).sort((l,u)=>u.timestamp-l.timestamp).slice(0,e)}aggregateByTxId(t,e,s){const n=new Map;for(const i of e){const l=i.transaction_id.toLowerCase(),u=n.get(l)??[];u.push(i),n.set(l,u)}const o=[],a=new Set;for(const i of t){const l=i.txID.toLowerCase();if(a.has(l))continue;a.add(l);const u=n.get(l)??[],d=this.buildAggregatedTransaction(i,u,s);d&&o.push(d)}for(const[i,l]of n){if(a.has(i))continue;a.add(i);const u=this.buildOrphanTrc20Transaction(l,s);o.push(u)}return o}shouldFilterTransaction(t,e){const s=t.raw_data?.contract?.[0],n=s?.type??"",o=s?.parameter?.value?.amount??0,a=t.ret?.[0]?.contractRet;return["TransferContract","TransferAssetContract","FreezeBalanceContract","FreezeBalanceV2Contract","UnfreezeBalanceContract","UnfreezeBalanceV2Contract","VoteWitnessContract","AccountCreateContract","WithdrawBalanceContract","WithdrawExpireUnfreezeContract"].includes(n)||e||o>0||a!=="SUCCESS"||this.isApproveTransaction(t)?!1:n==="TriggerSmartContract"}isApproveTransaction(t){const e=t.raw_data?.contract?.[0];if(e?.type!=="TriggerSmartContract")return!1;const s=e?.parameter?.value?.data;return!s||typeof s!="string"?!1:s.toLowerCase().startsWith("095ea7b3")}buildAggregatedTransaction(t,e,s){const n=t.raw_data?.contract?.[0],o=n?.type??"",a=n?.parameter?.value,i=t.ret?.[0]?.contractRet==="SUCCESS"?"confirmed":"failed",l=e.length>0;if(this.shouldFilterTransaction(t,l))return null;let u=this.detectAction(o);u==="contract"&&l&&(u="transfer"),u==="contract"&&this.isApproveTransaction(t)&&(u="approve");const d=this.selectPrimaryToken(e,s);let h,f;d?(h=d.from,f=d.to):(h=a?.owner_address??"",f=a?.to_address??"");const p=this.getDirection(h,f,s),b=[];for(const I of e.slice(0,3))b.push({assetType:"token",value:I.value,symbol:I.token_info.symbol,decimals:I.token_info.decimals,contractAddress:I.token_info.address,name:I.token_info.name});const S=a?.amount??0;return(S>0||b.length===0)&&b.push({assetType:"native",value:S.toString(),symbol:this.symbol,decimals:this.decimals}),{hash:t.txID,from:h,to:f,timestamp:t.raw_data?.timestamp??0,status:i,action:u,direction:p,assets:b}}buildOrphanTrc20Transaction(t,e){const s=this.selectPrimaryToken(t,e),n=this.getDirection(s.from,s.to,e),o=t.slice(0,3).map(a=>({assetType:"token",value:a.value,symbol:a.token_info.symbol,decimals:a.token_info.decimals,contractAddress:a.token_info.address,name:a.token_info.name}));return{hash:s.transaction_id,from:s.from,to:s.to,timestamp:s.block_timestamp,status:"confirmed",action:"transfer",direction:n,assets:o}}selectPrimaryToken(t,e){if(t.length===0)return null;if(t.length===1)return t[0];const s=t.filter(o=>o.from.toLowerCase()===e||o.to.toLowerCase()===e);return(s.length>0?s:t).reduce((o,a)=>{const i=BigInt(o.value);return BigInt(a.value)>i?a:o})}detectAction(t){switch(t){case"TransferContract":case"TransferAssetContract":return"transfer";case"TriggerSmartContract":return"contract";case"FreezeBalanceContract":case"FreezeBalanceV2Contract":case"VoteWitnessContract":return"stake";case"UnfreezeBalanceContract":case"UnfreezeBalanceV2Contract":return"unstake";case"WithdrawExpireUnfreezeContract":return"claim";default:return"transfer"}}async fetchNativeTransactions(t,e){const s=await this.api(`/v1/accounts/${t}/transactions?limit=${e}`,Je,void 0,{ttlMs:3e5,tags:[`txhistory:${this.chainId}:${t}`]});if(!s.success)throw new Error("Tron API error");return s.data??[]}async fetchTrc20Transactions(t,e){const s=await this.api(`/v1/accounts/${t}/transactions/trc20?limit=${e}`,Ge,void 0,{ttlMs:3e5,tags:[`txhistory:${this.chainId}:${t}`]});if(!s.success)throw new Error("Tron API error");return s.data??[]}getDirection(t,e,s){const n=t.toLowerCase(),o=e.toLowerCase();return n===s&&o===s?"self":n===s?"out":"in"}}function Wt(r,t){return r.type==="tron-rpc"||r.type==="tron-rpc-pro"?new jt(r,t):null}const Xe=m({address:c().optional(),chain_stats:m({funded_txo_sum:w(),spent_txo_sum:w()}),mempool_stats:m({funded_txo_sum:w(),spent_txo_sum:w()})}),Ze=m({txid:c(),status:m({confirmed:_(),block_height:w().optional(),block_time:w().optional()}),vin:k(m({prevout:m({scriptpubkey_address:c().optional(),value:w()}).optional()})),vout:k(m({scriptpubkey_address:c().optional(),value:w()}))});class Vt{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}async api(t,e){const s=`${this.endpoint}${t}`,n=await A(s,void 0,{cacheKey:`mempool:${s}`,ttlMs:3e4}),o=e.safeParse(n);if(!o.success)throw new Error("Invalid API response");return o.data}async getNativeBalance(t){const e=`${this.endpoint}/address/${t}`,s=await A(e,void 0,{cacheKey:`mempool:balance:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}).then(i=>{const l=Xe.safeParse(i);if(!l.success)throw new Error("Invalid API response");return l.data}),n=s.chain_stats.funded_txo_sum-s.chain_stats.spent_txo_sum,o=s.mempool_stats.funded_txo_sum-s.mempool_stats.spent_txo_sum,a=n+o;return P({key:`balance:${this.chainId}:${t}`,value:a.toString(),invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(a.toString(),this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){const s=`${this.endpoint}/address/${t}/txs`;return(await A(s,void 0,{cacheKey:`mempool:txs:${t}`,ttlMs:5*6e4,tags:[`txhistory:${this.chainId}:${t}`]}).then(o=>{const a=k(Ze).safeParse(o);if(!a.success)throw new Error("Invalid API response");return a.data})).slice(0,e).map(o=>{const a=o.vin.some(f=>f.prevout?.scriptpubkey_address===t);let i=0n;if(a)for(const f of o.vout)f.scriptpubkey_address&&f.scriptpubkey_address!==t&&(i+=BigInt(f.value));else for(const f of o.vout)f.scriptpubkey_address===t&&(i+=BigInt(f.value));const l=a?o.vout.find(f=>f.scriptpubkey_address!==t)?.scriptpubkey_address??"":o.vin[0]?.prevout?.scriptpubkey_address??"",u=a?t:l,d=a?l:t,h=a?"out":"in";return{hash:o.txid,from:u,to:d,timestamp:(o.status.block_time??Math.floor(Date.now()/1e3))*1e3,status:o.status.confirmed?"confirmed":"pending",blockNumber:o.status.block_height?BigInt(o.status.block_height):void 0,action:"transfer",direction:h,assets:[{assetType:"native",value:i.toString(),symbol:this.symbol,decimals:this.decimals}]}})}async getBlockHeight(){const t=await this.api("/blocks/tip/height",w());return BigInt(t)}}function qt(r,t){return r.type.startsWith("mempool-")?new Vt(r,t):null}const Qe=_t([c(),w().transform(r=>String(r))]),ts=m({status:c().optional(),result:k(X())}),es=m({blockNumber:c(),timeStamp:c(),hash:c(),from:c(),to:c(),value:c(),isError:c().optional(),input:c().optional(),methodId:c().optional(),functionName:c().optional()}),ss=m({blockNumber:c(),timeStamp:c(),hash:c(),from:c(),to:c(),value:c(),tokenName:c(),tokenSymbol:c(),tokenDecimal:c(),contractAddress:c()}),ns=5;function tt(r,t,e){const s=r.toLowerCase(),n=t.toLowerCase();return s===e&&n===e?"self":s===e?"out":"in"}function os(r){const t=r.value;return t&&t!=="0"?"transfer":"contract"}function as(r,t){if(r.length===0)return null;if(r.length===1)return r[0];const e=r.filter(n=>n.from.toLowerCase()===t||n.to.toLowerCase()===t);return(e.length>0?e:r).reduce((n,o)=>{const a=BigInt(n.value);return BigInt(o.value)>a?o:n})}class Jt{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}get supportsNativeBalance(){return!0}get supportsTransactionHistory(){return!0}async getNativeBalance(t){const e=new URL(`${this.endpoint}/balance`);e.searchParams.set("address",t);const s=await A(e.toString(),void 0,{cacheKey:`ethwallet:${this.chainId}:balance:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),n=Qe.safeParse(s);if(!n.success)throw new Error("Invalid API response");return P({key:`balance:${this.chainId}:${t}`,value:n.data,invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(n.data,this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){const s=e*ns,[n,o]=await Promise.all([this.fetchHistory(`${this.endpoint}/trans/normal/history`,t,s,es,"normal"),this.fetchHistory(`${this.endpoint}/trans/erc20/history`,t,s,ss,"erc20")]),a=t.toLowerCase(),i=new Map;for(const d of o){const h=d.hash.toLowerCase(),f=i.get(h)??[];f.push(d),i.set(h,f)}const l=[],u=new Set;for(const d of n){const h=d.hash.toLowerCase();if(u.has(h))continue;u.add(h);const f=i.get(h)??[],p=as(f,a);if(p){l.push({hash:p.hash,from:p.from,to:p.to,timestamp:Number(p.timeStamp)*1e3,status:"confirmed",blockNumber:BigInt(p.blockNumber),action:"transfer",direction:tt(p.from,p.to,a),assets:[{assetType:"token",value:p.value,symbol:p.tokenSymbol,decimals:parseInt(p.tokenDecimal,10),contractAddress:p.contractAddress,name:p.tokenName}],contract:{address:d.to,method:d.functionName??void 0,methodId:d.methodId??void 0}});continue}l.push({hash:d.hash,from:d.from,to:d.to,timestamp:Number(d.timeStamp)*1e3,status:d.isError==="1"?"failed":"confirmed",blockNumber:BigInt(d.blockNumber),action:os(d),direction:tt(d.from,d.to,a),assets:[{assetType:"native",value:d.value,symbol:this.symbol,decimals:this.decimals}],contract:d.value==="0"?{address:d.to,method:d.functionName??void 0,methodId:d.methodId??void 0}:void 0})}for(const d of o){const h=d.hash.toLowerCase();u.has(h)||(u.add(h),l.push({hash:d.hash,from:d.from,to:d.to,timestamp:Number(d.timeStamp)*1e3,status:"confirmed",blockNumber:BigInt(d.blockNumber),action:"transfer",direction:tt(d.from,d.to,a),assets:[{assetType:"token",value:d.value,symbol:d.tokenSymbol,decimals:parseInt(d.tokenDecimal,10),contractAddress:d.contractAddress,name:d.tokenName}]}))}return l.sort((d,h)=>h.timestamp-d.timestamp).slice(0,e)}async fetchHistory(t,e,s,n,o){const a=await A(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:e,page:1,offset:s})},{cacheKey:`ethwallet:${this.chainId}:${o}:${e}:${s}`,ttlMs:3e5,tags:[`txhistory:${this.chainId}:${e}`]}),i=ts.safeParse(a);if(!i.success)throw new Error("Invalid API response");return i.data.result.map(l=>n.safeParse(l)).filter(l=>l.success).map(l=>l.data)}}function Yt(r,t){return r.type==="ethwallet-v1"?new Jt(r,t):null}const at="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",rs=_t([c(),w().transform(r=>String(r))]),is=m({data:k(X()),success:_(),fingerprint:c().optional()}),cs=m({contractRet:c().optional(),txID:c(),blockNumber:w().optional(),from:c(),to:c(),amount:w(),timestamp:w()}),ls=m({txID:c(),from:c(),to:c(),value:c(),token_symbol:c(),token_address:c(),token_name:c(),token_decimals:w(),timestamp:w()}),us=5;function ds(r){let t=BigInt(0);for(const n of r){const o=at.indexOf(n);if(o===-1)throw new Error("Invalid base58");t=t*58n+BigInt(o)}const e=t.toString(16).padStart(50,"0"),s=new Uint8Array(25);for(let n=0;n<25;n++)s[n]=parseInt(e.slice(n*2,n*2+2),16);return s}function hs(r){let t=BigInt(0);for(const s of r)t=t*256n+BigInt(s);let e="";for(;t>0n;){const s=Number(t%58n);t=t/58n,e=at[s]+e}for(const s of r)if(s===0)e=at[0]+e;else break;return e}function vt(r){const e=ds(r).slice(0,21);return x(e)}function fs(r){const t=r.startsWith("0x")?r.slice(2):r,e=U(t),s=B(B(e)).slice(0,4),n=new Uint8Array([...e,...s]);return hs(n)}function C(r){return r.startsWith("T")?r:fs(r)}function et(r,t,e){const s=r.toLowerCase(),n=t.toLowerCase();return s===e&&n===e?"self":s===e?"out":"in"}class Gt{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}get supportsNativeBalance(){return!0}get supportsTransactionHistory(){return!0}async getNativeBalance(t){const e=t.startsWith("T")?vt(t):t,s=new URL(`${this.endpoint}/balance`);s.searchParams.set("address",e);const n=await A(s.toString(),void 0,{cacheKey:`tronwallet:${this.chainId}:balance:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),o=rs.safeParse(n);if(!o.success)throw new Error("Invalid API response");return P({key:`balance:${this.chainId}:${t}`,value:o.data,invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(o.data,this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){const s=e*us,n=t.startsWith("T")?vt(t):t,[o,a]=await Promise.all([this.fetchHistory(`${this.endpoint}/trans/common/history`,n,t,s,cs,"common"),this.fetchHistory(`${this.endpoint}/trans/trc20/history`,n,t,s,ls,"trc20")]),i=t.toLowerCase(),l=new Map;for(const h of a){const f=h.txID.toLowerCase(),p=l.get(f)??[];p.push(h),l.set(f,p)}const u=[],d=new Set;for(const h of o){const f=h.txID.toLowerCase();if(d.has(f))continue;d.add(f);const p=l.get(f)??[];if(p.length>0){const I=p[0],R=C(I.from),O=C(I.to);u.push({hash:I.txID,from:R,to:O,timestamp:I.timestamp,status:"confirmed",blockNumber:h.blockNumber!==void 0?BigInt(h.blockNumber):void 0,action:"transfer",direction:et(R,O,i),assets:[{assetType:"token",value:I.value,symbol:I.token_symbol,decimals:I.token_decimals,contractAddress:C(I.token_address),name:I.token_name}]});continue}const b=C(h.from),S=C(h.to);u.push({hash:h.txID,from:b,to:S,timestamp:h.timestamp,status:"confirmed",blockNumber:h.blockNumber!==void 0?BigInt(h.blockNumber):void 0,action:"transfer",direction:et(b,S,i),assets:[{assetType:"native",value:String(h.amount),symbol:this.symbol,decimals:this.decimals}]})}for(const h of a){const f=h.txID.toLowerCase();if(d.has(f))continue;d.add(f);const p=C(h.from),b=C(h.to);u.push({hash:h.txID,from:p,to:b,timestamp:h.timestamp,status:"confirmed",action:"transfer",direction:et(p,b,i),assets:[{assetType:"token",value:h.value,symbol:h.token_symbol,decimals:h.token_decimals,contractAddress:C(h.token_address),name:h.token_name}]})}return u.sort((h,f)=>f.timestamp-h.timestamp).slice(0,e)}async fetchHistory(t,e,s,n,o,a){const i=await A(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:e,limit:n})},{cacheKey:`tronwallet:${this.chainId}:${a}:${e}:${n}`,ttlMs:3e5,tags:[`txhistory:${this.chainId}:${s}`]}),l=is.safeParse(i);if(!l.success||!l.data.success)throw new Error("Upstream API error");return l.data.data.map(u=>o.safeParse(u)).filter(u=>u.success).map(u=>u.data)}}function zt(r,t){return r.type==="tronwallet-v1"?new Gt(r,t):null}const ms=m({error:c()}),ps=m({addresses:k(c()),value:c()}),gs=m({addresses:k(c()),value:c()}),ys=m({txid:c(),blockHeight:w(),confirmations:w(),blockTime:w(),vin:k(ps),vout:k(gs),fees:c().optional()}),It=m({address:c().optional(),balance:c(),unconfirmedBalance:c().optional(),txs:w().optional(),transactions:k(ys).optional()});function St(r,t){let e=0n;for(const s of r)s.addresses.some(n=>n===t)&&(e+=BigInt(s.value));return e}function ws(r){return r>0n?"in":r<0n?"out":"self"}class Xt{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}get supportsNativeBalance(){return!0}get supportsTransactionHistory(){return!0}async getNativeBalance(t){const e=await this.proxyGet(`/api/v2/address/${t}`,It,{cacheKey:`btcwallet:${this.chainId}:address:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),s=BigInt(e.balance),n=BigInt(e.unconfirmedBalance??"0"),o=s+n;return P({key:`balance:${this.chainId}:${t}`,value:o.toString(),invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(o.toString(),this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){return((await this.proxyGet(`/api/v2/address/${t}?details=txs&page=1&pageSize=${e}`,It,{cacheKey:`btcwallet:${this.chainId}:txs:${t}:${e}`,ttlMs:3e5,tags:[`txhistory:${this.chainId}:${t}`]})).transactions??[]).map(a=>{const i=St(a.vin,t),u=St(a.vout,t)-i,d=ws(u),h=u<0n?(-u).toString():u.toString(),f=d==="in"?a.vin[0]?.addresses?.[0]??"":t,p=a.vout.flatMap(S=>S.addresses).find(S=>S!==t),b=d==="out"?p??t:t;return{hash:a.txid,from:f,to:b,timestamp:a.blockTime*1e3,status:a.confirmations>0?"confirmed":"pending",blockNumber:a.blockHeight>0?BigInt(a.blockHeight):void 0,action:"transfer",direction:d,assets:[{assetType:"native",value:h,symbol:this.symbol,decimals:this.decimals}]}}).sort((a,i)=>i.timestamp-a.timestamp)}async proxyGet(t,e,s){const n=await A(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({url:t,method:"GET"})},{cacheKey:s?.cacheKey,ttlMs:s?.ttlMs,tags:s?.tags}),o=ms.safeParse(n);if(o.success&&o.data.error)throw new Error(o.data.error);const a=e.safeParse(n);if(!a.success)throw new Error("Invalid API response");return a.data}}function Zt(r,t){return r.type==="btcwallet-v1"?new Xt(r,t):null}class M{constructor(t,e,s){this.transactionService=e,this.assetService=s,this.type=t}type;endpoint="";get supportsTransactionHistory(){return this.transactionService.supportsTransactionHistory!==!1}async getNativeBalance(t){return this.assetService.getNativeBalance(t)}async getTransactionHistory(t,e){return(await this.transactionService.getTransactionHistory(t,e)).map(n=>this.convertTransaction(n,t))}async getTransaction(t){const e=await this.transactionService.getTransaction(t);return e?this.convertTransaction(e):null}async getTransactionStatus(t){const e=await this.transactionService.getTransactionStatus(t);return this.convertTransactionStatus(e)}async estimateFee(t){const e=await this.transactionService.estimateFee(t);return this.convertFeeEstimate(e)}async buildTransaction(t){return this.transactionService.buildTransaction(t)}async signTransaction(t,e){const s=await this.transactionService.signTransaction(t,e);return{chainId:s.chainId,data:s.data,signature:typeof s.signature=="string"?s.signature:""}}async broadcastTransaction(t){return this.transactionService.broadcastTransaction(t)}convertTransaction(t,e){const s=e?t.from.toLowerCase()===e.toLowerCase()?"out":t.to.toLowerCase()===e.toLowerCase()?"in":"self":"self",n=this.deriveAction(t);return{hash:t.hash,from:t.from,to:t.to,timestamp:t.timestamp,status:t.status.status==="confirmed"?"confirmed":t.status.status==="failed"?"failed":"pending",blockNumber:t.blockNumber,action:n,direction:s,assets:[{assetType:"native",value:t.amount.toRawString(),symbol:t.amount.symbol??"",decimals:t.amount.decimals}],contract:t.type==="contract-call"||n==="contract"?{address:t.to}:void 0,fee:{value:t.fee.toRawString(),symbol:t.fee.symbol??"",decimals:t.fee.decimals}}}deriveAction(t){const e=t.rawType;if(e){if(e.includes("BSE-01"))return"signature";if(e.includes("AST-02"))return"transfer";if(e.includes("AST-03"))return"destroyAsset";if(e.includes("AST-04"))return"gift";if(e.includes("AST-05"))return"grab";if(e.includes("AST-06"))return"trust";if(e.includes("AST-07"))return"signFor";if(e.includes("AST-08"))return"emigrate";if(e.includes("AST-09"))return"immigrate";if(e.includes("AST-10")||e.includes("AST-11"))return"exchange";if(e.includes("AST-12"))return"stake";if(e.includes("AST-13"))return"unstake";if(e.includes("AST-00"))return"issueAsset";if(e.includes("AST-01"))return"increaseAsset";if(e.includes("ETY-02")||e.includes("ETY-04"))return"issueEntity";if(e.includes("ETY-03"))return"destroyEntity";if(e.includes("ETY-00")||e.includes("ETY-01"))return"issueAsset";if(e.includes("ANY-00"))return"transfer";if(e.includes("ANY-01"))return"gift";if(e.includes("ANY-02"))return"grab";if(e.includes("ANY-03")||e.includes("ANY-04")||e.includes("ANY-05")||e.includes("ANY-06")||e.includes("ANY-07")||e.includes("ANY-08"))return"exchange";if(e.includes("LNS-"))return"locationName";if(e.includes("WOD-"))return"dapp";if(e.includes("CRT-"))return"certificate";if(e.includes("EXT-00"))return"mark"}return t.type==="stake"?"stake":t.type==="unstake"?"unstake":t.type==="contract-call"?"contract":"transfer"}convertTransactionStatus(t){let e;switch(t.status){case"pending":e="pending";break;case"confirmed":e="confirmed";break;case"failed":e="failed";break;default:e="pending"}return{status:e,confirmations:t.confirmations,requiredConfirmations:t.requiredConfirmations}}convertFeeEstimate(t){const e=(s,n)=>({amount:s.amount,estimatedTime:n});return{slow:e(t.slow,600),standard:e(t.standard,180),fast:e(t.fast,30)}}}class H{constructor(t,e){this.identityService=e,this.type=t}type;endpoint="";async deriveAddress(t,e=0){return this.identityService.deriveAddress(t,e)}async deriveAddresses(t,e,s){return this.identityService.deriveAddresses(t,e,s)}isValidAddress(t){return this.identityService.isValidAddress(t)}normalizeAddress(t){return this.identityService.normalizeAddress(t)}}class bs{chainId;constructor(t){this.chainId=t}async deriveAddress(t,e=0){const s=new TextDecoder().decode(t);return Y(s,"ethereum",e).address}async deriveAddresses(t,e,s){const n=new TextDecoder().decode(t),o=[];for(let a=0;a<s;a++){const i=Y(n,"ethereum",e+a);o.push(i.address)}return o}isValidAddress(t){return ue(t,"ethereum")}normalizeAddress(t){return de(t)}async signMessage(t,e){throw new Error("Not implemented")}async verifyMessage(t,e,s){throw new Error("Not implemented")}}class T extends Error{code;details;constructor(t,e,s,n){super(e,{cause:n}),this.name="ChainServiceError",this.code=t,this.details=s}}const v={CHAIN_NOT_SUPPORTED:"CHAIN_NOT_SUPPORTED",NOT_SUPPORTED:"NOT_SUPPORTED",NETWORK_ERROR:"NETWORK_ERROR",INSUFFICIENT_BALANCE:"INSUFFICIENT_BALANCE",INSUFFICIENT_FEE:"INSUFFICIENT_FEE",INVALID_ADDRESS:"INVALID_ADDRESS",TRANSACTION_REJECTED:"TRANSACTION_REJECTED",TRANSACTION_TIMEOUT:"TRANSACTION_TIMEOUT",TX_BUILD_FAILED:"TX_BUILD_FAILED",TX_BROADCAST_FAILED:"TX_BROADCAST_FAILED",SIGNATURE_FAILED:"SIGNATURE_FAILED",ADDRESS_FROZEN:"ADDRESS_FROZEN",PAYSECRET_REQUIRED:"PAYSECRET_REQUIRED",ADDRESS_NOT_ACTIVATED:"ADDRESS_NOT_ACTIVATED",ENERGY_INSUFFICIENT:"ENERGY_INSUFFICIENT",NONCE_TOO_LOW:"NONCE_TOO_LOW",GAS_TOO_LOW:"GAS_TOO_LOW",UTXO_INSUFFICIENT:"UTXO_INSUFFICIENT"};class Ts{chainId;constructor(t){this.chainId=t}get rpcUrl(){return y.getRpcUrl(this.chainId)}get decimals(){return y.getDecimals(this.chainId)}get symbol(){return y.getSymbol(this.chainId)}async rpc(t,e){const s=await fetch(this.rpcUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:1})});if(!s.ok)throw new T(v.NETWORK_ERROR,`HTTP ${s.status}: ${s.statusText}`);const n=await s.json();if(n.error)throw new T(v.NETWORK_ERROR,n.error.message);return n.result}async getNativeBalance(t){try{const e=await this.rpc("eth_getBalance",[t,"latest"]),s=BigInt(e).toString();return{amount:g.fromRaw(s,this.decimals,this.symbol),symbol:this.symbol}}catch{return{amount:g.fromRaw("0",this.decimals,this.symbol),symbol:this.symbol}}}async getTokenBalance(t,e){try{const s=`0x70a08231000000000000000000000000${t.slice(2).toLowerCase()}`,n=await this.rpc("eth_call",[{to:e,data:s},"latest"]),o=BigInt(n).toString();return{amount:g.fromRaw(o,18,"TOKEN"),symbol:"TOKEN"}}catch{return{amount:g.fromRaw("0",18,"UNKNOWN"),symbol:"UNKNOWN"}}}async getTokenBalances(t){return[await this.getNativeBalance(t)]}async getTokenMetadata(t){return{address:t,name:"Unknown Token",symbol:"UNKNOWN",decimals:18}}}const vs={ethereum:1,"ethereum-sepolia":11155111,binance:56,"bsc-testnet":97};class Is{chainId;evmChainId;constructor(t){this.chainId=t,this.evmChainId=vs[t]??1}get rpcUrl(){return y.getRpcUrl(this.chainId)}get decimals(){return y.getDecimals(this.chainId)}get symbol(){return y.getSymbol(this.chainId)}async rpc(t,e=[]){const s=await fetch(this.rpcUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:Date.now(),method:t,params:e})});if(!s.ok)throw new T(v.NETWORK_ERROR,`HTTP ${s.status}: ${s.statusText}`);const n=await s.json();if(n.error)throw new T(v.NETWORK_ERROR,n.error.message,{code:n.error.code});return n.result}async estimateFee(t){const e=await this.rpc("eth_gasPrice"),o=21000n*BigInt(e),a=g.fromRaw((o*80n/100n).toString(),this.decimals,this.symbol),i=g.fromRaw(o.toString(),this.decimals,this.symbol),l=g.fromRaw((o*120n/100n).toString(),this.decimals,this.symbol);return{slow:{amount:a,estimatedTime:60},standard:{amount:i,estimatedTime:15},fast:{amount:l,estimatedTime:5}}}async buildTransaction(t){const e=await this.rpc("eth_getTransactionCount",[t.from,"pending"]),s=parseInt(e,16),n=await this.rpc("eth_gasPrice");return{chainId:this.chainId,data:{nonce:s,gasPrice:n,gasLimit:"0x5208",to:t.to,value:"0x"+t.amount.raw.toString(16),data:"0x",chainId:this.evmChainId}}}async signTransaction(t,e){const s=t.data,n=this.rlpEncode([this.toRlpHex(s.nonce),s.gasPrice,s.gasLimit,s.to.toLowerCase(),s.value,s.data,this.toRlpHex(s.chainId),"0x","0x"]),o=q(U(n.slice(2))),a=F.sign(o,e,{prehash:!1,format:"recovered"}),i=BigInt("0x"+x(a.slice(0,32))),l=BigInt("0x"+x(a.slice(32,64))),u=a[64],d=s.chainId*2+35+u,h=i.toString(16).padStart(64,"0"),f=l.toString(16).padStart(64,"0"),p=this.rlpEncode([this.toRlpHex(s.nonce),s.gasPrice,s.gasLimit,s.to.toLowerCase(),s.value,s.data,this.toRlpHex(d),"0x"+h,"0x"+f]);return{chainId:this.chainId,data:p,signature:"0x"+h+f}}async broadcastTransaction(t){const e=t.data;return await this.rpc("eth_sendRawTransaction",[e])}toRlpHex(t){return t===0?"0x":"0x"+t.toString(16)}rlpEncode(t){const e=t.map(i=>{if(i==="0x"||i==="")return new Uint8Array([128]);const l=U(i.startsWith("0x")?i.slice(2):i);if(l.length===1&&l[0]<128)return l;if(l.length<=55)return new Uint8Array([128+l.length,...l]);const u=this.numberToBytes(l.length);return new Uint8Array([183+u.length,...u,...l])}),s=e.reduce((i,l)=>i+l.length,0);let n;if(s<=55)n=new Uint8Array([192+s]);else{const i=this.numberToBytes(s);n=new Uint8Array([247+i.length,...i])}const o=new Uint8Array(n.length+s);o.set(n);let a=n.length;for(const i of e)o.set(i,a),a+=i.length;return"0x"+x(o)}numberToBytes(t){const e=t.toString(16),s=e.length%2?"0"+e:e;return U(s)}async getTransactionStatus(t){try{const e=await this.rpc("eth_getTransactionReceipt",[t]);if(!e)return{status:"pending",confirmations:0,requiredConfirmations:12};const s=await this.rpc("eth_blockNumber"),n=parseInt(s,16)-parseInt(e.blockNumber,16);return{status:n>=12?"confirmed":"confirming",confirmations:Math.max(0,n),requiredConfirmations:12}}catch{return{status:"pending",confirmations:0,requiredConfirmations:12}}}async getTransaction(t){try{const[e,s]=await Promise.all([this.rpc("eth_getTransactionByHash",[t]),this.rpc("eth_getTransactionReceipt",[t])]);if(!e)return null;const n=e.blockNumber?await this.rpc("eth_getBlockByNumber",[e.blockNumber,!1]):null;return{hash:e.hash,from:e.from,to:e.to??"",amount:g.fromRaw(BigInt(e.value).toString(),this.decimals,this.symbol),fee:s?g.fromRaw((BigInt(s.gasUsed)*BigInt(e.gasPrice)).toString(),this.decimals,this.symbol):g.fromRaw("0",this.decimals,this.symbol),status:{status:s?.status==="0x1"?"confirmed":s?"failed":"pending",confirmations:s?12:0,requiredConfirmations:12},timestamp:n?parseInt(n.timestamp,16)*1e3:Date.now(),blockNumber:e.blockNumber?BigInt(e.blockNumber):void 0,type:"transfer"}}catch{return null}}supportsTransactionHistory=!1;async getTransactionHistory(t,e=20){throw new T(v.NOT_SUPPORTED,"Transaction history not supported by standard EVM JSON-RPC")}}const j="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";class Ss{constructor(t){}async deriveAddress(t,e=0){const s=new TextDecoder().decode(t);return Y(s,"tron",e).address}async deriveAddresses(t,e,s){const n=new TextDecoder().decode(t),o=[];for(let a=0;a<s;a++){const i=Y(n,"tron",e+a);o.push(i.address)}return o}isValidAddress(t){if(!t.startsWith("T")||t.length!==34)return!1;for(const e of t)if(!j.includes(e))return!1;try{const e=this.decodeBase58(t);if(e.length!==25)return!1;const s=e.slice(0,21),n=e.slice(21),o=B(B(s));return n.every((a,i)=>a===o[i])}catch{return!1}}decodeBase58(t){let e=BigInt(0);for(const o of t){const a=j.indexOf(o);if(a===-1)throw new Error(`Invalid base58 character: ${o}`);e=e*58n+BigInt(a)}const s=e.toString(16).padStart(50,"0"),n=new Uint8Array(25);for(let o=0;o<25;o++)n[o]=parseInt(s.slice(o*2,o*2+2),16);return n}normalizeAddress(t){return t}async signMessage(t,e){const s=typeof t=="string"?new TextEncoder().encode(t):t,n=new TextEncoder().encode(`TRON Signed Message:
`+s.length),o=q(new Uint8Array([...n,...s])),a=F.sign(o,e,{prehash:!1,format:"recovered"});return x(a)}async verifyMessage(t,e,s){try{const n=typeof t=="string"?new TextEncoder().encode(t):t,o=new TextEncoder().encode(`TRON Signed Message:
`+n.length),a=q(new Uint8Array([...o,...n])),i=U(e),l=F.recoverPublicKey(a,i);if(!l)return!1;const d=q(l.slice(1)).slice(-20),h=new Uint8Array([65,...d]),f=B(B(h)).slice(0,4),p=new Uint8Array([...h,...f]);return this.encodeBase58(p)===s}catch{return!1}}encodeBase58(t){let e=BigInt(0);for(const n of t)e=e*256n+BigInt(n);let s="";for(;e>0n;){const n=Number(e%58n);e=e/58n,s=j[n]+s}for(const n of t)if(n===0)s=j[0]+s;else break;return s}}class As{chainId;constructor(t){this.chainId=t}get rpcUrl(){return y.getRpcUrl(this.chainId)}get decimals(){return y.getDecimals(this.chainId)}get symbol(){return y.getSymbol(this.chainId)}async api(t,e){const s=`${this.rpcUrl}${t}`,n=e?{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)}:{method:"GET"},o=await fetch(s,n);if(!o.ok)throw new T(v.NETWORK_ERROR,`Tron API error: ${o.status}`);return o.json()}async getNativeBalance(t){const e=await this.api("/wallet/getaccount",{address:t,visible:!0});return!e||!("balance"in e)?{amount:g.fromRaw("0",this.decimals,this.symbol),symbol:this.symbol}:{amount:g.fromRaw(e.balance.toString(),this.decimals,this.symbol),symbol:this.symbol}}async getTokenBalance(t,e){try{const s=await this.api("/wallet/getaccount",{address:t,visible:!0});if(s?.trc20){for(const n of s.trc20)if(n[e])return{amount:g.fromRaw(n[e],18,"TOKEN"),symbol:"TOKEN"}}return{amount:g.fromRaw("0",18,"TOKEN"),symbol:"TOKEN"}}catch{return{amount:g.fromRaw("0",18,"TOKEN"),symbol:"TOKEN"}}}async getTokenBalances(t){return[await this.getNativeBalance(t)]}async getTokenMetadata(t){return{address:t,name:"TRC20 Token",symbol:"TOKEN",decimals:18}}}const ks="https://api.trongrid.io";class Es{chainId;config=null;rpcUrl="";constructor(t){this.chainId=t}getConfig(){if(!this.config){const t=y.getConfig(this.chainId);if(!t)throw new T(v.CHAIN_NOT_FOUND,`Chain config not found: ${this.chainId}`);this.config=t,this.rpcUrl=y.getRpcUrl(t.id)||ks}return this.config}async api(t,e){const s=`${this.rpcUrl}${t}`,n=e?{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)}:{method:"GET"},o=await fetch(s,n);if(!o.ok)throw new T(v.NETWORK_ERROR,`Tron API error: ${o.status} ${o.statusText}`);return o.json()}base58ToHex(t){const e="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";let s=BigInt(0);for(const o of t){const a=e.indexOf(o);if(a===-1)throw new Error(`Invalid base58 character: ${o}`);s=s*58n+BigInt(a)}return s.toString(16).padStart(50,"0").slice(0,42)}async estimateFee(t){const e=this.getConfig(),n={amount:g.fromRaw("0",e.decimals,e.symbol),estimatedTime:3};return{slow:n,standard:n,fast:n}}async buildTransaction(t){const e=this.getConfig(),s=this.base58ToHex(t.from),n=this.base58ToHex(t.to),o=await this.api("/wallet/createtransaction",{owner_address:s,to_address:n,amount:Number(t.amount.raw),visible:!1});if(!o.txID)throw new T(v.TX_BUILD_FAILED,"Failed to create Tron transaction");return{chainId:e.id,data:o}}async signTransaction(t,e){const s=t.data,n=U(s.txID),o=F.sign(n,e,{prehash:!1,format:"recovered"}),a=x(o),i={...s,signature:[a]};return{chainId:t.chainId,data:i,signature:a}}async broadcastTransaction(t){const e=t.data,s=await this.api("/wallet/broadcasttransaction",e);if(!s.result){const n=s.message?Buffer.from(s.message,"hex").toString("utf8"):s.code??"Unknown error";throw new T(v.TX_BROADCAST_FAILED,`Broadcast failed: ${n}`)}return e.txID}async getTransactionStatus(t){try{const e=await this.api("/wallet/gettransactioninfobyid",{value:t});if(!e||!("blockNumber"in e))return{status:"pending",confirmations:0,requiredConfirmations:19};const o=(await this.api("/wallet/getnowblock")).block_header.raw_data.number-e.blockNumber;return{status:o>=19?"confirmed":"confirming",confirmations:Math.max(0,o),requiredConfirmations:19}}catch{return{status:"pending",confirmations:0,requiredConfirmations:19}}}async getTransaction(t){try{const[e,s]=await Promise.all([this.api("/wallet/gettransactionbyid",{value:t}),this.api("/wallet/gettransactioninfobyid",{value:t})]);if(!e||!("txID"in e))return null;const n=e.raw_data.contract[0];if(!n||n.type!=="TransferContract")return null;const{amount:o,owner_address:a,to_address:i}=n.parameter.value,l="blockNumber"in s,u=this.getConfig();return{hash:e.txID,from:a,to:i,amount:g.fromRaw(o.toString(),u.decimals,u.symbol),fee:g.fromRaw((s.receipt?.net_usage??0).toString(),u.decimals,u.symbol),status:{status:l?"confirmed":"pending",confirmations:l?19:0,requiredConfirmations:19},timestamp:e.raw_data.timestamp,blockNumber:l?BigInt(s.blockNumber):void 0,type:"transfer"}}catch{return null}}supportsTransactionHistory=!1;async getTransactionHistory(t,e=20){throw new T(v.NOT_SUPPORTED,"Transaction history not supported by Tron HTTP API, use TronGrid API instead")}}class Ns{constructor(t){}async deriveAddress(t,e=0){const s=new TextDecoder().decode(t);return dt(s,84,e).address}async deriveAddresses(t,e,s){const n=new TextDecoder().decode(t),o=[];for(let a=0;a<s;a++){const i=dt(n,84,e+a);o.push(i.address)}return o}isValidAddress(t){try{if(t.startsWith("1")||t.startsWith("3"))return he(B).decode(t).length===21;if(t.toLowerCase().startsWith("bc1q")){const e=t.toLowerCase(),s=ht.decode(e),n=ht.fromWords(s.words.slice(1));return s.prefix==="bc"&&s.words[0]===0&&n.length===20}if(t.toLowerCase().startsWith("bc1p")){const e=t.toLowerCase(),s=ft.decode(e),n=ft.fromWords(s.words.slice(1));return s.prefix==="bc"&&s.words[0]===1&&n.length===32}return!1}catch{return!1}}normalizeAddress(t){return t.startsWith("bc1")||t.startsWith("BC1")?t.toLowerCase():t}async signMessage(t,e){const s=typeof t=="string"?new TextEncoder().encode(t):t,n=new TextEncoder().encode(`Bitcoin Signed Message:
`),o=new Uint8Array([s.length]),a=new Uint8Array([...n,...o,...s]),i=B(B(a)),l=F.sign(i,e,{prehash:!1,format:"recovered"});return x(l)}async verifyMessage(t,e,s){return!1}}const At={bitcoin:"https://mempool.space/api","bitcoin-testnet":"https://mempool.space/testnet/api","bitcoin-signet":"https://mempool.space/signet/api"};class _s{config;apiUrl;constructor(t){this.config=t,this.apiUrl=At[t.id]??At.bitcoin}async api(t){const e=`${this.apiUrl}${t}`,s=await fetch(e);if(!s.ok)throw new T(v.NETWORK_ERROR,`Bitcoin API error: ${s.status}`);return s.json()}async getNativeBalance(t){try{const e=await this.api(`/address/${t}`),s=e.chain_stats.funded_txo_sum-e.chain_stats.spent_txo_sum,n=e.mempool_stats.funded_txo_sum-e.mempool_stats.spent_txo_sum,o=s+n;return{amount:g.fromRaw(o.toString(),this.config.decimals,this.config.symbol),symbol:this.config.symbol}}catch{return{amount:g.fromRaw("0",this.config.decimals,this.config.symbol),symbol:this.config.symbol}}}async getTokenBalance(t,e){return{amount:g.fromRaw("0",8,"TOKEN"),symbol:"TOKEN"}}async getTokenBalances(t){return[]}async getTokenMetadata(t){return{address:t,name:"Unknown",symbol:"UNKNOWN",decimals:8}}async getUtxos(t){return this.api(`/address/${t}/utxo`)}}const Bs="https://mempool.space/api";class Cs{config;apiUrl;constructor(t){this.config=t,this.apiUrl=y.getMempoolApi(t.id)??Bs}async api(t,e){const s=`${this.apiUrl}${t}`,n=await fetch(s,e);if(!n.ok)throw new T(v.NETWORK_ERROR,`Bitcoin API error: ${n.status}`);const o=await n.text();try{return JSON.parse(o)}catch{return o}}async estimateFee(t){try{const e=await this.api("/v1/fees/recommended"),s=140,n={amount:g.fromRaw((e.hourFee*s).toString(),this.config.decimals,this.config.symbol),estimatedTime:3600},o={amount:g.fromRaw((e.halfHourFee*s).toString(),this.config.decimals,this.config.symbol),estimatedTime:1800},a={amount:g.fromRaw((e.fastestFee*s).toString(),this.config.decimals,this.config.symbol),estimatedTime:600};return{slow:n,standard:o,fast:a}}catch{const e={amount:g.fromRaw("2000",this.config.decimals,this.config.symbol),estimatedTime:1800};return{slow:e,standard:e,fast:e}}}async buildTransaction(t){const e=await this.api(`/address/${t.from}/utxo`);if(e.length===0)throw new T(v.INSUFFICIENT_BALANCE,"No UTXOs available");const n=(await this.api("/v1/fees/recommended")).halfHourFee,o=e.reduce((h,f)=>h+f.value,0),a=Number(t.amount.raw),i=10+e.length*68+62,l=n*i;if(o<a+l)throw new T(v.INSUFFICIENT_BALANCE,`Insufficient balance: need ${a+l}, have ${o}`);const u=o-a-l,d={inputs:e.map(h=>({txid:h.txid,vout:h.vout,value:h.value,scriptPubKey:""})),outputs:[{address:t.to,value:a}],fee:l,changeAddress:t.from};return u>546&&d.outputs.push({address:t.from,value:u}),{chainId:this.config.id,data:d}}async signTransaction(t,e){throw new T(v.CHAIN_NOT_SUPPORTED,"Bitcoin transaction signing requires specialized library (bitcoinjs-lib or similar)")}async broadcastTransaction(t){const e=t.data;return await this.api("/tx",{method:"POST",body:e})}async getTransactionStatus(t){try{const e=await this.api(`/tx/${t}`);if(!e.status.confirmed)return{status:"pending",confirmations:0,requiredConfirmations:6};const s=await this.api("/blocks/tip/height"),n=s-(e.status.block_height??s)+1;return{status:n>=6?"confirmed":"confirming",confirmations:Math.max(0,n),requiredConfirmations:6}}catch{return{status:"pending",confirmations:0,requiredConfirmations:6}}}async getTransaction(t){try{const e=await this.api(`/tx/${t}`),s=e.vin[0]?.prevout?.scriptpubkey_address??"",n=e.vout[0]?.scriptpubkey_address??"",o=e.vout[0]?.value??0;return{hash:e.txid,from:s,to:n,amount:g.fromRaw(o.toString(),this.config.decimals,this.config.symbol),fee:g.fromRaw(e.fee.toString(),this.config.decimals,this.config.symbol),status:{status:e.status.confirmed?"confirmed":"pending",confirmations:e.status.confirmed?6:0,requiredConfirmations:6},timestamp:(e.status.block_time??Math.floor(Date.now()/1e3))*1e3,blockNumber:e.status.block_height?BigInt(e.status.block_height):void 0,type:"transfer"}}catch{return null}}async getTransactionHistory(t,e=20){try{return(await this.api(`/address/${t}/txs`)).slice(0,e).map(n=>{const o=n.vin.some(u=>u.prevout?.scriptpubkey_address===t),a=o?t:n.vin[0]?.prevout?.scriptpubkey_address??"",i=o?n.vout.find(u=>u.scriptpubkey_address!==t)?.scriptpubkey_address??"":t,l=o?n.vout.filter(u=>u.scriptpubkey_address!==t).reduce((u,d)=>u+d.value,0):n.vout.filter(u=>u.scriptpubkey_address===t).reduce((u,d)=>u+d.value,0);return{hash:n.txid,from:a,to:i,amount:g.fromRaw(l.toString(),this.config.decimals,this.config.symbol),fee:g.fromRaw(n.fee.toString(),this.config.decimals,this.config.symbol),status:{status:n.status.confirmed?"confirmed":"pending",confirmations:n.status.confirmed?6:0,requiredConfirmations:6},timestamp:(n.status.block_time??Math.floor(Date.now()/1e3))*1e3,blockNumber:n.status.block_height?BigInt(n.status.block_height):void 0,type:"transfer"}})}catch{return[]}}}function $s(r){return Array.from(r).map(t=>t.toString(16).padStart(2,"0")).join("")}class Ps{chainId;prefix=null;constructor(t){this.chainId=t}getPrefix(){if(!this.prefix){const t=y.getConfig(this.chainId);this.prefix=t?.prefix??"b"}return this.prefix}async deriveAddress(t,e=0){const s=new TextDecoder().decode(t),n=fe(s);return me(n.publicKey,this.getPrefix())}async deriveAddresses(t,e,s){const n=await this.deriveAddress(t,e);return Array(s).fill(n)}isValidAddress(t){return pe(t)}normalizeAddress(t){return t}async signMessage(t,e){const s=Bt(t,e);return $s(s)}async verifyMessage(t,e,s){return!1}}const Rs=N({assetNumber:c(),assetType:c().min(1),sourceChainMagic:c(),sourceChainName:c(),iconUrl:c().optional()}),xs=N({success:_(),result:N({address:c(),assets:J(c(),J(c(),Rs)),forgingRewards:c().optional()}).nullish(),error:N({code:w(),message:c(),info:c().optional()}).nullish()});class Os{chainId;config=null;constructor(t){this.chainId=t}getConfig(){if(!this.config){const t=y.getConfig(this.chainId);if(!t)throw new T(v.CHAIN_NOT_FOUND,`Chain config not found: ${this.chainId}`);this.config=t}return this.config}getEmptyNativeBalance(){const t=this.getConfig();return{amount:g.zero(t.decimals,t.symbol),symbol:t.symbol}}async getNativeBalance(t){const e=await this.getTokenBalances(t),s=this.getConfig();return e.find(o=>o.symbol===s.symbol)??this.getEmptyNativeBalance()}async getTokenBalance(t,e){const s=e,o=(await this.getTokenBalances(t)).find(i=>i.symbol===s);if(o)return o;const a=this.getConfig();return{amount:g.zero(a.decimals,s),symbol:s}}async getTokenBalances(t){const e=this.getConfig(),s=y.getBiowalletApi(e.id);if(!s)return[this.getEmptyNativeBalance()];const{endpoint:n,path:o}=s;try{const a=await fetch(`${n}/wallet/${o}/address/asset`,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({address:t})});if(!a.ok)throw new T(v.NETWORK_ERROR,`Failed to fetch balances: ${a.status}`);const i=await a.json(),l=xs.safeParse(i);if(!l.success)return console.warn("[BioforestAssetService] Invalid API response:",l.error.message),[this.getEmptyNativeBalance()];const{success:u,result:d}=l.data;if(!u||!d)return[this.getEmptyNativeBalance()];const h=[],{assets:f}=d;for(const p of Object.keys(f)){const b=f[p];if(b)for(const S of Object.keys(b)){const I=b[S];if(!I)continue;const R=e.decimals,O=g.fromRaw(I.assetNumber,R,I.assetType);h.push({amount:O,symbol:I.assetType})}}return h.length>0?h:[this.getEmptyNativeBalance()]}catch(a){throw a instanceof T?a:new T(v.NETWORK_ERROR,"Failed to fetch balances",void 0,a instanceof Error?a:void 0)}}async getTokenMetadata(t){const e=this.getConfig();return{address:null,name:t,symbol:t,decimals:e.decimals}}}class L extends Error{constructor(t,e,s){super(t),this.status=e,this.response=s,this.name="ApiError"}}class Us{baseUrl;timeout;fetchFn;constructor(t){this.baseUrl=t.baseUrl.replace(/\/$/,""),this.timeout=t.timeout??3e4,this.fetchFn=t.fetch??((e,s)=>fetch(e,s))}async request(t,e,s){const n=`${this.baseUrl}${e}`,o=new AbortController,a=setTimeout(()=>o.abort(),this.timeout);try{const i={method:t,signal:o.signal};s&&(i.headers={"Content-Type":"application/json"},i.body=JSON.stringify(s));const l=await this.fetchFn(n,i),u=await l.json();if(!l.ok)throw new L(u.message??`Request failed: ${l.status}`,l.status,u);if(!u.success)throw new L(u.message??"Request failed",l.status,u);return u.result}catch(i){throw i instanceof L?i:i instanceof Error&&i.name==="AbortError"?new L("Request timeout",void 0,void 0):new L(i instanceof Error?i.message:"Unknown error",void 0,void 0)}finally{clearTimeout(a)}}async get(t){return this.request("GET",t)}async post(t,e){return this.request("POST",t,e)}}const Ds="https://walletapi.bfmeta.info";class Ls{client;chainPath;constructor(t){this.chainPath=t.chainPath;const e={baseUrl:t.baseUrl??Ds};t.timeout!==void 0&&(e.timeout=t.timeout),t.fetch!==void 0&&(e.fetch=t.fetch),this.client=new Us(e)}path(t){return`/wallet/${this.chainPath}${t}`}async getLastBlock(){return this.client.get(this.path("/lastblock"))}async getBlockByHeight(t){return this.client.post(this.path("/block/query"),{height:t})}async getBalance(t){return this.client.post(this.path("/address/balance"),t)}async getAddressInfo(t){return this.client.post(this.path("/address/info"),{address:t})}async getAddressAssets(t){return this.client.post(this.path("/address/asset"),{address:t})}async getBlockAverageFee(){return this.client.get(this.path("/blockAveFee"))}async broadcastTransaction(t){return this.client.post(this.path("/transactions/broadcast"),t)}async queryTransactions(t){return this.client.post(this.path("/transactions/query"),t)}async queryPendingTransactions(t){return this.client.post(this.path("/pendingTr"),t)}async queryTokenList(t){return this.client.post(this.path("/assets"),t)}async queryTokenDetail(t){return this.client.post(this.path("/asset/details"),t)}}const kt=new Map;function lt(r,t){const e=`${r}|${t}`;let s=kt.get(e);return s||(s=new Ls({baseUrl:r,chainPath:t}),kt.set(e,s)),s}const Et=new Map,Nt=new Map;let W=null,V=null;function ut(r,t){return t||(r==="bfmeta"?"bfm":r)}function Ms(){return typeof document<"u"?new URL("/configs/genesis",document.baseURI).href:"/configs/genesis"}async function Hs(r){const t=Et.get(r);if(t)return t;const e=`${Ms()}/${r}.json`;let s;if(e.startsWith("http://")||e.startsWith("https://")){const n=await fetch(e);if(!n.ok)throw new Error(`Failed to fetch genesis block: ${n.status}`);s=await n.json()}else s=(await import(e)).default;return Et.set(r,s),s}async function Fs(){const{sha256:r}=await st(async()=>{const{sha256:o}=await import("./bioforest-uXX5qE5N.js").then(a=>a.Z);return{sha256:o}},[],import.meta.url),{md5:t,ripemd160:e}=await st(async()=>{const{md5:o,ripemd160:a}=await import("./bioforest-uXX5qE5N.js").then(i=>i._);return{md5:o,ripemd160:a}},[],import.meta.url),s=o=>{const a=[];return{update(i){const l=typeof i=="string"?new TextEncoder().encode(i):i;return a.push(l),this},async digest(){const i=a.reduce((d,h)=>d+h.length,0),l=new Uint8Array(i);let u=0;for(const d of a)l.set(d,u),u+=d.length;return Buffer.from(o(l))}}};return{sha256(o){if(!o)return s(i=>r(i));const a=typeof o=="string"?new TextEncoder().encode(o):o;return Promise.resolve(Buffer.from(r(a)))},md5(o){if(!o)return s(i=>t(i));const a=typeof o=="string"?new TextEncoder().encode(o):o;return Promise.resolve(Buffer.from(t(a)))},ripemd160(o){if(!o)return s(i=>e(i));const a=typeof o=="string"?new TextEncoder().encode(o):o;return Promise.resolve(Buffer.from(e(a)))}}}async function Ks(){return W||V||(V=(async()=>(W={setup:(await st(()=>import("./bioforest-chain-bundle-CsZkxsox.js"),[],import.meta.url)).setup},W))(),V)}async function D(r){const t=await Hs(r),e=t.magic,s=Nt.get(e);if(s)return s;const n=await Ks(),o=await Fs(),a=await n.setup(t,o,{n:"KeyApp",m:"true",a:"web"});return Nt.set(e,a),a}async function K(r,t){const s=await lt(r,t).getLastBlock();return{height:s.height,timestamp:s.timestamp}}async function Qt(r,t,e){const s=lt(r,t);try{return await s.getAddressInfo(e)??{address:e}}catch{return{address:e}}}async function js(r){const t=await D(r.chainId),e=ut(r.chainId,r.apiPath),s=await K(r.rpcUrl,e),n=s.height,o=s.timestamp;let a=r.fee;a||(a=await t.transactionController.getTransferTransactionMinFee({transaction:{applyBlockHeight:n,timestamp:o,remark:r.remark??{}},assetInfo:{sourceChainName:await t.getChainName(),sourceChainMagic:await t.getMagic(),assetType:r.assetType,amount:r.amount}}));let i=!1;if(r.paySecret){const d=await Qt(r.rpcUrl,e,r.from);d.secondPublicKey&&(i=await ee(r.chainId,r.mainSecret,r.paySecret,d.secondPublicKey)==="v1")}const l={mainSecret:r.mainSecret,...r.paySecret?{paySecret:r.paySecret,usePaySecretV1:i}:{}},u={sourceChainName:await t.getChainName(),sourceChainMagic:await t.getMagic(),assetType:r.assetType,amount:r.amount};return t.transactionController.createTransferTransactionJSON({secrets:l,transaction:{fee:a,recipientId:r.to,applyBlockHeight:n,timestamp:o,remark:r.remark??{},effectiveBlockHeight:n+100},assetInfo:u})}async function te(r,t,e){const{nonce:s,...n}=e,a=await lt(r,t).broadcastTransaction(n);if(!a.success){const i=a.message??"Transaction rejected",l=a.minFee;throw new Error(l?`${i} (minFee: ${l})`:i)}return e.signature}async function ee(r,t,e,s){const o=(await D(r)).accountBaseHelper();try{if((await o.createSecondSecretKeypairV2(t,e)).publicKey.toString("hex")===s)return"v2"}catch{}try{if((await o.createSecondSecretKeypair(t,e)).publicKey.toString("hex")===s)return"v1"}catch{}return!1}async function Ws(r,t,e){const s=await D(e),n=await K(r,t),o=n.height,a=n.timestamp;return s.transactionController.getSignatureTransactionMinFee({newPaySecret:`${Date.now()}getSignatureTransactionMinFee`,applyBlockHeight:o,timestamp:a})}async function se(r){const t=await D(r.chainId),e=ut(r.chainId,r.apiPath),s=await K(r.rpcUrl,e),n=s.height,o=s.timestamp;let a=r.fee;return a||(a=await t.transactionController.getSignatureTransactionMinFee({newPaySecret:r.newPaySecret,applyBlockHeight:n,timestamp:o})),t.transactionController.createSignatureTransactionJSON({mainSecret:r.mainSecret},{newPaySecret:r.newPaySecret,fee:a,applyBlockHeight:n,timestamp:o,effectiveBlockHeight:n+100})}async function Vs(r){const t=ut(r.chainId,r.apiPath),e=await se({rpcUrl:r.rpcUrl,chainId:r.chainId,apiPath:t,mainSecret:r.mainSecret,newPaySecret:r.newPaySecret});return await te(r.rpcUrl,t,e).catch(()=>{}),{txHash:e.signature,success:!0}}const an=Object.freeze(Object.defineProperty({__proto__:null,broadcastTransaction:te,createSignatureTransaction:se,createTransferTransaction:js,getAddressInfo:Qt,getBioforestCore:D,getLastBlock:K,getSignatureTransactionMinFee:Ws,setTwoStepSecret:Vs,verifyTwoStepSecret:ee},Symbol.toStringTag,{value:"Module"}));class qs{chainId;config=null;apiUrl="";apiPath="";constructor(t){this.chainId=t}getConfig(){if(!this.config){const t=y.getConfig(this.chainId);if(!t)throw new T(v.CHAIN_NOT_FOUND,`Chain config not found: ${this.chainId}`);this.config=t;const e=y.getBiowalletApi(t.id);this.apiUrl=e?.endpoint??"",this.apiPath=e?.path??t.id}return this.config}async estimateFee(t){const e=this.getConfig(),{decimals:s,symbol:n}=e,o=(a,i)=>({amount:a,estimatedTime:i});try{if(!this.apiUrl)throw new Error("No RPC URL configured");const a=await D(e.id),i=await K(this.apiUrl,this.apiPath),l=await a.transactionController.getTransferTransactionMinFee({transaction:{applyBlockHeight:i.height,timestamp:i.timestamp,remark:{}},assetInfo:{sourceChainName:await a.getChainName(),sourceChainMagic:await a.getMagic(),assetType:t.amount?.symbol??n,amount:t.amount?.toRawString()??"0"}}),u=g.fromRaw(l,s,n);return{slow:o(u,30),standard:o(u,15),fast:o(u.mul(2),5)}}catch(a){console.warn("[TransactionService] Failed to get min fee from SDK, using default:",a);const i=g.fromRaw("1000",s,n);return{slow:o(i,30),standard:o(i,15),fast:o(i.mul(2),5)}}}async buildTransaction(t){const e=this.getConfig();if(!t.from||!t.to)throw new T(v.INVALID_ADDRESS,"Invalid address");const s=await this.estimateFee(t);return{chainId:e.id,data:{type:"transfer",from:t.from,to:t.to,amount:t.amount.toRawString(),assetType:e.symbol,fee:s.standard.amount.toRawString(),memo:t.memo,timestamp:Date.now()}}}async signTransaction(t,e){const s=t.data,n=JSON.stringify({type:s.type,from:s.from,to:s.to,amount:s.amount,assetType:s.assetType,fee:s.fee,timestamp:s.timestamp,memo:s.memo??""}),o=Bt(n,e),a=mt(o);return{chainId:t.chainId,data:{...s,signature:a,publicKey:mt(e.slice(32,64))},signature:a}}async broadcastTransaction(t){if(this.getConfig(),!this.apiUrl)throw new T(v.NETWORK_ERROR,"RPC URL not configured");try{const e=await fetch(`${this.apiUrl}/wallet/${this.apiPath}/transactions/broadcast`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({transaction:t.data})});if(!e.ok){const n=await e.json().catch(()=>({}));throw new T(v.TRANSACTION_REJECTED,n.message??`Broadcast failed: ${e.status}`)}const s=await e.json();if(!s.success)throw new T(v.TRANSACTION_REJECTED,s.error?.message??"Broadcast failed");return t.signature}catch(e){throw e instanceof T?e:new T(v.NETWORK_ERROR,"Failed to broadcast transaction",void 0,e instanceof Error?e:void 0)}}async getTransactionStatus(t){if(this.getConfig(),!this.apiUrl)return{status:"pending",confirmations:0,requiredConfirmations:1};try{const e=await fetch(`${this.apiUrl}/wallet/${this.apiPath}/transactions/query`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({signature:t})});if(!e.ok)return{status:"pending",confirmations:0,requiredConfirmations:1};const s=await e.json();return s.success&&s.result?.trs?.[0]?.height?{status:"confirmed",confirmations:1,requiredConfirmations:1}:{status:"pending",confirmations:0,requiredConfirmations:1}}catch{return{status:"pending",confirmations:0,requiredConfirmations:1}}}async getTransaction(t){if(this.getConfig(),!this.apiUrl)return null;try{const e=await fetch(`${this.apiUrl}/wallet/${this.apiPath}/transactions/query`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({signature:t})});if(!e.ok)return null;const s=await e.json();if(!s.success||!s.result?.trs?.[0])return null;const n=s.result.trs[0],o=n.transaction,{decimals:a,symbol:i}=this.config,l=o.asset?.transferAsset?.amount??"0";return{hash:o.signature,from:o.senderId,to:o.recipientId??"",amount:g.fromRaw(l,a,i),fee:g.fromRaw(o.fee,a,i),status:{status:"confirmed",confirmations:1,requiredConfirmations:1},timestamp:o.timestamp*1e3,blockNumber:BigInt(n.height),type:"transfer"}}catch{return null}}async getTransactionHistory(t,e=20){const s=this.getConfig();if(!this.apiUrl)return console.warn("[TransactionService] No baseUrl configured for chain:",s.id),[];try{const n=`${this.apiUrl}/wallet/${this.apiPath}/lastblock`,o=await fetch(n);if(!o.ok)return console.warn("[TransactionService] Failed to get lastblock:",o.status),[];const a=await o.json();if(!a.success)return console.warn("[TransactionService] lastblock API returned success=false"),[];const i=a.result.height,l=`${this.apiUrl}/wallet/${this.apiPath}/transactions/query`,u=await fetch(l,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({maxHeight:i,address:t,page:1,pageSize:e,sort:-1})});if(!u.ok)return console.warn("[TransactionService] API error:",u.status,u.statusText,"for",l),[];const d=await u.json();if(!d.success)return console.warn("[TransactionService] API returned success=false"),[];const h=d.result?.trs??[];if(h.length===0)return console.debug("[TransactionService] No transactions found for",t,"on",s.id),[];const{decimals:f,symbol:p}=s;return h.map(b=>{const S=b.transaction,I=S.type,R=S.asset?.transferAsset,O=R?.amount??S.fee??"0",oe=R?.assetType??p;return{hash:S.signature||`${b.signature}:${b.tIndex}`,from:S.senderId,to:S.recipientId??"",amount:g.fromRaw(O,f,oe),fee:g.fromRaw(S.fee,f,p),status:{status:"confirmed",confirmations:1,requiredConfirmations:1},timestamp:S.timestamp*1e3,blockNumber:BigInt(b.height),type:"transfer",rawType:I}})}catch(n){return console.error("[TransactionService] Failed to fetch history:",n),[]}}}const Js=[Ht,Kt,Ut,Lt,Wt,qt,Yt,zt,Zt];function Ys(r,t){for(const e of Js){const s=e(r,t);if(s)return s}return null}function Gs(r){const t=[];switch(r.chainKind){case"evm":{const e=new bs(r.id),s=new Ts(r.id),n=new Is(r.id);t.push(new M("wrapped-evm-tx",n,s),new H("wrapped-evm-identity",e));break}case"tron":{const e=new Ss(r.id),s=new As(r.id),n=new Es(r.id);t.push(new M("wrapped-tron-tx",n,s),new H("wrapped-tron-identity",e));break}case"bitcoin":{const e=new Ns(r.id),s=new _s(r.id),n=new Cs(r.id);t.push(new M("wrapped-bitcoin-tx",n,s),new H("wrapped-bitcoin-identity",e));break}case"bioforest":{const e=new Ps(r.id),s=new Os(r.id),n=new qs(r.id);t.push(new M("wrapped-bioforest-tx",n,s),new H("wrapped-bioforest-identity",e));break}}return t}function ne(r){const t=y.getApi(r),e=y.getConfig(r),s=[];for(const n of t){const o=Ys(n,r);o&&s.push(o)}if(e){const n=Gs(e);s.push(...n)}return new xt(r,s)}const rt=new Map;function zs(r){let t=rt.get(r);return t||(t=ne(r),rt.set(r,t)),t}function Xs(){rt.clear()}const rn=Object.freeze(Object.defineProperty({__proto__:null,ActionSchema:Ct,AssetSchema:Pt,BiowalletProvider:Mt,BscWalletProvider:Ft,BtcWalletProvider:Xt,ChainProvider:xt,DirectionSchema:$t,EthWalletProvider:Jt,EtherscanProvider:Ot,EvmRpcProvider:Dt,InvalidDataError:Rt,MempoolProvider:Vt,TransactionSchema:nt,TronRpcProvider:jt,TronWalletProvider:Gt,WrappedIdentityProvider:H,WrappedTransactionProvider:M,clearProviderCache:Xs,createBiowalletProvider:Ht,createBscWalletProvider:Kt,createBtcwalletProvider:Zt,createChainProvider:ne,createEtherscanProvider:Ut,createEthwalletProvider:Yt,createEvmRpcProvider:Lt,createFallbackResult:E,createMempoolProvider:qt,createSupportedResult:$,createTronRpcProvider:Wt,createTronwalletProvider:zt,getChainProvider:zs,isSupported:we,pickApiKey:ct},Symbol.toStringTag,{value:"Module"}));export{Ct as A,Ps as B,Ae as C,$t as D,Rt as I,ne as a,y as b,Xs as c,Pt as d,T as e,v as f,zs as g,Os as h,we as i,qs as j,xt as k,Qt as l,Ws as m,js as n,te as o,an as p,rn as q,Vs as s,ee as v};
