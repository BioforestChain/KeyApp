const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./index-wSp7Vo6A.js","./schemas-BX8BzOgD.js","./amount-BQsqQYGO.js","./bioforest-uXX5qE5N.js","./index-D0E7N0oa.js","./preload-helper-PPVm8Dsz.js","./index-LxS4rbbm.js","./iframe-CLYHcCRY.js","./iframe-mJ9ZJ2FV.css","./address-format-DY2duW3A.js"])))=>i.map(i=>d[i]);
import{_ as Qt}from"./preload-helper-PPVm8Dsz.js";import"./index-D0E7N0oa.js";import{b as Ot,e as U,f as Je,g as qe,v as Ln,r as Kn,j as _n,k as Dn,l as br,m as Er,h as bt,n as J,o as ie,q as On,s as vr,t as Ar,u as Me,w as Ze,x as Ir,y as Sr,z as Cr,A as en,B as tn,C as xr,D as nn,E as kr,F as Br,G as j,H as Z,I as Qe,J as Le,K as Et,L as Tr,M as ke,N as rn,O as Lr,P as Kr,Q as sn,R as _r,S as Dr,T as Or,U as Nr,V as Rr,W as Wr}from"./bioforest-uXX5qE5N.js";import{o as q,n as Y,b as he,s as A,a as Nt,c as et,r as Nn,u as Pr,d as Mr}from"./schemas-BX8BzOgD.js";import{S as Rt,u as ne}from"./iframe-CLYHcCRY.js";import{d as on}from"./address-format-DY2duW3A.js";const Rn=1e5,Ur=16,Wn=12,Wt=256;async function Pn(t,e){const n=new TextEncoder().encode(t),s=await crypto.subtle.importKey("raw",n,"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:Rn,hash:"SHA-256"},s,{name:"AES-GCM",length:Wt},!1,["encrypt","decrypt"])}async function Ue(t,e){const n=new TextEncoder().encode(t),s=crypto.getRandomValues(new Uint8Array(Ur)),o=crypto.getRandomValues(new Uint8Array(Wn)),i=await Pn(e,s),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},i,n);return{ciphertext:Be(a),salt:Be(s),iv:Be(o),iterations:Rn}}async function vt(t,e){const r=Te(t.salt),n=Te(t.iv),s=Te(t.ciphertext),o=await Pn(e,r);try{const i=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},o,s);return new TextDecoder().decode(i)}catch{throw new Error("解密失败：密码错误或数据损坏")}}async function Ho(t,e){try{return await vt(t,e),!0}catch{return!1}}async function it(t,e){const n=new TextEncoder().encode(t),s=crypto.getRandomValues(new Uint8Array(Wn)),o=await crypto.subtle.importKey("raw",e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength),{name:"AES-GCM",length:Wt},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},o,n);return{ciphertext:Be(i),salt:"",iv:Be(s),iterations:0}}async function an(t,e){const r=Te(t.iv),n=Te(t.ciphertext),s=await crypto.subtle.importKey("raw",e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength),{name:"AES-GCM",length:Wt},!1,["decrypt"]);try{const o=await crypto.subtle.decrypt({name:"AES-GCM",iv:r},s,n);return new TextDecoder().decode(o)}catch{throw new Error("解密失败：密钥错误或数据损坏")}}function Be(t){const e=t instanceof Uint8Array?t:new Uint8Array(t);let r="";for(let n=0;n<e.byteLength;n++)r+=String.fromCharCode(e[n]);return btoa(r)}function Te(t){const e=atob(t),r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r}class Mn{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(e,r){if(Ot(e),U(r,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?e.create().update(r).digest():r);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=e.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),Je(s)}update(e){return qe(this),this.iHash.update(e),this}digestInto(e){qe(this),U(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||=Object.create(Object.getPrototypeOf(this),{});const{oHash:r,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=r._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ke=(t,e,r)=>new Mn(t,e).update(r).digest();Ke.create=(t,e)=>new Mn(t,e);const cn=(t,e)=>(t+(t>=0?e:-e)/Un)/e;function Fr(t,e,r){const[[n,s],[o,i]]=e,a=cn(i*t,r),c=cn(-s*t,r);let d=t-a*n-c*o,h=-a*s-c*i;const y=d<te,g=h<te;y&&(d=-d),g&&(h=-h);const u=Dn(Math.ceil(kr(r)/2))+ye;if(d<te||d>=u||h<te||h>=u)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:y,k1:d,k2neg:g,k2:h}}function At(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function at(t,e){const r={};for(let n of Object.keys(e))r[n]=t[n]===void 0?e[n]:t[n];return Ze(r.lowS,"lowS"),Ze(r.prehash,"prehash"),r.format!==void 0&&At(r.format),r}class $r extends Error{constructor(e=""){super(e)}}const se={Err:$r,_tlv:{encode:(t,e)=>{const{Err:r}=se;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length&1)throw new r("tlv.encode: unpadded data");const n=e.length/2,s=Me(n);if(s.length/2&128)throw new r("tlv.encode: long form length too big");const o=n>127?Me(s.length/2|128):"";return Me(t)+o+s+e},decode(t,e){const{Err:r}=se;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const s=e[n++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new r("tlv.decode(long): indefinite length not supported");if(c>4)throw new r("tlv.decode(long): byte length is too big");const d=e.subarray(n,n+c);if(d.length!==c)throw new r("tlv.decode: length bytes not complete");if(d[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const h of d)i=i<<8|h;if(n+=c,i<128)throw new r("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+i);if(a.length!==i)throw new r("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+i)}}},_int:{encode(t){const{Err:e}=se;if(t<te)throw new e("integer: negative integers are not allowed");let r=Me(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=se;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return _n(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=se,s=U(t,void 0,"signature"),{v:o,l:i}=n.decode(48,s);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:d,l:h}=n.decode(2,c);if(h.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(d)}},hexFromSig(t){const{_tlv:e,_int:r}=se,n=e.encode(2,r.encode(t.r)),s=e.encode(2,r.encode(t.s)),o=n+s;return e.encode(48,o)}},te=BigInt(0),ye=BigInt(1),Un=BigInt(2),Fe=BigInt(3),Hr=BigInt(4);function zr(t,e={}){const r=Sr("weierstrass",t,e),{Fp:n,Fn:s}=r;let o=r.CURVE;const{h:i,n:a}=o;Ln(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!n.is0(o.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const d=$n(n,s);function h(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function y(T,p,f){const{x:l,y:w}=p.toAffine(),E=n.toBytes(l);if(Ze(f,"isCompressed"),f){h();const I=!n.isOdd(w);return J(Fn(I),E)}else return J(Uint8Array.of(4),E,n.toBytes(w))}function g(T){U(T,void 0,"Point");const{publicKey:p,publicKeyUncompressed:f}=d,l=T.length,w=T[0],E=T.subarray(1);if(l===p&&(w===2||w===3)){const I=n.fromBytes(E);if(!n.isValid(I))throw new Error("bad point: is not on curve, wrong x");const v=B(I);let b;try{b=n.sqrt(v)}catch(F){const O=F instanceof Error?": "+F.message:"";throw new Error("bad point: is not on curve, sqrt error"+O)}h();const S=n.isOdd(b);return(w&1)===1!==S&&(b=n.neg(b)),{x:I,y:b}}else if(l===f&&w===4){const I=n.BYTES,v=n.fromBytes(E.subarray(0,I)),b=n.fromBytes(E.subarray(I,I*2));if(!x(v,b))throw new Error("bad point: is not on curve");return{x:v,y:b}}else throw new Error(`bad point: got length ${l}, expected compressed=${p} or uncompressed=${f}`)}const u=e.toBytes||y,m=e.fromBytes||g;function B(T){const p=n.sqr(T),f=n.mul(p,T);return n.add(n.add(f,n.mul(T,o.a)),o.b)}function x(T,p){const f=n.sqr(p),l=B(T);return n.eql(f,l)}if(!x(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const K=n.mul(n.pow(o.a,Fe),Hr),Q=n.mul(n.sqr(o.b),BigInt(27));if(n.is0(n.add(K,Q)))throw new Error("bad curve params: a or b");function G(T,p,f=!1){if(!n.isValid(p)||f&&n.is0(p))throw new Error(`bad point coordinate ${T}`);return p}function z(T){if(!(T instanceof L))throw new Error("Weierstrass Point expected")}function de(T){if(!c||!c.basises)throw new Error("no endo");return Fr(T,c.basises,s.ORDER)}const re=en((T,p)=>{const{X:f,Y:l,Z:w}=T;if(n.eql(w,n.ONE))return{x:f,y:l};const E=T.is0();p==null&&(p=E?n.ONE:n.inv(w));const I=n.mul(f,p),v=n.mul(l,p),b=n.mul(w,p);if(E)return{x:n.ZERO,y:n.ZERO};if(!n.eql(b,n.ONE))throw new Error("invZ was invalid");return{x:I,y:v}}),ot=en(T=>{if(T.is0()){if(e.allowInfinityPoint&&!n.is0(T.Y))return;throw new Error("bad point: ZERO")}const{x:p,y:f}=T.toAffine();if(!n.isValid(p)||!n.isValid(f))throw new Error("bad point: x or y not field elements");if(!x(p,f))throw new Error("bad point: equation left != right");if(!T.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function me(T,p,f,l,w){return f=new L(n.mul(f.X,T),f.Y,f.Z),p=nn(l,p),f=nn(w,f),p.add(f)}class L{static BASE=new L(o.Gx,o.Gy,n.ONE);static ZERO=new L(n.ZERO,n.ONE,n.ZERO);static Fp=n;static Fn=s;X;Y;Z;constructor(p,f,l){this.X=G("x",p),this.Y=G("y",f,!0),this.Z=G("z",l),Object.freeze(this)}static CURVE(){return o}static fromAffine(p){const{x:f,y:l}=p||{};if(!p||!n.isValid(f)||!n.isValid(l))throw new Error("invalid affine point");if(p instanceof L)throw new Error("projective point not allowed");return n.is0(f)&&n.is0(l)?L.ZERO:new L(f,l,n.ONE)}static fromBytes(p){const f=L.fromAffine(m(U(p,void 0,"point")));return f.assertValidity(),f}static fromHex(p){return L.fromBytes(bt(p))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(p=8,f=!0){return le.createCache(this,p),f||this.multiply(Fe),this}assertValidity(){ot(this)}hasEvenY(){const{y:p}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(p)}equals(p){z(p);const{X:f,Y:l,Z:w}=this,{X:E,Y:I,Z:v}=p,b=n.eql(n.mul(f,v),n.mul(E,w)),S=n.eql(n.mul(l,v),n.mul(I,w));return b&&S}negate(){return new L(this.X,n.neg(this.Y),this.Z)}double(){const{a:p,b:f}=o,l=n.mul(f,Fe),{X:w,Y:E,Z:I}=this;let v=n.ZERO,b=n.ZERO,S=n.ZERO,C=n.mul(w,w),F=n.mul(E,E),O=n.mul(I,I),k=n.mul(w,E);return k=n.add(k,k),S=n.mul(w,I),S=n.add(S,S),v=n.mul(p,S),b=n.mul(l,O),b=n.add(v,b),v=n.sub(F,b),b=n.add(F,b),b=n.mul(v,b),v=n.mul(k,v),S=n.mul(l,S),O=n.mul(p,O),k=n.sub(C,O),k=n.mul(p,k),k=n.add(k,S),S=n.add(C,C),C=n.add(S,C),C=n.add(C,O),C=n.mul(C,k),b=n.add(b,C),O=n.mul(E,I),O=n.add(O,O),C=n.mul(O,k),v=n.sub(v,C),S=n.mul(O,F),S=n.add(S,S),S=n.add(S,S),new L(v,b,S)}add(p){z(p);const{X:f,Y:l,Z:w}=this,{X:E,Y:I,Z:v}=p;let b=n.ZERO,S=n.ZERO,C=n.ZERO;const F=o.a,O=n.mul(o.b,Fe);let k=n.mul(f,E),R=n.mul(l,I),$=n.mul(w,v),X=n.add(f,l),W=n.add(E,I);X=n.mul(X,W),W=n.add(k,R),X=n.sub(X,W),W=n.add(f,w);let H=n.add(E,v);return W=n.mul(W,H),H=n.add(k,$),W=n.sub(W,H),H=n.add(l,w),b=n.add(I,v),H=n.mul(H,b),b=n.add(R,$),H=n.sub(H,b),C=n.mul(F,W),b=n.mul(O,$),C=n.add(b,C),b=n.sub(R,C),C=n.add(R,C),S=n.mul(b,C),R=n.add(k,k),R=n.add(R,k),$=n.mul(F,$),W=n.mul(O,W),R=n.add(R,$),$=n.sub(k,$),$=n.mul(F,$),W=n.add(W,$),k=n.mul(R,W),S=n.add(S,k),k=n.mul(H,W),b=n.mul(X,b),b=n.sub(b,k),k=n.mul(X,R),C=n.mul(H,C),C=n.add(C,k),new L(b,S,C)}subtract(p){return this.add(p.negate())}is0(){return this.equals(L.ZERO)}multiply(p){const{endo:f}=e;if(!s.isValidNot0(p))throw new Error("invalid scalar: out of range");let l,w;const E=I=>le.cached(this,I,v=>tn(L,v));if(f){const{k1neg:I,k1:v,k2neg:b,k2:S}=de(p),{p:C,f:F}=E(v),{p:O,f:k}=E(S);w=F.add(k),l=me(f.beta,C,O,I,b)}else{const{p:I,f:v}=E(p);l=I,w=v}return tn(L,[l,w])[0]}multiplyUnsafe(p){const{endo:f}=e,l=this;if(!s.isValid(p))throw new Error("invalid scalar: out of range");if(p===te||l.is0())return L.ZERO;if(p===ye)return l;if(le.hasCache(this))return this.multiply(p);if(f){const{k1neg:w,k1:E,k2neg:I,k2:v}=de(p),{p1:b,p2:S}=xr(L,l,E,v);return me(f.beta,b,S,w,I)}else return le.unsafe(l,p)}toAffine(p){return re(this,p)}isTorsionFree(){const{isTorsionFree:p}=e;return i===ye?!0:p?p(L,this):le.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:p}=e;return i===ye?this:p?p(L,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(p=!0){return Ze(p,"isCompressed"),this.assertValidity(),u(L,this,p)}toHex(p=!0){return ie(this.toBytes(p))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const We=s.BITS,le=new Cr(L,e.endo?Math.ceil(We/2):We);return L.BASE.precompute(8),L}function Fn(t){return Uint8Array.of(t?2:3)}function $n(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function jr(t,e={}){const{Fn:r}=t,n=e.randomBytes||Kn,s=Object.assign($n(t.Fp,r),{seed:br(r.ORDER)});function o(u){try{const m=r.fromBytes(u);return r.isValidNot0(m)}catch{return!1}}function i(u,m){const{publicKey:B,publicKeyUncompressed:x}=s;try{const K=u.length;return m===!0&&K!==B||m===!1&&K!==x?!1:!!t.fromBytes(u)}catch{return!1}}function a(u=n(s.seed)){return Ar(U(u,s.seed,"seed"),r.ORDER)}function c(u,m=!0){return t.BASE.multiply(r.fromBytes(u)).toBytes(m)}function d(u){const{secretKey:m,publicKey:B,publicKeyUncompressed:x}=s;if(!On(u)||"_lengths"in r&&r._lengths||m===B)return;const K=U(u,void 0,"key").length;return K===B||K===x}function h(u,m,B=!0){if(d(u)===!0)throw new Error("first arg must be private key");if(d(m)===!1)throw new Error("second arg must be public key");const x=r.fromBytes(u);return t.fromBytes(m).multiply(x).toBytes(B)}const y={isValidSecretKey:o,isValidPublicKey:i,randomSecretKey:a},g=Er(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:h,keygen:g,Point:t,utils:y,lengths:s})}function Vr(t,e,r={}){Ot(e),Ln(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),r=Object.assign({},r);const n=r.randomBytes||Kn,s=r.hmac||((f,l)=>Ke(e,f,l)),{Fp:o,Fn:i}=t,{ORDER:a,BITS:c}=i,{keygen:d,getPublicKey:h,getSharedSecret:y,utils:g,lengths:u}=jr(t,r),m={prehash:!0,lowS:typeof r.lowS=="boolean"?r.lowS:!0,format:"compact",extraEntropy:!1},B=a*Un<o.ORDER;function x(f){const l=a>>ye;return f>l}function K(f,l){if(!i.isValidNot0(l))throw new Error(`invalid signature ${f}: out of range 1..Point.Fn.ORDER`);return l}function Q(){if(B)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function G(f,l){At(l);const w=u.signature,E=l==="compact"?w:l==="recovered"?w+1:void 0;return U(f,E)}class z{r;s;recovery;constructor(l,w,E){if(this.r=K("r",l),this.s=K("s",w),E!=null){if(Q(),![0,1,2,3].includes(E))throw new Error("invalid recovery id");this.recovery=E}Object.freeze(this)}static fromBytes(l,w=m.format){G(l,w);let E;if(w==="der"){const{r:S,s:C}=se.toSig(U(l));return new z(S,C)}w==="recovered"&&(E=l[0],w="compact",l=l.subarray(1));const I=u.signature/2,v=l.subarray(0,I),b=l.subarray(I,I*2);return new z(i.fromBytes(v),i.fromBytes(b),E)}static fromHex(l,w){return this.fromBytes(bt(l),w)}assertRecovery(){const{recovery:l}=this;if(l==null)throw new Error("invalid recovery id: must be present");return l}addRecoveryBit(l){return new z(this.r,this.s,l)}recoverPublicKey(l){const{r:w,s:E}=this,I=this.assertRecovery(),v=I===2||I===3?w+a:w;if(!o.isValid(v))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const b=o.toBytes(v),S=t.fromBytes(J(Fn((I&1)===0),b)),C=i.inv(v),F=re(U(l,void 0,"msgHash")),O=i.create(-F*C),k=i.create(E*C),R=t.BASE.multiplyUnsafe(O).add(S.multiplyUnsafe(k));if(R.is0())throw new Error("invalid recovery: point at infinify");return R.assertValidity(),R}hasHighS(){return x(this.s)}toBytes(l=m.format){if(At(l),l==="der")return bt(se.hexFromSig(this));const{r:w,s:E}=this,I=i.toBytes(w),v=i.toBytes(E);return l==="recovered"?(Q(),J(Uint8Array.of(this.assertRecovery()),I,v)):J(I,v)}toHex(l){return ie(this.toBytes(l))}}const de=r.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const w=_n(l),E=l.length*8-c;return E>0?w>>BigInt(E):w},re=r.bits2int_modN||function(l){return i.create(de(l))},ot=Dn(c);function me(f){return Ir("num < 2^"+c,f,te,ot),i.toBytes(f)}function L(f,l){return U(f,void 0,"message"),l?U(e(f),void 0,"prehashed message"):f}function We(f,l,w){const{lowS:E,prehash:I,extraEntropy:v}=at(w,m);f=L(f,I);const b=re(f),S=i.fromBytes(l);if(!i.isValidNot0(S))throw new Error("invalid private key");const C=[me(S),me(b)];if(v!=null&&v!==!1){const R=v===!0?n(u.secretKey):v;C.push(U(R,void 0,"extraEntropy"))}const F=J(...C),O=b;function k(R){const $=de(R);if(!i.isValidNot0($))return;const X=i.inv($),W=t.BASE.multiply($).toAffine(),H=i.create(W.x);if(H===te)return;const Pe=i.create(X*i.create(O+H*S));if(Pe===te)return;let Xt=(W.x===H?0:2)|Number(W.y&ye),Jt=Pe;return E&&x(Pe)&&(Jt=i.neg(Pe),Xt^=1),new z(H,Jt,B?void 0:Xt)}return{seed:F,k2sig:k}}function le(f,l,w={}){const{seed:E,k2sig:I}=We(f,l,w);return vr(e.outputLen,i.BYTES,s)(E,I).toBytes(w.format)}function T(f,l,w,E={}){const{lowS:I,prehash:v,format:b}=at(E,m);if(w=U(w,void 0,"publicKey"),l=L(l,v),!On(f)){const S=f instanceof z?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+S)}G(f,b);try{const S=z.fromBytes(f,b),C=t.fromBytes(w);if(I&&S.hasHighS())return!1;const{r:F,s:O}=S,k=re(l),R=i.inv(O),$=i.create(k*R),X=i.create(F*R),W=t.BASE.multiplyUnsafe($).add(C.multiplyUnsafe(X));return W.is0()?!1:i.create(W.x)===F}catch{return!1}}function p(f,l,w={}){const{prehash:E}=at(w,m);return l=L(l,E),z.fromBytes(f,"recovered").recoverPublicKey(l).toBytes()}return Object.freeze({keygen:d,getPublicKey:h,getSharedSecret:y,utils:g,lengths:u,Point:t,sign:le,verify:T,recoverPublicKey:p,Signature:z,hash:e})}const Pt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Yr={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},dn=BigInt(2);function qr(t){const e=Pt.p,r=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),d=t*t*t%e,h=d*d*t%e,y=Z(h,r,e)*h%e,g=Z(y,r,e)*h%e,u=Z(g,dn,e)*d%e,m=Z(u,s,e)*u%e,B=Z(m,o,e)*m%e,x=Z(B,a,e)*B%e,K=Z(x,c,e)*x%e,Q=Z(K,a,e)*B%e,G=Z(Q,r,e)*h%e,z=Z(G,i,e)*m%e,de=Z(z,n,e)*d%e,re=Z(de,dn,e);if(!It.eql(It.sqr(re),t))throw new Error("Cannot find square root");return re}const It=Br(Pt.p,{sqrt:qr}),Zr=zr(Pt,{Fp:It,endo:Yr}),oe=Vr(Zr,j);function _e(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Hn(t,e){return Array.isArray(e)?e.length===0?!0:t?e.every(r=>typeof r=="string"):e.every(r=>Number.isSafeInteger(r)):!1}function zn(t){if(typeof t!="function")throw new Error("function expected");return!0}function De(t,e){if(typeof e!="string")throw new Error(`${t}: string expected`);return!0}function Oe(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function Ge(t){if(!Array.isArray(t))throw new Error("array expected")}function jn(t,e){if(!Hn(!0,e))throw new Error(`${t}: array of strings expected`)}function Mt(t,e){if(!Hn(!1,e))throw new Error(`${t}: array of numbers expected`)}function Ut(...t){const e=o=>o,r=(o,i)=>a=>o(i(a)),n=t.map(o=>o.encode).reduceRight(r,e),s=t.map(o=>o.decode).reduce(r,e);return{encode:n,decode:s}}function Vn(t){const e=typeof t=="string"?t.split(""):t,r=e.length;jn("alphabet",e);const n=new Map(e.map((s,o)=>[s,o]));return{encode:s=>(Ge(s),s.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=r)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${t}`);return e[o]})),decode:s=>(Ge(s),s.map(o=>{De("alphabet.decode",o);const i=n.get(o);if(i===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${t}`);return i}))}}function Yn(t=""){return De("join",t),{encode:e=>(jn("join.decode",e),e.join(t)),decode:e=>(De("join.decode",e),e.split(t))}}function ln(t,e,r){if(e<2)throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);if(Ge(t),!t.length)return[];let n=0;const s=[],o=Array.from(t,a=>{if(Oe(a),a<0||a>=e)throw new Error(`invalid integer: ${a}`);return a}),i=o.length;for(;;){let a=0,c=!0;for(let d=n;d<i;d++){const h=o[d],y=e*a,g=y+h;if(!Number.isSafeInteger(g)||y/e!==a||g-h!==y)throw new Error("convertRadix: carry overflow");const u=g/r;a=g%r;const m=Math.floor(u);if(o[d]=m,!Number.isSafeInteger(m)||m*r+a!==g)throw new Error("convertRadix: carry overflow");if(c)m?c=!1:n=d;else continue}if(s.push(a),c)break}for(let a=0;a<t.length-1&&t[a]===0;a++)s.push(0);return s.reverse()}const qn=(t,e)=>e===0?t:qn(e,t%e),Xe=(t,e)=>t+(e-qn(t,e)),Ye=(()=>{let t=[];for(let e=0;e<40;e++)t.push(2**e);return t})();function St(t,e,r,n){if(Ge(t),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(Xe(e,r)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${Xe(e,r)}`);let s=0,o=0;const i=Ye[e],a=Ye[r]-1,c=[];for(const d of t){if(Oe(d),d>=i)throw new Error(`convertRadix2: invalid data word=${d} from=${e}`);if(s=s<<e|d,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=r;o-=r)c.push((s>>o-r&a)>>>0);const h=Ye[o];if(h===void 0)throw new Error("invalid carry");s&=h-1}if(s=s<<r-o&a,!n&&o>=e)throw new Error("Excess padding");if(!n&&s>0)throw new Error(`Non-zero padding: ${s}`);return n&&o>0&&c.push(s>>>0),c}function Gr(t){Oe(t);const e=2**8;return{encode:r=>{if(!_e(r))throw new Error("radix.encode input should be Uint8Array");return ln(Array.from(r),e,t)},decode:r=>(Mt("radix.decode",r),Uint8Array.from(ln(r,t,e)))}}function Xr(t,e=!1){if(Oe(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(Xe(8,t)>32||Xe(t,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!_e(r))throw new Error("radix2.encode input should be Uint8Array");return St(Array.from(r),8,t,!e)},decode:r=>(Mt("radix2.decode",r),Uint8Array.from(St(r,t,8,e)))}}function un(t){return zn(t),function(...e){try{return t.apply(null,e)}catch{}}}function Jr(t,e){return Oe(t),zn(e),{encode(r){if(!_e(r))throw new Error("checksum.encode: input should be Uint8Array");const n=e(r).slice(0,t),s=new Uint8Array(r.length+t);return s.set(r),s.set(n,r.length),s},decode(r){if(!_e(r))throw new Error("checksum.decode: input should be Uint8Array");const n=r.slice(0,-t),s=r.slice(-t),o=e(n).slice(0,t);for(let i=0;i<t;i++)if(o[i]!==s[i])throw new Error("Invalid checksum");return n}}}const Qr=t=>Ut(Gr(58),Vn(t),Yn("")),es=Qr("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),Zn=t=>Ut(Jr(4,e=>t(t(e))),es),zo=Zn,Ct=Ut(Vn("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),Yn("")),fn=[996825010,642813549,513874426,1027748829,705979059];function ge(t){const e=t>>25;let r=(t&33554431)<<5;for(let n=0;n<fn.length;n++)(e>>n&1)===1&&(r^=fn[n]);return r}function hn(t,e,r=1){const n=t.length;let s=1;for(let o=0;o<n;o++){const i=t.charCodeAt(o);if(i<33||i>126)throw new Error(`Invalid prefix (${t})`);s=ge(s)^i>>5}s=ge(s);for(let o=0;o<n;o++)s=ge(s)^t.charCodeAt(o)&31;for(let o of e)s=ge(s)^o;for(let o=0;o<6;o++)s=ge(s);return s^=r,Ct.encode(St([s%Ye[30]],30,5,!1))}function Gn(t){const e=t==="bech32"?1:734539939,r=Xr(5),n=r.decode,s=r.encode,o=un(n);function i(y,g,u=90){De("bech32.encode prefix",y),_e(g)&&(g=Array.from(g)),Mt("bech32.encode",g);const m=y.length;if(m===0)throw new TypeError(`Invalid prefix length ${m}`);const B=m+7+g.length;if(u!==!1&&B>u)throw new TypeError(`Length ${B} exceeds limit ${u}`);const x=y.toLowerCase(),K=hn(x,g,e);return`${x}1${Ct.encode(g)}${K}`}function a(y,g=90){De("bech32.decode input",y);const u=y.length;if(u<8||g!==!1&&u>g)throw new TypeError(`invalid string length: ${u} (${y}). Expected (8..${g})`);const m=y.toLowerCase();if(y!==m&&y!==y.toUpperCase())throw new Error("String must be lowercase or uppercase");const B=m.lastIndexOf("1");if(B===0||B===-1)throw new Error('Letter "1" must be present between prefix and data only');const x=m.slice(0,B),K=m.slice(B+1);if(K.length<6)throw new Error("Data must be at least 6 characters long");const Q=Ct.decode(K).slice(0,-6),G=hn(x,Q,e);if(!K.endsWith(G))throw new Error(`Invalid checksum in ${y}: expected "${G}"`);return{prefix:x,words:Q}}const c=un(a);function d(y){const{prefix:g,words:u}=a(y,!1);return{prefix:g,words:u,bytes:n(u)}}function h(y,g){return i(y,s(g))}return{encode:i,decode:a,encodeFromBytes:h,decodeToBytes:d,decodeUnsafe:c,fromWords:n,fromWordsUnsafe:o,toWords:s}}const jo=Gn("bech32"),Vo=Gn("bech32m");const Ce=oe.Point,{Fn:be}=Ce,ct=Zn(j),ts=Uint8Array.from("Bitcoin seed".split(""),t=>t.charCodeAt(0)),dt={private:76066276,public:76067358},lt=2147483648,ns=t=>Le(j(t)),rs=t=>Qe(t).getUint32(0,!1),$e=t=>{if(!Number.isSafeInteger(t)||t<0||t>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+t);const e=new Uint8Array(4);return Qe(e).setUint32(0,t,!1),e};class fe{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return rs(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const e=this._privateKey;if(!e)throw new Error("No private key");return ct.encode(this.serialize(this.versions.private,J(Uint8Array.of(0),e)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return ct.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(e,r=dt){if(U(e),8*e.length<128||8*e.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+e.length);const n=Ke(Et,ts,e),s=n.slice(0,32),o=n.slice(32);return new fe({versions:r,chainCode:o,privateKey:s})}static fromExtendedKey(e,r=dt){const n=ct.decode(e),s=Qe(n),o=s.getUint32(0,!1),i={versions:r,depth:n[4],parentFingerprint:s.getUint32(5,!1),index:s.getUint32(9,!1),chainCode:n.slice(13,45)},a=n.slice(45),c=a[0]===0;if(o!==r[c?"private":"public"])throw new Error("Version mismatch");return c?new fe({...i,privateKey:a.slice(1)}):new fe({...i,publicKey:a})}static fromJSON(e){return fe.fromExtendedKey(e.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(e){if(!e||typeof e!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||dt,this.depth=e.depth||0,this.chainCode=e.chainCode||null,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!oe.utils.isValidSecretKey(e.privateKey))throw new Error("Invalid private key");this._privateKey=e.privateKey,this._publicKey=oe.getPublicKey(e.privateKey,!0)}else if(e.publicKey)this._publicKey=Ce.fromBytes(e.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=ns(this._publicKey)}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;const r=e.replace(/^[mM]'?\//,"").split("/");let n=this;for(const s of r){const o=/^(\d+)('?)$/.exec(s),i=o&&o[1];if(!o||o.length!==3||typeof i!="string")throw new Error("invalid child index: "+s);let a=+i;if(!Number.isSafeInteger(a)||a>=lt)throw new Error("Invalid index");o[2]==="'"&&(a+=lt),n=n.deriveChild(a)}return n}deriveChild(e){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let r=$e(e);if(e>=lt){const c=this._privateKey;if(!c)throw new Error("Could not derive hardened child key");r=J(Uint8Array.of(0),c,r)}else r=J(this._publicKey,r);const n=Ke(Et,this.chainCode,r),s=n.slice(0,32),o=n.slice(32);if(!oe.utils.isValidSecretKey(s))throw new Error("Tweak bigger than curve order");const i={versions:this.versions,chainCode:o,depth:this.depth+1,parentFingerprint:this.fingerprint,index:e},a=be.fromBytes(s);try{if(this._privateKey){const c=be.create(be.fromBytes(this._privateKey)+a);if(!be.isValidNot0(c))throw new Error("The tweak was out of range or the resulted private key is invalid");i.privateKey=be.toBytes(c)}else{const c=Ce.fromBytes(this._publicKey).add(Ce.BASE.multiply(a));if(c.equals(Ce.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");i.publicKey=c.toBytes(!0)}return new fe(i)}catch{return this.deriveChild(e+1)}}sign(e){if(!this._privateKey)throw new Error("No privateKey set!");return U(e,32),oe.sign(e,this._privateKey,{prehash:!1})}verify(e,r){if(U(e,32),U(r,64),!this._publicKey)throw new Error("No publicKey set!");return oe.verify(r,e,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,r){if(!this.chainCode)throw new Error("No chainCode set");return U(r,33),J($e(e),new Uint8Array([this.depth]),$e(this.parentFingerprint),$e(this.index),this.chainCode,r)}}function ss(t,e,r,n){Ot(t);const s=Tr({dkLen:32,asyncTick:10},n),{c:o,dkLen:i,asyncTick:a}=s;if(ke(o,"c"),ke(i,"dkLen"),ke(a,"asyncTick"),o<1)throw new Error("iterations (c) must be >= 1");const c=rn(e,"password"),d=rn(r,"salt"),h=new Uint8Array(i),y=Ke.create(t,c),g=y._cloneInto().update(d);return{c:o,dkLen:i,asyncTick:a,DK:h,PRF:y,PRFSalt:g}}function os(t,e,r,n,s){return t.destroy(),e.destroy(),n&&n.destroy(),Je(s),r}function is(t,e,r,n){const{c:s,dkLen:o,DK:i,PRF:a,PRFSalt:c}=ss(t,e,r,n);let d;const h=new Uint8Array(4),y=Qe(h),g=new Uint8Array(a.outputLen);for(let u=1,m=0;m<o;u++,m+=a.outputLen){const B=i.subarray(m,m+a.outputLen);y.setInt32(0,u,!1),(d=c._cloneInto(d)).update(h).digestInto(g),B.set(g.subarray(0,B.length));for(let x=1;x<s;x++){a._cloneInto(d).update(g).digestInto(g);for(let K=0;K<B.length;K++)B[K]^=g[K]}}return os(a,c,i,d,g)}function Xn(t){if(typeof t!="string")throw new TypeError("invalid mnemonic type: "+typeof t);return t.normalize("NFKD")}function as(t){const e=Xn(t),r=e.split(" ");if(![12,15,18,21,24].includes(r.length))throw new Error("Invalid mnemonic");return{nfkd:e,words:r}}const cs=t=>Xn("mnemonic"+t);function ds(t,e=""){return is(Et,as(t).nfkd,cs(e),{c:2048,dkLen:64})}const ls=BigInt(0),Ee=BigInt(1),us=BigInt(2),fs=BigInt(7),hs=BigInt(256),ps=BigInt(113),Jn=[],Qn=[],er=[];for(let t=0,e=Ee,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],Jn.push(2*(5*n+r)),Qn.push((t+1)*(t+2)/2%64);let s=ls;for(let o=0;o<7;o++)e=(e<<Ee^(e>>fs)*ps)%hs,e&us&&(s^=Ee<<(Ee<<BigInt(o))-Ee);er.push(s)}const tr=Wr(er,!0),ys=tr[0],ws=tr[1],pn=(t,e,r)=>r>32?Nr(t,e,r):Dr(t,e,r),yn=(t,e,r)=>r>32?Rr(t,e,r):Or(t,e,r);function ms(t,e=24){const r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let i=0;i<10;i++)r[i]=t[i]^t[i+10]^t[i+20]^t[i+30]^t[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,d=r[c],h=r[c+1],y=pn(d,h,1)^r[a],g=yn(d,h,1)^r[a+1];for(let u=0;u<50;u+=10)t[i+u]^=y,t[i+u+1]^=g}let s=t[2],o=t[3];for(let i=0;i<24;i++){const a=Qn[i],c=pn(s,o,a),d=yn(s,o,a),h=Jn[i];s=t[h],o=t[h+1],t[h]=c,t[h+1]=d}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)r[a]=t[i+a];for(let a=0;a<10;a++)t[i+a]^=~r[(a+2)%10]&r[(a+4)%10]}t[0]^=ys[n],t[1]^=ws[n]}Je(r)}class Ft{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(e,r,n,s=!1,o=24){if(this.blockLen=e,this.suffix=r,this.outputLen=n,this.enableXOF=s,this.rounds=o,ke(n,"outputLen"),!(0<e&&e<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=Kr(this.state)}clone(){return this._cloneInto()}keccak(){sn(this.state32),ms(this.state32,this.rounds),sn(this.state32),this.posOut=0,this.pos=0}update(e){qe(this),U(e);const{blockLen:r,state:n}=this,s=e.length;for(let o=0;o<s;){const i=Math.min(r-this.pos,s-o);for(let a=0;a<i;a++)n[this.pos++]^=e[o++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:r,pos:n,blockLen:s}=this;e[n]^=r,(r&128)!==0&&n===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){qe(this,!1),U(e),this.finish();const r=this.state,{blockLen:n}=this;for(let s=0,o=e.length;s<o;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,o-s);e.set(r.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return ke(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(_r(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,Je(this.state)}_cloneInto(e){const{blockLen:r,suffix:n,outputLen:s,rounds:o,enableXOF:i}=this;return e||=new Ft(r,n,s,i,o),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=n,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}}const gs=(t,e,r,n={})=>Lr(()=>new Ft(e,t,r),n),$t=gs(1,136,32),nr={ethereum:60,bitcoin:0,tron:195,bfmeta:9999};function Ht(t,e){const r=ds(t,e);return fe.fromMasterSeed(r)}function bs(t,e=0,r=0,n=0){return`m/44'/${nr[t]}'/${e}'/${r}/${n}`}function Es(t,e,r=0,n=0,s=0){return`m/${t}'/${e}'/${r}'/${n}/${s}`}function zt(t,e){return t.derive(e)}function wn(t){const r=oe.getPublicKey(t,!1).slice(1),s=$t(r).slice(-20);return"0x"+ie(s)}function mn(t){const e=t.toLowerCase().replace("0x",""),r=new TextEncoder,n=ie($t(r.encode(e)));let s="0x";for(let o=0;o<e.length;o++)parseInt(n[o],16)>=8?s+=e[o].toUpperCase():s+=e[o];return s}function rr(t,e="mainnet"){const r=j(t),n=Le(r),s=e==="mainnet"?0:111,o=new Uint8Array([s,...n]),i=j(j(o)).slice(0,4),a=new Uint8Array([...o,...i]);return jt(a)}function vs(t,e="mainnet"){const r=j(t),n=Le(r),s=new Uint8Array([0,20,...n]),o=j(s),i=Le(o),a=e==="mainnet"?5:196,c=new Uint8Array([a,...i]),d=j(j(c)).slice(0,4),h=new Uint8Array([...c,...d]);return jt(h)}function As(t,e="mainnet"){const r=j(t),n=Le(r);return Bs(e==="mainnet"?"bc":"tb",0,n)}function Is(t,e="mainnet"){const r=t.length===33?t.slice(1):t.slice(1,33);return Ts(e==="mainnet"?"bc":"tb",1,r)}function Ss(t){const r=oe.getPublicKey(t,!1).slice(1),s=$t(r).slice(-20),o=new Uint8Array([65,...s]),i=j(j(o)).slice(0,4),a=new Uint8Array([...o,...i]);return jt(a)}const gn="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";function jt(t){const e=[0];for(const n of t){let s=n;for(let o=0;o<e.length;o++)s+=e[o]<<8,e[o]=s%58,s=s/58|0;for(;s>0;)e.push(s%58),s=s/58|0}let r="";for(const n of t)if(n===0)r+=gn[0];else break;for(let n=e.length-1;n>=0;n--)r+=gn[e[n]];return r}const sr="qpzry9x8gf2tvdw0s3jn54khce6mua7l",Cs=[996825010,642813549,513874426,1027748829,705979059];function xs(t){let e=1;for(const r of t){const n=e>>25;e=(e&33554431)<<5^r;for(let s=0;s<5;s++)n>>s&1&&(e^=Cs[s])}return e}function ks(t){const e=[];for(const r of t)e.push(r.charCodeAt(0)>>5);e.push(0);for(const r of t)e.push(r.charCodeAt(0)&31);return e}function or(t,e,r){const n=[...ks(t),...e],s=r?734539939:1,o=xs([...n,0,0,0,0,0,0])^s,i=[];for(let a=0;a<6;a++)i.push(o>>5*(5-a)&31);return i}function ir(t,e,r,n){let s=0,o=0;const i=[],a=(1<<r)-1;for(const c of t)for(s=s<<e|c,o+=e;o>=r;)o-=r,i.push(s>>o&a);return o>0&&i.push(s<<r-o&a),i}function Bs(t,e,r){const n=ir(r,8,5),s=[e,...n],o=or(t,s,!1),i=[...s,...o].map(a=>sr[a]).join("");return`${t}1${i}`}function Ts(t,e,r){const n=ir(r,8,5),s=[e,...n],o=or(t,s,!0),i=[...s,...o].map(a=>sr[a]).join("");return`${t}1${i}`}function ut(t,e,r=0,n=0){const s=Ht(t),o=bs(e,n,0,r),i=zt(s,o);if(!i.privateKey||!i.publicKey)throw new Error("密钥派生失败");const a=ie(i.privateKey),c=ie(i.publicKey);let d;switch(e){case"ethereum":d=mn(wn(i.privateKey));break;case"bitcoin":d=rr(i.publicKey);break;case"tron":d=Ss(i.privateKey);break;case"bfmeta":d=mn(wn(i.privateKey));break;default:throw new Error(`不支持的链类型: ${e}`)}return{privateKey:a,publicKey:c,address:d,path:o,chain:e}}function Ls(t,e=44,r=0,n=0,s="mainnet"){const o=Ht(t),i=Es(e,nr.bitcoin,n,0,r),a=zt(o,i);if(!a.privateKey||!a.publicKey)throw new Error("密钥派生失败");const c=ie(a.privateKey),d=ie(a.publicKey);let h;switch(e){case 44:h=rr(a.publicKey,s);break;case 49:h=vs(a.publicKey,s);break;case 84:h=As(a.publicKey,s);break;case 86:h=Is(a.publicKey,s);break;default:throw new Error(`不支持的 Bitcoin purpose: ${e}`)}return{privateKey:c,publicKey:d,address:h,path:i,chain:"bitcoin",purpose:e}}function Ks(t,e=0,r=0,n="mainnet"){return[44,49,84,86].map(o=>Ls(t,o,e,r,n))}function Yo(t,e=0,r=0){const n=[];return n.push(ut(t,"ethereum",e,r)),n.push(ut(t,"bfmeta",e,r)),n.push(ut(t,"tron",e,r)),n.push(...Ks(t,e,r)),n}function He(t){const e=Ht(t),n=zt(e,"m/44'/9999'/0'/1/0");if(!n.privateKey)throw new Error("密钥派生失败");return n.privateKey}function ze(t){const r=new TextEncoder().encode(`KeyApp:EncryptionKey:${t}`);return j(r)}function qo(t,e){switch(e){case"ethereum":case"bfmeta":return/^0x[a-fA-F0-9]{40}$/.test(t);case"bitcoin":return/^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(t)||/^bc1q[a-z0-9]{38,}$/.test(t)||/^bc1p[a-z0-9]{58}$/.test(t);case"tron":return/^T[a-zA-Z0-9]{33}$/.test(t);default:return!1}}const xt=(t,e)=>e.some(r=>t instanceof r);let bn,En;function _s(){return bn||(bn=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function Ds(){return En||(En=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const kt=new WeakMap,ft=new WeakMap,tt=new WeakMap;function Os(t){const e=new Promise((r,n)=>{const s=()=>{t.removeEventListener("success",o),t.removeEventListener("error",i)},o=()=>{r(pe(t.result)),s()},i=()=>{n(t.error),s()};t.addEventListener("success",o),t.addEventListener("error",i)});return tt.set(e,t),e}function Ns(t){if(kt.has(t))return;const e=new Promise((r,n)=>{const s=()=>{t.removeEventListener("complete",o),t.removeEventListener("error",i),t.removeEventListener("abort",i)},o=()=>{r(),s()},i=()=>{n(t.error||new DOMException("AbortError","AbortError")),s()};t.addEventListener("complete",o),t.addEventListener("error",i),t.addEventListener("abort",i)});kt.set(t,e)}let Bt={get(t,e,r){if(t instanceof IDBTransaction){if(e==="done")return kt.get(t);if(e==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return pe(t[e])},set(t,e,r){return t[e]=r,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function ar(t){Bt=t(Bt)}function Rs(t){return Ds().includes(t)?function(...e){return t.apply(Tt(this),e),pe(this.request)}:function(...e){return pe(t.apply(Tt(this),e))}}function Ws(t){return typeof t=="function"?Rs(t):(t instanceof IDBTransaction&&Ns(t),xt(t,_s())?new Proxy(t,Bt):t)}function pe(t){if(t instanceof IDBRequest)return Os(t);if(ft.has(t))return ft.get(t);const e=Ws(t);return e!==t&&(ft.set(t,e),tt.set(e,t)),e}const Tt=t=>tt.get(t);function Ps(t,e,{blocked:r,upgrade:n,blocking:s,terminated:o}={}){const i=indexedDB.open(t,e),a=pe(i);return n&&i.addEventListener("upgradeneeded",c=>{n(pe(i.result),c.oldVersion,c.newVersion,pe(i.transaction),c)}),r&&i.addEventListener("blocked",c=>r(c.oldVersion,c.newVersion,c)),a.then(c=>{o&&c.addEventListener("close",()=>o()),s&&c.addEventListener("versionchange",d=>s(d.oldVersion,d.newVersion,d))}).catch(()=>{}),a}const Ms=["get","getKey","getAll","getAllKeys","count"],Us=["put","add","delete","clear"],ht=new Map;function vn(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(ht.get(e))return ht.get(e);const r=e.replace(/FromIndex$/,""),n=e!==r,s=Us.includes(r);if(!(r in(n?IDBIndex:IDBObjectStore).prototype)||!(s||Ms.includes(r)))return;const o=async function(i,...a){const c=this.transaction(i,s?"readwrite":"readonly");let d=c.store;return n&&(d=d.index(a.shift())),(await Promise.all([d[r](...a),s&&c.done]))[0]};return ht.set(e,o),o}ar(t=>({...t,get:(e,r,n)=>vn(e,r)||t.get(e,r,n),has:(e,r)=>!!vn(e,r)||t.has(e,r)}));const Fs=["continue","continuePrimaryKey","advance"],An={},Lt=new WeakMap,cr=new WeakMap,$s={get(t,e){if(!Fs.includes(e))return t[e];let r=An[e];return r||(r=An[e]=function(...n){Lt.set(this,cr.get(this)[e](...n))}),r}};async function*Hs(...t){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...t)),!e)return;e=e;const r=new Proxy(e,$s);for(cr.set(r,e),tt.set(r,Tt(e));e;)yield r,e=await(Lt.get(r)||e.continue()),Lt.delete(r)}function In(t,e){return e===Symbol.asyncIterator&&xt(t,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&xt(t,[IDBIndex,IDBObjectStore])}ar(t=>({...t,get(e,r,n){return In(e,r)?Hs:t.get(e,r,n)},has(e,r){return In(e,r)||t.has(e,r)}}));function ve(t,e,r){if(!Array.isArray(e))return console.warn(`[safeParse] Expected array from ${r}, got ${typeof e}`),[];const n=[];for(let s=0;s<e.length;s++){const o=t.safeParse(e[s]);o.success?n.push(o.data):console.warn(`[safeParse] Invalid item at index ${s} from ${r}:`,o.error.issues[0])}return n}const je=2;var D=(t=>(t.NOT_INITIALIZED="STORAGE_NOT_INITIALIZED",t.WALLET_NOT_FOUND="WALLET_NOT_FOUND",t.ADDRESS_NOT_FOUND="ADDRESS_NOT_FOUND",t.DECRYPTION_FAILED="DECRYPTION_FAILED",t.ENCRYPTION_FAILED="ENCRYPTION_FAILED",t.STORAGE_FULL="STORAGE_FULL",t.MIGRATION_FAILED="MIGRATION_FAILED",t.INVALID_PASSWORD="INVALID_PASSWORD",t))(D||{});class N extends Error{constructor(e,r,n){super(r),this.code=e,this.cause=n,this.name="WalletStorageError"}}class dr extends Error{code="WALLET_MIGRATION_REQUIRED";storedVersion;requiredVersion;constructor(e,r){super(`Wallet storage migration required: v${e} → v${r}`),this.name="WalletStorageMigrationError",this.storedVersion=e,this.requiredVersion=r}}const Kt=q({salt:A(),iv:A(),ciphertext:A()}).passthrough(),zs=q({assetType:A(),symbol:A(),decimals:Y(),balance:A().default("0"),contractAddress:A().optional(),logoUrl:A().optional()}).passthrough(),pt=q({addressKey:A(),walletId:A(),chain:A(),address:A(),publicKey:A().optional(),encryptedPrivateKey:Kt.optional(),derivationPath:A().optional(),assets:et(zs).default([]),isCustomAssets:he().default(!1),isFrozen:he().default(!1)}).passthrough(),Sn=q({id:A(),name:A(),keyType:Nt(["mnemonic","arbitrary","privateKey"]),primaryChain:A(),primaryAddress:A(),encryptedMnemonic:Kt.optional(),encryptedWalletLock:Kt.optional(),isBackedUp:he().default(!1),themeHue:Y().optional(),createdAt:Y(),updatedAt:Y()}).passthrough(),js=q({name:A(),passwordTips:A().optional(),activeWalletId:A().nullable(),biometricEnabled:he().default(!1),walletLockEnabled:he().default(!0),agreementAccepted:he().default(!1),createdAt:Y(),updatedAt:Y()}).passthrough();q({version:Y(),createdAt:Y(),lastMigratedAt:Y().optional()}).passthrough();const yt=q({id:A(),chain:A(),address:A(),name:A(),note:A().optional(),createdAt:Y(),updatedAt:Y()}).passthrough(),Vs="bfm-wallet-db",Ys=1;class qs{db=null;initialized=!1;async initialize(){if(this.initialized)return;this.db=await Ps(Vs,Ys,{upgrade(n,s,o,i){let a;if(n.objectStoreNames.contains("metadata")||(a=n.createObjectStore("metadata")),n.objectStoreNames.contains("walleter")||n.createObjectStore("walleter"),n.objectStoreNames.contains("wallets")||n.createObjectStore("wallets",{keyPath:"id"}).createIndex("by-chain","primaryChain"),!n.objectStoreNames.contains("chainAddresses")){const c=n.createObjectStore("chainAddresses",{keyPath:"addressKey"});c.createIndex("by-wallet","walletId"),c.createIndex("by-chain","chain")}n.objectStoreNames.contains("addressBook")||n.createObjectStore("addressBook",{keyPath:"id"}).createIndex("by-chain","chain"),s===0&&a?a.put({version:je,createdAt:Date.now()},"main"):s===0&&i.objectStore("metadata").put({version:je,createdAt:Date.now()},"main")}}),this.initialized=!0;const r=(await this.getMetadata())?.version??0;if(r>0&&r<je)throw new dr(r,je);await this.runMigrations()}isInitialized(){return this.initialized}ensureInitialized(){if(!this.initialized||!this.db)throw new N(D.NOT_INITIALIZED,"Storage service not initialized. Call initialize() first.")}async getMetadata(){return this.ensureInitialized(),await this.db.get("metadata","main")??null}async saveWalleterInfo(e){this.ensureInitialized(),await this.db.put("walleter",e,"main")}async getWalleterInfo(){this.ensureInitialized();const e=await this.db.get("walleter","main");if(!e)return null;const r=js.safeParse(e);return r.success?r.data:(console.warn("[WalletStorage] Invalid walleter info:",r.error.issues[0]),null)}async createWallet(e,r,n){if(this.ensureInitialized(),!r||typeof r!="string")throw new N(D.ENCRYPTION_FAILED,"Invalid mnemonic: mnemonic is required");if(!n||typeof n!="string")throw new N(D.ENCRYPTION_FAILED,"Invalid walletLock: wallet lock password is required");if(typeof crypto>"u"||!crypto.subtle)throw new N(D.ENCRYPTION_FAILED,"Web Crypto API is not available. Please use HTTPS or localhost.");try{const s=await Ue(r,n),o=e.keyType==="mnemonic"?He(r):ze(r),i=await it(n,o),a={...e,encryptedMnemonic:s,encryptedWalletLock:i};return await this.db.put("wallets",a),a}catch(s){const o=s instanceof Error?s.message:String(s);throw new N(D.ENCRYPTION_FAILED,`Failed to encrypt wallet data: ${o}`,s instanceof Error?s:void 0)}}async saveWallet(e){this.ensureInitialized(),await this.db.put("wallets",e)}async getWallet(e){this.ensureInitialized();const r=await this.db.get("wallets",e);if(!r)return null;const n=Sn.safeParse(r);return n.success?n.data:(console.warn("[WalletStorage] Invalid wallet info:",n.error.issues[0]),null)}async getAllWallets(){this.ensureInitialized();const e=await this.db.getAll("wallets");return ve(Sn,e,"indexeddb:wallets")}async updateWallet(e,r){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new N(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);await this.db.put("wallets",{...n,...r,updatedAt:Date.now()})}async deleteWallet(e){this.ensureInitialized(),await this.db.delete("wallets",e);const r=await this.getWalletChainAddresses(e),n=this.db.transaction("chainAddresses","readwrite");await Promise.all(r.map(s=>n.store.delete(s.addressKey))),await n.done}async getMnemonic(e,r){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new N(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!n.encryptedMnemonic)throw new N(D.DECRYPTION_FAILED,"No encrypted mnemonic found for this wallet");try{return await vt(n.encryptedMnemonic,r)}catch(s){throw new N(D.DECRYPTION_FAILED,"Failed to decrypt mnemonic. Wrong password or corrupted data.",s instanceof Error?s:void 0)}}async updateWalletLockEncryption(e,r,n){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new N(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);const o=await this.getMnemonic(e,r);try{const i=await Ue(o,n),a=s.keyType==="mnemonic"?He(o):ze(o),c=await it(n,a);await this.updateWallet(e,{encryptedMnemonic:i,encryptedWalletLock:c})}catch(i){throw new N(D.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",i instanceof Error?i:void 0)}}async verifyMnemonic(e,r){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new N(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!n.encryptedWalletLock)throw new N(D.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");try{const s=n.keyType==="mnemonic"?He(r):ze(r);return await an(n.encryptedWalletLock,s),!0}catch{return!1}}async resetWalletLockByMnemonic(e,r,n){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new N(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!s.encryptedWalletLock)throw new N(D.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");const o=s.keyType==="mnemonic"?He(r):ze(r);try{await an(s.encryptedWalletLock,o)}catch{throw new N(D.INVALID_PASSWORD,"Invalid mnemonic/secret: failed to decrypt wallet lock")}try{const i=await Ue(r,n),a=await it(n,o);await this.updateWallet(e,{encryptedMnemonic:i,encryptedWalletLock:a})}catch(i){throw new N(D.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",i instanceof Error?i:void 0)}}async savePrivateKey(e,r,n){this.ensureInitialized();const s=await this.getChainAddress(e);if(!s)throw new N(D.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);try{const o=await Ue(r,n);await this.db.put("chainAddresses",{...s,encryptedPrivateKey:o})}catch(o){throw new N(D.ENCRYPTION_FAILED,"Failed to encrypt private key",o instanceof Error?o:void 0)}}async getPrivateKey(e,r){this.ensureInitialized();const n=await this.getChainAddress(e);if(!n)throw new N(D.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);if(!n.encryptedPrivateKey)throw new N(D.DECRYPTION_FAILED,"No encrypted private key found for this address");try{return await vt(n.encryptedPrivateKey,r)}catch(s){throw new N(D.DECRYPTION_FAILED,"Failed to decrypt private key. Wrong password or corrupted data.",s instanceof Error?s:void 0)}}async saveChainAddress(e){this.ensureInitialized(),await this.db.put("chainAddresses",e)}async getChainAddress(e){this.ensureInitialized();const r=await this.db.get("chainAddresses",e);if(!r)return null;const n=pt.safeParse(r);return n.success?n.data:(console.warn("[WalletStorage] Invalid chain address:",n.error.issues[0]),null)}async getWalletChainAddresses(e){this.ensureInitialized();const r=await this.db.getAllFromIndex("chainAddresses","by-wallet",e);return ve(pt,r,"indexeddb:chainAddresses")}async getChainAddresses(e){this.ensureInitialized();const r=await this.db.getAllFromIndex("chainAddresses","by-chain",e);return ve(pt,r,"indexeddb:chainAddresses")}async updateAssets(e,r){this.ensureInitialized();const n=await this.getChainAddress(e);if(!n)throw new N(D.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);await this.db.put("chainAddresses",{...n,assets:r,isCustomAssets:!0})}async deleteChainAddress(e){this.ensureInitialized(),await this.db.delete("chainAddresses",e)}async saveAddressBookEntry(e){this.ensureInitialized(),await this.db.put("addressBook",e)}async getAddressBookEntry(e){this.ensureInitialized();const r=await this.db.get("addressBook",e);if(!r)return null;const n=yt.safeParse(r);return n.success?n.data:(console.warn("[WalletStorage] Invalid address book entry:",n.error.issues[0]),null)}async getAllAddressBookEntries(){this.ensureInitialized();const e=await this.db.getAll("addressBook");return ve(yt,e,"indexeddb:addressBook")}async getChainAddressBookEntries(e){this.ensureInitialized();const r=await this.db.getAllFromIndex("addressBook","by-chain",e);return ve(yt,r,"indexeddb:addressBook")}async deleteAddressBookEntry(e){this.ensureInitialized(),await this.db.delete("addressBook",e)}async clearAll(){this.ensureInitialized();const e=this.db.transaction(["walleter","wallets","chainAddresses","addressBook"],"readwrite");await Promise.all([e.objectStore("walleter").clear(),e.objectStore("wallets").clear(),e.objectStore("chainAddresses").clear(),e.objectStore("addressBook").clear()]),await e.done}close(){this.db&&(this.db.close(),this.db=null,this.initialized=!1)}async runMigrations(){await this.getMetadata()}async migrateFromLocalStorage(){this.ensureInitialized();const e=localStorage.getItem("bfm_wallets");if(!e)return!1;try{const{wallets:r,currentWalletId:n}=JSON.parse(e);for(const o of r){const i={id:o.id,name:o.name,keyType:o.keyType||"mnemonic",primaryChain:o.chain,primaryAddress:o.address,encryptedMnemonic:o.encryptedMnemonic,isBackedUp:!1,createdAt:o.createdAt,updatedAt:Date.now()};if(await this.saveWallet(i),o.chainAddresses)for(const a of o.chainAddresses){const d={addressKey:`${o.id}:${a.chain}`,walletId:o.id,chain:a.chain,address:a.address,assets:[],isCustomAssets:!1,isFrozen:!1};await this.saveChainAddress(d)}}const s=await this.getWalleterInfo();return s?n&&await this.saveWalleterInfo({...s,activeWalletId:n,updatedAt:Date.now()}):await this.saveWalleterInfo({name:"User",activeWalletId:n,biometricEnabled:!1,walletLockEnabled:!1,agreementAccepted:!0,createdAt:Date.now(),updatedAt:Date.now()}),localStorage.removeItem("bfm_wallets"),!0}catch(r){throw console.error("Failed to migrate from localStorage:",r),new N(D.MIGRATION_FAILED,"Failed to migrate data from localStorage",r instanceof Error?r:void 0)}}}const _=new qs;function Cn(t){let e=0;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);e=(e<<5)-e+n,e=e&e}return Math.abs(e)%360}const lr="wallet_chain_preferences";function Zs(){try{const t=localStorage.getItem(lr);if(t)return JSON.parse(t)}catch{}return{}}function xn(t){try{localStorage.setItem(lr,JSON.stringify(t))}catch{}}const _t={wallets:[],currentWalletId:null,selectedChain:"ethereum",chainPreferences:{},isLoading:!1,isInitialized:!1,migrationRequired:!1},M=new Rt(_t);function Gs(t,e){const r=t.keyType==="mnemonic"?"mnemonic":"arbitrary",n={id:t.id,name:t.name,keyType:r,address:t.primaryAddress,chain:t.primaryChain,createdAt:t.createdAt,chainAddresses:e.map(s=>({chain:s.chain,address:s.address,publicKey:s.publicKey??"",tokens:s.assets.map(o=>{const i={id:`${s.chain}:${o.assetType}`,symbol:o.symbol,name:o.symbol,balance:o.balance,fiatValue:0,change24h:0,decimals:o.decimals,chain:s.chain};return o.contractAddress&&(i.contractAddress=o.contractAddress),o.logoUrl&&(i.icon=o.logoUrl),i})})),themeHue:t.themeHue??0,tokens:[]};return t.encryptedMnemonic&&(n.encryptedMnemonic=t.encryptedMnemonic),t.encryptedWalletLock&&(n.encryptedWalletLock=t.encryptedWalletLock),n}const wt={initialize:async()=>{const t=M.state;if(!(t.isInitialized||t.isLoading)){M.setState(e=>({...e,isLoading:!0}));try{await _.initialize(),await _.migrateFromLocalStorage();const[e,r]=await Promise.all([_.getWalleterInfo(),_.getAllWallets()]),n=await Promise.all(r.map(async c=>{const d=await _.getWalletChainAddresses(c.id);return Gs(c,d)})),s=Zs(),o=e?.activeWalletId??n[0]?.id??null,i=n.find(c=>c.id===o),a=o?s[o]??i?.chain??"bfmeta":"bfmeta";M.setState(c=>({...c,wallets:n,currentWalletId:o,selectedChain:a,chainPreferences:s,isInitialized:!0,isLoading:!1}))}catch(e){if(e instanceof dr){M.setState(r=>({...r,isInitialized:!0,isLoading:!1,migrationRequired:!0}));return}console.error("Failed to initialize wallets:",e),M.setState(r=>({...r,isInitialized:!0,isLoading:!1}))}}},createWallet:async(t,e,r,n)=>{const s=crypto.randomUUID(),o=Date.now(),i={id:s,name:t.name,keyType:t.keyType??"mnemonic",primaryChain:t.chain,primaryAddress:t.address,isBackedUp:!1,themeHue:n??Cn(e),createdAt:o,updatedAt:o},a=await _.createWallet(i,e,r),c=t.chainAddresses||[{chain:t.chain,address:t.address,publicKey:"",tokens:[]}];for(const y of c)await _.saveChainAddress({addressKey:`${s}:${y.chain}`,walletId:s,chain:y.chain,address:y.address,publicKey:y.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});const d=await _.getWalleterInfo();await _.saveWalleterInfo({name:d?.name??"User",activeWalletId:s,biometricEnabled:d?.biometricEnabled??!1,walletLockEnabled:d?.walletLockEnabled??!1,agreementAccepted:!0,createdAt:d?.createdAt??o,updatedAt:o});const h={id:s,name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:o,chainAddresses:c,themeHue:n??Cn(e),tokens:[],...a.encryptedMnemonic?{encryptedMnemonic:a.encryptedMnemonic}:{}};return M.setState(y=>({...y,wallets:[...y.wallets,h],currentWalletId:s})),h},importWallet:async(t,e,r)=>wt.createWallet(t,e,r),deleteWallet:async t=>{await _.deleteWallet(t),M.setState(e=>{const r=e.wallets.filter(c=>c.id!==t),n=e.currentWalletId===t?r[0]?.id??null:e.currentWalletId,{[t]:s,...o}=e.chainPreferences;xn(o);const i=r.find(c=>c.id===n),a=n?o[n]??i?.chain??"bfmeta":e.selectedChain;return{...e,wallets:r,currentWalletId:n,selectedChain:a,chainPreferences:o}})},setCurrentWallet:async t=>{const e=await _.getWalleterInfo();e&&await _.saveWalleterInfo({...e,activeWalletId:t,updatedAt:Date.now()}),M.setState(r=>{const n=r.wallets.find(o=>o.id===t),s=r.chainPreferences[t]??n?.chain??"bfmeta";return{...r,currentWalletId:t,selectedChain:s}})},setSelectedChain:t=>{M.setState(e=>{const{currentWalletId:r,chainPreferences:n}=e;if(r){const s={...n,[r]:t};return xn(s),{...e,selectedChain:t,chainPreferences:s}}return{...e,selectedChain:t}})},updateWalletName:async(t,e)=>{await _.updateWallet(t,{name:e}),M.setState(r=>({...r,wallets:r.wallets.map(n=>n.id===t?{...n,name:e}:n)}))},updateWalletThemeHue:async(t,e)=>{await _.updateWallet(t,{themeHue:e}),M.setState(r=>({...r,wallets:r.wallets.map(n=>n.id===t?{...n,themeHue:e}:n)}))},updateChainAssets:async(t,e,r)=>{const n=`${t}:${e}`;await _.updateAssets(n,r.map(s=>({assetType:s.symbol,symbol:s.symbol,decimals:s.decimals,balance:s.balance,contractAddress:s.contractAddress,logoUrl:s.icon}))),M.setState(s=>({...s,wallets:s.wallets.map(o=>o.id!==t?o:{...o,chainAddresses:o.chainAddresses.map(i=>i.chain===e?{...i,tokens:r}:i)})}))},refreshBalance:async(t,e)=>{const n=M.state.wallets.find(o=>o.id===t);if(!n)return;const s=n.chainAddresses.find(o=>o.chain===e);if(s)try{const{getChainProvider:o,isSupported:i}=await Qt(async()=>{const{getChainProvider:y,isSupported:g}=await import("./index-wSp7Vo6A.js").then(u=>u.q);return{getChainProvider:y,isSupported:g}},__vite__mapDeps([0,1,2,3,4,5]),import.meta.url),c=await o(e).getNativeBalance(s.address);if(!i(c))return;const d=c.data,h=[{id:`${e}:${d.symbol}`,symbol:d.symbol,name:d.symbol,balance:d.amount.toFormatted(),fiatValue:0,change24h:0,decimals:d.amount.decimals,chain:e}];await wt.updateChainAssets(t,e,h)}catch(o){console.error(`[refreshBalance] Failed to refresh balance for ${e}:`,o)}},refreshAllBalances:async()=>{const t=M.state,e=xe.getCurrentWallet(t);e&&await Promise.all(e.chainAddresses.map(r=>wt.refreshBalance(e.id,r.chain)))},updateWalletLock:async(t,e,r)=>{await _.updateWalletLockEncryption(t,e,r);const n=await _.getWallet(t);n?.encryptedMnemonic&&n.encryptedWalletLock&&M.setState(s=>({...s,wallets:s.wallets.map(o=>o.id===t?{...o,encryptedMnemonic:n.encryptedMnemonic,encryptedWalletLock:n.encryptedWalletLock}:o)}))},verifyMnemonic:async(t,e)=>_.verifyMnemonic(t,e),resetWalletLockByMnemonic:async(t,e,r)=>{await _.resetWalletLockByMnemonic(t,e,r);const n=await _.getWallet(t);n?.encryptedMnemonic&&n.encryptedWalletLock&&M.setState(s=>({...s,wallets:s.wallets.map(o=>o.id===t?{...o,encryptedMnemonic:n.encryptedMnemonic,encryptedWalletLock:n.encryptedWalletLock}:o)}))},getMnemonic:async(t,e)=>_.getMnemonic(t,e),updateWalletChainAddresses:async(t,e,r,n)=>{const o=M.state.wallets.find(u=>u.id===t);if(!o)throw new Error("Wallet not found");const i=await _.getMnemonic(t,r),a=new Set(o.chainAddresses.map(u=>u.chain)),c=new Set(e),d=e.filter(u=>!a.has(u)),h=[...a].filter(u=>!c.has(u));if(d.length===0&&h.length===0)return;let y=[];if(d.length>0){const{deriveWalletChainAddresses:u}=await Qt(async()=>{const{deriveWalletChainAddresses:x}=await import("./index-LxS4rbbm.js");return{deriveWalletChainAddresses:x}},__vite__mapDeps([6,0,1,2,3,4,5,7,8,9]),import.meta.url),m=n.filter(x=>d.includes(x.id));y=(await u({mnemonic:i,chainConfigs:m,selectedChainIds:d})).map(x=>({chain:x.chainId,address:x.address,publicKey:x.publicKey??""}))}for(const u of y)await _.saveChainAddress({addressKey:`${t}:${u.chain}`,walletId:t,chain:u.chain,address:u.address,publicKey:u.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});for(const u of h)await _.deleteChainAddress(`${t}:${u}`);const g=[...o.chainAddresses.filter(u=>!h.includes(u.chain)),...y.map(u=>({chain:u.chain,address:u.address,publicKey:u.publicKey,tokens:[]}))];M.setState(u=>({...u,wallets:u.wallets.map(m=>m.id===t?{...m,chainAddresses:g}:m)}))},clearAll:async()=>{await _.clearAll(),M.setState(()=>_t)},_testAddWallet:t=>{const e={id:t.id??crypto.randomUUID(),name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:t.createdAt??Date.now(),chainAddresses:t.chainAddresses??[{chain:t.chain,address:t.address,publicKey:"",tokens:[]}],themeHue:t.themeHue,tokens:[],...t.encryptedMnemonic?{encryptedMnemonic:t.encryptedMnemonic}:{}};return M.setState(r=>({...r,wallets:[...r.wallets,e],currentWalletId:r.currentWalletId??e.id,isInitialized:!0})),e},_testReset:()=>{M.setState(()=>_t)}},xe={getCurrentWallet:t=>t.currentWalletId&&t.wallets.find(e=>e.id===t.currentWalletId)||null,getCurrentChainAddress:t=>{const e=xe.getCurrentWallet(t);return e&&e.chainAddresses.find(r=>r.chain===t.selectedChain)||null},getCurrentChainTokens:t=>xe.getCurrentChainAddress(t)?.tokens||[],getAvailableChains:t=>{const e=xe.getCurrentWallet(t);return e?e.chainAddresses.map(r=>r.chain):[]},getTotalFiatValue:t=>{const e=xe.getCurrentWallet(t);return e?e.chainAddresses.reduce((r,n)=>r+n.tokens.reduce((s,o)=>s+o.fiatValue,0),0):0},hasWallet:t=>t.wallets.length>0},ur={contacts:[],isInitialized:!1},ee=new Rt(ur),Vt="bfm_address_book",fr=3;function ue(t){try{const e={version:fr,contacts:t};localStorage.setItem(Vt,JSON.stringify(e))}catch(e){console.error("Failed to persist address book:",e)}}function Xs(){try{const t=localStorage.getItem(Vt);if(!t)return[];const e=JSON.parse(t);return e.version===fr&&Array.isArray(e.contacts)?e.contacts:[]}catch(t){return console.error("Failed to load address book:",t),[]}}const Zo={initialize:()=>{const t=Xs();ee.setState(()=>({contacts:t,isInitialized:!0}))},addContact:t=>{if(t.addresses.length>3)throw new Error("Maximum 3 addresses per contact");const e=Date.now(),r={...t,id:crypto.randomUUID(),createdAt:e,updatedAt:e};return ee.setState(n=>{const s=[...n.contacts,r];return ue(s),{...n,contacts:s}}),r},updateContact:(t,e)=>{ee.setState(r=>{const n=r.contacts.map(s=>s.id===t?{...s,...e,updatedAt:Date.now()}:s);return ue(n),{...r,contacts:n}})},deleteContact:t=>{ee.setState(e=>{const r=e.contacts.filter(n=>n.id!==t);return ue(r),{...e,contacts:r}})},addAddressToContact:(t,e)=>{const r={...e,id:crypto.randomUUID()};ee.setState(n=>{const s=n.contacts.map(o=>{if(o.id!==t)return o;if(o.addresses.length>=3)throw new Error("Maximum 3 addresses per contact");return{...o,addresses:[...o.addresses,r],updatedAt:Date.now()}});return ue(s),{...n,contacts:s}})},removeAddressFromContact:(t,e)=>{ee.setState(r=>{const n=r.contacts.map(s=>s.id!==t?s:{...s,addresses:s.addresses.filter(o=>o.id!==e),updatedAt:Date.now()});return ue(n),{...r,contacts:n}})},setDefaultAddress:(t,e)=>{ee.setState(r=>{const n=r.contacts.map(s=>s.id!==t?s:{...s,addresses:s.addresses.map(o=>({...o,isDefault:o.id===e})),updatedAt:Date.now()});return ue(n),{...r,contacts:n}})},importContacts:t=>{if(t.length===0)return 0;let e=0;return ee.setState(r=>{const n=r.contacts,s=new Set(n.map(a=>a.name.toLowerCase())),o=t.filter(a=>{const c=a.name.toLowerCase();return s.has(c)?!1:(s.add(c),!0)});if(e=o.length,o.length===0)return r;const i=[...n,...o];return ue(i),{...r,contacts:i}}),e},clearAll:()=>{localStorage.removeItem(Vt),ee.setState(()=>ur)}},Go={getContactByAddress:(t,e)=>{const r=e.toLowerCase();for(const n of t.contacts){const s=n.addresses.find(o=>o.address.toLowerCase()===r);if(s)return{contact:n,matchedAddress:s}}},searchContacts:(t,e)=>{const r=e.toLowerCase();return t.contacts.filter(n=>n.name.toLowerCase().includes(r)||n.addresses.some(s=>s.address.toLowerCase().includes(r)))},suggestContacts:(t,e,r=5)=>{const n=[],s=e&&e.length>0,o=s?e.toLowerCase():"",i=[...t.contacts].sort((c,d)=>d.updatedAt-c.updatedAt);for(const c of i){const d=c.addresses;if(d.length!==0){if(!s){const h=d.find(y=>y.isDefault)??d[0];h&&n.push({contact:c,matchedAddress:h,matchType:"name",score:40});continue}for(const h of d){const y=h.address.toLowerCase();y===o?n.push({contact:c,matchedAddress:h,matchType:"exact",score:100}):y.startsWith(o)?n.push({contact:c,matchedAddress:h,matchType:"prefix",score:80}):y.includes(o)&&n.push({contact:c,matchedAddress:h,matchType:"prefix",score:50})}if(c.name.toLowerCase().includes(o)){const h=d.find(y=>y.isDefault)??d[0];h&&n.push({contact:c,matchedAddress:h,matchType:"name",score:60})}}}const a=new Map;for(const c of n){const d=`${c.contact.id}:${c.matchedAddress.id}`,h=a.get(d);(!h||h.score<c.score)&&a.set(d,c)}return Array.from(a.values()).sort((c,d)=>d.score!==c.score?d.score-c.score:d.contact.updatedAt-c.contact.updatedAt).slice(0,r)},getContactsByChain:(t,e)=>t.contacts.filter(r=>r.addresses.some(n=>on(n.address).chainType===e)),getDefaultAddress:(t,e)=>{const r=e?t.addresses.filter(n=>on(n.address).chainType===e):t.addresses;return r.find(n=>n.isDefault)??r[0]}},Js=A().regex(/^\d+\.\d+$/,'version must be "major.minor" (e.g. "1.0")'),Qs=Nt(["bioforest","evm","bitcoin","tron"]),hr=Nt(["default","subscription","manual"]),eo=q({type:A().min(1),endpoint:A().url(),config:Nn(A(),Pr()).optional()}).strict(),to=et(eo),no=q({url:A().url(),queryTx:A().optional(),queryAddress:A().optional(),queryBlock:A().optional()}),nt=q({id:A().regex(/^[a-z0-9-]+$/,"id must match /^[a-z0-9-]+$/"),version:Js,chainKind:Qs,name:A().min(1).max(50),symbol:A().min(1).max(10),icon:A().min(1).optional(),tokenIconBase:et(A().min(1)).optional(),prefix:A().min(1).max(10).optional(),decimals:Y().int().min(0).max(18),apis:to.optional(),explorer:no.optional(),enabled:he().default(!0),source:hr.default("default")}).strict(),Yt=et(nt).min(1),ro=q({version:A().regex(/^\d+\.\d+\.\d+$/,'version must be semver (e.g. "2.0.0")'),chains:Yt}),qt=q({url:A().min(1),refreshIntervalMinutes:Y().int().min(1).default(1440),lastUpdated:A().optional(),etag:A().optional()}).strict(),so="bfm_chain_config",oo=1,we="chain_configs",V="chain_preferences";let Ve=null,Ae=null;const io=nt.omit({enabled:!0,source:!0}),ao=q({key:A(),id:A(),source:hr,config:io}),co=Nn(A(),Mr());function lo(){if(typeof indexedDB>"u")throw new Error("indexedDB is not available in this environment")}function rt(t){return new Promise((e,r)=>{t.onsuccess=()=>e(t.result),t.onerror=()=>r(t.error??new Error("IndexedDB request failed"))})}function ae(t){return new Promise((e,r)=>{t.oncomplete=()=>e(),t.onerror=()=>r(t.error??new Error("IndexedDB transaction failed")),t.onabort=()=>r(t.error??new Error("IndexedDB transaction aborted"))})}async function ce(){if(lo(),Ve)return Ve;if(Ae)return Ae;Ae=new Promise((t,e)=>{const r=indexedDB.open(so,oo);r.onupgradeneeded=()=>{const n=r.result;n.objectStoreNames.contains(we)||n.createObjectStore(we,{keyPath:"key"}).createIndex("source","source",{unique:!1}),n.objectStoreNames.contains(V)||n.createObjectStore(V,{keyPath:"key"})},r.onsuccess=()=>t(r.result),r.onerror=()=>e(r.error??new Error("Failed to open IndexedDB"))});try{return Ve=await Ae,Ve}finally{Ae=null}}async function uo(t,e){const r=t.index("source"),n=[];return new Promise((s,o)=>{const i=r.openCursor(IDBKeyRange.only(e));i.onsuccess=()=>{const a=i.result;if(!a){s(n);return}n.push(a.primaryKey),a.continue()},i.onerror=()=>o(i.error??new Error("Failed to read IndexedDB cursor"))})}async function Zt(t){const r=(await ce()).transaction([we],"readwrite"),n=r.objectStore(we),s=await uo(n,t.source);for(const o of s)n.delete(o);for(const o of t.configs){const i={id:o.id,version:o.version,chainKind:o.chainKind,name:o.name,symbol:o.symbol,decimals:o.decimals,...o.icon!==void 0?{icon:o.icon}:{},...o.prefix!==void 0?{prefix:o.prefix}:{},...o.apis!==void 0?{apis:o.apis}:{},...o.explorer!==void 0?{explorer:o.explorer}:{}},a={key:`${t.source}:${o.id}`,id:o.id,source:t.source,config:i};n.put(a)}await ae(r)}async function Gt(){const e=(await ce()).transaction([we],"readonly"),r=e.objectStore(we),n=await rt(r.getAll());await ae(e);const s=[];for(const o of n){const i=ao.safeParse(o);if(!i.success){console.warn("[ChainConfigStorage] Invalid chain config record:",i.error.issues[0]);continue}if(i.data.id!==i.data.config.id){console.warn("[ChainConfigStorage] Invalid chain config record (id mismatch):",{key:i.data.key,id:i.data.id,configId:i.data.config.id});continue}s.push({...i.data.config,source:i.data.source,enabled:!0})}return s}async function fo(t){const r=(await ce()).transaction([V],"readwrite"),n=r.objectStore(V),s={key:"enabledMap",value:t};n.put(s),await ae(r)}async function pr(){const e=(await ce()).transaction([V],"readonly"),r=e.objectStore(V),n=await rt(r.get("enabledMap"));if(await ae(e),!n||typeof n!="object")return{};const s=n.value,o=co.safeParse(s);if(!o.success)return console.warn("[ChainConfigStorage] Invalid enabledMap:",o.error.issues[0]),{};const i={};for(const[a,c]of Object.entries(o.data)){if(typeof c=="boolean"){i[a]=c;continue}if(typeof c=="string"){const d=c.trim().toLowerCase();d==="true"||d==="1"?i[a]=!0:(d==="false"||d==="0")&&(i[a]=!1);continue}c===1?i[a]=!0:c===0&&(i[a]=!1)}return i}async function yr(t){const r=(await ce()).transaction([V],"readwrite"),n=r.objectStore(V),s={key:"subscriptionMeta",value:t};n.put(s),await ae(r)}async function st(){const e=(await ce()).transaction([V],"readonly"),r=e.objectStore(V),n=await rt(r.get("subscriptionMeta"));if(await ae(e),!n||typeof n!="object")return null;const s=n.value,o=qt.safeParse(s);return o.success?o.data:null}async function ho(t){const r=(await ce()).transaction([V],"readwrite"),n=r.objectStore(V),s={key:"defaultVersion",value:t};n.put(s),await ae(r)}async function po(){const e=(await ce()).transaction([V],"readonly"),r=e.objectStore(V),n=await rt(r.get("defaultVersion"));if(await ae(e),!n||typeof n!="object")return null;const s=n.value,o=A().safeParse(s);return o.success?o.data:(console.warn("[ChainConfigStorage] Invalid defaultVersion:",o.error.issues[0]),null)}const yo=1e4;function wo(t){const e=Array.isArray(t)?Yt.safeParse(t):nt.safeParse(t);if(!e.success){const n=e.error.issues[0];throw new Error(n?.message??"Invalid subscription chain config")}return(Array.isArray(t)?e.data:[e.data]).map(n=>({...n,source:"subscription",enabled:!0}))}function mo(t,e){if(t.length===0)return e;const r=new Map;for(const n of t)r.set(n.id,{...n,source:"subscription",enabled:!0});return[...r.values()]}function go(t){return t.filter(e=>e.source==="subscription")}async function bo(t,e){if(t==="default")return{status:"skipped",reason:"default",configs:[],meta:null};const r=await Gt(),n=go(r),s=await st(),o=void 0,i=new AbortController,a=setTimeout(()=>i.abort(),yo);try{const c=await fetch(t,{method:"GET",signal:i.signal,headers:{Accept:"application/json",...o!==void 0?{"If-None-Match":o}:{}}});if(clearTimeout(a),c.status===304)return{status:"not_modified",configs:n,meta:s};if(!c.ok)return{status:"error",error:`Subscription fetch failed: ${c.status} ${c.statusText}`,configs:n,meta:s};const d=await c.json(),h=wo(d),y=mo(h,n),g=c.headers.get("ETag")??void 0,u=qt.safeParse({url:t,...g!==void 0?{etag:g}:{},lastUpdated:new Date().toISOString()});if(!u.success)return{status:"error",error:"Invalid subscription meta",configs:n,meta:s??null};const m=u.data;return await Zt({source:"subscription",configs:y}),await yr(m),{status:"updated",configs:y,meta:m}}catch(c){return clearTimeout(a),{status:"error",error:c instanceof Error&&c.name==="AbortError"?"Subscription request timeout":c instanceof Error?c.message:"Failed to fetch subscription",configs:n,meta:s??null}}}class wr extends Error{code="MIGRATION_REQUIRED";storedVersion;requiredVersion;constructor(e,r){super(`Database migration required: stored version ${e??"unknown"} is incompatible with ${r}`),this.name="ChainConfigMigrationError",this.storedVersion=e,this.requiredVersion=r}}const mr={bioforest:1,evm:1,bitcoin:1,tron:1},Eo="./configs/default-chains.json";let mt=null,Ie=null;function gr(t){const e=t.split(".")[0],r=Number(e);return Number.isInteger(r)?r:null}function vo(t){const e=gr(t.version);return e===null?!1:e<=mr[t.chainKind]}function Ao(){const t=typeof window>"u"?"http://localhost/":window.location.href;return new URL(Eo,t).toString()}async function Io(){if(mt)return mt;if(Ie)return Ie;Ie=(async()=>{if(typeof fetch>"u")throw new Error("fetch is not available in this environment");const t=Ao(),e=await fetch(t,{method:"GET",headers:{Accept:"application/json"}});if(!e.ok)throw new Error(`Failed to load default chain configs: ${e.status} ${e.statusText}`);const r=await e.json(),n=ro.safeParse(r);if(!n.success){const a=n.error.issues[0];throw new Error(a?.message??"Invalid default chain config file")}const s=n.data,o=s.chains.map(a=>{const c=Co(a,t);return{...a,...c,source:"default",enabled:!0}}),i={version:s.version,configs:o};return mt=i,i})();try{return await Ie}finally{Ie=null}}function So(t){try{return JSON.parse(t)}catch{throw new Error("Invalid JSON")}}function kn(t,e){return t.startsWith("http://")||t.startsWith("https://")?t:new URL(t,e).toString()}function Co(t,e){const r={};return t.icon!==void 0&&(r.icon=kn(t.icon,e)),t.tokenIconBase!==void 0&&(r.tokenIconBase=t.tokenIconBase.map(n=>kn(n,e))),r}function xo(t,e,r){const n=Array.isArray(t)?Yt.safeParse(t):nt.safeParse(t);if(!n.success){const o=n.error.issues[0];throw new Error(o?.message??"Invalid chain config")}return(Array.isArray(t)?n.data:[n.data]).map(o=>({...o,...{},source:e,enabled:!0}))}function ko(t){const e=new Map;for(const r of t.manual)e.set(r.id,{...r,source:"manual"});for(const r of t.subscription)e.has(r.id)||e.set(r.id,{...r,source:"subscription"});for(const r of t.defaults)e.has(r.id)||e.set(r.id,{...r,source:"default"});return[...e.values()]}function Bo(t,e){return t.map(r=>{const n=e[r.id];return{...r,enabled:typeof n=="boolean"?n:!0}})}function To(t){const e=[];for(const r of t){const n=gr(r.version);if(n===null)continue;const s=mr[r.chainKind];n>s&&e.push({id:r.id,kind:"incompatible_major",version:r.version,supportedMajor:s,source:r.source})}return e}function Lo(t){const e=parseInt(t.split(".")[0]??"0",10);return Number.isNaN(e)?0:e}function Ko(t,e){const r=t.split(".").map(Number),n=e.split(".").map(Number);for(let s=0;s<3;s++){const o=r[s]??0,i=n[s]??0;if(o>i)return 1;if(o<i)return-1}return 0}async function Ne(){const{version:t,configs:e}=await Io(),[r,n,s,o]=await Promise.all([Gt(),pr(),st(),po()]),i=Lo(t),a=r.length>0||Object.keys(n).length>0||s!==null;if(o===null&&i>=2&&a)throw new wr(o,t);Ko(t,o??"0.0.0")>0&&await ho(t);const d=r.filter(m=>m.source==="manual"),h=s?.url&&s.url!=="default"?r.filter(m=>m.source==="subscription"):[],y=ko({manual:d,subscription:h,defaults:e}),g=Bo(y,n),u=To(g);return{configs:g,enabledMap:n,subscription:s,warnings:u}}async function _o(t){const e=typeof t=="string"?So(t):t,r=xo(e,"manual"),s=(await Gt()).filter(i=>i.source==="manual"),o=new Map;for(const i of s)o.set(i.id,{...i,source:"manual",enabled:!0});for(const i of r)o.set(i.id,{...i,source:"manual",enabled:!0});return await Zt({source:"manual",configs:[...o.values()]}),Ne()}async function gt(t,e){const n={...await pr(),[t]:e};return await fo(n),Ne()}async function Bn(){const e=(await st())?.url??"default",r=await bo(e),n=await Ne();return{result:r,snapshot:n}}function Do(t){const e=t.trim();if(e==="")return"default";if(e==="default")return e;let r;try{r=new URL(e)}catch{throw new Error("Invalid subscription URL")}if(r.protocol!=="http:"&&r.protocol!=="https:")throw new Error("Subscription URL must use http(s)");return e}async function Oo(t){const e=Do(t),r=await st(),n=r?.url;n!==e&&await Zt({source:"subscription",configs:[]});const s=qt.parse({url:e,refreshIntervalMinutes:r?.refreshIntervalMinutes??1440,...n===e?{...r?.etag?{etag:r.etag}:{},...r?.lastUpdated?{lastUpdated:r.lastUpdated}:{}}:{}});return await yr(s),Ne()}function Tn(t){return t.configs.filter(e=>e.enabled&&vo(e))}function No(t,e){return t.configs.find(r=>r.id===e)??null}const Ro={snapshot:null,isLoading:!1,error:null,migrationRequired:!1},P=new Rt(Ro);function Dt(t){return t instanceof Error?t.message:"Unknown error"}async function Se(t){P.setState(e=>({...e,isLoading:!0,error:null,migrationRequired:!1}));try{const e=await t();P.setState(r=>({...r,snapshot:e,isLoading:!1,error:null}))}catch(e){e instanceof wr?P.setState(r=>({...r,isLoading:!1,error:e.message,migrationRequired:!0})):P.setState(r=>({...r,isLoading:!1,error:Dt(e)}))}}const Xo={initialize:async()=>{const t=P.state;t.isLoading||t.snapshot||await Se(async()=>Ne())},setSubscriptionUrl:async t=>{P.setState(e=>({...e,isLoading:!0,error:null}));try{const e=await Oo(t);if((e.subscription?.url??"default")==="default"){P.setState(i=>({...i,snapshot:e,isLoading:!1,error:null}));return}const{result:n,snapshot:s}=await Bn(),o=n.status==="error"?n.error:null;P.setState(i=>({...i,snapshot:s,isLoading:!1,error:o}))}catch(e){P.setState(r=>({...r,isLoading:!1,error:Dt(e)}))}},refreshSubscription:async()=>{P.setState(t=>({...t,isLoading:!0,error:null}));try{const{result:t,snapshot:e}=await Bn(),r=t.status==="error"?t.error:null;P.setState(n=>({...n,snapshot:e,isLoading:!1,error:r}))}catch(t){P.setState(e=>({...e,isLoading:!1,error:Dt(t)}))}},addManualConfig:async t=>{await Se(async()=>_o(t))},setChainEnabled:async(t,e)=>{await Se(async()=>gt(t,e))},enableChain:async t=>{await Se(async()=>gt(t,!0))},disableChain:async t=>{await Se(async()=>gt(t,!1))},clearError:()=>{P.setState(t=>({...t,error:null}))}},Re={getSnapshot:t=>t.snapshot,getConfigs:t=>t.snapshot?.configs??[],getSubscription:t=>t.snapshot?.subscription??null,getWarnings:t=>t.snapshot?.warnings??[],getEnabledChains:t=>t.snapshot?Tn(t.snapshot):[],getEnabledBioforestChainConfigs:t=>t.snapshot?Tn(t.snapshot).filter(e=>e.chainKind==="bioforest"):[],getChainById:(t,e)=>t.snapshot?No(t.snapshot,e):null};function Jo(){return ne(P)}function Qo(){return ne(P,t=>Re.getConfigs(t))}function ei(){return ne(P,t=>Re.getEnabledChains(t))}function ti(){return ne(P,t=>Re.getEnabledBioforestChainConfigs(t))}function ni(){return ne(P,t=>Re.getSubscription(t))}function ri(){return ne(P,t=>Re.getWarnings(t))}function si(){return ne(P,t=>t.isLoading)}function oi(){return ne(P,t=>t.error)}function ii(){return ne(P,t=>t.migrationRequired)}export{xe as A,vt as B,Ho as C,wt as D,ei as E,ti as F,ni as G,ri as H,si as I,oi as J,ii as K,ds as L,Yo as M,qs as W,Zo as a,P as b,Xo as c,Go as d,ee as e,ut as f,Re as g,No as h,Ne as i,_ as j,Tn as k,qo as l,$t as m,Ls as n,zo as o,jo as p,Vo as q,Qo as r,oe as s,mn as t,Jo as u,je as v,M as w,N as x,D as y,dr as z};
