import{g as v}from"./index-C_mQ6ej2.js";import{v as M,w as b,C as k,k as y}from"./index-C_mQ6ej2.js";import"./iframe-BePrFnKO.js";import"./preload-helper-PPVm8Dsz.js";import"./service-B1moYL-R.js";import"./schemas-CO8_C8zP.js";import"./index-D0E7N0oa.js";import"./derivation-C-vexf_V.js";import"./amount-BQsqQYGO.js";import"./bioforest-CLIupf7w.js";async function I(s){const{mnemonic:t,chainConfigs:d,selectedChainIds:a,accountIndex:c=0}=s,p=new Map(d.map(r=>[r.id,r])),h=new TextEncoder().encode(t),e=[];for(const r of a){const o=p.get(r);if(!o)continue;const i=v(r);if(!i.supportsDeriveAddress)throw new Error(`Chain "${r}" (${o.chainKind}) does not support address derivation`);const n=i.deriveAddress;if(!n)throw new Error(`Chain "${r}" deriveAddress method not available`);const m=await n(h,c);e.push({chainId:r,address:m})}return e}export{M as ChainErrorCodes,b as ChainProvider,k as ChainServiceError,y as createChainProvider,I as deriveWalletChainAddresses,v as getChainProvider};
