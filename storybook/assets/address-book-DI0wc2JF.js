const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./index-B2mNTGNA.js","./schemas-jh0dXz-I.js","./amount-BQsqQYGO.js","./bioforest-D91I-84E.js","./index-D0E7N0oa.js","./preload-helper-PPVm8Dsz.js","./iframe-CHpnNFF-.js","./iframe-Bh1ogEJ1.css","./index-B0RUVa8g.js","./address-format-Bt4Tl7ZW.js"])))=>i.map(i=>d[i]);
import{u as ne,S as Ot}from"./iframe-CHpnNFF-.js";import{o as q,s as A,n as Y,a as Qe,b as Rt,c as he,r as Ln,u as br,d as Er}from"./schemas-jh0dXz-I.js";import{_ as Qt}from"./preload-helper-PPVm8Dsz.js";import"./index-D0E7N0oa.js";import{b as Nt,e as U,f as et,g as Ze,v as Kn,r as _n,j as Dn,k as On,l as vr,m as Ar,h as bt,n as J,o as ie,q as Rn,s as Ir,t as Sr,u as Me,w as Ge,x as Cr,y as xr,z as kr,A as en,B as tn,C as Br,D as nn,E as Tr,F as Lr,G as j,H as Z,I as tt,J as Le,K as Et,L as Kr,M as ke,N as rn,O as _r,P as Dr,Q as sn,R as Or,S as Rr,T as Nr,U as Wr,V as Pr,W as Mr}from"./bioforest-D91I-84E.js";import{d as on}from"./address-format-Bt4Tl7ZW.js";const Ur={snapshot:null,isLoading:!1,error:null,migrationRequired:!1},P=new Ot(Ur);function vt(t){return t instanceof Error?t.message:"Unknown error"}async function ge(t){P.setState(e=>({...e,isLoading:!0,error:null,migrationRequired:!1}));try{const e=await t();P.setState(r=>({...r,snapshot:e,isLoading:!1,error:null}))}catch(e){e instanceof Mn?P.setState(r=>({...r,isLoading:!1,error:e.message,migrationRequired:!0})):P.setState(r=>({...r,isLoading:!1,error:vt(e)}))}}const Ho={initialize:async()=>{const t=P.state;t.isLoading||t.snapshot||await ge(async()=>Re())},setSubscriptionUrl:async t=>{P.setState(e=>({...e,isLoading:!0,error:null}));try{const e=await As(t);if((e.subscription?.url??"default")==="default"){P.setState(i=>({...i,snapshot:e,isLoading:!1,error:null}));return}const{result:n,snapshot:s}=await cn(),o=n.status==="error"?n.error:null;P.setState(i=>({...i,snapshot:s,isLoading:!1,error:o}))}catch(e){P.setState(r=>({...r,isLoading:!1,error:vt(e)}))}},refreshSubscription:async()=>{P.setState(t=>({...t,isLoading:!0,error:null}));try{const{result:t,snapshot:e}=await cn(),r=t.status==="error"?t.error:null;P.setState(n=>({...n,snapshot:e,isLoading:!1,error:r}))}catch(t){P.setState(e=>({...e,isLoading:!1,error:vt(t)}))}},addManualConfig:async t=>{await ge(async()=>Es(t))},setChainEnabled:async(t,e)=>{await ge(async()=>ct(t,e))},enableChain:async t=>{await ge(async()=>ct(t,!0))},disableChain:async t=>{await ge(async()=>ct(t,!1))},clearError:()=>{P.setState(t=>({...t,error:null}))}},Oe={getSnapshot:t=>t.snapshot,getConfigs:t=>t.snapshot?.configs??[],getSubscription:t=>t.snapshot?.subscription??null,getWarnings:t=>t.snapshot?.warnings??[],getEnabledChains:t=>t.snapshot?dn(t.snapshot):[],getEnabledBioforestChainConfigs:t=>t.snapshot?dn(t.snapshot).filter(e=>e.chainKind==="bioforest"):[],getChainById:(t,e)=>t.snapshot?Is(t.snapshot,e):null};function zo(){return ne(P)}function jo(){return ne(P,t=>Oe.getConfigs(t))}function Vo(){return ne(P,t=>Oe.getEnabledChains(t))}function Yo(){return ne(P,t=>Oe.getEnabledBioforestChainConfigs(t))}function qo(){return ne(P,t=>Oe.getSubscription(t))}function Zo(){return ne(P,t=>Oe.getWarnings(t))}function Go(){return ne(P,t=>t.isLoading)}function Xo(){return ne(P,t=>t.error)}function Jo(){return ne(P,t=>t.migrationRequired)}const Fr=A().regex(/^\d+\.\d+$/,'version must be "major.minor" (e.g. "1.0")'),$r=Rt(["bioforest","evm","bitcoin","tron"]),Nn=Rt(["default","subscription","manual"]),Hr=q({type:A().min(1),endpoint:A().url(),config:Ln(A(),br()).optional()}).strict(),zr=Qe(Hr),jr=q({url:A().url(),queryTx:A().optional(),queryAddress:A().optional(),queryBlock:A().optional()}),nt=q({id:A().regex(/^[a-z0-9-]+$/,"id must match /^[a-z0-9-]+$/"),version:Fr,chainKind:$r,name:A().min(1).max(50),symbol:A().min(1).max(10),icon:A().min(1).optional(),tokenIconBase:Qe(A().min(1)).optional(),prefix:A().min(1).max(10).optional(),decimals:Y().int().min(0).max(18),apis:zr.optional(),explorer:jr.optional(),enabled:he().default(!0),source:Nn.default("default")}).strict(),Wt=Qe(nt).min(1),Vr=q({version:A().regex(/^\d+\.\d+\.\d+$/,'version must be semver (e.g. "2.0.0")'),chains:Wt}),Pt=q({url:A().min(1),refreshIntervalMinutes:Y().int().min(1).default(1440),lastUpdated:A().optional(),etag:A().optional()}).strict(),Yr="bfm_chain_config",qr=1,we="chain_configs",V="chain_preferences";let Ue=null,be=null;const Zr=nt.omit({enabled:!0,source:!0}),Gr=q({key:A(),id:A(),source:Nn,config:Zr}),Xr=Ln(A(),Er());function Jr(){if(typeof indexedDB>"u")throw new Error("indexedDB is not available in this environment")}function rt(t){return new Promise((e,r)=>{t.onsuccess=()=>e(t.result),t.onerror=()=>r(t.error??new Error("IndexedDB request failed"))})}function ae(t){return new Promise((e,r)=>{t.oncomplete=()=>e(),t.onerror=()=>r(t.error??new Error("IndexedDB transaction failed")),t.onabort=()=>r(t.error??new Error("IndexedDB transaction aborted"))})}async function ce(){if(Jr(),Ue)return Ue;if(be)return be;be=new Promise((t,e)=>{const r=indexedDB.open(Yr,qr);r.onupgradeneeded=()=>{const n=r.result;n.objectStoreNames.contains(we)||n.createObjectStore(we,{keyPath:"key"}).createIndex("source","source",{unique:!1}),n.objectStoreNames.contains(V)||n.createObjectStore(V,{keyPath:"key"})},r.onsuccess=()=>t(r.result),r.onerror=()=>e(r.error??new Error("Failed to open IndexedDB"))});try{return Ue=await be,Ue}finally{be=null}}async function Qr(t,e){const r=t.index("source"),n=[];return new Promise((s,o)=>{const i=r.openCursor(IDBKeyRange.only(e));i.onsuccess=()=>{const a=i.result;if(!a){s(n);return}n.push(a.primaryKey),a.continue()},i.onerror=()=>o(i.error??new Error("Failed to read IndexedDB cursor"))})}async function Mt(t){const r=(await ce()).transaction([we],"readwrite"),n=r.objectStore(we),s=await Qr(n,t.source);for(const o of s)n.delete(o);for(const o of t.configs){const i={id:o.id,version:o.version,chainKind:o.chainKind,name:o.name,symbol:o.symbol,decimals:o.decimals,...o.icon!==void 0?{icon:o.icon}:{},...o.prefix!==void 0?{prefix:o.prefix}:{},...o.apis!==void 0?{apis:o.apis}:{},...o.explorer!==void 0?{explorer:o.explorer}:{}},a={key:`${t.source}:${o.id}`,id:o.id,source:t.source,config:i};n.put(a)}await ae(r)}async function Ut(){const e=(await ce()).transaction([we],"readonly"),r=e.objectStore(we),n=await rt(r.getAll());await ae(e);const s=[];for(const o of n){const i=Gr.safeParse(o);if(!i.success){console.warn("[ChainConfigStorage] Invalid chain config record:",i.error.issues[0]);continue}if(i.data.id!==i.data.config.id){console.warn("[ChainConfigStorage] Invalid chain config record (id mismatch):",{key:i.data.key,id:i.data.id,configId:i.data.config.id});continue}s.push({...i.data.config,source:i.data.source,enabled:!0})}return s}async function es(t){const r=(await ce()).transaction([V],"readwrite"),n=r.objectStore(V),s={key:"enabledMap",value:t};n.put(s),await ae(r)}async function Wn(){const e=(await ce()).transaction([V],"readonly"),r=e.objectStore(V),n=await rt(r.get("enabledMap"));if(await ae(e),!n||typeof n!="object")return{};const s=n.value,o=Xr.safeParse(s);if(!o.success)return console.warn("[ChainConfigStorage] Invalid enabledMap:",o.error.issues[0]),{};const i={};for(const[a,c]of Object.entries(o.data)){if(typeof c=="boolean"){i[a]=c;continue}if(typeof c=="string"){const d=c.trim().toLowerCase();d==="true"||d==="1"?i[a]=!0:(d==="false"||d==="0")&&(i[a]=!1);continue}c===1?i[a]=!0:c===0&&(i[a]=!1)}return i}async function Pn(t){const r=(await ce()).transaction([V],"readwrite"),n=r.objectStore(V),s={key:"subscriptionMeta",value:t};n.put(s),await ae(r)}async function st(){const e=(await ce()).transaction([V],"readonly"),r=e.objectStore(V),n=await rt(r.get("subscriptionMeta"));if(await ae(e),!n||typeof n!="object")return null;const s=n.value,o=Pt.safeParse(s);return o.success?o.data:null}async function ts(t){const r=(await ce()).transaction([V],"readwrite"),n=r.objectStore(V),s={key:"defaultVersion",value:t};n.put(s),await ae(r)}async function ns(){const e=(await ce()).transaction([V],"readonly"),r=e.objectStore(V),n=await rt(r.get("defaultVersion"));if(await ae(e),!n||typeof n!="object")return null;const s=n.value,o=A().safeParse(s);return o.success?o.data:(console.warn("[ChainConfigStorage] Invalid defaultVersion:",o.error.issues[0]),null)}const rs=1e4;function ss(t){const e=Array.isArray(t)?Wt.safeParse(t):nt.safeParse(t);if(!e.success){const n=e.error.issues[0];throw new Error(n?.message??"Invalid subscription chain config")}return(Array.isArray(t)?e.data:[e.data]).map(n=>({...n,source:"subscription",enabled:!0}))}function os(t,e){if(t.length===0)return e;const r=new Map;for(const n of t)r.set(n.id,{...n,source:"subscription",enabled:!0});return[...r.values()]}function is(t){return t.filter(e=>e.source==="subscription")}async function as(t,e){if(t==="default")return{status:"skipped",reason:"default",configs:[],meta:null};const r=await Ut(),n=is(r),s=await st(),o=void 0,i=new AbortController,a=setTimeout(()=>i.abort(),rs);try{const c=await fetch(t,{method:"GET",signal:i.signal,headers:{Accept:"application/json",...o!==void 0?{"If-None-Match":o}:{}}});if(clearTimeout(a),c.status===304)return{status:"not_modified",configs:n,meta:s};if(!c.ok)return{status:"error",error:`Subscription fetch failed: ${c.status} ${c.statusText}`,configs:n,meta:s};const d=await c.json(),h=ss(d),y=os(h,n),g=c.headers.get("ETag")??void 0,u=Pt.safeParse({url:t,...g!==void 0?{etag:g}:{},lastUpdated:new Date().toISOString()});if(!u.success)return{status:"error",error:"Invalid subscription meta",configs:n,meta:s??null};const m=u.data;return await Mt({source:"subscription",configs:y}),await Pn(m),{status:"updated",configs:y,meta:m}}catch(c){return clearTimeout(a),{status:"error",error:c instanceof Error&&c.name==="AbortError"?"Subscription request timeout":c instanceof Error?c.message:"Failed to fetch subscription",configs:n,meta:s??null}}}class Mn extends Error{code="MIGRATION_REQUIRED";storedVersion;requiredVersion;constructor(e,r){super(`Database migration required: stored version ${e??"unknown"} is incompatible with ${r}`),this.name="ChainConfigMigrationError",this.storedVersion=e,this.requiredVersion=r}}const Un={bioforest:1,evm:1,bitcoin:1,tron:1},cs="./configs/default-chains.json";let at=null,Ee=null;function Fn(t){const e=t.split(".")[0],r=Number(e);return Number.isInteger(r)?r:null}function ds(t){const e=Fn(t.version);return e===null?!1:e<=Un[t.chainKind]}function ls(){const t=typeof window>"u"?"http://localhost/":window.location.href;return new URL(cs,t).toString()}async function us(){if(at)return at;if(Ee)return Ee;Ee=(async()=>{if(typeof fetch>"u")throw new Error("fetch is not available in this environment");const t=ls(),e=await fetch(t,{method:"GET",headers:{Accept:"application/json"}});if(!e.ok)throw new Error(`Failed to load default chain configs: ${e.status} ${e.statusText}`);const r=await e.json(),n=Vr.safeParse(r);if(!n.success){const a=n.error.issues[0];throw new Error(a?.message??"Invalid default chain config file")}const s=n.data,o=s.chains.map(a=>{const c=hs(a,t);return{...a,...c,source:"default",enabled:!0}}),i={version:s.version,configs:o};return at=i,i})();try{return await Ee}finally{Ee=null}}function fs(t){try{return JSON.parse(t)}catch{throw new Error("Invalid JSON")}}function an(t,e){return t.startsWith("http://")||t.startsWith("https://")?t:new URL(t,e).toString()}function hs(t,e){const r={};return t.icon!==void 0&&(r.icon=an(t.icon,e)),t.tokenIconBase!==void 0&&(r.tokenIconBase=t.tokenIconBase.map(n=>an(n,e))),r}function ps(t,e,r){const n=Array.isArray(t)?Wt.safeParse(t):nt.safeParse(t);if(!n.success){const o=n.error.issues[0];throw new Error(o?.message??"Invalid chain config")}return(Array.isArray(t)?n.data:[n.data]).map(o=>({...o,...{},source:e,enabled:!0}))}function ys(t){const e=new Map;for(const r of t.manual)e.set(r.id,{...r,source:"manual"});for(const r of t.subscription)e.has(r.id)||e.set(r.id,{...r,source:"subscription"});for(const r of t.defaults)e.has(r.id)||e.set(r.id,{...r,source:"default"});return[...e.values()]}function ws(t,e){return t.map(r=>{const n=e[r.id];return{...r,enabled:typeof n=="boolean"?n:!0}})}function ms(t){const e=[];for(const r of t){const n=Fn(r.version);if(n===null)continue;const s=Un[r.chainKind];n>s&&e.push({id:r.id,kind:"incompatible_major",version:r.version,supportedMajor:s,source:r.source})}return e}function gs(t){const e=parseInt(t.split(".")[0]??"0",10);return Number.isNaN(e)?0:e}function bs(t,e){const r=t.split(".").map(Number),n=e.split(".").map(Number);for(let s=0;s<3;s++){const o=r[s]??0,i=n[s]??0;if(o>i)return 1;if(o<i)return-1}return 0}async function Re(){const{version:t,configs:e}=await us(),[r,n,s,o]=await Promise.all([Ut(),Wn(),st(),ns()]),i=gs(t),a=r.length>0||Object.keys(n).length>0||s!==null;if(o===null&&i>=2&&a)throw new Mn(o,t);bs(t,o??"0.0.0")>0&&await ts(t);const d=r.filter(m=>m.source==="manual"),h=s?.url&&s.url!=="default"?r.filter(m=>m.source==="subscription"):[],y=ys({manual:d,subscription:h,defaults:e}),g=ws(y,n),u=ms(g);return{configs:g,enabledMap:n,subscription:s,warnings:u}}async function Es(t){const e=typeof t=="string"?fs(t):t,r=ps(e,"manual"),s=(await Ut()).filter(i=>i.source==="manual"),o=new Map;for(const i of s)o.set(i.id,{...i,source:"manual",enabled:!0});for(const i of r)o.set(i.id,{...i,source:"manual",enabled:!0});return await Mt({source:"manual",configs:[...o.values()]}),Re()}async function ct(t,e){const n={...await Wn(),[t]:e};return await es(n),Re()}async function cn(){const e=(await st())?.url??"default",r=await as(e),n=await Re();return{result:r,snapshot:n}}function vs(t){const e=t.trim();if(e==="")return"default";if(e==="default")return e;let r;try{r=new URL(e)}catch{throw new Error("Invalid subscription URL")}if(r.protocol!=="http:"&&r.protocol!=="https:")throw new Error("Subscription URL must use http(s)");return e}async function As(t){const e=vs(t),r=await st(),n=r?.url;n!==e&&await Mt({source:"subscription",configs:[]});const s=Pt.parse({url:e,refreshIntervalMinutes:r?.refreshIntervalMinutes??1440,...n===e?{...r?.etag?{etag:r.etag}:{},...r?.lastUpdated?{lastUpdated:r.lastUpdated}:{}}:{}});return await Pn(s),Re()}function dn(t){return t.configs.filter(e=>e.enabled&&ds(e))}function Is(t,e){return t.configs.find(r=>r.id===e)??null}const $n=1e5,Ss=16,Hn=12,Ft=256;async function zn(t,e){const n=new TextEncoder().encode(t),s=await crypto.subtle.importKey("raw",n,"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:$n,hash:"SHA-256"},s,{name:"AES-GCM",length:Ft},!1,["encrypt","decrypt"])}async function Fe(t,e){const n=new TextEncoder().encode(t),s=crypto.getRandomValues(new Uint8Array(Ss)),o=crypto.getRandomValues(new Uint8Array(Hn)),i=await zn(e,s),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},i,n);return{ciphertext:Be(a),salt:Be(s),iv:Be(o),iterations:$n}}async function At(t,e){const r=Te(t.salt),n=Te(t.iv),s=Te(t.ciphertext),o=await zn(e,r);try{const i=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},o,s);return new TextDecoder().decode(i)}catch{throw new Error("解密失败：密码错误或数据损坏")}}async function Qo(t,e){try{return await At(t,e),!0}catch{return!1}}async function dt(t,e){const n=new TextEncoder().encode(t),s=crypto.getRandomValues(new Uint8Array(Hn)),o=await crypto.subtle.importKey("raw",e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength),{name:"AES-GCM",length:Ft},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},o,n);return{ciphertext:Be(i),salt:"",iv:Be(s),iterations:0}}async function ln(t,e){const r=Te(t.iv),n=Te(t.ciphertext),s=await crypto.subtle.importKey("raw",e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength),{name:"AES-GCM",length:Ft},!1,["decrypt"]);try{const o=await crypto.subtle.decrypt({name:"AES-GCM",iv:r},s,n);return new TextDecoder().decode(o)}catch{throw new Error("解密失败：密钥错误或数据损坏")}}function Be(t){const e=t instanceof Uint8Array?t:new Uint8Array(t);let r="";for(let n=0;n<e.byteLength;n++)r+=String.fromCharCode(e[n]);return btoa(r)}function Te(t){const e=atob(t),r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r}class jn{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(e,r){if(Nt(e),U(r,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?e.create().update(r).digest():r);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=e.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),et(s)}update(e){return Ze(this),this.iHash.update(e),this}digestInto(e){Ze(this),U(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||=Object.create(Object.getPrototypeOf(this),{});const{oHash:r,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=r._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ke=(t,e,r)=>new jn(t,e).update(r).digest();Ke.create=(t,e)=>new jn(t,e);const un=(t,e)=>(t+(t>=0?e:-e)/Vn)/e;function Cs(t,e,r){const[[n,s],[o,i]]=e,a=un(i*t,r),c=un(-s*t,r);let d=t-a*n-c*o,h=-a*s-c*i;const y=d<te,g=h<te;y&&(d=-d),g&&(h=-h);const u=On(Math.ceil(Tr(r)/2))+ye;if(d<te||d>=u||h<te||h>=u)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:y,k1:d,k2neg:g,k2:h}}function It(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function lt(t,e){const r={};for(let n of Object.keys(e))r[n]=t[n]===void 0?e[n]:t[n];return Ge(r.lowS,"lowS"),Ge(r.prehash,"prehash"),r.format!==void 0&&It(r.format),r}class xs extends Error{constructor(e=""){super(e)}}const se={Err:xs,_tlv:{encode:(t,e)=>{const{Err:r}=se;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length&1)throw new r("tlv.encode: unpadded data");const n=e.length/2,s=Me(n);if(s.length/2&128)throw new r("tlv.encode: long form length too big");const o=n>127?Me(s.length/2|128):"";return Me(t)+o+s+e},decode(t,e){const{Err:r}=se;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const s=e[n++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new r("tlv.decode(long): indefinite length not supported");if(c>4)throw new r("tlv.decode(long): byte length is too big");const d=e.subarray(n,n+c);if(d.length!==c)throw new r("tlv.decode: length bytes not complete");if(d[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const h of d)i=i<<8|h;if(n+=c,i<128)throw new r("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+i);if(a.length!==i)throw new r("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+i)}}},_int:{encode(t){const{Err:e}=se;if(t<te)throw new e("integer: negative integers are not allowed");let r=Me(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=se;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Dn(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=se,s=U(t,void 0,"signature"),{v:o,l:i}=n.decode(48,s);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:d,l:h}=n.decode(2,c);if(h.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(d)}},hexFromSig(t){const{_tlv:e,_int:r}=se,n=e.encode(2,r.encode(t.r)),s=e.encode(2,r.encode(t.s)),o=n+s;return e.encode(48,o)}},te=BigInt(0),ye=BigInt(1),Vn=BigInt(2),$e=BigInt(3),ks=BigInt(4);function Bs(t,e={}){const r=xr("weierstrass",t,e),{Fp:n,Fn:s}=r;let o=r.CURVE;const{h:i,n:a}=o;Kn(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!n.is0(o.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const d=qn(n,s);function h(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function y(T,p,f){const{x:l,y:w}=p.toAffine(),E=n.toBytes(l);if(Ge(f,"isCompressed"),f){h();const I=!n.isOdd(w);return J(Yn(I),E)}else return J(Uint8Array.of(4),E,n.toBytes(w))}function g(T){U(T,void 0,"Point");const{publicKey:p,publicKeyUncompressed:f}=d,l=T.length,w=T[0],E=T.subarray(1);if(l===p&&(w===2||w===3)){const I=n.fromBytes(E);if(!n.isValid(I))throw new Error("bad point: is not on curve, wrong x");const v=B(I);let b;try{b=n.sqrt(v)}catch(F){const O=F instanceof Error?": "+F.message:"";throw new Error("bad point: is not on curve, sqrt error"+O)}h();const S=n.isOdd(b);return(w&1)===1!==S&&(b=n.neg(b)),{x:I,y:b}}else if(l===f&&w===4){const I=n.BYTES,v=n.fromBytes(E.subarray(0,I)),b=n.fromBytes(E.subarray(I,I*2));if(!x(v,b))throw new Error("bad point: is not on curve");return{x:v,y:b}}else throw new Error(`bad point: got length ${l}, expected compressed=${p} or uncompressed=${f}`)}const u=e.toBytes||y,m=e.fromBytes||g;function B(T){const p=n.sqr(T),f=n.mul(p,T);return n.add(n.add(f,n.mul(T,o.a)),o.b)}function x(T,p){const f=n.sqr(p),l=B(T);return n.eql(f,l)}if(!x(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const K=n.mul(n.pow(o.a,$e),ks),Q=n.mul(n.sqr(o.b),BigInt(27));if(n.is0(n.add(K,Q)))throw new Error("bad curve params: a or b");function G(T,p,f=!1){if(!n.isValid(p)||f&&n.is0(p))throw new Error(`bad point coordinate ${T}`);return p}function z(T){if(!(T instanceof L))throw new Error("Weierstrass Point expected")}function de(T){if(!c||!c.basises)throw new Error("no endo");return Cs(T,c.basises,s.ORDER)}const re=en((T,p)=>{const{X:f,Y:l,Z:w}=T;if(n.eql(w,n.ONE))return{x:f,y:l};const E=T.is0();p==null&&(p=E?n.ONE:n.inv(w));const I=n.mul(f,p),v=n.mul(l,p),b=n.mul(w,p);if(E)return{x:n.ZERO,y:n.ZERO};if(!n.eql(b,n.ONE))throw new Error("invZ was invalid");return{x:I,y:v}}),it=en(T=>{if(T.is0()){if(e.allowInfinityPoint&&!n.is0(T.Y))return;throw new Error("bad point: ZERO")}const{x:p,y:f}=T.toAffine();if(!n.isValid(p)||!n.isValid(f))throw new Error("bad point: x or y not field elements");if(!x(p,f))throw new Error("bad point: equation left != right");if(!T.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function me(T,p,f,l,w){return f=new L(n.mul(f.X,T),f.Y,f.Z),p=nn(l,p),f=nn(w,f),p.add(f)}class L{static BASE=new L(o.Gx,o.Gy,n.ONE);static ZERO=new L(n.ZERO,n.ONE,n.ZERO);static Fp=n;static Fn=s;X;Y;Z;constructor(p,f,l){this.X=G("x",p),this.Y=G("y",f,!0),this.Z=G("z",l),Object.freeze(this)}static CURVE(){return o}static fromAffine(p){const{x:f,y:l}=p||{};if(!p||!n.isValid(f)||!n.isValid(l))throw new Error("invalid affine point");if(p instanceof L)throw new Error("projective point not allowed");return n.is0(f)&&n.is0(l)?L.ZERO:new L(f,l,n.ONE)}static fromBytes(p){const f=L.fromAffine(m(U(p,void 0,"point")));return f.assertValidity(),f}static fromHex(p){return L.fromBytes(bt(p))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(p=8,f=!0){return le.createCache(this,p),f||this.multiply($e),this}assertValidity(){it(this)}hasEvenY(){const{y:p}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(p)}equals(p){z(p);const{X:f,Y:l,Z:w}=this,{X:E,Y:I,Z:v}=p,b=n.eql(n.mul(f,v),n.mul(E,w)),S=n.eql(n.mul(l,v),n.mul(I,w));return b&&S}negate(){return new L(this.X,n.neg(this.Y),this.Z)}double(){const{a:p,b:f}=o,l=n.mul(f,$e),{X:w,Y:E,Z:I}=this;let v=n.ZERO,b=n.ZERO,S=n.ZERO,C=n.mul(w,w),F=n.mul(E,E),O=n.mul(I,I),k=n.mul(w,E);return k=n.add(k,k),S=n.mul(w,I),S=n.add(S,S),v=n.mul(p,S),b=n.mul(l,O),b=n.add(v,b),v=n.sub(F,b),b=n.add(F,b),b=n.mul(v,b),v=n.mul(k,v),S=n.mul(l,S),O=n.mul(p,O),k=n.sub(C,O),k=n.mul(p,k),k=n.add(k,S),S=n.add(C,C),C=n.add(S,C),C=n.add(C,O),C=n.mul(C,k),b=n.add(b,C),O=n.mul(E,I),O=n.add(O,O),C=n.mul(O,k),v=n.sub(v,C),S=n.mul(O,F),S=n.add(S,S),S=n.add(S,S),new L(v,b,S)}add(p){z(p);const{X:f,Y:l,Z:w}=this,{X:E,Y:I,Z:v}=p;let b=n.ZERO,S=n.ZERO,C=n.ZERO;const F=o.a,O=n.mul(o.b,$e);let k=n.mul(f,E),N=n.mul(l,I),$=n.mul(w,v),X=n.add(f,l),W=n.add(E,I);X=n.mul(X,W),W=n.add(k,N),X=n.sub(X,W),W=n.add(f,w);let H=n.add(E,v);return W=n.mul(W,H),H=n.add(k,$),W=n.sub(W,H),H=n.add(l,w),b=n.add(I,v),H=n.mul(H,b),b=n.add(N,$),H=n.sub(H,b),C=n.mul(F,W),b=n.mul(O,$),C=n.add(b,C),b=n.sub(N,C),C=n.add(N,C),S=n.mul(b,C),N=n.add(k,k),N=n.add(N,k),$=n.mul(F,$),W=n.mul(O,W),N=n.add(N,$),$=n.sub(k,$),$=n.mul(F,$),W=n.add(W,$),k=n.mul(N,W),S=n.add(S,k),k=n.mul(H,W),b=n.mul(X,b),b=n.sub(b,k),k=n.mul(X,N),C=n.mul(H,C),C=n.add(C,k),new L(b,S,C)}subtract(p){return this.add(p.negate())}is0(){return this.equals(L.ZERO)}multiply(p){const{endo:f}=e;if(!s.isValidNot0(p))throw new Error("invalid scalar: out of range");let l,w;const E=I=>le.cached(this,I,v=>tn(L,v));if(f){const{k1neg:I,k1:v,k2neg:b,k2:S}=de(p),{p:C,f:F}=E(v),{p:O,f:k}=E(S);w=F.add(k),l=me(f.beta,C,O,I,b)}else{const{p:I,f:v}=E(p);l=I,w=v}return tn(L,[l,w])[0]}multiplyUnsafe(p){const{endo:f}=e,l=this;if(!s.isValid(p))throw new Error("invalid scalar: out of range");if(p===te||l.is0())return L.ZERO;if(p===ye)return l;if(le.hasCache(this))return this.multiply(p);if(f){const{k1neg:w,k1:E,k2neg:I,k2:v}=de(p),{p1:b,p2:S}=Br(L,l,E,v);return me(f.beta,b,S,w,I)}else return le.unsafe(l,p)}toAffine(p){return re(this,p)}isTorsionFree(){const{isTorsionFree:p}=e;return i===ye?!0:p?p(L,this):le.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:p}=e;return i===ye?this:p?p(L,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(p=!0){return Ge(p,"isCompressed"),this.assertValidity(),u(L,this,p)}toHex(p=!0){return ie(this.toBytes(p))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const We=s.BITS,le=new kr(L,e.endo?Math.ceil(We/2):We);return L.BASE.precompute(8),L}function Yn(t){return Uint8Array.of(t?2:3)}function qn(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function Ts(t,e={}){const{Fn:r}=t,n=e.randomBytes||_n,s=Object.assign(qn(t.Fp,r),{seed:vr(r.ORDER)});function o(u){try{const m=r.fromBytes(u);return r.isValidNot0(m)}catch{return!1}}function i(u,m){const{publicKey:B,publicKeyUncompressed:x}=s;try{const K=u.length;return m===!0&&K!==B||m===!1&&K!==x?!1:!!t.fromBytes(u)}catch{return!1}}function a(u=n(s.seed)){return Sr(U(u,s.seed,"seed"),r.ORDER)}function c(u,m=!0){return t.BASE.multiply(r.fromBytes(u)).toBytes(m)}function d(u){const{secretKey:m,publicKey:B,publicKeyUncompressed:x}=s;if(!Rn(u)||"_lengths"in r&&r._lengths||m===B)return;const K=U(u,void 0,"key").length;return K===B||K===x}function h(u,m,B=!0){if(d(u)===!0)throw new Error("first arg must be private key");if(d(m)===!1)throw new Error("second arg must be public key");const x=r.fromBytes(u);return t.fromBytes(m).multiply(x).toBytes(B)}const y={isValidSecretKey:o,isValidPublicKey:i,randomSecretKey:a},g=Ar(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:h,keygen:g,Point:t,utils:y,lengths:s})}function Ls(t,e,r={}){Nt(e),Kn(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),r=Object.assign({},r);const n=r.randomBytes||_n,s=r.hmac||((f,l)=>Ke(e,f,l)),{Fp:o,Fn:i}=t,{ORDER:a,BITS:c}=i,{keygen:d,getPublicKey:h,getSharedSecret:y,utils:g,lengths:u}=Ts(t,r),m={prehash:!0,lowS:typeof r.lowS=="boolean"?r.lowS:!0,format:"compact",extraEntropy:!1},B=a*Vn<o.ORDER;function x(f){const l=a>>ye;return f>l}function K(f,l){if(!i.isValidNot0(l))throw new Error(`invalid signature ${f}: out of range 1..Point.Fn.ORDER`);return l}function Q(){if(B)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function G(f,l){It(l);const w=u.signature,E=l==="compact"?w:l==="recovered"?w+1:void 0;return U(f,E)}class z{r;s;recovery;constructor(l,w,E){if(this.r=K("r",l),this.s=K("s",w),E!=null){if(Q(),![0,1,2,3].includes(E))throw new Error("invalid recovery id");this.recovery=E}Object.freeze(this)}static fromBytes(l,w=m.format){G(l,w);let E;if(w==="der"){const{r:S,s:C}=se.toSig(U(l));return new z(S,C)}w==="recovered"&&(E=l[0],w="compact",l=l.subarray(1));const I=u.signature/2,v=l.subarray(0,I),b=l.subarray(I,I*2);return new z(i.fromBytes(v),i.fromBytes(b),E)}static fromHex(l,w){return this.fromBytes(bt(l),w)}assertRecovery(){const{recovery:l}=this;if(l==null)throw new Error("invalid recovery id: must be present");return l}addRecoveryBit(l){return new z(this.r,this.s,l)}recoverPublicKey(l){const{r:w,s:E}=this,I=this.assertRecovery(),v=I===2||I===3?w+a:w;if(!o.isValid(v))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const b=o.toBytes(v),S=t.fromBytes(J(Yn((I&1)===0),b)),C=i.inv(v),F=re(U(l,void 0,"msgHash")),O=i.create(-F*C),k=i.create(E*C),N=t.BASE.multiplyUnsafe(O).add(S.multiplyUnsafe(k));if(N.is0())throw new Error("invalid recovery: point at infinify");return N.assertValidity(),N}hasHighS(){return x(this.s)}toBytes(l=m.format){if(It(l),l==="der")return bt(se.hexFromSig(this));const{r:w,s:E}=this,I=i.toBytes(w),v=i.toBytes(E);return l==="recovered"?(Q(),J(Uint8Array.of(this.assertRecovery()),I,v)):J(I,v)}toHex(l){return ie(this.toBytes(l))}}const de=r.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const w=Dn(l),E=l.length*8-c;return E>0?w>>BigInt(E):w},re=r.bits2int_modN||function(l){return i.create(de(l))},it=On(c);function me(f){return Cr("num < 2^"+c,f,te,it),i.toBytes(f)}function L(f,l){return U(f,void 0,"message"),l?U(e(f),void 0,"prehashed message"):f}function We(f,l,w){const{lowS:E,prehash:I,extraEntropy:v}=lt(w,m);f=L(f,I);const b=re(f),S=i.fromBytes(l);if(!i.isValidNot0(S))throw new Error("invalid private key");const C=[me(S),me(b)];if(v!=null&&v!==!1){const N=v===!0?n(u.secretKey):v;C.push(U(N,void 0,"extraEntropy"))}const F=J(...C),O=b;function k(N){const $=de(N);if(!i.isValidNot0($))return;const X=i.inv($),W=t.BASE.multiply($).toAffine(),H=i.create(W.x);if(H===te)return;const Pe=i.create(X*i.create(O+H*S));if(Pe===te)return;let Xt=(W.x===H?0:2)|Number(W.y&ye),Jt=Pe;return E&&x(Pe)&&(Jt=i.neg(Pe),Xt^=1),new z(H,Jt,B?void 0:Xt)}return{seed:F,k2sig:k}}function le(f,l,w={}){const{seed:E,k2sig:I}=We(f,l,w);return Ir(e.outputLen,i.BYTES,s)(E,I).toBytes(w.format)}function T(f,l,w,E={}){const{lowS:I,prehash:v,format:b}=lt(E,m);if(w=U(w,void 0,"publicKey"),l=L(l,v),!Rn(f)){const S=f instanceof z?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+S)}G(f,b);try{const S=z.fromBytes(f,b),C=t.fromBytes(w);if(I&&S.hasHighS())return!1;const{r:F,s:O}=S,k=re(l),N=i.inv(O),$=i.create(k*N),X=i.create(F*N),W=t.BASE.multiplyUnsafe($).add(C.multiplyUnsafe(X));return W.is0()?!1:i.create(W.x)===F}catch{return!1}}function p(f,l,w={}){const{prehash:E}=lt(w,m);return l=L(l,E),z.fromBytes(f,"recovered").recoverPublicKey(l).toBytes()}return Object.freeze({keygen:d,getPublicKey:h,getSharedSecret:y,utils:g,lengths:u,Point:t,sign:le,verify:T,recoverPublicKey:p,Signature:z,hash:e})}const $t={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Ks={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},fn=BigInt(2);function _s(t){const e=$t.p,r=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),d=t*t*t%e,h=d*d*t%e,y=Z(h,r,e)*h%e,g=Z(y,r,e)*h%e,u=Z(g,fn,e)*d%e,m=Z(u,s,e)*u%e,B=Z(m,o,e)*m%e,x=Z(B,a,e)*B%e,K=Z(x,c,e)*x%e,Q=Z(K,a,e)*B%e,G=Z(Q,r,e)*h%e,z=Z(G,i,e)*m%e,de=Z(z,n,e)*d%e,re=Z(de,fn,e);if(!St.eql(St.sqr(re),t))throw new Error("Cannot find square root");return re}const St=Lr($t.p,{sqrt:_s}),Ds=Bs($t,{Fp:St,endo:Ks}),oe=Ls(Ds,j);function _e(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Zn(t,e){return Array.isArray(e)?e.length===0?!0:t?e.every(r=>typeof r=="string"):e.every(r=>Number.isSafeInteger(r)):!1}function Gn(t){if(typeof t!="function")throw new Error("function expected");return!0}function De(t,e){if(typeof e!="string")throw new Error(`${t}: string expected`);return!0}function Ne(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function Xe(t){if(!Array.isArray(t))throw new Error("array expected")}function Xn(t,e){if(!Zn(!0,e))throw new Error(`${t}: array of strings expected`)}function Ht(t,e){if(!Zn(!1,e))throw new Error(`${t}: array of numbers expected`)}function zt(...t){const e=o=>o,r=(o,i)=>a=>o(i(a)),n=t.map(o=>o.encode).reduceRight(r,e),s=t.map(o=>o.decode).reduce(r,e);return{encode:n,decode:s}}function Jn(t){const e=typeof t=="string"?t.split(""):t,r=e.length;Xn("alphabet",e);const n=new Map(e.map((s,o)=>[s,o]));return{encode:s=>(Xe(s),s.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=r)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${t}`);return e[o]})),decode:s=>(Xe(s),s.map(o=>{De("alphabet.decode",o);const i=n.get(o);if(i===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${t}`);return i}))}}function Qn(t=""){return De("join",t),{encode:e=>(Xn("join.decode",e),e.join(t)),decode:e=>(De("join.decode",e),e.split(t))}}function hn(t,e,r){if(e<2)throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);if(Xe(t),!t.length)return[];let n=0;const s=[],o=Array.from(t,a=>{if(Ne(a),a<0||a>=e)throw new Error(`invalid integer: ${a}`);return a}),i=o.length;for(;;){let a=0,c=!0;for(let d=n;d<i;d++){const h=o[d],y=e*a,g=y+h;if(!Number.isSafeInteger(g)||y/e!==a||g-h!==y)throw new Error("convertRadix: carry overflow");const u=g/r;a=g%r;const m=Math.floor(u);if(o[d]=m,!Number.isSafeInteger(m)||m*r+a!==g)throw new Error("convertRadix: carry overflow");if(c)m?c=!1:n=d;else continue}if(s.push(a),c)break}for(let a=0;a<t.length-1&&t[a]===0;a++)s.push(0);return s.reverse()}const er=(t,e)=>e===0?t:er(e,t%e),Je=(t,e)=>t+(e-er(t,e)),qe=(()=>{let t=[];for(let e=0;e<40;e++)t.push(2**e);return t})();function Ct(t,e,r,n){if(Xe(t),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(Je(e,r)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${Je(e,r)}`);let s=0,o=0;const i=qe[e],a=qe[r]-1,c=[];for(const d of t){if(Ne(d),d>=i)throw new Error(`convertRadix2: invalid data word=${d} from=${e}`);if(s=s<<e|d,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=r;o-=r)c.push((s>>o-r&a)>>>0);const h=qe[o];if(h===void 0)throw new Error("invalid carry");s&=h-1}if(s=s<<r-o&a,!n&&o>=e)throw new Error("Excess padding");if(!n&&s>0)throw new Error(`Non-zero padding: ${s}`);return n&&o>0&&c.push(s>>>0),c}function Os(t){Ne(t);const e=2**8;return{encode:r=>{if(!_e(r))throw new Error("radix.encode input should be Uint8Array");return hn(Array.from(r),e,t)},decode:r=>(Ht("radix.decode",r),Uint8Array.from(hn(r,t,e)))}}function Rs(t,e=!1){if(Ne(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(Je(8,t)>32||Je(t,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!_e(r))throw new Error("radix2.encode input should be Uint8Array");return Ct(Array.from(r),8,t,!e)},decode:r=>(Ht("radix2.decode",r),Uint8Array.from(Ct(r,t,8,e)))}}function pn(t){return Gn(t),function(...e){try{return t.apply(null,e)}catch{}}}function Ns(t,e){return Ne(t),Gn(e),{encode(r){if(!_e(r))throw new Error("checksum.encode: input should be Uint8Array");const n=e(r).slice(0,t),s=new Uint8Array(r.length+t);return s.set(r),s.set(n,r.length),s},decode(r){if(!_e(r))throw new Error("checksum.decode: input should be Uint8Array");const n=r.slice(0,-t),s=r.slice(-t),o=e(n).slice(0,t);for(let i=0;i<t;i++)if(o[i]!==s[i])throw new Error("Invalid checksum");return n}}}const Ws=t=>zt(Os(58),Jn(t),Qn("")),Ps=Ws("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),tr=t=>zt(Ns(4,e=>t(t(e))),Ps),ei=tr,xt=zt(Jn("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),Qn("")),yn=[996825010,642813549,513874426,1027748829,705979059];function ve(t){const e=t>>25;let r=(t&33554431)<<5;for(let n=0;n<yn.length;n++)(e>>n&1)===1&&(r^=yn[n]);return r}function wn(t,e,r=1){const n=t.length;let s=1;for(let o=0;o<n;o++){const i=t.charCodeAt(o);if(i<33||i>126)throw new Error(`Invalid prefix (${t})`);s=ve(s)^i>>5}s=ve(s);for(let o=0;o<n;o++)s=ve(s)^t.charCodeAt(o)&31;for(let o of e)s=ve(s)^o;for(let o=0;o<6;o++)s=ve(s);return s^=r,xt.encode(Ct([s%qe[30]],30,5,!1))}function nr(t){const e=t==="bech32"?1:734539939,r=Rs(5),n=r.decode,s=r.encode,o=pn(n);function i(y,g,u=90){De("bech32.encode prefix",y),_e(g)&&(g=Array.from(g)),Ht("bech32.encode",g);const m=y.length;if(m===0)throw new TypeError(`Invalid prefix length ${m}`);const B=m+7+g.length;if(u!==!1&&B>u)throw new TypeError(`Length ${B} exceeds limit ${u}`);const x=y.toLowerCase(),K=wn(x,g,e);return`${x}1${xt.encode(g)}${K}`}function a(y,g=90){De("bech32.decode input",y);const u=y.length;if(u<8||g!==!1&&u>g)throw new TypeError(`invalid string length: ${u} (${y}). Expected (8..${g})`);const m=y.toLowerCase();if(y!==m&&y!==y.toUpperCase())throw new Error("String must be lowercase or uppercase");const B=m.lastIndexOf("1");if(B===0||B===-1)throw new Error('Letter "1" must be present between prefix and data only');const x=m.slice(0,B),K=m.slice(B+1);if(K.length<6)throw new Error("Data must be at least 6 characters long");const Q=xt.decode(K).slice(0,-6),G=wn(x,Q,e);if(!K.endsWith(G))throw new Error(`Invalid checksum in ${y}: expected "${G}"`);return{prefix:x,words:Q}}const c=pn(a);function d(y){const{prefix:g,words:u}=a(y,!1);return{prefix:g,words:u,bytes:n(u)}}function h(y,g){return i(y,s(g))}return{encode:i,decode:a,encodeFromBytes:h,decodeToBytes:d,decodeUnsafe:c,fromWords:n,fromWordsUnsafe:o,toWords:s}}const ti=nr("bech32"),ni=nr("bech32m");const Ce=oe.Point,{Fn:Ae}=Ce,ut=tr(j),Ms=Uint8Array.from("Bitcoin seed".split(""),t=>t.charCodeAt(0)),ft={private:76066276,public:76067358},ht=2147483648,Us=t=>Le(j(t)),Fs=t=>tt(t).getUint32(0,!1),He=t=>{if(!Number.isSafeInteger(t)||t<0||t>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+t);const e=new Uint8Array(4);return tt(e).setUint32(0,t,!1),e};class fe{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Fs(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const e=this._privateKey;if(!e)throw new Error("No private key");return ut.encode(this.serialize(this.versions.private,J(Uint8Array.of(0),e)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return ut.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(e,r=ft){if(U(e),8*e.length<128||8*e.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+e.length);const n=Ke(Et,Ms,e),s=n.slice(0,32),o=n.slice(32);return new fe({versions:r,chainCode:o,privateKey:s})}static fromExtendedKey(e,r=ft){const n=ut.decode(e),s=tt(n),o=s.getUint32(0,!1),i={versions:r,depth:n[4],parentFingerprint:s.getUint32(5,!1),index:s.getUint32(9,!1),chainCode:n.slice(13,45)},a=n.slice(45),c=a[0]===0;if(o!==r[c?"private":"public"])throw new Error("Version mismatch");return c?new fe({...i,privateKey:a.slice(1)}):new fe({...i,publicKey:a})}static fromJSON(e){return fe.fromExtendedKey(e.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(e){if(!e||typeof e!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||ft,this.depth=e.depth||0,this.chainCode=e.chainCode||null,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!oe.utils.isValidSecretKey(e.privateKey))throw new Error("Invalid private key");this._privateKey=e.privateKey,this._publicKey=oe.getPublicKey(e.privateKey,!0)}else if(e.publicKey)this._publicKey=Ce.fromBytes(e.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=Us(this._publicKey)}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;const r=e.replace(/^[mM]'?\//,"").split("/");let n=this;for(const s of r){const o=/^(\d+)('?)$/.exec(s),i=o&&o[1];if(!o||o.length!==3||typeof i!="string")throw new Error("invalid child index: "+s);let a=+i;if(!Number.isSafeInteger(a)||a>=ht)throw new Error("Invalid index");o[2]==="'"&&(a+=ht),n=n.deriveChild(a)}return n}deriveChild(e){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let r=He(e);if(e>=ht){const c=this._privateKey;if(!c)throw new Error("Could not derive hardened child key");r=J(Uint8Array.of(0),c,r)}else r=J(this._publicKey,r);const n=Ke(Et,this.chainCode,r),s=n.slice(0,32),o=n.slice(32);if(!oe.utils.isValidSecretKey(s))throw new Error("Tweak bigger than curve order");const i={versions:this.versions,chainCode:o,depth:this.depth+1,parentFingerprint:this.fingerprint,index:e},a=Ae.fromBytes(s);try{if(this._privateKey){const c=Ae.create(Ae.fromBytes(this._privateKey)+a);if(!Ae.isValidNot0(c))throw new Error("The tweak was out of range or the resulted private key is invalid");i.privateKey=Ae.toBytes(c)}else{const c=Ce.fromBytes(this._publicKey).add(Ce.BASE.multiply(a));if(c.equals(Ce.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");i.publicKey=c.toBytes(!0)}return new fe(i)}catch{return this.deriveChild(e+1)}}sign(e){if(!this._privateKey)throw new Error("No privateKey set!");return U(e,32),oe.sign(e,this._privateKey,{prehash:!1})}verify(e,r){if(U(e,32),U(r,64),!this._publicKey)throw new Error("No publicKey set!");return oe.verify(r,e,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,r){if(!this.chainCode)throw new Error("No chainCode set");return U(r,33),J(He(e),new Uint8Array([this.depth]),He(this.parentFingerprint),He(this.index),this.chainCode,r)}}function $s(t,e,r,n){Nt(t);const s=Kr({dkLen:32,asyncTick:10},n),{c:o,dkLen:i,asyncTick:a}=s;if(ke(o,"c"),ke(i,"dkLen"),ke(a,"asyncTick"),o<1)throw new Error("iterations (c) must be >= 1");const c=rn(e,"password"),d=rn(r,"salt"),h=new Uint8Array(i),y=Ke.create(t,c),g=y._cloneInto().update(d);return{c:o,dkLen:i,asyncTick:a,DK:h,PRF:y,PRFSalt:g}}function Hs(t,e,r,n,s){return t.destroy(),e.destroy(),n&&n.destroy(),et(s),r}function zs(t,e,r,n){const{c:s,dkLen:o,DK:i,PRF:a,PRFSalt:c}=$s(t,e,r,n);let d;const h=new Uint8Array(4),y=tt(h),g=new Uint8Array(a.outputLen);for(let u=1,m=0;m<o;u++,m+=a.outputLen){const B=i.subarray(m,m+a.outputLen);y.setInt32(0,u,!1),(d=c._cloneInto(d)).update(h).digestInto(g),B.set(g.subarray(0,B.length));for(let x=1;x<s;x++){a._cloneInto(d).update(g).digestInto(g);for(let K=0;K<B.length;K++)B[K]^=g[K]}}return Hs(a,c,i,d,g)}function rr(t){if(typeof t!="string")throw new TypeError("invalid mnemonic type: "+typeof t);return t.normalize("NFKD")}function js(t){const e=rr(t),r=e.split(" ");if(![12,15,18,21,24].includes(r.length))throw new Error("Invalid mnemonic");return{nfkd:e,words:r}}const Vs=t=>rr("mnemonic"+t);function Ys(t,e=""){return zs(Et,js(t).nfkd,Vs(e),{c:2048,dkLen:64})}const qs=BigInt(0),Ie=BigInt(1),Zs=BigInt(2),Gs=BigInt(7),Xs=BigInt(256),Js=BigInt(113),sr=[],or=[],ir=[];for(let t=0,e=Ie,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],sr.push(2*(5*n+r)),or.push((t+1)*(t+2)/2%64);let s=qs;for(let o=0;o<7;o++)e=(e<<Ie^(e>>Gs)*Js)%Xs,e&Zs&&(s^=Ie<<(Ie<<BigInt(o))-Ie);ir.push(s)}const ar=Mr(ir,!0),Qs=ar[0],eo=ar[1],mn=(t,e,r)=>r>32?Wr(t,e,r):Rr(t,e,r),gn=(t,e,r)=>r>32?Pr(t,e,r):Nr(t,e,r);function to(t,e=24){const r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let i=0;i<10;i++)r[i]=t[i]^t[i+10]^t[i+20]^t[i+30]^t[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,d=r[c],h=r[c+1],y=mn(d,h,1)^r[a],g=gn(d,h,1)^r[a+1];for(let u=0;u<50;u+=10)t[i+u]^=y,t[i+u+1]^=g}let s=t[2],o=t[3];for(let i=0;i<24;i++){const a=or[i],c=mn(s,o,a),d=gn(s,o,a),h=sr[i];s=t[h],o=t[h+1],t[h]=c,t[h+1]=d}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)r[a]=t[i+a];for(let a=0;a<10;a++)t[i+a]^=~r[(a+2)%10]&r[(a+4)%10]}t[0]^=Qs[n],t[1]^=eo[n]}et(r)}class jt{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(e,r,n,s=!1,o=24){if(this.blockLen=e,this.suffix=r,this.outputLen=n,this.enableXOF=s,this.rounds=o,ke(n,"outputLen"),!(0<e&&e<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=Dr(this.state)}clone(){return this._cloneInto()}keccak(){sn(this.state32),to(this.state32,this.rounds),sn(this.state32),this.posOut=0,this.pos=0}update(e){Ze(this),U(e);const{blockLen:r,state:n}=this,s=e.length;for(let o=0;o<s;){const i=Math.min(r-this.pos,s-o);for(let a=0;a<i;a++)n[this.pos++]^=e[o++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:r,pos:n,blockLen:s}=this;e[n]^=r,(r&128)!==0&&n===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){Ze(this,!1),U(e),this.finish();const r=this.state,{blockLen:n}=this;for(let s=0,o=e.length;s<o;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,o-s);e.set(r.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return ke(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Or(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,et(this.state)}_cloneInto(e){const{blockLen:r,suffix:n,outputLen:s,rounds:o,enableXOF:i}=this;return e||=new jt(r,n,s,i,o),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=n,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}}const no=(t,e,r,n={})=>_r(()=>new jt(e,t,r),n),Vt=no(1,136,32),cr={ethereum:60,bitcoin:0,tron:195,bfmeta:9999};function Yt(t,e){const r=Ys(t,e);return fe.fromMasterSeed(r)}function ro(t,e=0,r=0,n=0){return`m/44'/${cr[t]}'/${e}'/${r}/${n}`}function so(t,e,r=0,n=0,s=0){return`m/${t}'/${e}'/${r}'/${n}/${s}`}function qt(t,e){return t.derive(e)}function bn(t){const r=oe.getPublicKey(t,!1).slice(1),s=Vt(r).slice(-20);return"0x"+ie(s)}function En(t){const e=t.toLowerCase().replace("0x",""),r=new TextEncoder,n=ie(Vt(r.encode(e)));let s="0x";for(let o=0;o<e.length;o++)parseInt(n[o],16)>=8?s+=e[o].toUpperCase():s+=e[o];return s}function dr(t,e="mainnet"){const r=j(t),n=Le(r),s=e==="mainnet"?0:111,o=new Uint8Array([s,...n]),i=j(j(o)).slice(0,4),a=new Uint8Array([...o,...i]);return Zt(a)}function oo(t,e="mainnet"){const r=j(t),n=Le(r),s=new Uint8Array([0,20,...n]),o=j(s),i=Le(o),a=e==="mainnet"?5:196,c=new Uint8Array([a,...i]),d=j(j(c)).slice(0,4),h=new Uint8Array([...c,...d]);return Zt(h)}function io(t,e="mainnet"){const r=j(t),n=Le(r);return ho(e==="mainnet"?"bc":"tb",0,n)}function ao(t,e="mainnet"){const r=t.length===33?t.slice(1):t.slice(1,33);return po(e==="mainnet"?"bc":"tb",1,r)}function co(t){const r=oe.getPublicKey(t,!1).slice(1),s=Vt(r).slice(-20),o=new Uint8Array([65,...s]),i=j(j(o)).slice(0,4),a=new Uint8Array([...o,...i]);return Zt(a)}const vn="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";function Zt(t){const e=[0];for(const n of t){let s=n;for(let o=0;o<e.length;o++)s+=e[o]<<8,e[o]=s%58,s=s/58|0;for(;s>0;)e.push(s%58),s=s/58|0}let r="";for(const n of t)if(n===0)r+=vn[0];else break;for(let n=e.length-1;n>=0;n--)r+=vn[e[n]];return r}const lr="qpzry9x8gf2tvdw0s3jn54khce6mua7l",lo=[996825010,642813549,513874426,1027748829,705979059];function uo(t){let e=1;for(const r of t){const n=e>>25;e=(e&33554431)<<5^r;for(let s=0;s<5;s++)n>>s&1&&(e^=lo[s])}return e}function fo(t){const e=[];for(const r of t)e.push(r.charCodeAt(0)>>5);e.push(0);for(const r of t)e.push(r.charCodeAt(0)&31);return e}function ur(t,e,r){const n=[...fo(t),...e],s=r?734539939:1,o=uo([...n,0,0,0,0,0,0])^s,i=[];for(let a=0;a<6;a++)i.push(o>>5*(5-a)&31);return i}function fr(t,e,r,n){let s=0,o=0;const i=[],a=(1<<r)-1;for(const c of t)for(s=s<<e|c,o+=e;o>=r;)o-=r,i.push(s>>o&a);return o>0&&i.push(s<<r-o&a),i}function ho(t,e,r){const n=fr(r,8,5),s=[e,...n],o=ur(t,s,!1),i=[...s,...o].map(a=>lr[a]).join("");return`${t}1${i}`}function po(t,e,r){const n=fr(r,8,5),s=[e,...n],o=ur(t,s,!0),i=[...s,...o].map(a=>lr[a]).join("");return`${t}1${i}`}function pt(t,e,r=0,n=0){const s=Yt(t),o=ro(e,n,0,r),i=qt(s,o);if(!i.privateKey||!i.publicKey)throw new Error("密钥派生失败");const a=ie(i.privateKey),c=ie(i.publicKey);let d;switch(e){case"ethereum":d=En(bn(i.privateKey));break;case"bitcoin":d=dr(i.publicKey);break;case"tron":d=co(i.privateKey);break;case"bfmeta":d=En(bn(i.privateKey));break;default:throw new Error(`不支持的链类型: ${e}`)}return{privateKey:a,publicKey:c,address:d,path:o,chain:e}}function yo(t,e=44,r=0,n=0,s="mainnet"){const o=Yt(t),i=so(e,cr.bitcoin,n,0,r),a=qt(o,i);if(!a.privateKey||!a.publicKey)throw new Error("密钥派生失败");const c=ie(a.privateKey),d=ie(a.publicKey);let h;switch(e){case 44:h=dr(a.publicKey,s);break;case 49:h=oo(a.publicKey,s);break;case 84:h=io(a.publicKey,s);break;case 86:h=ao(a.publicKey,s);break;default:throw new Error(`不支持的 Bitcoin purpose: ${e}`)}return{privateKey:c,publicKey:d,address:h,path:i,chain:"bitcoin",purpose:e}}function wo(t,e=0,r=0,n="mainnet"){return[44,49,84,86].map(o=>yo(t,o,e,r,n))}function ri(t,e=0,r=0){const n=[];return n.push(pt(t,"ethereum",e,r)),n.push(pt(t,"bfmeta",e,r)),n.push(pt(t,"tron",e,r)),n.push(...wo(t,e,r)),n}function ze(t){const e=Yt(t),n=qt(e,"m/44'/9999'/0'/1/0");if(!n.privateKey)throw new Error("密钥派生失败");return n.privateKey}function je(t){const r=new TextEncoder().encode(`KeyApp:EncryptionKey:${t}`);return j(r)}function si(t,e){switch(e){case"ethereum":case"bfmeta":return/^0x[a-fA-F0-9]{40}$/.test(t);case"bitcoin":return/^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(t)||/^bc1q[a-z0-9]{38,}$/.test(t)||/^bc1p[a-z0-9]{58}$/.test(t);case"tron":return/^T[a-zA-Z0-9]{33}$/.test(t);default:return!1}}const kt=(t,e)=>e.some(r=>t instanceof r);let An,In;function mo(){return An||(An=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function go(){return In||(In=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const Bt=new WeakMap,yt=new WeakMap,ot=new WeakMap;function bo(t){const e=new Promise((r,n)=>{const s=()=>{t.removeEventListener("success",o),t.removeEventListener("error",i)},o=()=>{r(pe(t.result)),s()},i=()=>{n(t.error),s()};t.addEventListener("success",o),t.addEventListener("error",i)});return ot.set(e,t),e}function Eo(t){if(Bt.has(t))return;const e=new Promise((r,n)=>{const s=()=>{t.removeEventListener("complete",o),t.removeEventListener("error",i),t.removeEventListener("abort",i)},o=()=>{r(),s()},i=()=>{n(t.error||new DOMException("AbortError","AbortError")),s()};t.addEventListener("complete",o),t.addEventListener("error",i),t.addEventListener("abort",i)});Bt.set(t,e)}let Tt={get(t,e,r){if(t instanceof IDBTransaction){if(e==="done")return Bt.get(t);if(e==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return pe(t[e])},set(t,e,r){return t[e]=r,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function hr(t){Tt=t(Tt)}function vo(t){return go().includes(t)?function(...e){return t.apply(Lt(this),e),pe(this.request)}:function(...e){return pe(t.apply(Lt(this),e))}}function Ao(t){return typeof t=="function"?vo(t):(t instanceof IDBTransaction&&Eo(t),kt(t,mo())?new Proxy(t,Tt):t)}function pe(t){if(t instanceof IDBRequest)return bo(t);if(yt.has(t))return yt.get(t);const e=Ao(t);return e!==t&&(yt.set(t,e),ot.set(e,t)),e}const Lt=t=>ot.get(t);function Io(t,e,{blocked:r,upgrade:n,blocking:s,terminated:o}={}){const i=indexedDB.open(t,e),a=pe(i);return n&&i.addEventListener("upgradeneeded",c=>{n(pe(i.result),c.oldVersion,c.newVersion,pe(i.transaction),c)}),r&&i.addEventListener("blocked",c=>r(c.oldVersion,c.newVersion,c)),a.then(c=>{o&&c.addEventListener("close",()=>o()),s&&c.addEventListener("versionchange",d=>s(d.oldVersion,d.newVersion,d))}).catch(()=>{}),a}const So=["get","getKey","getAll","getAllKeys","count"],Co=["put","add","delete","clear"],wt=new Map;function Sn(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(wt.get(e))return wt.get(e);const r=e.replace(/FromIndex$/,""),n=e!==r,s=Co.includes(r);if(!(r in(n?IDBIndex:IDBObjectStore).prototype)||!(s||So.includes(r)))return;const o=async function(i,...a){const c=this.transaction(i,s?"readwrite":"readonly");let d=c.store;return n&&(d=d.index(a.shift())),(await Promise.all([d[r](...a),s&&c.done]))[0]};return wt.set(e,o),o}hr(t=>({...t,get:(e,r,n)=>Sn(e,r)||t.get(e,r,n),has:(e,r)=>!!Sn(e,r)||t.has(e,r)}));const xo=["continue","continuePrimaryKey","advance"],Cn={},Kt=new WeakMap,pr=new WeakMap,ko={get(t,e){if(!xo.includes(e))return t[e];let r=Cn[e];return r||(r=Cn[e]=function(...n){Kt.set(this,pr.get(this)[e](...n))}),r}};async function*Bo(...t){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...t)),!e)return;e=e;const r=new Proxy(e,ko);for(pr.set(r,e),ot.set(r,Lt(e));e;)yield r,e=await(Kt.get(r)||e.continue()),Kt.delete(r)}function xn(t,e){return e===Symbol.asyncIterator&&kt(t,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&kt(t,[IDBIndex,IDBObjectStore])}hr(t=>({...t,get(e,r,n){return xn(e,r)?Bo:t.get(e,r,n)},has(e,r){return xn(e,r)||t.has(e,r)}}));function Se(t,e,r){if(!Array.isArray(e))return console.warn(`[safeParse] Expected array from ${r}, got ${typeof e}`),[];const n=[];for(let s=0;s<e.length;s++){const o=t.safeParse(e[s]);o.success?n.push(o.data):console.warn(`[safeParse] Invalid item at index ${s} from ${r}:`,o.error.issues[0])}return n}const Ve=2;var D=(t=>(t.NOT_INITIALIZED="STORAGE_NOT_INITIALIZED",t.WALLET_NOT_FOUND="WALLET_NOT_FOUND",t.ADDRESS_NOT_FOUND="ADDRESS_NOT_FOUND",t.DECRYPTION_FAILED="DECRYPTION_FAILED",t.ENCRYPTION_FAILED="ENCRYPTION_FAILED",t.STORAGE_FULL="STORAGE_FULL",t.MIGRATION_FAILED="MIGRATION_FAILED",t.INVALID_PASSWORD="INVALID_PASSWORD",t))(D||{});class R extends Error{constructor(e,r,n){super(r),this.code=e,this.cause=n,this.name="WalletStorageError"}}class yr extends Error{code="WALLET_MIGRATION_REQUIRED";storedVersion;requiredVersion;constructor(e,r){super(`Wallet storage migration required: v${e} → v${r}`),this.name="WalletStorageMigrationError",this.storedVersion=e,this.requiredVersion=r}}const _t=q({salt:A(),iv:A(),ciphertext:A()}).passthrough(),To=q({assetType:A(),symbol:A(),decimals:Y(),balance:A().default("0"),contractAddress:A().optional(),logoUrl:A().optional()}).passthrough(),mt=q({addressKey:A(),walletId:A(),chain:A(),address:A(),publicKey:A().optional(),encryptedPrivateKey:_t.optional(),derivationPath:A().optional(),assets:Qe(To).default([]),isCustomAssets:he().default(!1),isFrozen:he().default(!1)}).passthrough(),kn=q({id:A(),name:A(),keyType:Rt(["mnemonic","arbitrary","privateKey"]),primaryChain:A(),primaryAddress:A(),encryptedMnemonic:_t.optional(),encryptedWalletLock:_t.optional(),isBackedUp:he().default(!1),themeHue:Y().optional(),createdAt:Y(),updatedAt:Y()}).passthrough(),Lo=q({name:A(),passwordTips:A().optional(),activeWalletId:A().nullable(),biometricEnabled:he().default(!1),walletLockEnabled:he().default(!0),agreementAccepted:he().default(!1),createdAt:Y(),updatedAt:Y()}).passthrough();q({version:Y(),createdAt:Y(),lastMigratedAt:Y().optional()}).passthrough();const gt=q({id:A(),chain:A(),address:A(),name:A(),note:A().optional(),createdAt:Y(),updatedAt:Y()}).passthrough(),Ko="bfm-wallet-db",_o=1;class Do{db=null;initialized=!1;async initialize(){if(this.initialized)return;this.db=await Io(Ko,_o,{upgrade(n,s,o,i){let a;if(n.objectStoreNames.contains("metadata")||(a=n.createObjectStore("metadata")),n.objectStoreNames.contains("walleter")||n.createObjectStore("walleter"),n.objectStoreNames.contains("wallets")||n.createObjectStore("wallets",{keyPath:"id"}).createIndex("by-chain","primaryChain"),!n.objectStoreNames.contains("chainAddresses")){const c=n.createObjectStore("chainAddresses",{keyPath:"addressKey"});c.createIndex("by-wallet","walletId"),c.createIndex("by-chain","chain")}n.objectStoreNames.contains("addressBook")||n.createObjectStore("addressBook",{keyPath:"id"}).createIndex("by-chain","chain"),s===0&&a?a.put({version:Ve,createdAt:Date.now()},"main"):s===0&&i.objectStore("metadata").put({version:Ve,createdAt:Date.now()},"main")}}),this.initialized=!0;const r=(await this.getMetadata())?.version??0;if(r>0&&r<Ve)throw new yr(r,Ve);await this.runMigrations()}isInitialized(){return this.initialized}ensureInitialized(){if(!this.initialized||!this.db)throw new R(D.NOT_INITIALIZED,"Storage service not initialized. Call initialize() first.")}async getMetadata(){return this.ensureInitialized(),await this.db.get("metadata","main")??null}async saveWalleterInfo(e){this.ensureInitialized(),await this.db.put("walleter",e,"main")}async getWalleterInfo(){this.ensureInitialized();const e=await this.db.get("walleter","main");if(!e)return null;const r=Lo.safeParse(e);return r.success?r.data:(console.warn("[WalletStorage] Invalid walleter info:",r.error.issues[0]),null)}async createWallet(e,r,n){if(this.ensureInitialized(),!r||typeof r!="string")throw new R(D.ENCRYPTION_FAILED,"Invalid mnemonic: mnemonic is required");if(!n||typeof n!="string")throw new R(D.ENCRYPTION_FAILED,"Invalid walletLock: wallet lock password is required");if(typeof crypto>"u"||!crypto.subtle)throw new R(D.ENCRYPTION_FAILED,"Web Crypto API is not available. Please use HTTPS or localhost.");try{const s=await Fe(r,n),o=e.keyType==="mnemonic"?ze(r):je(r),i=await dt(n,o),a={...e,encryptedMnemonic:s,encryptedWalletLock:i};return await this.db.put("wallets",a),a}catch(s){const o=s instanceof Error?s.message:String(s);throw new R(D.ENCRYPTION_FAILED,`Failed to encrypt wallet data: ${o}`,s instanceof Error?s:void 0)}}async saveWallet(e){this.ensureInitialized(),await this.db.put("wallets",e)}async getWallet(e){this.ensureInitialized();const r=await this.db.get("wallets",e);if(!r)return null;const n=kn.safeParse(r);return n.success?n.data:(console.warn("[WalletStorage] Invalid wallet info:",n.error.issues[0]),null)}async getAllWallets(){this.ensureInitialized();const e=await this.db.getAll("wallets");return Se(kn,e,"indexeddb:wallets")}async updateWallet(e,r){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new R(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);await this.db.put("wallets",{...n,...r,updatedAt:Date.now()})}async deleteWallet(e){this.ensureInitialized(),await this.db.delete("wallets",e);const r=await this.getWalletChainAddresses(e),n=this.db.transaction("chainAddresses","readwrite");await Promise.all(r.map(s=>n.store.delete(s.addressKey))),await n.done}async getMnemonic(e,r){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new R(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!n.encryptedMnemonic)throw new R(D.DECRYPTION_FAILED,"No encrypted mnemonic found for this wallet");try{return await At(n.encryptedMnemonic,r)}catch(s){throw new R(D.DECRYPTION_FAILED,"Failed to decrypt mnemonic. Wrong password or corrupted data.",s instanceof Error?s:void 0)}}async updateWalletLockEncryption(e,r,n){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new R(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);const o=await this.getMnemonic(e,r);try{const i=await Fe(o,n),a=s.keyType==="mnemonic"?ze(o):je(o),c=await dt(n,a);await this.updateWallet(e,{encryptedMnemonic:i,encryptedWalletLock:c})}catch(i){throw new R(D.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",i instanceof Error?i:void 0)}}async verifyMnemonic(e,r){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new R(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!n.encryptedWalletLock)throw new R(D.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");try{const s=n.keyType==="mnemonic"?ze(r):je(r);return await ln(n.encryptedWalletLock,s),!0}catch{return!1}}async resetWalletLockByMnemonic(e,r,n){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new R(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!s.encryptedWalletLock)throw new R(D.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");const o=s.keyType==="mnemonic"?ze(r):je(r);try{await ln(s.encryptedWalletLock,o)}catch{throw new R(D.INVALID_PASSWORD,"Invalid mnemonic/secret: failed to decrypt wallet lock")}try{const i=await Fe(r,n),a=await dt(n,o);await this.updateWallet(e,{encryptedMnemonic:i,encryptedWalletLock:a})}catch(i){throw new R(D.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",i instanceof Error?i:void 0)}}async savePrivateKey(e,r,n){this.ensureInitialized();const s=await this.getChainAddress(e);if(!s)throw new R(D.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);try{const o=await Fe(r,n);await this.db.put("chainAddresses",{...s,encryptedPrivateKey:o})}catch(o){throw new R(D.ENCRYPTION_FAILED,"Failed to encrypt private key",o instanceof Error?o:void 0)}}async getPrivateKey(e,r){this.ensureInitialized();const n=await this.getChainAddress(e);if(!n)throw new R(D.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);if(!n.encryptedPrivateKey)throw new R(D.DECRYPTION_FAILED,"No encrypted private key found for this address");try{return await At(n.encryptedPrivateKey,r)}catch(s){throw new R(D.DECRYPTION_FAILED,"Failed to decrypt private key. Wrong password or corrupted data.",s instanceof Error?s:void 0)}}async saveChainAddress(e){this.ensureInitialized(),await this.db.put("chainAddresses",e)}async getChainAddress(e){this.ensureInitialized();const r=await this.db.get("chainAddresses",e);if(!r)return null;const n=mt.safeParse(r);return n.success?n.data:(console.warn("[WalletStorage] Invalid chain address:",n.error.issues[0]),null)}async getWalletChainAddresses(e){this.ensureInitialized();const r=await this.db.getAllFromIndex("chainAddresses","by-wallet",e);return Se(mt,r,"indexeddb:chainAddresses")}async getChainAddresses(e){this.ensureInitialized();const r=await this.db.getAllFromIndex("chainAddresses","by-chain",e);return Se(mt,r,"indexeddb:chainAddresses")}async updateAssets(e,r){this.ensureInitialized();const n=await this.getChainAddress(e);if(!n)throw new R(D.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);await this.db.put("chainAddresses",{...n,assets:r,isCustomAssets:!0})}async deleteChainAddress(e){this.ensureInitialized(),await this.db.delete("chainAddresses",e)}async saveAddressBookEntry(e){this.ensureInitialized(),await this.db.put("addressBook",e)}async getAddressBookEntry(e){this.ensureInitialized();const r=await this.db.get("addressBook",e);if(!r)return null;const n=gt.safeParse(r);return n.success?n.data:(console.warn("[WalletStorage] Invalid address book entry:",n.error.issues[0]),null)}async getAllAddressBookEntries(){this.ensureInitialized();const e=await this.db.getAll("addressBook");return Se(gt,e,"indexeddb:addressBook")}async getChainAddressBookEntries(e){this.ensureInitialized();const r=await this.db.getAllFromIndex("addressBook","by-chain",e);return Se(gt,r,"indexeddb:addressBook")}async deleteAddressBookEntry(e){this.ensureInitialized(),await this.db.delete("addressBook",e)}async clearAll(){this.ensureInitialized();const e=this.db.transaction(["walleter","wallets","chainAddresses","addressBook"],"readwrite");await Promise.all([e.objectStore("walleter").clear(),e.objectStore("wallets").clear(),e.objectStore("chainAddresses").clear(),e.objectStore("addressBook").clear()]),await e.done}close(){this.db&&(this.db.close(),this.db=null,this.initialized=!1)}async runMigrations(){await this.getMetadata()}async migrateFromLocalStorage(){this.ensureInitialized();const e=localStorage.getItem("bfm_wallets");if(!e)return!1;try{const{wallets:r,currentWalletId:n}=JSON.parse(e);for(const o of r){const i={id:o.id,name:o.name,keyType:o.keyType||"mnemonic",primaryChain:o.chain,primaryAddress:o.address,encryptedMnemonic:o.encryptedMnemonic,isBackedUp:!1,createdAt:o.createdAt,updatedAt:Date.now()};if(await this.saveWallet(i),o.chainAddresses)for(const a of o.chainAddresses){const d={addressKey:`${o.id}:${a.chain}`,walletId:o.id,chain:a.chain,address:a.address,assets:[],isCustomAssets:!1,isFrozen:!1};await this.saveChainAddress(d)}}const s=await this.getWalleterInfo();return s?n&&await this.saveWalleterInfo({...s,activeWalletId:n,updatedAt:Date.now()}):await this.saveWalleterInfo({name:"User",activeWalletId:n,biometricEnabled:!1,walletLockEnabled:!1,agreementAccepted:!0,createdAt:Date.now(),updatedAt:Date.now()}),localStorage.removeItem("bfm_wallets"),!0}catch(r){throw console.error("Failed to migrate from localStorage:",r),new R(D.MIGRATION_FAILED,"Failed to migrate data from localStorage",r instanceof Error?r:void 0)}}}const _=new Do;function Bn(t){let e=0;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);e=(e<<5)-e+n,e=e&e}return Math.abs(e)%360}const wr="wallet_chain_preferences";function Oo(){try{const t=localStorage.getItem(wr);if(t)return JSON.parse(t)}catch{}return{}}function Tn(t){try{localStorage.setItem(wr,JSON.stringify(t))}catch{}}const Dt={wallets:[],currentWalletId:null,selectedChain:"ethereum",chainPreferences:{},isLoading:!1,isInitialized:!1,migrationRequired:!1},M=new Ot(Dt);function Ro(t,e){const r=t.keyType==="mnemonic"?"mnemonic":"arbitrary",n={id:t.id,name:t.name,keyType:r,address:t.primaryAddress,chain:t.primaryChain,createdAt:t.createdAt,chainAddresses:e.map(s=>({chain:s.chain,address:s.address,publicKey:s.publicKey??"",tokens:s.assets.map(o=>{const i={id:`${s.chain}:${o.assetType}`,symbol:o.symbol,name:o.symbol,balance:o.balance,fiatValue:0,change24h:0,decimals:o.decimals,chain:s.chain};return o.contractAddress&&(i.contractAddress=o.contractAddress),o.logoUrl&&(i.icon=o.logoUrl),i})})),themeHue:t.themeHue??0,tokens:[]};return t.encryptedMnemonic&&(n.encryptedMnemonic=t.encryptedMnemonic),t.encryptedWalletLock&&(n.encryptedWalletLock=t.encryptedWalletLock),n}const Ye={initialize:async()=>{const t=M.state;if(!(t.isInitialized||t.isLoading)){M.setState(e=>({...e,isLoading:!0}));try{await _.initialize(),await _.migrateFromLocalStorage();const[e,r]=await Promise.all([_.getWalleterInfo(),_.getAllWallets()]),n=await Promise.all(r.map(async c=>{const d=await _.getWalletChainAddresses(c.id);return Ro(c,d)})),s=Oo(),o=e?.activeWalletId??n[0]?.id??null,i=n.find(c=>c.id===o),a=o?s[o]??i?.chain??"bfmeta":"bfmeta";M.setState(c=>({...c,wallets:n,currentWalletId:o,selectedChain:a,chainPreferences:s,isInitialized:!0,isLoading:!1}))}catch(e){if(e instanceof yr){M.setState(r=>({...r,isInitialized:!0,isLoading:!1,migrationRequired:!0}));return}console.error("Failed to initialize wallets:",e),M.setState(r=>({...r,isInitialized:!0,isLoading:!1}))}}},createWallet:async(t,e,r,n)=>{const s=crypto.randomUUID(),o=Date.now(),i={id:s,name:t.name,keyType:t.keyType??"mnemonic",primaryChain:t.chain,primaryAddress:t.address,isBackedUp:!1,themeHue:n??Bn(e),createdAt:o,updatedAt:o},a=await _.createWallet(i,e,r),c=t.chainAddresses||[{chain:t.chain,address:t.address,publicKey:"",tokens:[]}];for(const y of c)await _.saveChainAddress({addressKey:`${s}:${y.chain}`,walletId:s,chain:y.chain,address:y.address,publicKey:y.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});const d=await _.getWalleterInfo();await _.saveWalleterInfo({name:d?.name??"User",activeWalletId:s,biometricEnabled:d?.biometricEnabled??!1,walletLockEnabled:d?.walletLockEnabled??!1,agreementAccepted:!0,createdAt:d?.createdAt??o,updatedAt:o});const h={id:s,name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:o,chainAddresses:c,themeHue:n??Bn(e),tokens:[],...a.encryptedMnemonic?{encryptedMnemonic:a.encryptedMnemonic}:{}};return M.setState(y=>({...y,wallets:[...y.wallets,h],currentWalletId:s})),h},importWallet:async(t,e,r)=>Ye.createWallet(t,e,r),deleteWallet:async t=>{await _.deleteWallet(t),M.setState(e=>{const r=e.wallets.filter(c=>c.id!==t),n=e.currentWalletId===t?r[0]?.id??null:e.currentWalletId,{[t]:s,...o}=e.chainPreferences;Tn(o);const i=r.find(c=>c.id===n),a=n?o[n]??i?.chain??"bfmeta":e.selectedChain;return{...e,wallets:r,currentWalletId:n,selectedChain:a,chainPreferences:o}})},setCurrentWallet:async t=>{const e=await _.getWalleterInfo();e&&await _.saveWalleterInfo({...e,activeWalletId:t,updatedAt:Date.now()}),M.setState(r=>{const n=r.wallets.find(o=>o.id===t),s=r.chainPreferences[t]??n?.chain??"bfmeta";return{...r,currentWalletId:t,selectedChain:s}})},setSelectedChain:t=>{M.setState(e=>{const{currentWalletId:r,chainPreferences:n}=e;if(r){const s={...n,[r]:t};return Tn(s),{...e,selectedChain:t,chainPreferences:s}}return{...e,selectedChain:t}})},updateWalletName:async(t,e)=>{await _.updateWallet(t,{name:e}),M.setState(r=>({...r,wallets:r.wallets.map(n=>n.id===t?{...n,name:e}:n)}))},updateWalletThemeHue:async(t,e)=>{await _.updateWallet(t,{themeHue:e}),M.setState(r=>({...r,wallets:r.wallets.map(n=>n.id===t?{...n,themeHue:e}:n)}))},updateChainAssets:async(t,e,r)=>{const n=`${t}:${e}`;await _.updateAssets(n,r.map(s=>({assetType:s.symbol,symbol:s.symbol,decimals:s.decimals,balance:s.balance,contractAddress:s.contractAddress,logoUrl:s.icon}))),M.setState(s=>({...s,wallets:s.wallets.map(o=>o.id!==t?o:{...o,chainAddresses:o.chainAddresses.map(i=>i.chain===e?{...i,tokens:r}:i)})}))},refreshBalance:async(t,e)=>{const n=M.state.wallets.find(o=>o.id===t);if(!n)return{supported:!1,fallbackReason:"Wallet not found"};const s=n.chainAddresses.find(o=>o.chain===e);if(!s)return{supported:!1,fallbackReason:"Chain address not found"};try{const{getChainProvider:o,isSupported:i}=await Qt(async()=>{const{getChainProvider:y,isSupported:g}=await import("./index-B2mNTGNA.js").then(u=>u.z);return{getChainProvider:y,isSupported:g}},__vite__mapDeps([0,1,2,3,4,5,6,7]),import.meta.url),a=o(e);if(a.supportsTokenBalances){const y=await a.getTokenBalances(s.address);if(i(y)&&y.data.length>0){const g=y.data.map(u=>({id:`${e}:${u.symbol}`,symbol:u.symbol,name:u.name,balance:u.amount.toFormatted(),fiatValue:0,change24h:0,decimals:u.amount.decimals,chain:e}));return await Ye.updateChainAssets(t,e,g),{supported:!0}}}const c=await a.getNativeBalance(s.address);if(!i(c))return{supported:!1,fallbackReason:c.reason};const d=c.data,h=[{id:`${e}:${d.symbol}`,symbol:d.symbol,name:d.symbol,balance:d.amount.toFormatted(),fiatValue:0,change24h:0,decimals:d.amount.decimals,chain:e}];return await Ye.updateChainAssets(t,e,h),{supported:!0}}catch(o){return console.error(`[refreshBalance] Failed to refresh balance for ${e}:`,o),{supported:!1,fallbackReason:o instanceof Error?o.message:"Unknown error"}}},refreshAllBalances:async()=>{const t=M.state,e=xe.getCurrentWallet(t);e&&await Promise.all(e.chainAddresses.map(r=>Ye.refreshBalance(e.id,r.chain)))},updateWalletLock:async(t,e,r)=>{await _.updateWalletLockEncryption(t,e,r);const n=await _.getWallet(t);n?.encryptedMnemonic&&n.encryptedWalletLock&&M.setState(s=>({...s,wallets:s.wallets.map(o=>o.id===t?{...o,encryptedMnemonic:n.encryptedMnemonic,encryptedWalletLock:n.encryptedWalletLock}:o)}))},verifyMnemonic:async(t,e)=>_.verifyMnemonic(t,e),resetWalletLockByMnemonic:async(t,e,r)=>{await _.resetWalletLockByMnemonic(t,e,r);const n=await _.getWallet(t);n?.encryptedMnemonic&&n.encryptedWalletLock&&M.setState(s=>({...s,wallets:s.wallets.map(o=>o.id===t?{...o,encryptedMnemonic:n.encryptedMnemonic,encryptedWalletLock:n.encryptedWalletLock}:o)}))},getMnemonic:async(t,e)=>_.getMnemonic(t,e),updateWalletChainAddresses:async(t,e,r,n)=>{const o=M.state.wallets.find(u=>u.id===t);if(!o)throw new Error("Wallet not found");const i=await _.getMnemonic(t,r),a=new Set(o.chainAddresses.map(u=>u.chain)),c=new Set(e),d=e.filter(u=>!a.has(u)),h=[...a].filter(u=>!c.has(u));if(d.length===0&&h.length===0)return;let y=[];if(d.length>0){const{deriveWalletChainAddresses:u}=await Qt(async()=>{const{deriveWalletChainAddresses:x}=await import("./index-B0RUVa8g.js");return{deriveWalletChainAddresses:x}},__vite__mapDeps([8,0,1,2,3,4,5,6,7,9]),import.meta.url),m=n.filter(x=>d.includes(x.id));y=(await u({mnemonic:i,chainConfigs:m,selectedChainIds:d})).map(x=>({chain:x.chainId,address:x.address,publicKey:x.publicKey??""}))}for(const u of y)await _.saveChainAddress({addressKey:`${t}:${u.chain}`,walletId:t,chain:u.chain,address:u.address,publicKey:u.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});for(const u of h)await _.deleteChainAddress(`${t}:${u}`);const g=[...o.chainAddresses.filter(u=>!h.includes(u.chain)),...y.map(u=>({chain:u.chain,address:u.address,publicKey:u.publicKey,tokens:[]}))];M.setState(u=>({...u,wallets:u.wallets.map(m=>m.id===t?{...m,chainAddresses:g}:m)}))},clearAll:async()=>{await _.clearAll(),M.setState(()=>Dt)},_testAddWallet:t=>{const e={id:t.id??crypto.randomUUID(),name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:t.createdAt??Date.now(),chainAddresses:t.chainAddresses??[{chain:t.chain,address:t.address,publicKey:"",tokens:[]}],themeHue:t.themeHue,tokens:[],...t.encryptedMnemonic?{encryptedMnemonic:t.encryptedMnemonic}:{}};return M.setState(r=>({...r,wallets:[...r.wallets,e],currentWalletId:r.currentWalletId??e.id,isInitialized:!0})),e},_testReset:()=>{M.setState(()=>Dt)}},xe={getCurrentWallet:t=>t.currentWalletId&&t.wallets.find(e=>e.id===t.currentWalletId)||null,getCurrentChainAddress:t=>{const e=xe.getCurrentWallet(t);return e&&e.chainAddresses.find(r=>r.chain===t.selectedChain)||null},getCurrentChainTokens:t=>xe.getCurrentChainAddress(t)?.tokens||[],getAvailableChains:t=>{const e=xe.getCurrentWallet(t);return e?e.chainAddresses.map(r=>r.chain):[]},getTotalFiatValue:t=>{const e=xe.getCurrentWallet(t);return e?e.chainAddresses.reduce((r,n)=>r+n.tokens.reduce((s,o)=>s+o.fiatValue,0),0):0},hasWallet:t=>t.wallets.length>0},mr={contacts:[],isInitialized:!1},ee=new Ot(mr),Gt="bfm_address_book",gr=3;function ue(t){try{const e={version:gr,contacts:t};localStorage.setItem(Gt,JSON.stringify(e))}catch(e){console.error("Failed to persist address book:",e)}}function No(){try{const t=localStorage.getItem(Gt);if(!t)return[];const e=JSON.parse(t);return e.version===gr&&Array.isArray(e.contacts)?e.contacts:[]}catch(t){return console.error("Failed to load address book:",t),[]}}const oi={initialize:()=>{const t=No();ee.setState(()=>({contacts:t,isInitialized:!0}))},addContact:t=>{if(t.addresses.length>3)throw new Error("Maximum 3 addresses per contact");const e=Date.now(),r={...t,id:crypto.randomUUID(),createdAt:e,updatedAt:e};return ee.setState(n=>{const s=[...n.contacts,r];return ue(s),{...n,contacts:s}}),r},updateContact:(t,e)=>{ee.setState(r=>{const n=r.contacts.map(s=>s.id===t?{...s,...e,updatedAt:Date.now()}:s);return ue(n),{...r,contacts:n}})},deleteContact:t=>{ee.setState(e=>{const r=e.contacts.filter(n=>n.id!==t);return ue(r),{...e,contacts:r}})},addAddressToContact:(t,e)=>{const r={...e,id:crypto.randomUUID()};ee.setState(n=>{const s=n.contacts.map(o=>{if(o.id!==t)return o;if(o.addresses.length>=3)throw new Error("Maximum 3 addresses per contact");return{...o,addresses:[...o.addresses,r],updatedAt:Date.now()}});return ue(s),{...n,contacts:s}})},removeAddressFromContact:(t,e)=>{ee.setState(r=>{const n=r.contacts.map(s=>s.id!==t?s:{...s,addresses:s.addresses.filter(o=>o.id!==e),updatedAt:Date.now()});return ue(n),{...r,contacts:n}})},setDefaultAddress:(t,e)=>{ee.setState(r=>{const n=r.contacts.map(s=>s.id!==t?s:{...s,addresses:s.addresses.map(o=>({...o,isDefault:o.id===e})),updatedAt:Date.now()});return ue(n),{...r,contacts:n}})},importContacts:t=>{if(t.length===0)return 0;let e=0;return ee.setState(r=>{const n=r.contacts,s=new Set(n.map(a=>a.name.toLowerCase())),o=t.filter(a=>{const c=a.name.toLowerCase();return s.has(c)?!1:(s.add(c),!0)});if(e=o.length,o.length===0)return r;const i=[...n,...o];return ue(i),{...r,contacts:i}}),e},clearAll:()=>{localStorage.removeItem(Gt),ee.setState(()=>mr)}},ii={getContactByAddress:(t,e)=>{const r=e.toLowerCase();for(const n of t.contacts){const s=n.addresses.find(o=>o.address.toLowerCase()===r);if(s)return{contact:n,matchedAddress:s}}},searchContacts:(t,e)=>{const r=e.toLowerCase();return t.contacts.filter(n=>n.name.toLowerCase().includes(r)||n.addresses.some(s=>s.address.toLowerCase().includes(r)))},suggestContacts:(t,e,r=5)=>{const n=[],s=e&&e.length>0,o=s?e.toLowerCase():"",i=[...t.contacts].toSorted((c,d)=>d.updatedAt-c.updatedAt);for(const c of i){const d=c.addresses;if(d.length!==0){if(!s){const h=d.find(y=>y.isDefault)??d[0];h&&n.push({contact:c,matchedAddress:h,matchType:"name",score:40});continue}for(const h of d){const y=h.address.toLowerCase();y===o?n.push({contact:c,matchedAddress:h,matchType:"exact",score:100}):y.startsWith(o)?n.push({contact:c,matchedAddress:h,matchType:"prefix",score:80}):y.includes(o)&&n.push({contact:c,matchedAddress:h,matchType:"prefix",score:50})}if(c.name.toLowerCase().includes(o)){const h=d.find(y=>y.isDefault)??d[0];h&&n.push({contact:c,matchedAddress:h,matchType:"name",score:60})}}}const a=new Map;for(const c of n){const d=`${c.contact.id}:${c.matchedAddress.id}`,h=a.get(d);(!h||h.score<c.score)&&a.set(d,c)}return Array.from(a.values()).toSorted((c,d)=>d.score!==c.score?d.score-c.score:d.contact.updatedAt-c.contact.updatedAt).slice(0,r)},getContactsByChain:(t,e)=>t.contacts.filter(r=>r.addresses.some(n=>on(n.address).chainType===e)),getDefaultAddress:(t,e)=>{const r=e?t.addresses.filter(n=>on(n.address).chainType===e):t.addresses;return r.find(n=>n.isDefault)??r[0]}};export{xe as A,Ye as B,Vo as C,Yo as D,qo as E,Zo as F,Go as G,Xo as H,Jo as I,At as J,Qo as K,Ys as L,ri as M,Do as W,oi as a,jo as b,Ho as c,P as d,ii as e,ee as f,Oe as g,pt as h,Re as i,Is as j,_ as k,dn as l,si as m,Vt as n,yo as o,ei as p,ti as q,ni as r,oe as s,En as t,zo as u,Ve as v,M as w,R as x,D as y,yr as z};
