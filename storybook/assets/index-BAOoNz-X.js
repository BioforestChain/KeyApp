import{b as p,a as g,f as s,h as a,j as m,B as C,k as y,l as v}from"./index-C_NqyCS_.js";import{m as j,c as x,d as K}from"./index-C_NqyCS_.js";import"./address-book-Dx0_vESo.js";import{A as R}from"./amount-BQsqQYGO.js";import"./index-D0E7N0oa.js";import"./schemas-jh0dXz-I.js";import"./bioforest-D91I-84E.js";import"./preload-helper-PPVm8Dsz.js";import"./iframe-BthQp-yI.js";import"./address-format-Bt4Tl7ZW.js";async function H(r){const{mnemonic:e,chainConfigs:t,selectedChainIds:o,accountIndex:i=0}=r,c=new Map(t.map(n=>[n.id,n])),w=new TextEncoder().encode(e),h=[];for(const n of o){const l=c.get(n);if(!l){console.warn(`[deriveWalletChainAddresses] Chain config not found: ${n}`);continue}const d=p(n);if(!d.supportsDeriveAddress)throw new Error(`Chain "${n}" (${l.chainKind}) does not support address derivation`);const f=d.deriveAddress;if(!f)throw new Error(`Chain "${n}" deriveAddress method not available`);const u=await f(w,i);h.push({chainId:n,address:u})}return h}class b{chainId;config=null;baseUrl="";constructor(e){this.chainId=e}getConfig(){if(!this.config){const e=g.getConfig(this.chainId);if(!e)throw new s(a.CHAIN_NOT_FOUND,`Chain config not found: ${this.chainId}`);this.config=e,this.baseUrl=g.getBiowalletApi(e.id)??""}return this.config}getChainInfo(){const e=this.getConfig(),t={chainId:e.id,name:e.name,symbol:e.symbol,decimals:e.decimals,blockTime:10,confirmations:1};return e.explorer?.url&&(t.explorerUrl=e.explorer.url),t}async getBlockHeight(){if(this.getConfig(),!this.baseUrl)return 0n;try{const e=await fetch(`${this.baseUrl}/lastblock`,{method:"GET",headers:{"Content-Type":"application/json"}});if(!e.ok)throw new s(a.NETWORK_ERROR,`Failed to fetch block height: ${e.status}`);const t=await e.json();if(!t.success)throw new s(a.NETWORK_ERROR,"API returned success=false");return BigInt(t.result.height)}catch(e){throw e instanceof s?e:new s(a.NETWORK_ERROR,"Failed to fetch block height",void 0,e instanceof Error?e:void 0)}}async getGasPrice(){const e=this.getConfig(),{decimals:t,symbol:o}=e;if(!this.baseUrl)throw new s(a.NETWORK_ERROR,"RPC URL not configured for BioForest chain");try{const i=await m(this.baseUrl,e.id,void 0),c=R.fromRaw(i,t,o);return{slow:c,standard:c,fast:c.mul(2),lastUpdated:Date.now()}}catch(i){throw i instanceof s?i:new s(a.NETWORK_ERROR,"Failed to calculate minimum fee from SDK",void 0,i instanceof Error?i:void 0)}}async healthCheck(){if(this.getConfig(),!this.baseUrl)return{isHealthy:!1,latency:0,blockHeight:0n,isSyncing:!1,lastUpdated:Date.now()};const e=Date.now();try{const t=await fetch(`${this.baseUrl}/lastblock`,{method:"GET",headers:{"Content-Type":"application/json"}}),o=Date.now()-e;if(!t.ok)return{isHealthy:!1,latency:o,blockHeight:0n,isSyncing:!1,lastUpdated:Date.now()};const i=await t.json();return{isHealthy:i.success,latency:o,blockHeight:i.success?BigInt(i.result.height):0n,isSyncing:!1,lastUpdated:Date.now()}}catch{return{isHealthy:!1,latency:Date.now()-e,blockHeight:0n,isSyncing:!1,lastUpdated:Date.now()}}}}class E{chainId;chainType="bioforest";identity;asset;transaction;chain;staking=null;initialized=!1;constructor(e){this.chainId=e,this.identity=new C(e),this.asset=new y(e),this.transaction=new v(e),this.chain=new b(e)}async initialize(){this.initialized||(this.initialized=!0)}dispose(){this.initialized=!1}}function F(r){return new E(r)}export{E as BioforestAdapter,a as ChainErrorCodes,j as ChainProvider,s as ChainServiceError,x as clearProviderCache,F as createBioforestAdapter,K as createChainProvider,H as deriveWalletChainAddresses,p as getChainProvider};
