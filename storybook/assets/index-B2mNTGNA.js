import{g as le,Z as ue,o as B,s as c,c as E,a as A,b as Z,n as w,l as ut,h as de,i as m,u as Q,r as G,j as Ct}from"./schemas-jh0dXz-I.js";import{g as he,d as fe,h as z,m as me,t as pe,n as Y,s as K,o as ft,p as ge,q as mt,r as pt}from"./address-book-DI0wc2JF.js";import{A as g}from"./amount-BQsqQYGO.js";import{o as x,h as D,G as C,c as ye,p as we,a as be,X as Rt,Y as gt}from"./bioforest-D91I-84E.js";import"./index-D0E7N0oa.js";import{_ as ot}from"./preload-helper-PPVm8Dsz.js";import{T as U}from"./iframe-CHpnNFF-.js";function Te(o){return le(ue,o)}class ve{getConfig(t){return he.getChainById(fe.state,t)}getApi(t){return this.getConfig(t)?.apis??[]}getApiByType(t,e){return this.getApi(t).find(n=>n.type===e)??null}getApiByPattern(t,e){const s=this.getApi(t),n=new RegExp("^"+e.replace("*",".*")+"$");return s.find(a=>n.test(a.type))??null}getRpcUrl(t){return this.getApiByPattern(t,"*-rpc")?.endpoint??""}getBiowalletApi(t){return this.getApiByPattern(t,"biowallet-*")?.endpoint??null}getBiowalletGenesisBlock(t){return this.getApiByPattern(t,"biowallet-*")?.config?.genesisBlock??null}getEtherscanApi(t){return(this.getApiByPattern(t,"etherscan-*")??this.getApiByPattern(t,"*scan-*"))?.endpoint??null}getMempoolApi(t){return this.getApiByPattern(t,"mempool-*")?.endpoint??null}getDecimals(t){return this.getConfig(t)?.decimals??18}getSymbol(t){return this.getConfig(t)?.symbol??""}getExplorerUrl(t){return this.getConfig(t)?.explorer?.url??null}getTxQueryUrl(t,e){const n=this.getConfig(t)?.explorer?.queryTx;return n?n.replace(":hash",e).replace(":signature",e):null}getAddressQueryUrl(t,e){const n=this.getConfig(t)?.explorer?.queryAddress;return n?n.replace(":address",e):null}}const y=new ve;class L extends Error{constructor(t,e,s){super(t),this.status=e,this.response=s,this.name="ApiError"}}class Ie{baseUrl;timeout;fetchFn;constructor(t){this.baseUrl=t.baseUrl.replace(/\/$/,""),this.timeout=t.timeout??3e4,this.fetchFn=t.fetch??((e,s)=>fetch(e,s))}async request(t,e,s){const n=`${this.baseUrl}${e}`,a=new AbortController,r=setTimeout(()=>a.abort(),this.timeout);try{const i={method:t,signal:a.signal};s&&(i.headers={"Content-Type":"application/json"},i.body=JSON.stringify(s));const l=await this.fetchFn(n,i),u=await l.json();if(!l.ok)throw new L(u.message??`Request failed: ${l.status}`,l.status,u);if(!u.success)throw new L(u.message??"Request failed",l.status,u);return u.result}catch(i){throw i instanceof L?i:i instanceof Error&&i.name==="AbortError"?new L("Request timeout",void 0,void 0):new L(i instanceof Error?i.message:"Unknown error",void 0,void 0)}finally{clearTimeout(r)}}async get(t){return this.request("GET",t)}async post(t,e){return this.request("POST",t,e)}}const Se="https://walletapi.bfmeta.info";class Ae{client;chainPath;constructor(t){this.chainPath=t.chainPath;const e={baseUrl:t.baseUrl??Se};t.timeout!==void 0&&(e.timeout=t.timeout),t.fetch!==void 0&&(e.fetch=t.fetch),this.client=new Ie(e)}path(t){return`/wallet/${this.chainPath}${t}`}async getLastBlock(){return this.client.get(this.path("/lastblock"))}async getBlockByHeight(t){return this.client.post(this.path("/block/query"),{height:t})}async getBalance(t){return this.client.post(this.path("/address/balance"),t)}async getAddressInfo(t){return this.client.post(this.path("/address/info"),{address:t})}async getAddressAssets(t){return this.client.post(this.path("/address/asset"),{address:t})}async getBlockAverageFee(){return this.client.get(this.path("/blockAveFee"))}async broadcastTransaction(t){return this.client.post(this.path("/transactions/broadcast"),t)}async queryTransactions(t){return this.client.post(this.path("/transactions/query"),t)}async queryPendingTransactions(t){return this.client.post(this.path("/pendingTr"),t)}async queryTokenList(t){return this.client.post(this.path("/assets"),t)}async queryTokenDetail(t){return this.client.post(this.path("/asset/details"),t)}}class ke extends Error{constructor(t,e,s){super(e),this.code=t,this.minFee=s,this.name="BroadcastError"}}const Ee={"001-11028":"transaction:broadcast.assetNotEnough","001-11029":"transaction:broadcast.feeNotEnough"};function Ne(o){return o?Ee[o]??null:null}function vn(o){const t=Ne(o.code);if(t&&U.exists(t))return U.t(t);const e=o.message.toLowerCase();return e.includes("asset not enough")||e.includes("insufficient")?U.t("transaction:broadcast.assetNotEnough"):e.includes("fee")?U.t("transaction:broadcast.feeNotEnough"):e.includes("rejected")?U.t("transaction:broadcast.rejected"):o.message||U.t("transaction:broadcast.unknown")}const Be=B({code:c(),message:c()}),_e=B({success:E(),minFee:c().optional(),message:c().optional(),error:Be.optional()}),yt=new Map;function Ce(o){const t=o.match(/^(https?:\/\/[^/]+)\/wallet\/([^/]+)\/?$/);if(t)return{baseUrl:t[1],chainPath:t[2]};throw new Error(`Invalid wallet API URL format: ${o}. Expected format: https://host/wallet/chainPath`)}function j(o){let t=yt.get(o);if(!t){const{baseUrl:e,chainPath:s}=Ce(o);t=new Ae({baseUrl:e,chainPath:s}),yt.set(o,t)}return t}const wt=new Map,bt=new Map;let V=null,q=null;function Re(){return typeof document<"u"?new URL("./configs/genesis",document.baseURI).href:"./configs/genesis"}async function $e(o,t){const e=t??o,s=wt.get(e);if(s)return s;let n;t?typeof document<"u"?n=new URL(`./configs/${t.replace(/^\.\//,"")}`,document.baseURI).href:n=`./configs/${t.replace(/^\.\//,"")}`:n=`${Re()}/${o}.json`;let a;if(n.startsWith("http://")||n.startsWith("https://")){const r=await fetch(n);if(!r.ok)throw new Error(`Failed to fetch genesis block: ${r.status}`);a=await r.json()}else a=(await import(n)).default;return wt.set(e,a),a}async function Pe(){const{sha256:o}=await ot(async()=>{const{sha256:a}=await import("./bioforest-D91I-84E.js").then(r=>r.Z);return{sha256:a}},[],import.meta.url),{md5:t,ripemd160:e}=await ot(async()=>{const{md5:a,ripemd160:r}=await import("./bioforest-D91I-84E.js").then(i=>i._);return{md5:a,ripemd160:r}},[],import.meta.url),s=a=>{const r=[];return{update(i){const l=typeof i=="string"?new TextEncoder().encode(i):i;return r.push(l),this},async digest(){const i=r.reduce((d,h)=>d+h.length,0),l=new Uint8Array(i);let u=0;for(const d of r)l.set(d,u),u+=d.length;return Buffer.from(a(l))}}};return{sha256(a){if(!a)return s(i=>o(i));const r=typeof a=="string"?new TextEncoder().encode(a):a;return Promise.resolve(Buffer.from(o(r)))},md5(a){if(!a)return s(i=>t(i));const r=typeof a=="string"?new TextEncoder().encode(a):a;return Promise.resolve(Buffer.from(t(r)))},ripemd160(a){if(!a)return s(i=>e(i));const r=typeof a=="string"?new TextEncoder().encode(a):a;return Promise.resolve(Buffer.from(e(r)))}}}async function xe(){return V||q||(q=(async()=>(V={setup:(await ot(()=>import("./bioforest-chain-bundle-BNO2sBqj.js"),[],import.meta.url)).setup},V))(),q)}async function _(o,t){const e=await $e(o,t),s=e.magic,n=bt.get(s);if(n)return n;const a=await xe(),r=await Pe(),i=await a.setup(e,r,{n:"KeyApp",m:"true",a:"web"});return bt.set(s,i),i}async function O(o){const e=await j(o).getLastBlock();return{height:e.height,timestamp:e.timestamp}}async function tt(o,t){const e=j(o);try{return await e.getAddressInfo(t)??{address:t}}catch{return{address:t}}}async function Oe(o,t,e){const n=await(await _(t)).getAssetType(),a=j(o);try{const r=await a.getAddressAssets(e);if(!r?.assets)return"0";for(const i of Object.values(r.assets)){const l=i[n];if(l)return l.assetNumber}return"0"}catch{return"0"}}async function Ue(o){const t=await _(o.chainId),e=await O(o.baseUrl),s=e.height,n=e.timestamp;let a=o.fee;a||(a=await t.transactionController.getTransferTransactionMinFee({transaction:{applyBlockHeight:s,timestamp:n,remark:o.remark??{}},assetInfo:{sourceChainName:await t.getChainName(),sourceChainMagic:await t.getMagic(),assetType:o.assetType,amount:o.amount}}));let r=!1;if(o.paySecret){const u=await tt(o.baseUrl,o.from);u.secondPublicKey&&(r=await dt(o.chainId,o.mainSecret,o.paySecret,u.secondPublicKey)==="v1")}const i={mainSecret:o.mainSecret,...o.paySecret?{paySecret:o.paySecret,usePaySecretV1:r}:{}},l={sourceChainName:await t.getChainName(),sourceChainMagic:await t.getMagic(),assetType:o.assetType,amount:o.amount};return t.transactionController.createTransferTransactionJSON({secrets:i,transaction:{fee:a,recipientId:o.to,applyBlockHeight:s,timestamp:n,remark:o.remark??{},effectiveBlockHeight:s+100},assetInfo:l})}async function $t(o,t){const{nonce:e,...s}=t,a=await j(o).broadcastTransaction(s),r=_e.safeParse(a),i=r.success?r.data:a;if(!i.success){const l=i.error?.code,u=i.error?.message??i.message??"Transaction rejected";throw new ke(l,u,i.minFee)}return t.signature}async function dt(o,t,e,s){const a=(await _(o)).accountBaseHelper();try{if((await a.createSecondSecretKeypairV2(t,e)).publicKey.toString("hex")===s)return"v2"}catch{}try{if((await a.createSecondSecretKeypair(t,e)).publicKey.toString("hex")===s)return"v1"}catch{}return!1}async function Pt(o){const{baseUrl:t,chainId:e,intent:s,fromAddress:n}=o,a=await _(e),r=await O(t),i=r.height,l=r.timestamp;switch(s.type){case"transfer":{let u=!1;if(n)try{u=!!(await tt(t,n)).secondPublicKey}catch{}const d=s.amount||"99999999999999999";let h=await a.transactionController.getTransferTransactionMinFee({transaction:{applyBlockHeight:i,timestamp:l,remark:s.remark??{}},assetInfo:{sourceChainName:await a.getChainName(),sourceChainMagic:await a.getMagic(),assetType:await a.getAssetType(),amount:d}});return u&&(h=String(BigInt(h)*BigInt(105)/BigInt(100))),h}case"setPayPassword":return a.transactionController.getSignatureTransactionMinFee({newPaySecret:`${Date.now()}getSignatureTransactionMinFee`,applyBlockHeight:i,timestamp:l});default:throw new Error(`Unknown fee intent type: ${s.type}`)}}async function xt(o,t,e,s,n){return Pt({baseUrl:o,chainId:t,intent:{type:"transfer",amount:s??"0",remark:n},fromAddress:e})}async function De(o,t){const e=await _(t),s=await O(o),n=s.height,a=s.timestamp;return e.transactionController.getSignatureTransactionMinFee({newPaySecret:`${Date.now()}getSignatureTransactionMinFee`,applyBlockHeight:n,timestamp:a})}async function Ot(o){const t=await _(o.chainId),e=await O(o.baseUrl),s=e.height,n=e.timestamp;let a=o.fee;return a||(a=await t.transactionController.getSignatureTransactionMinFee({newPaySecret:o.newPaySecret,applyBlockHeight:s,timestamp:n})),t.transactionController.createSignatureTransactionJSON({mainSecret:o.mainSecret},{newPaySecret:o.newPaySecret,fee:a,applyBlockHeight:s,timestamp:n,effectiveBlockHeight:s+100})}async function Me(o){const t=await Ot({baseUrl:o.baseUrl,chainId:o.chainId,mainSecret:o.mainSecret,newPaySecret:o.newPaySecret});return await $t(o.baseUrl,t).catch(()=>{}),{txHash:t.signature,success:!0}}async function Ut(o,t,e,s){const n=await _(t),a=await O(o),r=a.height,i=a.timestamp;return n.transactionController.getDestoryAssetTransactionMinFee({transaction:{applyBlockHeight:r,timestamp:i,remark:{}},assetInfo:{sourceChainName:await n.getChainName(),sourceChainMagic:await n.getMagic(),assetType:e,amount:s}})}async function Le(o){const t=await _(o.chainId),e=await O(o.baseUrl),s=e.height,n=e.timestamp;let a=o.fee;a||(a=await Ut(o.baseUrl,o.chainId,o.assetType,o.amount));let r=!1;if(o.paySecret){const u=await tt(o.baseUrl,o.from);u.secondPublicKey&&(r=await dt(o.chainId,o.mainSecret,o.paySecret,u.secondPublicKey)==="v1")}const i={mainSecret:o.mainSecret,...o.paySecret?{paySecret:o.paySecret,usePaySecretV1:r}:{}},l={sourceChainName:await t.getChainName(),sourceChainMagic:await t.getMagic(),assetType:o.assetType,amount:o.amount};return t.transactionController.createDestoryAssetTransactionJSON({secrets:i,transaction:{fee:a,recipientId:o.recipientId,applyBlockHeight:s,timestamp:n,remark:o.remark??{},effectiveBlockHeight:s+100},assetInfo:l})}async function He(o,t,e){const s=j(o);try{const n=await s.queryTokenDetail({assetType:t,address:e});return n?.applyAddress?{applyAddress:n.applyAddress,assetType:n.assetType}:null}catch{return null}}const In=Object.freeze(Object.defineProperty({__proto__:null,broadcastTransaction:$t,createDestroyTransaction:Le,createSignatureTransaction:Ot,createTransferTransaction:Ue,getAccountBalance:Oe,getAddressInfo:tt,getAssetDetail:He,getBioforestCore:_,getDestroyTransactionMinFee:Ut,getLastBlock:O,getMinFee:Pt,getSignatureTransactionMinFee:De,getTransferMinFee:xt,setTwoStepSecret:Me,verifyTwoStepSecret:dt},Symbol.toStringTag,{value:"Module"}));function $(o){return{supported:!0,data:o}}function N(o,t){return{supported:!1,data:o,reason:t}}function Fe(o){return o.supported===!0}Z(["native","token","nft"]);const Dt=Z(["transfer","swap","exchange","approve","revoke","signature","stake","unstake","claim","mint","burn","gift","grab","trust","signFor","emigrate","immigrate","issueAsset","increaseAsset","destroyAsset","issueEntity","destroyEntity","locationName","dapp","certificate","mark","contract","unknown"]),Mt=Z(["in","out","self"]),Ke=Z(["pending","confirmed","failed"]),je=B({assetType:ut("native"),value:c(),symbol:c(),decimals:w()}),We=B({assetType:ut("token"),value:c(),symbol:c(),decimals:w(),contractAddress:c(),name:c().optional(),logoUrl:c().optional()}),Ve=B({assetType:ut("nft"),tokenId:c(),contractAddress:c(),name:c().optional(),imageUrl:c().optional(),collection:c().optional()}),Lt=de("assetType",[je,We,Ve]),qe=B({value:c(),symbol:c(),decimals:w()}),Je=B({address:c(),method:c().optional(),methodId:c().optional()}),rt=B({hash:c(),from:c(),to:c(),timestamp:w(),status:Ke,blockNumber:Te().optional(),action:Dt,direction:Mt,assets:A(Lt).min(1),fee:qe.optional(),contract:Je.optional()});class Ht extends Error{source;chainId;method;issues;constructor(t){super(`[InvalidData] ${t.source}:${t.chainId}:${t.method}`,{cause:t.cause instanceof Error?t.cause:void 0}),this.name="InvalidDataError",this.source=t.source,this.chainId=t.chainId,this.method=t.method,this.issues=t.issues??[]}}const Ye=new Set(["isValidAddress","normalizeAddress"]);class Ft{chainId;providers;constructor(t,e){this.chainId=t,this.providers=e}supports(t){return this.getCandidates(t).length>0}getCandidates(t){return this.providers.filter(e=>{if(typeof e[t]!="function")return!1;const s=t.startsWith("get")?t.slice(3):t,n=`supports${s.charAt(0).toUpperCase()}${s.slice(1)}`,a=e[n];return typeof a=="boolean"?a:!0})}getMethod(t){const e=this.providers.filter(r=>typeof r[t]=="function");if(e.length===0)return;const s=e[0],n=s[t];return typeof n!="function"?void 0:Ye.has(t)?n.bind(s):(async(...r)=>{let i=null;for(const l of e){const u=l[t];if(typeof u=="function")try{return await u.apply(l,r)}catch(d){i=d}}throw i instanceof Error?i:new Error("All providers failed")})}getDefaultBalance(){const t=y.getDecimals(this.chainId),e=y.getSymbol(this.chainId);return{amount:g.zero(t,e),symbol:e}}getDefaultTransactionStatus(){return{status:"pending",confirmations:0,requiredConfirmations:1}}get supportsNativeBalance(){return this.supports("getNativeBalance")}get supportsTokenBalances(){return this.supports("getTokenBalances")}get supportsTransactionHistory(){return this.supports("getTransactionHistory")}get supportsTransaction(){return this.supports("getTransaction")}get supportsBlockHeight(){return this.supports("getBlockHeight")}get supportsFeeEstimate(){return this.supports("estimateFee")}get supportsBuildTransaction(){return this.supports("buildTransaction")}get supportsSignTransaction(){return this.supports("signTransaction")}get supportsBroadcast(){return this.supports("broadcastTransaction")}get supportsFullTransaction(){return this.supportsBuildTransaction&&this.supportsSignTransaction&&this.supportsBroadcast}get supportsDeriveAddress(){return this.supports("deriveAddress")}get supportsAddressValidation(){return this.supports("isValidAddress")}async getNativeBalance(t){const e=this.providers.filter(a=>typeof a.getNativeBalance=="function");if(e.length===0)return N(this.getDefaultBalance(),"No provider implements getNativeBalance");let s=null;for(const a of e)try{const r=await a.getNativeBalance(t);return $(r)}catch(r){s=r}const n=s instanceof Error?s.message:"Unknown error";return N(this.getDefaultBalance(),`All ${e.length} provider(s) failed. Last error: ${n}`)}async getTokenBalances(t){const e=this.providers.filter(a=>typeof a.getTokenBalances=="function");if(e.length===0)return N([],"No provider implements getTokenBalances");let s=null;for(const a of e)try{const r=await a.getTokenBalances(t);return $(r)}catch(r){s=r}const n=s instanceof Error?s.message:"Unknown error";return N([],`All ${e.length} provider(s) failed. Last error: ${n}`)}async getTransactionHistory(t,e=20){const s=this.getCandidates("getTransactionHistory");if(s.length===0)return N([],"No provider implements getTransactionHistory");let n=null;for(const r of s)try{const i=await r.getTransactionHistory(t,e);if(!Array.isArray(i)){console.warn("[ChainProvider] Invalid transaction history payload (not array)",{chainId:this.chainId,method:"getTransactionHistory"});continue}const l=[];let u=0,d=null;for(const h of i){const f=rt.safeParse(h);f.success?l.push(f.data):(u+=1,d||(d=f.error.issues[0]))}return u>0&&console.warn("[ChainProvider] Dropped invalid transactions from history",{chainId:this.chainId,method:"getTransactionHistory",invalidCount:u,totalCount:i.length,firstIssue:d}),$(l)}catch(i){n=i}const a=n instanceof Error?n.message:"Unknown error";return N([],`All ${s.length} provider(s) failed. Last error: ${a}`)}async getTransaction(t){const e=this.providers.filter(a=>typeof a.getTransaction=="function");if(e.length===0)return N(null,"No provider implements getTransaction");let s=null;for(const a of e)try{const r=await a.getTransaction(t);if(r==null)return $(null);const i=rt.safeParse(r);if(!i.success)throw new Ht({source:"provider",chainId:this.chainId,method:"getTransaction",issues:i.error.issues});return $(i.data)}catch(r){s=r}const n=s instanceof Error?s.message:"Unknown error";return N(null,`All ${e.length} provider(s) failed. Last error: ${n}`)}async getTransactionStatus(t){const e=this.providers.filter(a=>typeof a.getTransactionStatus=="function");if(e.length===0)return N(this.getDefaultTransactionStatus(),"No provider implements getTransactionStatus");let s=null;for(const a of e)try{const r=await a.getTransactionStatus(t);return $(r)}catch(r){s=r}const n=s instanceof Error?s.message:"Unknown error";return N(this.getDefaultTransactionStatus(),`All ${e.length} provider(s) failed. Last error: ${n}`)}async getBlockHeight(){const t=this.providers.filter(n=>typeof n.getBlockHeight=="function");if(t.length===0)return N(0n,"No provider implements getBlockHeight");let e=null;for(const n of t)try{const a=await n.getBlockHeight();return $(a)}catch(a){e=a}const s=e instanceof Error?e.message:"Unknown error";return N(0n,`All ${t.length} provider(s) failed. Last error: ${s}`)}get estimateFee(){return this.getMethod("estimateFee")}get buildTransaction(){return this.getMethod("buildTransaction")}get signTransaction(){return this.getMethod("signTransaction")}get broadcastTransaction(){return this.getMethod("broadcastTransaction")}get deriveAddress(){return this.getMethod("deriveAddress")}get deriveAddresses(){return this.getMethod("deriveAddresses")}get isValidAddress(){return this.getMethod("isValidAddress")}get normalizeAddress(){return this.getMethod("normalizeAddress")}getProviders(){return this.providers}getProviderByType(t){return this.providers.find(e=>e.type===t)}}const et=new Map;function ht(o,t){if(!o||o.trim()==="")return;if(et.has(t))return et.get(t);const e=o.split(",").map(n=>n.trim()).filter(n=>n.length>0);if(e.length===0)return;const s=e[Math.floor(Math.random()*e.length)];return et.set(t,s),s}const st=new Map,it=new Map,X=new Map,Tt=new Map;function Ge(o,t){const e=(t?.method??"GET").toUpperCase(),s=typeof t?.body=="string"?t.body:"";return`${e}:${o}:${s}`}function ze(o,t){for(const e of t){const s=X.get(e)??new Set;s.add(o),X.set(e,s)}}function Xe(o){for(const t of o){const e=X.get(t);if(e){for(const s of e)it.delete(s);X.delete(t)}}}function P(o){const t=Tt.get(o.key);Tt.set(o.key,o.value),t!==void 0&&t!==o.value&&Xe(o.invalidateTags)}async function S(o,t,e){const s=e?.ttlMs??0,n=e?.cacheKey??Ge(o,t);if(s>0){const i=it.get(n);if(i&&i.expiresAt>Date.now())return i.value}const a=st.get(n);if(a)return await a;const r=(async()=>{const i=await fetch(o,t);if(!i.ok)throw new Error(`HTTP ${i.status}`);return await i.json()})();st.set(n,r);try{const i=await r;return s>0&&(it.set(n,{value:i,expiresAt:Date.now()+s}),e?.tags?.length&&ze(n,e.tags)),i}finally{st.delete(n)}}var vt={TRONGRID_API_KEY:"",ETHERSCAN_API_KEY:""},Ze={};function Qe(o){try{const t=Ze?.[o];if(typeof t=="string"&&t.length>0)return t}catch{}if(typeof vt<"u"){const t=vt[o];if(typeof t=="string"&&t.length>0)return t}}const ts={ethereum:1,binance:56,"ethereum-sepolia":11155111,"bsc-testnet":97},es=m({hash:c(),from:c(),to:c(),value:c(),timeStamp:c(),isError:c(),blockNumber:c(),input:c().optional(),methodId:c().optional(),functionName:c().optional()}),ss=m({hash:c(),from:c(),to:c(),value:c(),timeStamp:c(),blockNumber:c(),tokenSymbol:c(),tokenName:c(),tokenDecimal:c(),contractAddress:c()}),It=m({status:c(),message:c(),result:Q()}),ns=5;class Kt{type;endpoint;config;chainId;evmChainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.evmChainId=ts[e]??1,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}get supportsTransactionHistory(){return!0}get supportsNativeBalance(){return!0}getApiKey(){let t;const e=this.config?.apiKey;if(typeof e=="string"&&e.length>0)t=e;else{const s=this.config?.apiKeyEnv;typeof s=="string"&&s.length>0&&(t=Qe(s))}return ht(t,`etherscan:${this.chainId}`)}async getNativeBalance(t){const e=new URLSearchParams({module:"account",action:"balance",address:t});this.endpoint.includes("etherscan.io/v2")&&e.set("chainid",this.evmChainId.toString());const s=this.getApiKey();s&&e.set("apikey",s);const n=`${this.endpoint}?${e.toString()}`,a=await S(n,void 0,{cacheKey:`balance:${this.chainId}:${t}`,ttlMs:3e4,tags:[`balance:${this.chainId}:${t}`]}),r=It.safeParse(a);if(!r.success)throw new Error("Invalid API response for balance");if(r.data.status!=="1")throw new Error(`API error: ${r.data.message}`);const i=r.data.result;if(typeof i!="string")throw new Error("Invalid balance result");return{amount:g.fromRaw(i,this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){const s=e*ns,[n,a]=await Promise.all([this.fetchNativeTransactions(t,s),this.fetchTokenTransactions(t,s)]),r=t.toLowerCase();return this.aggregateByHash(n,a,r).toSorted((l,u)=>u.timestamp-l.timestamp).slice(0,e)}aggregateByHash(t,e,s){const n=new Map;for(const i of e){const l=i.hash.toLowerCase(),u=n.get(l)??[];u.push(i),n.set(l,u)}const a=[],r=new Set;for(const i of t){const l=i.hash.toLowerCase();if(r.has(l))continue;r.add(l);const u=n.get(l)??[],d=this.buildAggregatedTransaction(i,u,s);a.push(d)}for(const[i,l]of n){if(r.has(i))continue;r.add(i);const u=this.buildOrphanTokenTransaction(l,s);a.push(u)}return a}buildOrphanTokenTransaction(t,e){const s=this.selectPrimaryToken(t,e),n=this.getDirection(s.from,s.to,e),a=t.slice(0,3).map(r=>({assetType:"token",value:r.value,symbol:r.tokenSymbol,decimals:parseInt(r.tokenDecimal,10),contractAddress:r.contractAddress,name:r.tokenName}));return{hash:s.hash,from:s.from,to:s.to,timestamp:parseInt(s.timeStamp,10)*1e3,status:"confirmed",blockNumber:BigInt(s.blockNumber),action:"transfer",direction:n,assets:a}}buildAggregatedTransaction(t,e,s){const n=e.length>0,a=this.isContractCall(t),r=a?this.getMethodId(t):null;let i=this.detectAction(t);i==="contract"&&n&&(i="transfer");const l=this.selectPrimaryToken(e,s);let u,d;l?(u=l.from,d=l.to):(u=t.from,d=t.to);const h=this.getDirection(u,d,s),f=[];for(const p of e.slice(0,3))f.push({assetType:"token",value:p.value,symbol:p.tokenSymbol,decimals:parseInt(p.tokenDecimal,10),contractAddress:p.contractAddress,name:p.tokenName});return(t.value!=="0"||f.length===0)&&f.push({assetType:"native",value:t.value,symbol:this.symbol,decimals:this.decimals}),i==="swap"&&f.length>1&&f.sort((p,I)=>p.assetType==="token"&&I.assetType!=="token"?-1:p.assetType!=="token"&&I.assetType==="token"?1:0),{hash:t.hash,from:u,to:d,timestamp:parseInt(t.timeStamp,10)*1e3,status:t.isError==="0"?"confirmed":"failed",blockNumber:BigInt(t.blockNumber),action:i,direction:h,assets:f,contract:a?{address:t.to,method:t.functionName??void 0,methodId:r??void 0}:void 0}}selectPrimaryToken(t,e){if(t.length===0)return null;if(t.length===1)return t[0];const s=t.filter(a=>a.from.toLowerCase()===e||a.to.toLowerCase()===e);return(s.length>0?s:t).reduce((a,r)=>{const i=BigInt(a.value);return BigInt(r.value)>i?r:a})}async fetchNativeTransactions(t,e){const s=this.buildParams("txlist",t,e);return(await this.fetchApi(s,`etherscan:${this.type}:txlist:${t}:${e}`)).map(a=>es.safeParse(a)).filter(a=>a.success).map(a=>a.data)}async fetchTokenTransactions(t,e){const s=this.buildParams("tokentx",t,e);return(await this.fetchApi(s,`etherscan:${this.type}:tokentx:${t}:${e}`)).map(a=>ss.safeParse(a)).filter(a=>a.success).map(a=>a.data)}buildParams(t,e,s){const n=new URLSearchParams({module:"account",action:t,address:e,startblock:"0",endblock:"99999999",page:"1",offset:s.toString(),sort:"desc"});this.endpoint.includes("etherscan.io/v2")&&n.set("chainid",this.evmChainId.toString());const a=this.getApiKey();return a&&n.set("apikey",a),n}async fetchApi(t,e){const s=`${this.endpoint}?${t.toString()}`,n=t.get("address")??"",a=await S(s,void 0,{cacheKey:e,ttlMs:5*6e4,tags:n?[`txhistory:${this.chainId}:${n}`]:void 0}),r=It.safeParse(a);if(!r.success)throw new Error("Invalid API response");const i=r.data.status,l=r.data.message.toLowerCase();if(i==="0"&&l.includes("no transactions"))return[];if(i!=="1")throw new Error("Upstream API error");const u=r.data.result;if(!Array.isArray(u))throw new Error("Invalid API result");return u}getDirection(t,e,s){const n=t.toLowerCase(),a=e.toLowerCase();return n===s&&a===s?"self":n===s?"out":"in"}detectAction(t){if(this.isContractCall(t)){const e=this.getMethodId(t);return e?{"0xa9059cbb":"transfer","0x095ea7b3":"approve","0x23b872dd":"transfer","0x38ed1739":"swap","0x7ff36ab5":"swap","0x18cbafe5":"swap","0xa694fc3a":"stake","0x2e1a7d4d":"unstake","0x3ccfd60b":"claim","0x4e71d92d":"claim","0x40c10f19":"mint","0x42966c68":"burn"}[e]??"contract":"contract"}return"transfer"}isContractCall(t){const e=t.input??"";return e!=="0x"&&e!=="0x0"&&e!=="0x00"&&e.length>2}getMethodId(t){const e=(t.methodId??"").toLowerCase();if(e&&e!=="0x"&&e!=="0x0"&&e!=="0x00"){if(e.startsWith("0x")&&e.length===10)return e;if(!e.startsWith("0x")&&e.length===8)return`0x${e}`}const s=(t.input??"").toLowerCase();return s.startsWith("0x")&&s.length>=10?s.slice(0,10):!s.startsWith("0x")&&s.length>=8?`0x${s.slice(0,8)}`:null}}function jt(o,t){return o.type.includes("etherscan")||o.type.includes("blockscout")||o.type.includes("scan")?new Kt(o,t):null}const as=m({result:Q().optional(),error:m({message:c()}).optional()});class Wt{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}async rpc(t,e,s=[]){const n=JSON.stringify({jsonrpc:"2.0",id:1,method:t,params:s}),a=t==="eth_getBalance"||t==="eth_blockNumber",r=await S(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json"},body:n},{cacheKey:`evm-rpc:${this.endpoint}:${t}:${JSON.stringify(s)}`,ttlMs:a?1e4:0}),i=as.safeParse(r);if(!i.success)throw new Error("Invalid JSON-RPC response");if(i.data.error)throw new Error(i.data.error.message);const l=e.safeParse(i.data.result);if(!l.success)throw new Error("Invalid JSON-RPC result");return l.data}async getNativeBalance(t){const e=await this.rpc("eth_getBalance",c(),[t,"latest"]),s=BigInt(e);return{amount:g.fromRaw(s.toString(),this.decimals,this.symbol),symbol:this.symbol}}async getBlockHeight(){const t=await this.rpc("eth_blockNumber",c());return BigInt(t)}}function Vt(o,t){return o.type.endsWith("-rpc")&&(o.type.includes("ethereum")||o.type.includes("bsc"))?new Wt(o,t):null}const os=m({assetNumber:c(),assetType:c()}),St=m({success:E(),result:m({address:c(),assets:G(c(),G(c(),os))}).optional()}),rs=m({height:w(),signature:c(),transaction:m({type:c(),senderId:c(),recipientId:c().optional().default(""),timestamp:w(),asset:m({transferAsset:m({assetType:c(),amount:c()}).optional(),giftAsset:m({totalAmount:c(),assetType:c()}).optional(),grabAsset:m({transactionSignature:c()}).optional(),trustAsset:m({trustees:A(c()),numberOfSignFor:w(),assetType:c(),amount:c()}).optional(),signature:m({publicKey:c().optional()}).optional(),destroyAsset:m({assetType:c(),amount:c()}).optional(),issueEntity:m({entityId:c().optional()}).optional(),issueEntityFactory:m({factoryId:c().optional()}).optional()}).optional()})}),is=m({success:E(),result:m({trs:A(rs),count:w()}).optional()}),At=m({success:E(),result:m({height:w()}).optional()});class qt{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}get baseUrl(){return this.endpoint}async getNativeBalance(t){const e=`${this.baseUrl}/address/asset`,s=await S(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:t})},{cacheKey:`biowallet:${this.chainId}:assets:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),n=St.safeParse(s);if(!n.success||!n.data.success||!n.data.result)throw new Error("Upstream API error");for(const a of Object.values(n.data.result.assets))for(const r of Object.values(a))if(r.assetType===this.symbol)return P({key:`balance:${this.chainId}:${t}`,value:r.assetNumber,invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(r.assetNumber,this.decimals,this.symbol),symbol:this.symbol};return P({key:`balance:${this.chainId}:${t}`,value:"0",invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.zero(this.decimals,this.symbol),symbol:this.symbol}}async getTokenBalances(t){const e=`${this.baseUrl}/address/asset`,s=await S(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:t})},{cacheKey:`biowallet:${this.chainId}:assets:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),n=St.safeParse(s);if(!n.success||!n.data.success||!n.data.result)throw new Error("Upstream API error");const a=[];for(const r of Object.values(n.data.result.assets))for(const i of Object.values(r)){const l=i.assetType===this.symbol;a.push({symbol:i.assetType,name:i.assetType,amount:g.fromRaw(i.assetNumber,this.decimals,i.assetType),isNative:l})}return a.sort((r,i)=>r.isNative&&!i.isNative?-1:!r.isNative&&i.isNative?1:i.amount.toNumber()-r.amount.toNumber()),a}async getTransactionHistory(t,e=20){const s=await S(`${this.baseUrl}/lastblock`,void 0,{cacheKey:`biowallet:${this.chainId}:lastblock`,ttlMs:1e4}),n=At.safeParse(s);if(!n.success||!n.data.success||!n.data.result)throw new Error("Upstream API error");const a=n.data.result.height,r=await S(`${this.baseUrl}/transactions/query`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({maxHeight:a,address:t,limit:e})},{cacheKey:`biowallet:${this.chainId}:txs:${t}:${e}:${a}`,ttlMs:5*6e4,tags:[`txhistory:${this.chainId}:${t}`]}),i=is.safeParse(r);if(!i.success||!i.data.success||!i.data.result?.trs)throw new Error("Upstream API error");const l=t.toLowerCase();return i.data.result.trs.map(u=>{const d=u.transaction,h=this.detectAction(d.type),f=this.getDirection(d.senderId,d.recipientId,l),{value:p,assetType:I}=this.extractAssetInfo(d);return p===null?null:{hash:u.signature,from:d.senderId,to:d.recipientId,timestamp:d.timestamp*1e3,status:"confirmed",blockNumber:BigInt(u.height),action:h,direction:f,assets:[{assetType:"native",value:p,symbol:I,decimals:this.decimals}]}}).filter(u=>u!==null)}detectAction(t){const e={"AST-01":"transfer","AST-02":"transfer","AST-03":"destroyAsset","BSE-01":"signature","ETY-01":"issueEntity","ETY-02":"issueEntity","GFT-01":"gift","GFT-02":"gift","GRB-01":"grab","GRB-02":"grab","TRS-01":"trust","TRS-02":"trust","SGN-01":"signFor","SGN-02":"signFor","EMI-01":"emigrate","EMI-02":"emigrate","IMI-01":"immigrate","IMI-02":"immigrate","ISA-01":"issueAsset","ICA-01":"increaseAsset","DSA-01":"destroyAsset","ISE-01":"issueEntity","DSE-01":"destroyEntity","LNS-01":"locationName","DAP-01":"dapp","CRT-01":"certificate","MRK-01":"mark"},s=t.split("-");if(s.length>=4){const n=`${s[s.length-2]}-${s[s.length-1]}`;return e[n]??"unknown"}return"unknown"}getDirection(t,e,s){const n=t.toLowerCase(),a=e.toLowerCase();return a&&n===s&&a===s?"self":n===s?"out":"in"}extractAssetInfo(t){const e=t.asset;return e?.transferAsset?{value:e.transferAsset.amount,assetType:e.transferAsset.assetType}:e?.giftAsset?{value:e.giftAsset.totalAmount,assetType:e.giftAsset.assetType}:e?.trustAsset?{value:e.trustAsset.amount,assetType:e.trustAsset.assetType}:e?.grabAsset?{value:"0",assetType:this.symbol}:e?.destroyAsset?{value:e.destroyAsset.amount,assetType:e.destroyAsset.assetType}:e?.issueEntity||e?.issueEntityFactory?{value:"0",assetType:this.symbol}:e?.signature?{value:"0",assetType:this.symbol}:e?.destroyAsset?{value:e.destroyAsset.amount,assetType:e.destroyAsset.assetType}:e?.issueEntity||e?.issueEntityFactory?{value:"0",assetType:this.symbol}:e?.signature?{value:"0",assetType:this.symbol}:{value:null,assetType:this.symbol}}async getBlockHeight(){const t=await S(`${this.baseUrl}/lastblock`,void 0,{cacheKey:`biowallet:${this.chainId}:lastblock`,ttlMs:1e4}),e=At.safeParse(t);if(!e.success||!e.data.success||!e.data.result)throw new Error("Upstream API error");return BigInt(e.data.result.height)}}function Jt(o,t){return o.type.startsWith("biowallet-")?new qt(o,t):null}const cs=m({success:E(),result:c()}),ls=m({hash:c(),from:c(),to:c(),value:c(),timeStamp:c(),blockNumber:c(),isError:c().optional()}),us=m({success:E(),result:m({status:c(),result:A(ls)})});class Yt{type;endpoint;decimals;symbol;chainId;constructor(t,e,s,n){this.type=t.type,this.endpoint=t.endpoint.replace(/\/$/,""),this.chainId=e,this.decimals=s,this.symbol=n}get supportsNativeBalance(){return!0}get supportsTransactionHistory(){return!0}async getNativeBalance(t){const e=`${this.endpoint}/balance?address=${t}`,s=await S(e,void 0,{cacheKey:`bscwallet:balance:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),n=cs.safeParse(s);if(!n.success||!n.data.success)throw new Error("Upstream API error");return P({key:`balance:${this.chainId}:${t}`,value:n.data.result,invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(n.data.result,this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){const s=`${this.endpoint}/trans/normal/history`,n=await S(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:t,page:1,offset:e})},{cacheKey:`bscwallet:txs:${t}:${e}`,ttlMs:5*6e4,tags:[`txhistory:${this.chainId}:${t}`]}),a=us.safeParse(n);if(!a.success||!a.data.success)throw new Error("Upstream API error");if(a.data.result.status!=="1")return[];const r=t.toLowerCase();return a.data.result.result.map(i=>{const l=i.from,u=i.to,d=this.getDirection(l,u,r);return{hash:i.hash,from:l,to:u,timestamp:Number(i.timeStamp)*1e3,status:i.isError==="1"?"failed":"confirmed",blockNumber:BigInt(i.blockNumber),action:"transfer",direction:d,assets:[{assetType:"native",value:i.value,symbol:this.symbol,decimals:this.decimals}]}})}getDirection(t,e,s){const n=t.toLowerCase(),a=e.toLowerCase();return n===s&&a===s?"self":n===s?"out":"in"}}function Gt(o,t){if(o.type!=="bscwallet-v1")return null;const e=y.getDecimals(t),s=y.getSymbol(t);return new Yt(o,t,e,s)}var kt={TRONGRID_API_KEY:"",ETHERSCAN_API_KEY:""},ds={};function hs(o){try{const t=ds?.[o];if(typeof t=="string"&&t.length>0)return t}catch{}if(typeof kt<"u"){const t=kt[o];if(typeof t=="string"&&t.length>0)return t}}const fs=m({balance:w().optional(),address:c().optional()}),ms=m({block_header:m({raw_data:m({number:w().optional()}).optional()}).optional()}),ps=m({txID:c(),raw_data:m({contract:A(m({parameter:m({value:m({amount:w().optional(),owner_address:c().optional(),to_address:c().optional()}).optional()}).optional(),type:c().optional()})).optional(),timestamp:w().optional()}).optional(),ret:A(m({contractRet:c().optional()})).optional()}),gs=m({success:E(),data:A(ps).optional()}),ys=m({transaction_id:c(),token_info:m({symbol:c(),address:c(),decimals:w(),name:c().optional()}),block_timestamp:w(),from:c(),to:c(),type:c(),value:c()}),ws=m({success:E(),data:A(ys).optional()}),bs=5;class zt{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}async api(t,e,s,n){const a=`${this.endpoint}${t}`,r={};s!==void 0&&(r["Content-Type"]="application/json");let i;const l=this.config?.apiKey;if(typeof l=="string"&&l.length>0)i=l;else{const p=this.config?.apiKeyEnv;typeof p=="string"&&p.length>0&&(i=hs(p))}const u=ht(i,`trongrid:${this.chainId}`);u&&(r["TRON-PRO-API-KEY"]=u);const d=s!==void 0?{method:"POST",headers:r,body:JSON.stringify(s)}:{method:"GET",headers:r},h=await S(a,d,{cacheKey:`tron:${this.type}:${a}:${typeof d.body=="string"?d.body:""}`,ttlMs:n?.ttlMs??0,tags:n?.ttlMs?n?.tags:void 0}),f=e.safeParse(h);if(!f.success)throw new Error("Invalid API response");return f.data}async getNativeBalance(t){const s=(await this.api("/wallet/getaccount",fs,{address:t,visible:!0},{ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]})).balance??0;return P({key:`balance:${this.chainId}:${t}`,value:s.toString(),invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(s.toString(),this.decimals,this.symbol),symbol:this.symbol}}async getBlockHeight(){const e=(await this.api("/wallet/getnowblock",ms,void 0,{ttlMs:1e4})).block_header?.raw_data?.number??0;return BigInt(e)}async getTransactionHistory(t,e=20){const s=e*bs,[n,a]=await Promise.all([this.fetchNativeTransactions(t,s),this.fetchTrc20Transactions(t,s)]),r=t.toLowerCase();return this.aggregateByTxId(n,a,r).toSorted((l,u)=>u.timestamp-l.timestamp).slice(0,e)}aggregateByTxId(t,e,s){const n=new Map;for(const i of e){const l=i.transaction_id.toLowerCase(),u=n.get(l)??[];u.push(i),n.set(l,u)}const a=[],r=new Set;for(const i of t){const l=i.txID.toLowerCase();if(r.has(l))continue;r.add(l);const u=n.get(l)??[],d=this.buildAggregatedTransaction(i,u,s);d&&a.push(d)}for(const[i,l]of n){if(r.has(i))continue;r.add(i);const u=this.buildOrphanTrc20Transaction(l,s);a.push(u)}return a}shouldFilterTransaction(t,e){const s=t.raw_data?.contract?.[0],n=s?.type??"",a=s?.parameter?.value?.amount??0,r=t.ret?.[0]?.contractRet;return["TransferContract","TransferAssetContract","FreezeBalanceContract","FreezeBalanceV2Contract","UnfreezeBalanceContract","UnfreezeBalanceV2Contract","VoteWitnessContract","AccountCreateContract","WithdrawBalanceContract","WithdrawExpireUnfreezeContract"].includes(n)||e||a>0||r!=="SUCCESS"||this.isApproveTransaction(t)?!1:n==="TriggerSmartContract"}isApproveTransaction(t){const e=t.raw_data?.contract?.[0];if(e?.type!=="TriggerSmartContract")return!1;const s=e?.parameter?.value?.data;return!s||typeof s!="string"?!1:s.toLowerCase().startsWith("095ea7b3")}buildAggregatedTransaction(t,e,s){const n=t.raw_data?.contract?.[0],a=n?.type??"",r=n?.parameter?.value,i=t.ret?.[0]?.contractRet==="SUCCESS"?"confirmed":"failed",l=e.length>0;if(this.shouldFilterTransaction(t,l))return null;let u=this.detectAction(a);u==="contract"&&l&&(u="transfer"),u==="contract"&&this.isApproveTransaction(t)&&(u="approve");const d=this.selectPrimaryToken(e,s);let h,f;d?(h=d.from,f=d.to):(h=r?.owner_address??"",f=r?.to_address??"");const p=this.getDirection(h,f,s),I=[];for(const v of e.slice(0,3))I.push({assetType:"token",value:v.value,symbol:v.token_info.symbol,decimals:v.token_info.decimals,contractAddress:v.token_info.address,name:v.token_info.name});const k=r?.amount??0;return(k>0||I.length===0)&&I.push({assetType:"native",value:k.toString(),symbol:this.symbol,decimals:this.decimals}),{hash:t.txID,from:h,to:f,timestamp:t.raw_data?.timestamp??0,status:i,action:u,direction:p,assets:I}}buildOrphanTrc20Transaction(t,e){const s=this.selectPrimaryToken(t,e),n=this.getDirection(s.from,s.to,e),a=t.slice(0,3).map(r=>({assetType:"token",value:r.value,symbol:r.token_info.symbol,decimals:r.token_info.decimals,contractAddress:r.token_info.address,name:r.token_info.name}));return{hash:s.transaction_id,from:s.from,to:s.to,timestamp:s.block_timestamp,status:"confirmed",action:"transfer",direction:n,assets:a}}selectPrimaryToken(t,e){if(t.length===0)return null;if(t.length===1)return t[0];const s=t.filter(a=>a.from.toLowerCase()===e||a.to.toLowerCase()===e);return(s.length>0?s:t).reduce((a,r)=>{const i=BigInt(a.value);return BigInt(r.value)>i?r:a})}detectAction(t){switch(t){case"TransferContract":case"TransferAssetContract":return"transfer";case"TriggerSmartContract":return"contract";case"FreezeBalanceContract":case"FreezeBalanceV2Contract":case"VoteWitnessContract":return"stake";case"UnfreezeBalanceContract":case"UnfreezeBalanceV2Contract":return"unstake";case"WithdrawExpireUnfreezeContract":return"claim";default:return"transfer"}}async fetchNativeTransactions(t,e){const s=await this.api(`/v1/accounts/${t}/transactions?limit=${e}`,gs,void 0,{ttlMs:3e5,tags:[`txhistory:${this.chainId}:${t}`]});if(!s.success)throw new Error("Tron API error");return s.data??[]}async fetchTrc20Transactions(t,e){const s=await this.api(`/v1/accounts/${t}/transactions/trc20?limit=${e}`,ws,void 0,{ttlMs:3e5,tags:[`txhistory:${this.chainId}:${t}`]});if(!s.success)throw new Error("Tron API error");return s.data??[]}getDirection(t,e,s){const n=t.toLowerCase(),a=e.toLowerCase();return n===s&&a===s?"self":n===s?"out":"in"}}function Xt(o,t){return o.type==="tron-rpc"||o.type==="tron-rpc-pro"?new zt(o,t):null}const Ts=m({address:c().optional(),chain_stats:m({funded_txo_sum:w(),spent_txo_sum:w()}),mempool_stats:m({funded_txo_sum:w(),spent_txo_sum:w()})}),vs=m({txid:c(),status:m({confirmed:E(),block_height:w().optional(),block_time:w().optional()}),vin:A(m({prevout:m({scriptpubkey_address:c().optional(),value:w()}).optional()})),vout:A(m({scriptpubkey_address:c().optional(),value:w()}))});class Zt{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}async api(t,e){const s=`${this.endpoint}${t}`,n=await S(s,void 0,{cacheKey:`mempool:${s}`,ttlMs:3e4}),a=e.safeParse(n);if(!a.success)throw new Error("Invalid API response");return a.data}async getNativeBalance(t){const e=`${this.endpoint}/address/${t}`,s=await S(e,void 0,{cacheKey:`mempool:balance:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}).then(i=>{const l=Ts.safeParse(i);if(!l.success)throw new Error("Invalid API response");return l.data}),n=s.chain_stats.funded_txo_sum-s.chain_stats.spent_txo_sum,a=s.mempool_stats.funded_txo_sum-s.mempool_stats.spent_txo_sum,r=n+a;return P({key:`balance:${this.chainId}:${t}`,value:r.toString(),invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(r.toString(),this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){const s=`${this.endpoint}/address/${t}/txs`;return(await S(s,void 0,{cacheKey:`mempool:txs:${t}`,ttlMs:5*6e4,tags:[`txhistory:${this.chainId}:${t}`]}).then(a=>{const r=A(vs).safeParse(a);if(!r.success)throw new Error("Invalid API response");return r.data})).slice(0,e).map(a=>{const r=a.vin.some(f=>f.prevout?.scriptpubkey_address===t);let i=0n;if(r)for(const f of a.vout)f.scriptpubkey_address&&f.scriptpubkey_address!==t&&(i+=BigInt(f.value));else for(const f of a.vout)f.scriptpubkey_address===t&&(i+=BigInt(f.value));const l=r?a.vout.find(f=>f.scriptpubkey_address!==t)?.scriptpubkey_address??"":a.vin[0]?.prevout?.scriptpubkey_address??"",u=r?t:l,d=r?l:t,h=r?"out":"in";return{hash:a.txid,from:u,to:d,timestamp:(a.status.block_time??Math.floor(Date.now()/1e3))*1e3,status:a.status.confirmed?"confirmed":"pending",blockNumber:a.status.block_height?BigInt(a.status.block_height):void 0,action:"transfer",direction:h,assets:[{assetType:"native",value:i.toString(),symbol:this.symbol,decimals:this.decimals}]}})}async getBlockHeight(){const t=await this.api("/blocks/tip/height",w());return BigInt(t)}}function Qt(o,t){return o.type.startsWith("mempool-")?new Zt(o,t):null}const Is=m({success:E(),result:Ct([c(),w().transform(o=>String(o))])}),Ss=m({success:E(),result:m({status:c().optional(),result:A(Q())})}),As=m({blockNumber:c(),timeStamp:c(),hash:c(),from:c(),to:c(),value:c(),isError:c().optional(),input:c().optional(),methodId:c().optional(),functionName:c().optional()}),ks=m({blockNumber:c(),timeStamp:c(),hash:c(),from:c(),to:c(),value:c(),tokenName:c(),tokenSymbol:c(),tokenDecimal:c(),contractAddress:c()}),Es=5;function nt(o,t,e){const s=o.toLowerCase(),n=t.toLowerCase();return s===e&&n===e?"self":s===e?"out":"in"}function Ns(o){const t=o.value;return t&&t!=="0"?"transfer":"contract"}function Bs(o,t){if(o.length===0)return null;if(o.length===1)return o[0];const e=o.filter(n=>n.from.toLowerCase()===t||n.to.toLowerCase()===t);return(e.length>0?e:o).reduce((n,a)=>{const r=BigInt(n.value);return BigInt(a.value)>r?a:n})}class te{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}get supportsNativeBalance(){return!0}get supportsTransactionHistory(){return!0}async getNativeBalance(t){const e=new URL(`${this.endpoint}/balance`);e.searchParams.set("address",t);const s=await S(e.toString(),void 0,{cacheKey:`ethwallet:${this.chainId}:balance:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),n=Is.safeParse(s);if(!n.success||!n.data.success)throw new Error("Invalid API response");const a=n.data.result;return P({key:`balance:${this.chainId}:${t}`,value:a,invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(a,this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){const s=e*Es,[n,a]=await Promise.all([this.fetchHistory(`${this.endpoint}/trans/normal/history`,t,s,As,"normal"),this.fetchHistory(`${this.endpoint}/trans/erc20/history`,t,s,ks,"erc20")]),r=t.toLowerCase(),i=new Map;for(const d of a){const h=d.hash.toLowerCase(),f=i.get(h)??[];f.push(d),i.set(h,f)}const l=[],u=new Set;for(const d of n){const h=d.hash.toLowerCase();if(u.has(h))continue;u.add(h);const f=i.get(h)??[],p=Bs(f,r);if(p){l.push({hash:p.hash,from:p.from,to:p.to,timestamp:Number(p.timeStamp)*1e3,status:"confirmed",blockNumber:BigInt(p.blockNumber),action:"transfer",direction:nt(p.from,p.to,r),assets:[{assetType:"token",value:p.value,symbol:p.tokenSymbol,decimals:parseInt(p.tokenDecimal,10),contractAddress:p.contractAddress,name:p.tokenName}],contract:{address:d.to,method:d.functionName??void 0,methodId:d.methodId??void 0}});continue}l.push({hash:d.hash,from:d.from,to:d.to,timestamp:Number(d.timeStamp)*1e3,status:d.isError==="1"?"failed":"confirmed",blockNumber:BigInt(d.blockNumber),action:Ns(d),direction:nt(d.from,d.to,r),assets:[{assetType:"native",value:d.value,symbol:this.symbol,decimals:this.decimals}],contract:d.value==="0"?{address:d.to,method:d.functionName??void 0,methodId:d.methodId??void 0}:void 0})}for(const d of a){const h=d.hash.toLowerCase();u.has(h)||(u.add(h),l.push({hash:d.hash,from:d.from,to:d.to,timestamp:Number(d.timeStamp)*1e3,status:"confirmed",blockNumber:BigInt(d.blockNumber),action:"transfer",direction:nt(d.from,d.to,r),assets:[{assetType:"token",value:d.value,symbol:d.tokenSymbol,decimals:parseInt(d.tokenDecimal,10),contractAddress:d.contractAddress,name:d.tokenName}]}))}return l.toSorted((d,h)=>h.timestamp-d.timestamp).slice(0,e)}async fetchHistory(t,e,s,n,a){const r=await S(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:e,page:1,offset:s})},{cacheKey:`ethwallet:${this.chainId}:${a}:${e}:${s}`,ttlMs:3e5,tags:[`txhistory:${this.chainId}:${e}`]}),i=Ss.safeParse(r);if(!i.success||!i.data.success)throw new Error("Invalid API response");return i.data.result.result.map(l=>n.safeParse(l)).filter(l=>l.success).map(l=>l.data)}}function ee(o,t){return o.type==="ethwallet-v1"?new te(o,t):null}const ct="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",_s=m({success:E(),result:Ct([c(),w().transform(o=>String(o))])}),Cs=m({data:A(Q()),success:E(),fingerprint:c().optional()}),Rs=m({contractRet:c().optional(),txID:c(),blockNumber:w().optional(),from:c(),to:c(),amount:w(),timestamp:w()}),$s=m({txID:c(),from:c(),to:c(),value:c(),token_symbol:c(),token_address:c(),token_name:c(),token_decimals:w(),timestamp:w()}),Ps=5;function xs(o){let t=BigInt(0);for(const n of o){const a=ct.indexOf(n);if(a===-1)throw new Error("Invalid base58");t=t*58n+BigInt(a)}const e=t.toString(16).padStart(50,"0"),s=new Uint8Array(25);for(let n=0;n<25;n++)s[n]=parseInt(e.slice(n*2,n*2+2),16);return s}function Os(o){let t=BigInt(0);for(const s of o)t=t*256n+BigInt(s);let e="";for(;t>0n;){const s=Number(t%58n);t=t/58n,e=ct[s]+e}for(const s of o)if(s===0)e=ct[0]+e;else break;return e}function Et(o){const e=xs(o).slice(0,21);return x(e)}function Us(o){const t=o.startsWith("0x")?o.slice(2):o,e=D(t),s=C(C(e)).slice(0,4),n=new Uint8Array([...e,...s]);return Os(n)}function R(o){return o.startsWith("T")?o:Us(o)}function at(o,t,e){const s=o.toLowerCase(),n=t.toLowerCase();return s===e&&n===e?"self":s===e?"out":"in"}class se{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}get supportsNativeBalance(){return!0}get supportsTransactionHistory(){return!0}async getNativeBalance(t){const e=t.startsWith("T")?Et(t):t,s=new URL(`${this.endpoint}/balance`);s.searchParams.set("address",e);const n=await S(s.toString(),void 0,{cacheKey:`tronwallet:${this.chainId}:balance:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),a=_s.safeParse(n);if(!a.success||!a.data.success)throw new Error("Invalid API response");const r=a.data.result;return P({key:`balance:${this.chainId}:${t}`,value:r,invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(r,this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){const s=e*Ps,n=t.startsWith("T")?Et(t):t,[a,r]=await Promise.all([this.fetchHistory(`${this.endpoint}/trans/common/history`,n,t,s,Rs,"common"),this.fetchHistory(`${this.endpoint}/trans/trc20/history`,n,t,s,$s,"trc20")]),i=t.toLowerCase(),l=new Map;for(const h of r){const f=h.txID.toLowerCase(),p=l.get(f)??[];p.push(h),l.set(f,p)}const u=[],d=new Set;for(const h of a){const f=h.txID.toLowerCase();if(d.has(f))continue;d.add(f);const p=l.get(f)??[];if(p.length>0){const v=p[0],W=R(v.from),M=R(v.to);u.push({hash:v.txID,from:W,to:M,timestamp:v.timestamp,status:"confirmed",blockNumber:h.blockNumber!==void 0?BigInt(h.blockNumber):void 0,action:"transfer",direction:at(W,M,i),assets:[{assetType:"token",value:v.value,symbol:v.token_symbol,decimals:v.token_decimals,contractAddress:R(v.token_address),name:v.token_name}]});continue}const I=R(h.from),k=R(h.to);u.push({hash:h.txID,from:I,to:k,timestamp:h.timestamp,status:"confirmed",blockNumber:h.blockNumber!==void 0?BigInt(h.blockNumber):void 0,action:"transfer",direction:at(I,k,i),assets:[{assetType:"native",value:String(h.amount),symbol:this.symbol,decimals:this.decimals}]})}for(const h of r){const f=h.txID.toLowerCase();if(d.has(f))continue;d.add(f);const p=R(h.from),I=R(h.to);u.push({hash:h.txID,from:p,to:I,timestamp:h.timestamp,status:"confirmed",action:"transfer",direction:at(p,I,i),assets:[{assetType:"token",value:h.value,symbol:h.token_symbol,decimals:h.token_decimals,contractAddress:R(h.token_address),name:h.token_name}]})}return u.toSorted((h,f)=>f.timestamp-h.timestamp).slice(0,e)}async fetchHistory(t,e,s,n,a,r){const i=await S(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:e,limit:n})},{cacheKey:`tronwallet:${this.chainId}:${r}:${e}:${n}`,ttlMs:3e5,tags:[`txhistory:${this.chainId}:${s}`]}),l=Cs.safeParse(i);if(!l.success||!l.data.success)throw new Error("Upstream API error");return l.data.data.map(u=>a.safeParse(u)).filter(u=>u.success).map(u=>u.data)}}function ne(o,t){return o.type==="tronwallet-v1"?new se(o,t):null}const Ds=m({error:c()}),Ms=o=>m({success:E(),result:o}),Ls=m({addresses:A(c()),value:c()}),Hs=m({addresses:A(c()),value:c()}),Fs=m({txid:c(),blockHeight:w(),confirmations:w(),blockTime:w(),vin:A(Ls),vout:A(Hs),fees:c().optional()}),Nt=m({address:c().optional(),balance:c(),unconfirmedBalance:c().optional(),txs:w().optional(),transactions:A(Fs).optional()});function Bt(o,t){let e=0n;for(const s of o)s.addresses.some(n=>n===t)&&(e+=BigInt(s.value));return e}function Ks(o){return o>0n?"in":o<0n?"out":"self"}class ae{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=y.getSymbol(e),this.decimals=y.getDecimals(e)}get supportsNativeBalance(){return!0}get supportsTransactionHistory(){return!0}async getNativeBalance(t){const e=await this.proxyGet(`/api/v2/address/${t}`,Nt,{cacheKey:`btcwallet:${this.chainId}:address:${t}`,ttlMs:6e4,tags:[`balance:${this.chainId}:${t}`]}),s=BigInt(e.balance),n=BigInt(e.unconfirmedBalance??"0"),a=s+n;return P({key:`balance:${this.chainId}:${t}`,value:a.toString(),invalidateTags:[`txhistory:${this.chainId}:${t}`]}),{amount:g.fromRaw(a.toString(),this.decimals,this.symbol),symbol:this.symbol}}async getTransactionHistory(t,e=20){return((await this.proxyGet(`/api/v2/address/${t}?details=txs&page=1&pageSize=${e}`,Nt,{cacheKey:`btcwallet:${this.chainId}:txs:${t}:${e}`,ttlMs:3e5,tags:[`txhistory:${this.chainId}:${t}`]})).transactions??[]).map(r=>{const i=Bt(r.vin,t),u=Bt(r.vout,t)-i,d=Ks(u),h=u<0n?(-u).toString():u.toString(),f=d==="in"?r.vin[0]?.addresses?.[0]??"":t,p=r.vout.flatMap(k=>k.addresses).find(k=>k!==t),I=d==="out"?p??t:t;return{hash:r.txid,from:f,to:I,timestamp:r.blockTime*1e3,status:r.confirmations>0?"confirmed":"pending",blockNumber:r.blockHeight>0?BigInt(r.blockHeight):void 0,action:"transfer",direction:d,assets:[{assetType:"native",value:h,symbol:this.symbol,decimals:this.decimals}]}}).toSorted((r,i)=>i.timestamp-r.timestamp)}async proxyGet(t,e,s){const n=await S(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({url:t,method:"GET"})},{cacheKey:s?.cacheKey,ttlMs:s?.ttlMs,tags:s?.tags}),a=Ds.safeParse(n);if(a.success&&a.data.error)throw new Error(a.data.error);const r=Ms(e).safeParse(n);if(r.success&&r.data.success)return r.data.result;const i=e.safeParse(n);if(i.success)return i.data;throw new Error("Invalid API response")}}function oe(o,t){return o.type==="btcwallet-v1"?new ae(o,t):null}class H{constructor(t,e,s){this.transactionService=e,this.assetService=s,this.type=t}type;endpoint="";get supportsTransactionHistory(){return this.transactionService.supportsTransactionHistory!==!1}async getNativeBalance(t){return this.assetService.getNativeBalance(t)}async getTransactionHistory(t,e){return(await this.transactionService.getTransactionHistory(t,e)).map(n=>this.convertTransaction(n,t))}async getTransaction(t){const e=await this.transactionService.getTransaction(t);return e?this.convertTransaction(e):null}async getTransactionStatus(t){const e=await this.transactionService.getTransactionStatus(t);return this.convertTransactionStatus(e)}async estimateFee(t){const e=await this.transactionService.estimateFee(t);return this.convertFeeEstimate(e)}async buildTransaction(t){return this.transactionService.buildTransaction(t)}async signTransaction(t,e){const s=await this.transactionService.signTransaction(t,e);return{chainId:s.chainId,data:s.data,signature:typeof s.signature=="string"?s.signature:""}}async broadcastTransaction(t){return this.transactionService.broadcastTransaction(t)}convertTransaction(t,e){const s=e?t.from.toLowerCase()===e.toLowerCase()?"out":t.to.toLowerCase()===e.toLowerCase()?"in":"self":"self",n=this.deriveAction(t);return{hash:t.hash,from:t.from,to:t.to,timestamp:t.timestamp,status:t.status.status==="confirmed"?"confirmed":t.status.status==="failed"?"failed":"pending",blockNumber:t.blockNumber,action:n,direction:s,assets:[{assetType:"native",value:t.amount.toRawString(),symbol:t.amount.symbol??"",decimals:t.amount.decimals}],contract:t.type==="contract-call"||n==="contract"?{address:t.to}:void 0,fee:{value:t.fee.toRawString(),symbol:t.fee.symbol??"",decimals:t.fee.decimals}}}deriveAction(t){const e=t.rawType;if(e){if(e.includes("BSE-01"))return"signature";if(e.includes("AST-02"))return"transfer";if(e.includes("AST-03"))return"destroyAsset";if(e.includes("AST-04"))return"gift";if(e.includes("AST-05"))return"grab";if(e.includes("AST-06"))return"trust";if(e.includes("AST-07"))return"signFor";if(e.includes("AST-08"))return"emigrate";if(e.includes("AST-09"))return"immigrate";if(e.includes("AST-10")||e.includes("AST-11"))return"exchange";if(e.includes("AST-12"))return"stake";if(e.includes("AST-13"))return"unstake";if(e.includes("AST-00"))return"issueAsset";if(e.includes("AST-01"))return"increaseAsset";if(e.includes("ETY-02")||e.includes("ETY-04"))return"issueEntity";if(e.includes("ETY-03"))return"destroyEntity";if(e.includes("ETY-00")||e.includes("ETY-01"))return"issueAsset";if(e.includes("ANY-00"))return"transfer";if(e.includes("ANY-01"))return"gift";if(e.includes("ANY-02"))return"grab";if(e.includes("ANY-03")||e.includes("ANY-04")||e.includes("ANY-05")||e.includes("ANY-06")||e.includes("ANY-07")||e.includes("ANY-08"))return"exchange";if(e.includes("LNS-"))return"locationName";if(e.includes("WOD-"))return"dapp";if(e.includes("CRT-"))return"certificate";if(e.includes("EXT-00"))return"mark"}return t.type==="stake"?"stake":t.type==="unstake"?"unstake":t.type==="contract-call"?"contract":"transfer"}convertTransactionStatus(t){let e;switch(t.status){case"pending":e="pending";break;case"confirmed":e="confirmed";break;case"failed":e="failed";break;default:e="pending"}return{status:e,confirmations:t.confirmations,requiredConfirmations:t.requiredConfirmations}}convertFeeEstimate(t){const e=(s,n)=>({amount:s.amount,estimatedTime:n});return{slow:e(t.slow,600),standard:e(t.standard,180),fast:e(t.fast,30)}}}class F{constructor(t,e){this.identityService=e,this.type=t}type;endpoint="";async deriveAddress(t,e=0){return this.identityService.deriveAddress(t,e)}async deriveAddresses(t,e,s){return this.identityService.deriveAddresses(t,e,s)}isValidAddress(t){return this.identityService.isValidAddress(t)}normalizeAddress(t){return this.identityService.normalizeAddress(t)}}class js{chainId;constructor(t){this.chainId=t}async deriveAddress(t,e=0){const s=new TextDecoder().decode(t);return z(s,"ethereum",e).address}async deriveAddresses(t,e,s){const n=new TextDecoder().decode(t),a=[];for(let r=0;r<s;r++){const i=z(n,"ethereum",e+r);a.push(i.address)}return a}isValidAddress(t){return me(t,"ethereum")}normalizeAddress(t){return pe(t)}async signMessage(t,e){throw new Error("Not implemented")}async verifyMessage(t,e,s){throw new Error("Not implemented")}}class b extends Error{code;details;constructor(t,e,s,n){super(e,{cause:n}),this.name="ChainServiceError",this.code=t,this.details=s}}const T={CHAIN_NOT_SUPPORTED:"CHAIN_NOT_SUPPORTED",NOT_SUPPORTED:"NOT_SUPPORTED",NETWORK_ERROR:"NETWORK_ERROR",INSUFFICIENT_BALANCE:"INSUFFICIENT_BALANCE",INSUFFICIENT_FEE:"INSUFFICIENT_FEE",INVALID_ADDRESS:"INVALID_ADDRESS",TRANSACTION_REJECTED:"TRANSACTION_REJECTED",TRANSACTION_TIMEOUT:"TRANSACTION_TIMEOUT",TX_BUILD_FAILED:"TX_BUILD_FAILED",TX_BROADCAST_FAILED:"TX_BROADCAST_FAILED",SIGNATURE_FAILED:"SIGNATURE_FAILED",ADDRESS_FROZEN:"ADDRESS_FROZEN",PAYSECRET_REQUIRED:"PAYSECRET_REQUIRED",ADDRESS_NOT_ACTIVATED:"ADDRESS_NOT_ACTIVATED",ENERGY_INSUFFICIENT:"ENERGY_INSUFFICIENT",NONCE_TOO_LOW:"NONCE_TOO_LOW",GAS_TOO_LOW:"GAS_TOO_LOW",UTXO_INSUFFICIENT:"UTXO_INSUFFICIENT"};class Ws{chainId;constructor(t){this.chainId=t}get rpcUrl(){return y.getRpcUrl(this.chainId)}get decimals(){return y.getDecimals(this.chainId)}get symbol(){return y.getSymbol(this.chainId)}async rpc(t,e){const s=await fetch(this.rpcUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:1})});if(!s.ok)throw new b(T.NETWORK_ERROR,`HTTP ${s.status}: ${s.statusText}`);const n=await s.json();if(n.error)throw new b(T.NETWORK_ERROR,n.error.message);return n.result}async getNativeBalance(t){try{const e=await this.rpc("eth_getBalance",[t,"latest"]),s=BigInt(e).toString();return{amount:g.fromRaw(s,this.decimals,this.symbol),symbol:this.symbol}}catch{return{amount:g.fromRaw("0",this.decimals,this.symbol),symbol:this.symbol}}}async getTokenBalance(t,e){try{const s=`0x70a08231000000000000000000000000${t.slice(2).toLowerCase()}`,n=await this.rpc("eth_call",[{to:e,data:s},"latest"]),a=BigInt(n).toString();return{amount:g.fromRaw(a,18,"TOKEN"),symbol:"TOKEN"}}catch{return{amount:g.fromRaw("0",18,"UNKNOWN"),symbol:"UNKNOWN"}}}async getTokenBalances(t){return[await this.getNativeBalance(t)]}async getTokenMetadata(t){return{address:t,name:"Unknown Token",symbol:"UNKNOWN",decimals:18}}}const Vs={ethereum:1,"ethereum-sepolia":11155111,binance:56,"bsc-testnet":97};class qs{chainId;evmChainId;constructor(t){this.chainId=t,this.evmChainId=Vs[t]??1}get rpcUrl(){return y.getRpcUrl(this.chainId)}get decimals(){return y.getDecimals(this.chainId)}get symbol(){return y.getSymbol(this.chainId)}async rpc(t,e=[]){const s=await fetch(this.rpcUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:Date.now(),method:t,params:e})});if(!s.ok)throw new b(T.NETWORK_ERROR,`HTTP ${s.status}: ${s.statusText}`);const n=await s.json();if(n.error)throw new b(T.NETWORK_ERROR,n.error.message,{code:n.error.code});return n.result}async estimateFee(t){const e=await this.rpc("eth_gasPrice"),a=21000n*BigInt(e),r=g.fromRaw((a*80n/100n).toString(),this.decimals,this.symbol),i=g.fromRaw(a.toString(),this.decimals,this.symbol),l=g.fromRaw((a*120n/100n).toString(),this.decimals,this.symbol);return{slow:{amount:r,estimatedTime:60},standard:{amount:i,estimatedTime:15},fast:{amount:l,estimatedTime:5}}}async buildTransaction(t){const e=await this.rpc("eth_getTransactionCount",[t.from,"pending"]),s=parseInt(e,16),n=await this.rpc("eth_gasPrice");return{chainId:this.chainId,data:{nonce:s,gasPrice:n,gasLimit:"0x5208",to:t.to,value:"0x"+t.amount.raw.toString(16),data:"0x",chainId:this.evmChainId}}}async signTransaction(t,e){const s=t.data,n=this.rlpEncode([this.toRlpHex(s.nonce),s.gasPrice,s.gasLimit,s.to.toLowerCase(),s.value,s.data,this.toRlpHex(s.chainId),"0x","0x"]),a=Y(D(n.slice(2))),r=K.sign(a,e,{prehash:!1,format:"recovered"}),i=BigInt("0x"+x(r.slice(0,32))),l=BigInt("0x"+x(r.slice(32,64))),u=r[64],d=s.chainId*2+35+u,h=i.toString(16).padStart(64,"0"),f=l.toString(16).padStart(64,"0"),p=this.rlpEncode([this.toRlpHex(s.nonce),s.gasPrice,s.gasLimit,s.to.toLowerCase(),s.value,s.data,this.toRlpHex(d),"0x"+h,"0x"+f]);return{chainId:this.chainId,data:p,signature:"0x"+h+f}}async broadcastTransaction(t){const e=t.data;return await this.rpc("eth_sendRawTransaction",[e])}toRlpHex(t){return t===0?"0x":"0x"+t.toString(16)}rlpEncode(t){const e=t.map(i=>{if(i==="0x"||i==="")return new Uint8Array([128]);const l=D(i.startsWith("0x")?i.slice(2):i);if(l.length===1&&l[0]<128)return l;if(l.length<=55)return new Uint8Array([128+l.length,...l]);const u=this.numberToBytes(l.length);return new Uint8Array([183+u.length,...u,...l])}),s=e.reduce((i,l)=>i+l.length,0);let n;if(s<=55)n=new Uint8Array([192+s]);else{const i=this.numberToBytes(s);n=new Uint8Array([247+i.length,...i])}const a=new Uint8Array(n.length+s);a.set(n);let r=n.length;for(const i of e)a.set(i,r),r+=i.length;return"0x"+x(a)}numberToBytes(t){const e=t.toString(16),s=e.length%2?"0"+e:e;return D(s)}async getTransactionStatus(t){try{const e=await this.rpc("eth_getTransactionReceipt",[t]);if(!e)return{status:"pending",confirmations:0,requiredConfirmations:12};const s=await this.rpc("eth_blockNumber"),n=parseInt(s,16)-parseInt(e.blockNumber,16);return{status:n>=12?"confirmed":"confirming",confirmations:Math.max(0,n),requiredConfirmations:12}}catch{return{status:"pending",confirmations:0,requiredConfirmations:12}}}async getTransaction(t){try{const[e,s]=await Promise.all([this.rpc("eth_getTransactionByHash",[t]),this.rpc("eth_getTransactionReceipt",[t])]);if(!e)return null;const n=e.blockNumber?await this.rpc("eth_getBlockByNumber",[e.blockNumber,!1]):null;return{hash:e.hash,from:e.from,to:e.to??"",amount:g.fromRaw(BigInt(e.value).toString(),this.decimals,this.symbol),fee:s?g.fromRaw((BigInt(s.gasUsed)*BigInt(e.gasPrice)).toString(),this.decimals,this.symbol):g.fromRaw("0",this.decimals,this.symbol),status:{status:s?.status==="0x1"?"confirmed":s?"failed":"pending",confirmations:s?12:0,requiredConfirmations:12},timestamp:n?parseInt(n.timestamp,16)*1e3:Date.now(),blockNumber:e.blockNumber?BigInt(e.blockNumber):void 0,type:"transfer"}}catch{return null}}supportsTransactionHistory=!1;async getTransactionHistory(t,e=20){throw new b(T.NOT_SUPPORTED,"Transaction history not supported by standard EVM JSON-RPC")}}const J="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";class Js{async deriveAddress(t,e=0){const s=new TextDecoder().decode(t);return z(s,"tron",e).address}async deriveAddresses(t,e,s){const n=new TextDecoder().decode(t),a=[];for(let r=0;r<s;r++){const i=z(n,"tron",e+r);a.push(i.address)}return a}isValidAddress(t){if(!t.startsWith("T")||t.length!==34)return!1;for(const e of t)if(!J.includes(e))return!1;try{const e=this.decodeBase58(t);if(e.length!==25)return!1;const s=e.slice(0,21),n=e.slice(21),a=C(C(s));return n.every((r,i)=>r===a[i])}catch{return!1}}decodeBase58(t){let e=BigInt(0);for(const a of t){const r=J.indexOf(a);if(r===-1)throw new Error(`Invalid base58 character: ${a}`);e=e*58n+BigInt(r)}const s=e.toString(16).padStart(50,"0"),n=new Uint8Array(25);for(let a=0;a<25;a++)n[a]=parseInt(s.slice(a*2,a*2+2),16);return n}normalizeAddress(t){return t}async signMessage(t,e){const s=typeof t=="string"?new TextEncoder().encode(t):t,n=new TextEncoder().encode(`TRON Signed Message:
`+s.length),a=Y(new Uint8Array([...n,...s])),r=K.sign(a,e,{prehash:!1,format:"recovered"});return x(r)}async verifyMessage(t,e,s){try{const n=typeof t=="string"?new TextEncoder().encode(t):t,a=new TextEncoder().encode(`TRON Signed Message:
`+n.length),r=Y(new Uint8Array([...a,...n])),i=D(e),l=K.recoverPublicKey(r,i);if(!l)return!1;const d=Y(l.slice(1)).slice(-20),h=new Uint8Array([65,...d]),f=C(C(h)).slice(0,4),p=new Uint8Array([...h,...f]);return this.encodeBase58(p)===s}catch{return!1}}encodeBase58(t){let e=BigInt(0);for(const n of t)e=e*256n+BigInt(n);let s="";for(;e>0n;){const n=Number(e%58n);e=e/58n,s=J[n]+s}for(const n of t)if(n===0)s=J[0]+s;else break;return s}}class Ys{chainId;constructor(t){this.chainId=t}get rpcUrl(){return y.getRpcUrl(this.chainId)}get decimals(){return y.getDecimals(this.chainId)}get symbol(){return y.getSymbol(this.chainId)}async api(t,e){const s=`${this.rpcUrl}${t}`,n=e?{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)}:{method:"GET"},a=await fetch(s,n);if(!a.ok)throw new b(T.NETWORK_ERROR,`Tron API error: ${a.status}`);return a.json()}async getNativeBalance(t){const e=await this.api("/wallet/getaccount",{address:t,visible:!0});return!e||!("balance"in e)?{amount:g.fromRaw("0",this.decimals,this.symbol),symbol:this.symbol}:{amount:g.fromRaw(e.balance.toString(),this.decimals,this.symbol),symbol:this.symbol}}async getTokenBalance(t,e){try{const s=await this.api("/wallet/getaccount",{address:t,visible:!0});if(s?.trc20){for(const n of s.trc20)if(n[e])return{amount:g.fromRaw(n[e],18,"TOKEN"),symbol:"TOKEN"}}return{amount:g.fromRaw("0",18,"TOKEN"),symbol:"TOKEN"}}catch{return{amount:g.fromRaw("0",18,"TOKEN"),symbol:"TOKEN"}}}async getTokenBalances(t){return[await this.getNativeBalance(t)]}async getTokenMetadata(t){return{address:t,name:"TRC20 Token",symbol:"TOKEN",decimals:18}}}const Gs="https://api.trongrid.io";class zs{chainId;config=null;rpcUrl="";constructor(t){this.chainId=t}getConfig(){if(!this.config){const t=y.getConfig(this.chainId);if(!t)throw new b(T.CHAIN_NOT_FOUND,`Chain config not found: ${this.chainId}`);this.config=t,this.rpcUrl=y.getRpcUrl(t.id)||Gs}return this.config}async api(t,e){const s=`${this.rpcUrl}${t}`,n=e?{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)}:{method:"GET"},a=await fetch(s,n);if(!a.ok)throw new b(T.NETWORK_ERROR,`Tron API error: ${a.status} ${a.statusText}`);return a.json()}base58ToHex(t){const e="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";let s=BigInt(0);for(const a of t){const r=e.indexOf(a);if(r===-1)throw new Error(`Invalid base58 character: ${a}`);s=s*58n+BigInt(r)}return s.toString(16).padStart(50,"0").slice(0,42)}async estimateFee(t){const e=this.getConfig(),n={amount:g.fromRaw("0",e.decimals,e.symbol),estimatedTime:3};return{slow:n,standard:n,fast:n}}async buildTransaction(t){const e=this.getConfig(),s=this.base58ToHex(t.from),n=this.base58ToHex(t.to),a=await this.api("/wallet/createtransaction",{owner_address:s,to_address:n,amount:Number(t.amount.raw),visible:!1});if(!a.txID)throw new b(T.TX_BUILD_FAILED,"Failed to create Tron transaction");return{chainId:e.id,data:a}}async signTransaction(t,e){const s=t.data,n=D(s.txID),a=K.sign(n,e,{prehash:!1,format:"recovered"}),r=x(a),i={...s,signature:[r]};return{chainId:t.chainId,data:i,signature:r}}async broadcastTransaction(t){const e=t.data,s=await this.api("/wallet/broadcasttransaction",e);if(!s.result){const n=s.message?Buffer.from(s.message,"hex").toString("utf8"):s.code??"Unknown error";throw new b(T.TX_BROADCAST_FAILED,`Broadcast failed: ${n}`)}return e.txID}async getTransactionStatus(t){try{const e=await this.api("/wallet/gettransactioninfobyid",{value:t});if(!e||!("blockNumber"in e))return{status:"pending",confirmations:0,requiredConfirmations:19};const a=(await this.api("/wallet/getnowblock")).block_header.raw_data.number-e.blockNumber;return{status:a>=19?"confirmed":"confirming",confirmations:Math.max(0,a),requiredConfirmations:19}}catch{return{status:"pending",confirmations:0,requiredConfirmations:19}}}async getTransaction(t){try{const[e,s]=await Promise.all([this.api("/wallet/gettransactionbyid",{value:t}),this.api("/wallet/gettransactioninfobyid",{value:t})]);if(!e||!("txID"in e))return null;const n=e.raw_data.contract[0];if(!n||n.type!=="TransferContract")return null;const{amount:a,owner_address:r,to_address:i}=n.parameter.value,l="blockNumber"in s,u=this.getConfig();return{hash:e.txID,from:r,to:i,amount:g.fromRaw(a.toString(),u.decimals,u.symbol),fee:g.fromRaw((s.receipt?.net_usage??0).toString(),u.decimals,u.symbol),status:{status:l?"confirmed":"pending",confirmations:l?19:0,requiredConfirmations:19},timestamp:e.raw_data.timestamp,blockNumber:l?BigInt(s.blockNumber):void 0,type:"transfer"}}catch{return null}}supportsTransactionHistory=!1;async getTransactionHistory(t,e=20){throw new b(T.NOT_SUPPORTED,"Transaction history not supported by Tron HTTP API, use TronGrid API instead")}}class Xs{async deriveAddress(t,e=0){const s=new TextDecoder().decode(t);return ft(s,84,e).address}async deriveAddresses(t,e,s){const n=new TextDecoder().decode(t),a=[];for(let r=0;r<s;r++){const i=ft(n,84,e+r);a.push(i.address)}return a}isValidAddress(t){try{if(t.startsWith("1")||t.startsWith("3"))return ge(C).decode(t).length===21;if(t.toLowerCase().startsWith("bc1q")){const e=t.toLowerCase(),s=mt.decode(e),n=mt.fromWords(s.words.slice(1));return s.prefix==="bc"&&s.words[0]===0&&n.length===20}if(t.toLowerCase().startsWith("bc1p")){const e=t.toLowerCase(),s=pt.decode(e),n=pt.fromWords(s.words.slice(1));return s.prefix==="bc"&&s.words[0]===1&&n.length===32}return!1}catch{return!1}}normalizeAddress(t){return t.startsWith("bc1")||t.startsWith("BC1")?t.toLowerCase():t}async signMessage(t,e){const s=typeof t=="string"?new TextEncoder().encode(t):t,n=new TextEncoder().encode(`Bitcoin Signed Message:
`),a=new Uint8Array([s.length]),r=new Uint8Array([...n,...a,...s]),i=C(C(r)),l=K.sign(i,e,{prehash:!1,format:"recovered"});return x(l)}async verifyMessage(t,e,s){return!1}}const _t={bitcoin:"https://mempool.space/api","bitcoin-testnet":"https://mempool.space/testnet/api","bitcoin-signet":"https://mempool.space/signet/api"};class Zs{config;apiUrl;constructor(t){this.config=t,this.apiUrl=_t[t.id]??_t.bitcoin}async api(t){const e=`${this.apiUrl}${t}`,s=await fetch(e);if(!s.ok)throw new b(T.NETWORK_ERROR,`Bitcoin API error: ${s.status}`);return s.json()}async getNativeBalance(t){try{const e=await this.api(`/address/${t}`),s=e.chain_stats.funded_txo_sum-e.chain_stats.spent_txo_sum,n=e.mempool_stats.funded_txo_sum-e.mempool_stats.spent_txo_sum,a=s+n;return{amount:g.fromRaw(a.toString(),this.config.decimals,this.config.symbol),symbol:this.config.symbol}}catch{return{amount:g.fromRaw("0",this.config.decimals,this.config.symbol),symbol:this.config.symbol}}}async getTokenBalance(t,e){return{amount:g.fromRaw("0",8,"TOKEN"),symbol:"TOKEN"}}async getTokenBalances(t){return[]}async getTokenMetadata(t){return{address:t,name:"Unknown",symbol:"UNKNOWN",decimals:8}}async getUtxos(t){return this.api(`/address/${t}/utxo`)}}const Qs="https://mempool.space/api";class tn{config;apiUrl;constructor(t){this.config=t,this.apiUrl=y.getMempoolApi(t.id)??Qs}async api(t,e){const s=`${this.apiUrl}${t}`,n=await fetch(s,e);if(!n.ok)throw new b(T.NETWORK_ERROR,`Bitcoin API error: ${n.status}`);const a=await n.text();try{return JSON.parse(a)}catch{return a}}async estimateFee(t){try{const e=await this.api("/v1/fees/recommended"),s=140,n={amount:g.fromRaw((e.hourFee*s).toString(),this.config.decimals,this.config.symbol),estimatedTime:3600},a={amount:g.fromRaw((e.halfHourFee*s).toString(),this.config.decimals,this.config.symbol),estimatedTime:1800},r={amount:g.fromRaw((e.fastestFee*s).toString(),this.config.decimals,this.config.symbol),estimatedTime:600};return{slow:n,standard:a,fast:r}}catch{const e={amount:g.fromRaw("2000",this.config.decimals,this.config.symbol),estimatedTime:1800};return{slow:e,standard:e,fast:e}}}async buildTransaction(t){const e=await this.api(`/address/${t.from}/utxo`);if(e.length===0)throw new b(T.INSUFFICIENT_BALANCE,"No UTXOs available");const n=(await this.api("/v1/fees/recommended")).halfHourFee,a=e.reduce((h,f)=>h+f.value,0),r=Number(t.amount.raw),i=10+e.length*68+62,l=n*i;if(a<r+l)throw new b(T.INSUFFICIENT_BALANCE,`Insufficient balance: need ${r+l}, have ${a}`);const u=a-r-l,d={inputs:e.map(h=>({txid:h.txid,vout:h.vout,value:h.value,scriptPubKey:""})),outputs:[{address:t.to,value:r}],fee:l,changeAddress:t.from};return u>546&&d.outputs.push({address:t.from,value:u}),{chainId:this.config.id,data:d}}async signTransaction(t,e){throw new b(T.CHAIN_NOT_SUPPORTED,"Bitcoin transaction signing requires specialized library (bitcoinjs-lib or similar)")}async broadcastTransaction(t){const e=t.data;return await this.api("/tx",{method:"POST",body:e})}async getTransactionStatus(t){try{const e=await this.api(`/tx/${t}`);if(!e.status.confirmed)return{status:"pending",confirmations:0,requiredConfirmations:6};const s=await this.api("/blocks/tip/height"),n=s-(e.status.block_height??s)+1;return{status:n>=6?"confirmed":"confirming",confirmations:Math.max(0,n),requiredConfirmations:6}}catch{return{status:"pending",confirmations:0,requiredConfirmations:6}}}async getTransaction(t){try{const e=await this.api(`/tx/${t}`),s=e.vin[0]?.prevout?.scriptpubkey_address??"",n=e.vout[0]?.scriptpubkey_address??"",a=e.vout[0]?.value??0;return{hash:e.txid,from:s,to:n,amount:g.fromRaw(a.toString(),this.config.decimals,this.config.symbol),fee:g.fromRaw(e.fee.toString(),this.config.decimals,this.config.symbol),status:{status:e.status.confirmed?"confirmed":"pending",confirmations:e.status.confirmed?6:0,requiredConfirmations:6},timestamp:(e.status.block_time??Math.floor(Date.now()/1e3))*1e3,blockNumber:e.status.block_height?BigInt(e.status.block_height):void 0,type:"transfer"}}catch{return null}}async getTransactionHistory(t,e=20){try{return(await this.api(`/address/${t}/txs`)).slice(0,e).map(n=>{const a=n.vin.some(u=>u.prevout?.scriptpubkey_address===t),r=a?t:n.vin[0]?.prevout?.scriptpubkey_address??"",i=a?n.vout.find(u=>u.scriptpubkey_address!==t)?.scriptpubkey_address??"":t,l=a?n.vout.filter(u=>u.scriptpubkey_address!==t).reduce((u,d)=>u+d.value,0):n.vout.filter(u=>u.scriptpubkey_address===t).reduce((u,d)=>u+d.value,0);return{hash:n.txid,from:r,to:i,amount:g.fromRaw(l.toString(),this.config.decimals,this.config.symbol),fee:g.fromRaw(n.fee.toString(),this.config.decimals,this.config.symbol),status:{status:n.status.confirmed?"confirmed":"pending",confirmations:n.status.confirmed?6:0,requiredConfirmations:6},timestamp:(n.status.block_time??Math.floor(Date.now()/1e3))*1e3,blockNumber:n.status.block_height?BigInt(n.status.block_height):void 0,type:"transfer"}})}catch{return[]}}}function en(o){return Array.from(o).map(t=>t.toString(16).padStart(2,"0")).join("")}class sn{chainId;prefix=null;constructor(t){this.chainId=t}getPrefix(){if(!this.prefix){const t=y.getConfig(this.chainId);this.prefix=t?.prefix??"b"}return this.prefix}async deriveAddress(t,e=0){const s=new TextDecoder().decode(t),n=ye(s);return we(n.publicKey,this.getPrefix())}async deriveAddresses(t,e,s){const n=await this.deriveAddress(t,e);return Array(s).fill(n)}isValidAddress(t){return be(t)}normalizeAddress(t){return t}async signMessage(t,e){const s=Rt(t,e);return en(s)}async verifyMessage(t,e,s){return!1}}const nn=B({assetNumber:c(),assetType:c().min(1),sourceChainMagic:c(),sourceChainName:c(),iconUrl:c().optional()}),an=B({success:E(),result:B({address:c(),assets:G(c(),G(c(),nn)),forgingRewards:c().optional()}).nullish(),error:B({code:w(),message:c(),info:c().optional()}).nullish()});class on{chainId;config=null;constructor(t){this.chainId=t}getConfig(){if(!this.config){const t=y.getConfig(this.chainId);if(!t)throw new b(T.CHAIN_NOT_FOUND,`Chain config not found: ${this.chainId}`);this.config=t}return this.config}getEmptyNativeBalance(){const t=this.getConfig();return{amount:g.zero(t.decimals,t.symbol),symbol:t.symbol}}async getNativeBalance(t){const e=await this.getTokenBalances(t),s=this.getConfig();return e.find(a=>a.symbol===s.symbol)??this.getEmptyNativeBalance()}async getTokenBalance(t,e){const s=e,a=(await this.getTokenBalances(t)).find(i=>i.symbol===s);if(a)return a;const r=this.getConfig();return{amount:g.zero(r.decimals,s),symbol:s}}async getTokenBalances(t){const e=this.getConfig(),s=y.getBiowalletApi(e.id);if(!s)return[this.getEmptyNativeBalance()];try{const n=await fetch(`${s}/address/asset`,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({address:t})});if(!n.ok)throw new b(T.NETWORK_ERROR,`Failed to fetch balances: ${n.status}`);const a=await n.json(),r=an.safeParse(a);if(!r.success)return console.warn("[BioforestAssetService] Invalid API response:",r.error.message),[this.getEmptyNativeBalance()];const{success:i,result:l}=r.data;if(!i||!l)return[this.getEmptyNativeBalance()];const u=[],{assets:d}=l;for(const h of Object.keys(d)){const f=d[h];if(f)for(const p of Object.keys(f)){const I=f[p];if(!I)continue;const k=e.decimals,v=g.fromRaw(I.assetNumber,k,I.assetType);u.push({amount:v,symbol:I.assetType})}}return u.length>0?u:[this.getEmptyNativeBalance()]}catch(n){throw n instanceof b?n:new b(T.NETWORK_ERROR,"Failed to fetch balances",void 0,n instanceof Error?n:void 0)}}async getTokenMetadata(t){const e=this.getConfig();return{address:null,name:t,symbol:t,decimals:e.decimals}}}class rn{chainId;config=null;baseUrl="";beginEpochTime=null;constructor(t){this.chainId=t}async getBeginEpochTime(){if(this.beginEpochTime!==null)return this.beginEpochTime;try{const t=y.getBiowalletGenesisBlock(this.chainId),s=(await _(this.chainId,t??void 0)).config;this.beginEpochTime=s?.beginEpochTime??0}catch{this.beginEpochTime=0}return this.beginEpochTime}async toAbsoluteTimestamp(t){const e=await this.getBeginEpochTime();return t*1e3+e}getConfig(){if(!this.config){const t=y.getConfig(this.chainId);if(!t)throw new b(T.CHAIN_NOT_FOUND,`Chain config not found: ${this.chainId}`);this.config=t,this.baseUrl=y.getBiowalletApi(t.id)??""}return this.config}async estimateFee(t){const e=this.getConfig(),{decimals:s,symbol:n}=e,a=(r,i)=>({amount:r,estimatedTime:i});if(!this.baseUrl)throw new b(T.NETWORK_ERROR,"RPC URL not configured for BioForest chain");try{const r=await xt(this.baseUrl,e.id,t.from,t.amount?.toRawString(),void 0),i=g.fromRaw(r,s,n);return{slow:a(i,30),standard:a(i,15),fast:a(i.mul(2),5)}}catch(r){throw new b(T.NETWORK_ERROR,"Failed to calculate minimum fee from SDK",void 0,r instanceof Error?r:void 0)}}async buildTransaction(t){const e=this.getConfig();if(!t.from||!t.to)throw new b(T.INVALID_ADDRESS,"Invalid address");const s=await this.estimateFee(t);return{chainId:e.id,data:{type:"transfer",from:t.from,to:t.to,amount:t.amount.toRawString(),assetType:e.symbol,fee:s.standard.amount.toRawString(),memo:t.memo,timestamp:Date.now()}}}async signTransaction(t,e){const s=t.data,n=JSON.stringify({type:s.type,from:s.from,to:s.to,amount:s.amount,assetType:s.assetType,fee:s.fee,timestamp:s.timestamp,memo:s.memo??""}),a=Rt(n,e),r=gt(a);return{chainId:t.chainId,data:{...s,signature:r,publicKey:gt(e.slice(32,64))},signature:r}}async broadcastTransaction(t){if(this.getConfig(),!this.baseUrl)throw new b(T.NETWORK_ERROR,"RPC URL not configured");try{const e=await fetch(`${this.baseUrl}/transactions/broadcast`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({transaction:t.data})});if(!e.ok){const n=await e.json().catch(()=>({}));throw new b(T.TRANSACTION_REJECTED,n.message??`Broadcast failed: ${e.status}`)}const s=await e.json();if(!s.success)throw new b(T.TRANSACTION_REJECTED,s.error?.message??"Broadcast failed");return t.signature}catch(e){throw e instanceof b?e:new b(T.NETWORK_ERROR,"Failed to broadcast transaction",void 0,e instanceof Error?e:void 0)}}async getTransactionStatus(t){if(this.getConfig(),!this.baseUrl)return{status:"pending",confirmations:0,requiredConfirmations:1};try{const e=await fetch(`${this.baseUrl}/transactions/query`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({signature:t})});if(!e.ok)return{status:"pending",confirmations:0,requiredConfirmations:1};const s=await e.json();return s.success&&s.result?.trs?.[0]?.height?{status:"confirmed",confirmations:1,requiredConfirmations:1}:{status:"pending",confirmations:0,requiredConfirmations:1}}catch{return{status:"pending",confirmations:0,requiredConfirmations:1}}}async getTransaction(t){if(this.getConfig(),!this.baseUrl)return null;try{const e=await fetch(`${this.baseUrl}/transactions/query`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({signature:t})});if(!e.ok)return null;const s=await e.json();if(!s.success||!s.result?.trs?.[0])return null;const n=s.result.trs[0],a=n.transaction,{decimals:r,symbol:i}=this.config,l=a.asset?.transferAsset?.amount??"0";return{hash:a.signature,from:a.senderId,to:a.recipientId??"",amount:g.fromRaw(l,r,i),fee:g.fromRaw(a.fee,r,i),status:{status:"confirmed",confirmations:1,requiredConfirmations:1},timestamp:await this.toAbsoluteTimestamp(a.timestamp),blockNumber:BigInt(n.height),type:"transfer"}}catch{return null}}async getTransactionHistory(t,e=20){const s=this.getConfig();if(!this.baseUrl)return console.warn("[TransactionService] No baseUrl configured for chain:",s.id),[];try{const n=`${this.baseUrl}/lastblock`,a=await fetch(n);if(!a.ok)return console.warn("[TransactionService] Failed to get lastblock:",a.status),[];const r=await a.json();if(!r.success)return console.warn("[TransactionService] lastblock API returned success=false"),[];const i=r.result.height,l=`${this.baseUrl}/transactions/query`,u=await fetch(l,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({maxHeight:i,address:t,page:1,pageSize:e,sort:-1})});if(!u.ok)return console.warn("[TransactionService] API error:",u.status,u.statusText,"for",l),[];const d=await u.json();if(!d.success)return console.warn("[TransactionService] API returned success=false"),[];const h=d.result?.trs??[];if(h.length===0)return console.debug("[TransactionService] No transactions found for",t,"on",s.id),[];const{decimals:f,symbol:p}=s,I=await this.getBeginEpochTime();return h.map(k=>{const v=k.transaction,W=v.type,M=v.asset?.transferAsset,ie=M?.amount??v.fee??"0",ce=M?.assetType??p;return{hash:v.signature||`${k.signature}:${k.tIndex}`,from:v.senderId,to:v.recipientId??"",amount:g.fromRaw(ie,f,ce),fee:g.fromRaw(v.fee,f,p),status:{status:"confirmed",confirmations:1,requiredConfirmations:1},timestamp:v.timestamp*1e3+I,blockNumber:BigInt(k.height),type:"transfer",rawType:W}})}catch(n){return console.error("[TransactionService] Failed to fetch history:",n),[]}}}const cn=[Jt,Gt,jt,Vt,Xt,Qt,ee,ne,oe];function ln(o,t){for(const e of cn){const s=e(o,t);if(s)return s}return null}function un(o){const t=[];switch(o.chainKind){case"evm":{const e=new js(o.id),s=new Ws(o.id),n=new qs(o.id);t.push(new H("wrapped-evm-tx",n,s),new F("wrapped-evm-identity",e));break}case"tron":{const e=new Js(o.id),s=new Ys(o.id),n=new zs(o.id);t.push(new H("wrapped-tron-tx",n,s),new F("wrapped-tron-identity",e));break}case"bitcoin":{const e=new Xs(o.id),s=new Zs(o.id),n=new tn(o.id);t.push(new H("wrapped-bitcoin-tx",n,s),new F("wrapped-bitcoin-identity",e));break}case"bioforest":{const e=new sn(o.id),s=new on(o.id),n=new rn(o.id);t.push(new H("wrapped-bioforest-tx",n,s),new F("wrapped-bioforest-identity",e));break}}return t}function re(o){const t=y.getApi(o),e=y.getConfig(o),s=[];for(const n of t){const a=ln(n,o);a&&s.push(a)}if(e){const n=un(e);s.push(...n)}return new Ft(o,s)}const lt=new Map;function dn(o){let t=lt.get(o);return t||(t=re(o),lt.set(o,t)),t}function hn(){lt.clear()}const Sn=Object.freeze(Object.defineProperty({__proto__:null,ActionSchema:Dt,AssetSchema:Lt,BiowalletProvider:qt,BscWalletProvider:Yt,BtcWalletProvider:ae,ChainProvider:Ft,DirectionSchema:Mt,EthWalletProvider:te,EtherscanProvider:Kt,EvmRpcProvider:Wt,InvalidDataError:Ht,MempoolProvider:Zt,TransactionSchema:rt,TronRpcProvider:zt,TronWalletProvider:se,WrappedIdentityProvider:F,WrappedTransactionProvider:H,clearProviderCache:hn,createBiowalletProvider:Jt,createBscWalletProvider:Gt,createBtcwalletProvider:oe,createChainProvider:re,createEtherscanProvider:jt,createEthwalletProvider:ee,createEvmRpcProvider:Vt,createFallbackResult:N,createMempoolProvider:Qt,createSupportedResult:$,createTronRpcProvider:Xt,createTronwalletProvider:ne,getChainProvider:dn,isSupported:Fe,pickApiKey:ht},Symbol.toStringTag,{value:"Module"}));export{Dt as A,sn as B,Je as C,Mt as D,Ht as I,y as a,dn as b,hn as c,re as d,Lt as e,b as f,Oe as g,T as h,Fe as i,xt as j,on as k,rn as l,Ft as m,tt as n,De as o,Ue as p,$t as q,ke as r,Me as s,vn as t,He as u,dt as v,Ut as w,Le as x,In as y,Sn as z};
