import{q as St}from"./iframe-Dp2Ali2n.js";const vn=1e5,Or=16,Bn=12,Ue=256,An=St.t.bind(St);async function Sn(e,t){const r=new TextEncoder().encode(e),o=await crypto.subtle.importKey("raw",r,"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:vn,hash:"SHA-256"},o,{name:"AES-GCM",length:Ue},!1,["encrypt","decrypt"])}async function Ms(e,t){const r=new TextEncoder().encode(e),o=crypto.getRandomValues(new Uint8Array(Or)),s=crypto.getRandomValues(new Uint8Array(Bn)),i=await Sn(t,o),c=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},i,r);return{ciphertext:Tt(c),salt:Tt(o),iv:Tt(s),iterations:vn}}async function kr(e,t){const n=Lt(e.salt),r=Lt(e.iv),o=Lt(e.ciphertext),s=await Sn(t,n);try{const i=await crypto.subtle.decrypt({name:"AES-GCM",iv:r},s,o);return new TextDecoder().decode(i)}catch{throw new Error(An("error:crypto.decryptFailed"))}}async function Vs(e,t){try{return await kr(e,t),!0}catch{return!1}}async function Ys(e,t){const r=new TextEncoder().encode(e),o=crypto.getRandomValues(new Uint8Array(Bn)),s=await crypto.subtle.importKey("raw",t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength),{name:"AES-GCM",length:Ue},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},s,r);return{ciphertext:Tt(i),salt:"",iv:Tt(o),iterations:0}}async function Fs(e,t){const n=Lt(e.iv),r=Lt(e.ciphertext),o=await crypto.subtle.importKey("raw",t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength),{name:"AES-GCM",length:Ue},!1,["decrypt"]);try{const s=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},o,r);return new TextDecoder().decode(s)}catch{throw new Error(An("error:crypto.decryptKeyFailed"))}}function Tt(e){const t=e instanceof Uint8Array?e:new Uint8Array(e);let n="";for(let r=0;r<t.byteLength;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function Lt(e){const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t.charCodeAt(r);return n}St.t.bind(St);function fe(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function nt(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function C(e,t,n=""){const r=fe(e),o=e?.length,s=t!==void 0;if(!r||s&&o!==t){const i=n&&`"${n}" `,c=s?` of length ${t}`:"",f=r?`length=${o}`:`type=${typeof e}`;throw new Error(i+"expected Uint8Array"+c+", got "+f)}return e}function Te(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");nt(e.outputLen),nt(e.blockLen)}function Kt(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Kn(e,t){C(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function Ur(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function et(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function mt(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function st(e,t){return e<<32-t|e>>>t}function kt(e,t){return e<<t|e>>>32-t>>>0}const Tr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Lr(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function Hr(e){for(let t=0;t<e.length;t++)e[t]=Lr(e[t]);return e}const Pe=Tr?e=>e:Hr,_n=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Cr=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function rt(e){if(C(e),_n)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=Cr[e[n]];return t}const it={_0:48,_9:57,A:65,F:70,a:97,f:102};function We(e){if(e>=it._0&&e<=it._9)return e-it._0;if(e>=it.A&&e<=it.F)return e-(it.A-10);if(e>=it.a&&e<=it.f)return e-(it.a-10)}function Ct(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(_n)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const i=We(e.charCodeAt(s)),c=We(e.charCodeAt(s+1));if(i===void 0||c===void 0){const f=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+f+'" at index '+s)}r[o]=i*16+c}return r}function Nr(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function Je(e,t=""){return typeof e=="string"?Nr(e):C(e,void 0,t)}function Q(...e){let t=0;for(let r=0;r<e.length;r++){const o=e[r];C(o),t+=o.length}const n=new Uint8Array(t);for(let r=0,o=0;r<e.length;r++){const s=e[r];n.set(s,o),o+=s.length}return n}function $r(e,t){if(t!==void 0&&{}.toString.call(t)!=="[object Object]")throw new Error("options must be object or undefined");return Object.assign(e,t)}function Vt(e,t={}){const n=(o,s)=>e(s).update(o).digest(),r=e(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=o=>e(o),Object.assign(n,t),Object.freeze(n)}function Le(e=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}const In=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function Be(e,t,n){return e&t^~e&n}function Dr(e,t,n){return e&t^e&n^t&n}class ae{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(t,n,r,o){this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.buffer=new Uint8Array(t),this.view=mt(this.buffer)}update(t){Kt(this),C(t);const{view:n,buffer:r,blockLen:o}=this,s=t.length;for(let i=0;i<s;){const c=Math.min(o-this.pos,s-i);if(c===o){const f=mt(t);for(;o<=s-i;i+=o)this.process(f,i);continue}r.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Kt(this),Kn(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:i}=this;n[i++]=128,et(this.buffer.subarray(i)),this.padOffset>o-i&&(this.process(r,0),i=0);for(let d=i;d<o;d++)n[d]=0;r.setBigUint64(o-8,BigInt(this.length*8),s),this.process(r,0);const c=mt(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const a=f/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<a;d++)c.setUint32(4*d,u[d],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||=new this.constructor,t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:i,pos:c}=this;return t.destroyed=i,t.finished=s,t.length=o,t.pos=c,o%n&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const at=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),J=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Gt=BigInt(2**32-1),Qe=BigInt(32);function Zr(e,t=!1){return t?{h:Number(e&Gt),l:Number(e>>Qe&Gt)}:{h:Number(e>>Qe&Gt)|0,l:Number(e&Gt)|0}}function Rn(e,t=!1){const n=e.length;let r=new Uint32Array(n),o=new Uint32Array(n);for(let s=0;s<n;s++){const{h:i,l:c}=Zr(e[s],t);[r[s],o[s]]=[i,c]}return[r,o]}const tn=(e,t,n)=>e>>>n,en=(e,t,n)=>e<<32-n|t>>>n,vt=(e,t,n)=>e>>>n|t<<32-n,Bt=(e,t,n)=>e<<32-n|t>>>n,Xt=(e,t,n)=>e<<64-n|t>>>n-32,zt=(e,t,n)=>e>>>n-32|t<<64-n,qr=(e,t,n)=>e<<n|t>>>32-n,Mr=(e,t,n)=>t<<n|e>>>32-n,Vr=(e,t,n)=>t<<n-32|e>>>64-n,Yr=(e,t,n)=>e<<n-32|t>>>64-n;function ct(e,t,n,r){const o=(t>>>0)+(r>>>0);return{h:e+n+(o/2**32|0)|0,l:o|0}}const Fr=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),jr=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,Gr=(e,t,n,r)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0),Xr=(e,t,n,r,o)=>t+n+r+o+(e/2**32|0)|0,zr=(e,t,n,r,o)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0)+(o>>>0),Pr=(e,t,n,r,o,s)=>t+n+r+o+s+(e/2**32|0)|0,Wr=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ut=new Uint32Array(64);class Jr extends ae{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:n,C:r,D:o,E:s,F:i,G:c,H:f}=this;return[t,n,r,o,s,i,c,f]}set(t,n,r,o,s,i,c,f){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=f|0}process(t,n){for(let d=0;d<16;d++,n+=4)ut[d]=t.getUint32(n,!1);for(let d=16;d<64;d++){const p=ut[d-15],h=ut[d-2],w=st(p,7)^st(p,18)^p>>>3,A=st(h,17)^st(h,19)^h>>>10;ut[d]=A+ut[d-7]+w+ut[d-16]|0}let{A:r,B:o,C:s,D:i,E:c,F:f,G:a,H:u}=this;for(let d=0;d<64;d++){const p=st(c,6)^st(c,11)^st(c,25),h=u+p+Be(c,f,a)+Wr[d]+ut[d]|0,A=(st(r,2)^st(r,13)^st(r,22))+Dr(r,o,s)|0;u=a,a=f,f=c,c=i+h|0,i=s,s=o,o=r,r=h+A|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,f=f+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(r,o,s,i,c,f,a,u)}roundClean(){et(ut)}destroy(){this.set(0,0,0,0,0,0,0,0),et(this.buffer)}}class On extends Jr{A=at[0]|0;B=at[1]|0;C=at[2]|0;D=at[3]|0;E=at[4]|0;F=at[5]|0;G=at[6]|0;H=at[7]|0;constructor(){super(32)}}const kn=Rn(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),Qr=kn[0],to=kn[1],dt=new Uint32Array(80),lt=new Uint32Array(80);class eo extends ae{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:n,Bh:r,Bl:o,Ch:s,Cl:i,Dh:c,Dl:f,Eh:a,El:u,Fh:d,Fl:p,Gh:h,Gl:w,Hh:A,Hl:v}=this;return[t,n,r,o,s,i,c,f,a,u,d,p,h,w,A,v]}set(t,n,r,o,s,i,c,f,a,u,d,p,h,w,A,v){this.Ah=t|0,this.Al=n|0,this.Bh=r|0,this.Bl=o|0,this.Ch=s|0,this.Cl=i|0,this.Dh=c|0,this.Dl=f|0,this.Eh=a|0,this.El=u|0,this.Fh=d|0,this.Fl=p|0,this.Gh=h|0,this.Gl=w|0,this.Hh=A|0,this.Hl=v|0}process(t,n){for(let m=0;m<16;m++,n+=4)dt[m]=t.getUint32(n),lt[m]=t.getUint32(n+=4);for(let m=16;m<80;m++){const k=dt[m-15]|0,T=lt[m-15]|0,$=vt(k,T,1)^vt(k,T,8)^tn(k,T,7),Z=Bt(k,T,1)^Bt(k,T,8)^en(k,T,7),B=dt[m-2]|0,x=lt[m-2]|0,L=vt(B,x,19)^Xt(B,x,61)^tn(B,x,6),N=Bt(B,x,19)^zt(B,x,61)^en(B,x,6),R=Gr(Z,N,lt[m-7],lt[m-16]),b=Xr(R,$,L,dt[m-7],dt[m-16]);dt[m]=b|0,lt[m]=R|0}let{Ah:r,Al:o,Bh:s,Bl:i,Ch:c,Cl:f,Dh:a,Dl:u,Eh:d,El:p,Fh:h,Fl:w,Gh:A,Gl:v,Hh:g,Hl:S}=this;for(let m=0;m<80;m++){const k=vt(d,p,14)^vt(d,p,18)^Xt(d,p,41),T=Bt(d,p,14)^Bt(d,p,18)^zt(d,p,41),$=d&h^~d&A,Z=p&w^~p&v,B=zr(S,T,Z,to[m],lt[m]),x=Pr(B,g,k,$,Qr[m],dt[m]),L=B|0,N=vt(r,o,28)^Xt(r,o,34)^Xt(r,o,39),R=Bt(r,o,28)^zt(r,o,34)^zt(r,o,39),b=r&s^r&c^s&c,y=o&i^o&f^i&f;g=A|0,S=v|0,A=h|0,v=w|0,h=d|0,w=p|0,{h:d,l:p}=ct(a|0,u|0,x|0,L|0),a=c|0,u=f|0,c=s|0,f=i|0,s=r|0,i=o|0;const l=Fr(L,R,y);r=jr(l,x,N,b),o=l|0}({h:r,l:o}=ct(this.Ah|0,this.Al|0,r|0,o|0)),{h:s,l:i}=ct(this.Bh|0,this.Bl|0,s|0,i|0),{h:c,l:f}=ct(this.Ch|0,this.Cl|0,c|0,f|0),{h:a,l:u}=ct(this.Dh|0,this.Dl|0,a|0,u|0),{h:d,l:p}=ct(this.Eh|0,this.El|0,d|0,p|0),{h,l:w}=ct(this.Fh|0,this.Fl|0,h|0,w|0),{h:A,l:v}=ct(this.Gh|0,this.Gl|0,A|0,v|0),{h:g,l:S}=ct(this.Hh|0,this.Hl|0,g|0,S|0),this.set(r,o,s,i,c,f,a,u,d,p,h,w,A,v,g,S)}roundClean(){et(dt,lt)}destroy(){et(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Un extends eo{Ah=J[0]|0;Al=J[1]|0;Bh=J[2]|0;Bl=J[3]|0;Ch=J[4]|0;Cl=J[5]|0;Dh=J[6]|0;Dl=J[7]|0;Eh=J[8]|0;El=J[9]|0;Fh=J[10]|0;Fl=J[11]|0;Gh=J[12]|0;Gl=J[13]|0;Hh=J[14]|0;Hl=J[15]|0;constructor(){super(64)}}const j=Vt(()=>new On,In(1)),Nt=Vt(()=>new Un,In(3)),js=Object.freeze(Object.defineProperty({__proto__:null,_SHA256:On,_SHA512:Un,sha256:j,sha512:Nt},Symbol.toStringTag,{value:"Module"}));const He=BigInt(0),Ae=BigInt(1);function xt(e,t=""){if(typeof e!="boolean"){const n=t&&`"${t}" `;throw new Error(n+"expected boolean, got type="+typeof e)}return e}function Tn(e){if(typeof e=="bigint"){if(!ee(e))throw new Error("positive bigint expected, got "+e)}else nt(e);return e}function Pt(e){const t=Tn(e).toString(16);return t.length&1?"0"+t:t}function Ln(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?He:BigInt("0x"+e)}function ue(e){return Ln(rt(e))}function $t(e){return Ln(rt(Se(C(e)).reverse()))}function Ce(e,t){nt(t),e=Tn(e);const n=Ct(e.toString(16).padStart(t*2,"0"));if(n.length!==t)throw new Error("number too large");return n}function Hn(e,t){return Ce(e,t).reverse()}function Se(e){return Uint8Array.from(e)}const ee=e=>typeof e=="bigint"&&He<=e;function no(e,t,n){return ee(e)&&ee(t)&&ee(n)&&t<=e&&e<n}function Ke(e,t,n,r){if(!no(t,n,r))throw new Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}function ro(e){let t;for(t=0;e>He;e>>=Ae,t+=1);return t}const Ne=e=>(Ae<<BigInt(e))-Ae;function oo(e,t,n){if(nt(e,"hashLen"),nt(t,"qByteLen"),typeof n!="function")throw new Error("hmacFn must be a function");const r=v=>new Uint8Array(v),o=Uint8Array.of(),s=Uint8Array.of(0),i=Uint8Array.of(1),c=1e3;let f=r(e),a=r(e),u=0;const d=()=>{f.fill(1),a.fill(0),u=0},p=(...v)=>n(a,Q(f,...v)),h=(v=o)=>{a=p(s,v),f=p(),v.length!==0&&(a=p(i,v),f=p())},w=()=>{if(u++>=c)throw new Error("drbg: tried max amount of iterations");let v=0;const g=[];for(;v<t;){f=p();const S=f.slice();g.push(S),v+=f.length}return Q(...g)};return(v,g)=>{d(),h(v);let S;for(;!(S=g(w()));)h();return d(),S}}function Yt(e,t={},n={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(s,i,c){const f=e[s];if(c&&f===void 0)return;const a=typeof f;if(a!==i||f===null)throw new Error(`param "${s}" is invalid: expected ${i}, got ${a}`)}const o=(s,i)=>Object.entries(s).forEach(([c,f])=>r(c,f,i));o(t,!1),o(n,!0)}function re(e){const t=new WeakMap;return(n,...r)=>{const o=t.get(n);if(o!==void 0)return o;const s=e(n,...r);return t.set(n,s),s}}const tt=BigInt(0),P=BigInt(1),wt=BigInt(2),Cn=BigInt(3),Nn=BigInt(4),$n=BigInt(5),so=BigInt(7),Dn=BigInt(8),io=BigInt(9),Zn=BigInt(16);function G(e,t){const n=e%t;return n>=tt?n:t+n}function F(e,t,n){let r=e;for(;t-- >tt;)r*=r,r%=n;return r}function nn(e,t){if(e===tt)throw new Error("invert: expected non-zero number");if(t<=tt)throw new Error("invert: expected positive modulus, got "+t);let n=G(e,t),r=t,o=tt,s=P;for(;n!==tt;){const c=r/n,f=r%n,a=o-s*c;r=n,n=f,o=s,s=a}if(r!==P)throw new Error("invert: does not exist");return G(o,t)}function $e(e,t,n){if(!e.eql(e.sqr(t),n))throw new Error("Cannot find square root")}function qn(e,t){const n=(e.ORDER+P)/Nn,r=e.pow(t,n);return $e(e,r,t),r}function co(e,t){const n=(e.ORDER-$n)/Dn,r=e.mul(t,wt),o=e.pow(r,n),s=e.mul(t,o),i=e.mul(e.mul(s,wt),o),c=e.mul(s,e.sub(i,e.ONE));return $e(e,c,t),c}function fo(e){const t=de(e),n=Mn(e),r=n(t,t.neg(t.ONE)),o=n(t,r),s=n(t,t.neg(r)),i=(e+so)/Zn;return(c,f)=>{let a=c.pow(f,i),u=c.mul(a,r);const d=c.mul(a,o),p=c.mul(a,s),h=c.eql(c.sqr(u),f),w=c.eql(c.sqr(d),f);a=c.cmov(a,u,h),u=c.cmov(p,d,w);const A=c.eql(c.sqr(u),f),v=c.cmov(a,u,A);return $e(c,v,f),v}}function Mn(e){if(e<Cn)throw new Error("sqrt is not defined for small field");let t=e-P,n=0;for(;t%wt===tt;)t/=wt,n++;let r=wt;const o=de(e);for(;rn(o,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return qn;let s=o.pow(r,t);const i=(t+P)/wt;return function(f,a){if(f.is0(a))return a;if(rn(f,a)!==1)throw new Error("Cannot find square root");let u=n,d=f.mul(f.ONE,s),p=f.pow(a,t),h=f.pow(a,i);for(;!f.eql(p,f.ONE);){if(f.is0(p))return f.ZERO;let w=1,A=f.sqr(p);for(;!f.eql(A,f.ONE);)if(w++,A=f.sqr(A),w===u)throw new Error("Cannot find square root");const v=P<<BigInt(u-w-1),g=f.pow(d,v);u=w,d=f.sqr(g),p=f.mul(p,d),h=f.mul(h,g)}return h}}function ao(e){return e%Nn===Cn?qn:e%Dn===$n?co:e%Zn===io?fo(e):Mn(e)}const uo=(e,t)=>(G(e,t)&P)===P,lo=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ho(e){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},n=lo.reduce((r,o)=>(r[o]="function",r),t);return Yt(e,n),e}function bo(e,t,n){if(n<tt)throw new Error("invalid exponent, negatives unsupported");if(n===tt)return e.ONE;if(n===P)return t;let r=e.ONE,o=t;for(;n>tt;)n&P&&(r=e.mul(r,o)),o=e.sqr(o),n>>=P;return r}function Vn(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),o=t.reduce((i,c,f)=>e.is0(c)?i:(r[f]=i,e.mul(i,c)),e.ONE),s=e.inv(o);return t.reduceRight((i,c,f)=>e.is0(c)?i:(r[f]=e.mul(i,r[f]),e.mul(i,c)),s),r}function rn(e,t){const n=(e.ORDER-P)/wt,r=e.pow(t,n),o=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),i=e.eql(r,e.neg(e.ONE));if(!o&&!s&&!i)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function yo(e,t){t!==void 0&&nt(t);const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}class po{ORDER;BITS;BYTES;isLE;ZERO=tt;ONE=P;_lengths;_sqrt;_mod;constructor(t,n={}){if(t<=tt)throw new Error("invalid field: expected ORDER > 0, got "+t);let r;this.isLE=!1,n!=null&&typeof n=="object"&&(typeof n.BITS=="number"&&(r=n.BITS),typeof n.sqrt=="function"&&(this.sqrt=n.sqrt),typeof n.isLE=="boolean"&&(this.isLE=n.isLE),n.allowedLengths&&(this._lengths=n.allowedLengths?.slice()),typeof n.modFromBytes=="boolean"&&(this._mod=n.modFromBytes));const{nBitLength:o,nByteLength:s}=yo(t,r);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=o,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return G(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return tt<=t&&t<this.ORDER}is0(t){return t===tt}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&P)===P}neg(t){return G(-t,this.ORDER)}eql(t,n){return t===n}sqr(t){return G(t*t,this.ORDER)}add(t,n){return G(t+n,this.ORDER)}sub(t,n){return G(t-n,this.ORDER)}mul(t,n){return G(t*n,this.ORDER)}pow(t,n){return bo(this,t,n)}div(t,n){return G(t*nn(n,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,n){return t+n}subN(t,n){return t-n}mulN(t,n){return t*n}inv(t){return nn(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=ao(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Hn(t,this.BYTES):Ce(t,this.BYTES)}fromBytes(t,n=!1){C(t);const{_lengths:r,BYTES:o,isLE:s,ORDER:i,_mod:c}=this;if(r){if(!r.includes(t.length)||t.length>o)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+t.length);const a=new Uint8Array(o);a.set(t,s?0:a.length-t.length),t=a}if(t.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+t.length);let f=s?$t(t):ue(t);if(c&&(f=G(f,i)),!n&&!this.isValid(f))throw new Error("invalid field element: outside of range 0..ORDER");return f}invertBatch(t){return Vn(this,t)}cmov(t,n,r){return r?n:t}}function de(e,t={}){return new po(e,t)}function Yn(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Fn(e){const t=Yn(e);return t+Math.ceil(t/2)}function wo(e,t,n=!1){C(e);const r=e.length,o=Yn(t),s=Fn(t);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const i=n?$t(e):ue(e),c=G(i,t-P)+P;return n?Hn(c,o):Ce(c,o)}const _t=BigInt(0),gt=BigInt(1);function oe(e,t){const n=t.negate();return e?n:t}function Ht(e,t){const n=Vn(e.Fp,t.map(r=>r.Z));return t.map((r,o)=>e.fromAffine(r.toAffine(n[o])))}function jn(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function he(e,t){jn(e,t);const n=Math.ceil(t/e)+1,r=2**(e-1),o=2**e,s=Ne(e),i=BigInt(e);return{windows:n,windowSize:r,mask:s,maxNumber:o,shiftBy:i}}function on(e,t,n){const{windowSize:r,mask:o,maxNumber:s,shiftBy:i}=n;let c=Number(e&o),f=e>>i;c>r&&(c-=s,f+=gt);const a=t*r,u=a+Math.abs(c)-1,d=c===0,p=c<0,h=t%2!==0;return{nextN:f,offset:u,isZero:d,isNeg:p,isNegF:h,offsetF:a}}const be=new WeakMap,Gn=new WeakMap;function ye(e){return Gn.get(e)||1}function sn(e){if(e!==_t)throw new Error("invalid wNAF")}class Xn{BASE;ZERO;Fn;bits;constructor(t,n){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=n}_unsafeLadder(t,n,r=this.ZERO){let o=t;for(;n>_t;)n&gt&&(r=r.add(o)),o=o.double(),n>>=gt;return r}precomputeWindow(t,n){const{windows:r,windowSize:o}=he(n,this.bits),s=[];let i=t,c=i;for(let f=0;f<r;f++){c=i,s.push(c);for(let a=1;a<o;a++)c=c.add(i),s.push(c);i=c.double()}return s}wNAF(t,n,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE;const i=he(t,this.bits);for(let c=0;c<i.windows;c++){const{nextN:f,offset:a,isZero:u,isNeg:d,isNegF:p,offsetF:h}=on(r,c,i);r=f,u?s=s.add(oe(p,n[h])):o=o.add(oe(d,n[a]))}return sn(r),{p:o,f:s}}wNAFUnsafe(t,n,r,o=this.ZERO){const s=he(t,this.bits);for(let i=0;i<s.windows&&r!==_t;i++){const{nextN:c,offset:f,isZero:a,isNeg:u}=on(r,i,s);if(r=c,!a){const d=n[f];o=o.add(u?d.negate():d)}}return sn(r),o}getPrecomputes(t,n,r){let o=be.get(n);return o||(o=this.precomputeWindow(n,t),t!==1&&(typeof r=="function"&&(o=r(o)),be.set(n,o))),o}cached(t,n,r){const o=ye(t);return this.wNAF(o,this.getPrecomputes(o,t,r),n)}unsafe(t,n,r,o){const s=ye(t);return s===1?this._unsafeLadder(t,n,o):this.wNAFUnsafe(s,this.getPrecomputes(s,t,r),n,o)}createCache(t,n){jn(n,this.bits),Gn.set(t,n),be.delete(t)}hasCache(t){return ye(t)!==1}}function go(e,t,n,r){let o=t,s=e.ZERO,i=e.ZERO;for(;n>_t||r>_t;)n&gt&&(s=s.add(o)),r&gt&&(i=i.add(o)),o=o.double(),n>>=gt,r>>=gt;return{p1:s,p2:i}}function cn(e,t,n){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return ho(t),t}else return de(e,{isLE:n})}function zn(e,t,n={},r){if(r===void 0&&(r=e==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${e} CURVE object`);for(const f of["p","n","h"]){const a=t[f];if(!(typeof a=="bigint"&&a>_t))throw new Error(`CURVE.${f} must be positive bigint`)}const o=cn(t.p,n.Fp,r),s=cn(t.n,n.Fn,r),c=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const f of c)if(!o.isValid(t[f]))throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:o,Fn:s}}function Pn(e,t){return function(r){const o=e(r);return{secretKey:o,publicKey:t(o)}}}class Wn{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(t,n){if(Te(t),C(n,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,o=new Uint8Array(r);o.set(n.length>r?t.create().update(n).digest():n);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=t.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),et(o)}update(t){return Kt(this),this.iHash.update(t),this}digestInto(t){Kt(this),C(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||=Object.create(Object.getPrototypeOf(this),{});const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=i,t.outputLen=c,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Dt=(e,t,n)=>new Wn(e,t).update(n).digest();Dt.create=(e,t)=>new Wn(e,t);const fn=(e,t)=>(e+(e>=0?t:-t)/Jn)/t;function mo(e,t,n){const[[r,o],[s,i]]=t,c=fn(i*e,n),f=fn(-o*e,n);let a=e-c*r-f*s,u=-c*o-f*i;const d=a<ft,p=u<ft;d&&(a=-a),p&&(u=-u);const h=Ne(Math.ceil(ro(n)/2))+At;if(a<ft||a>=h||u<ft||u>=h)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:d,k1:a,k2neg:p,k2:u}}function _e(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function pe(e,t){const n={};for(let r of Object.keys(t))n[r]=e[r]===void 0?t[r]:e[r];return xt(n.lowS,"lowS"),xt(n.prehash,"prehash"),n.format!==void 0&&_e(n.format),n}class xo extends Error{constructor(t=""){super(t)}}const bt={Err:xo,_tlv:{encode:(e,t)=>{const{Err:n}=bt;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length&1)throw new n("tlv.encode: unpadded data");const r=t.length/2,o=Pt(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const s=r>127?Pt(o.length/2|128):"";return Pt(e)+s+o+t},decode(e,t){const{Err:n}=bt;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const o=t[r++],s=!!(o&128);let i=0;if(!s)i=o;else{const f=o&127;if(!f)throw new n("tlv.decode(long): indefinite length not supported");if(f>4)throw new n("tlv.decode(long): byte length is too big");const a=t.subarray(r,r+f);if(a.length!==f)throw new n("tlv.decode: length bytes not complete");if(a[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const u of a)i=i<<8|u;if(r+=f,i<128)throw new n("tlv.decode(long): not minimal encoding")}const c=t.subarray(r,r+i);if(c.length!==i)throw new n("tlv.decode: wrong value length");return{v:c,l:t.subarray(r+i)}}},_int:{encode(e){const{Err:t}=bt;if(e<ft)throw new t("integer: negative integers are not allowed");let n=Pt(e);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=bt;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return ue(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=bt,o=C(e,void 0,"signature"),{v:s,l:i}=r.decode(48,o);if(i.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:f}=r.decode(2,s),{v:a,l:u}=r.decode(2,f);if(u.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(a)}},hexFromSig(e){const{_tlv:t,_int:n}=bt,r=t.encode(2,n.encode(e.r)),o=t.encode(2,n.encode(e.s)),s=r+o;return t.encode(48,s)}},ft=BigInt(0),At=BigInt(1),Jn=BigInt(2),Wt=BigInt(3),Eo=BigInt(4);function vo(e,t={}){const n=zn("weierstrass",e,t),{Fp:r,Fn:o}=n;let s=n.CURVE;const{h:i,n:c}=s;Yt(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:f}=t;if(f&&(!r.is0(s.a)||typeof f.beta!="bigint"||!Array.isArray(f.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const a=tr(r,o);function u(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(R,b,y){const{x:l,y:E}=b.toAffine(),K=r.toBytes(l);if(xt(y,"isCompressed"),y){u();const I=!r.isOdd(E);return Q(Qn(I),K)}else return Q(Uint8Array.of(4),K,r.toBytes(E))}function p(R){C(R,void 0,"Point");const{publicKey:b,publicKeyUncompressed:y}=a,l=R.length,E=R[0],K=R.subarray(1);if(l===b&&(E===2||E===3)){const I=r.fromBytes(K);if(!r.isValid(I))throw new Error("bad point: is not on curve, wrong x");const O=A(I);let _;try{_=r.sqrt(O)}catch(M){const q=M instanceof Error?": "+M.message:"";throw new Error("bad point: is not on curve, sqrt error"+q)}u();const U=r.isOdd(_);return(E&1)===1!==U&&(_=r.neg(_)),{x:I,y:_}}else if(l===y&&E===4){const I=r.BYTES,O=r.fromBytes(K.subarray(0,I)),_=r.fromBytes(K.subarray(I,I*2));if(!v(O,_))throw new Error("bad point: is not on curve");return{x:O,y:_}}else throw new Error(`bad point: got length ${l}, expected compressed=${b} or uncompressed=${y}`)}const h=t.toBytes||d,w=t.fromBytes||p;function A(R){const b=r.sqr(R),y=r.mul(b,R);return r.add(r.add(y,r.mul(R,s.a)),s.b)}function v(R,b){const y=r.sqr(b),l=A(R);return r.eql(y,l)}if(!v(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const g=r.mul(r.pow(s.a,Wt),Eo),S=r.mul(r.sqr(s.b),BigInt(27));if(r.is0(r.add(g,S)))throw new Error("bad curve params: a or b");function m(R,b,y=!1){if(!r.isValid(b)||y&&r.is0(b))throw new Error(`bad point coordinate ${R}`);return b}function k(R){if(!(R instanceof x))throw new Error("Weierstrass Point expected")}function T(R){if(!f||!f.basises)throw new Error("no endo");return mo(R,f.basises,o.ORDER)}const $=re((R,b)=>{const{X:y,Y:l,Z:E}=R;if(r.eql(E,r.ONE))return{x:y,y:l};const K=R.is0();b==null&&(b=K?r.ONE:r.inv(E));const I=r.mul(y,b),O=r.mul(l,b),_=r.mul(E,b);if(K)return{x:r.ZERO,y:r.ZERO};if(!r.eql(_,r.ONE))throw new Error("invZ was invalid");return{x:I,y:O}}),Z=re(R=>{if(R.is0()){if(t.allowInfinityPoint&&!r.is0(R.Y))return;throw new Error("bad point: ZERO")}const{x:b,y}=R.toAffine();if(!r.isValid(b)||!r.isValid(y))throw new Error("bad point: x or y not field elements");if(!v(b,y))throw new Error("bad point: equation left != right");if(!R.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function B(R,b,y,l,E){return y=new x(r.mul(y.X,R),y.Y,y.Z),b=oe(l,b),y=oe(E,y),b.add(y)}class x{static BASE=new x(s.Gx,s.Gy,r.ONE);static ZERO=new x(r.ZERO,r.ONE,r.ZERO);static Fp=r;static Fn=o;X;Y;Z;constructor(b,y,l){this.X=m("x",b),this.Y=m("y",y,!0),this.Z=m("z",l),Object.freeze(this)}static CURVE(){return s}static fromAffine(b){const{x:y,y:l}=b||{};if(!b||!r.isValid(y)||!r.isValid(l))throw new Error("invalid affine point");if(b instanceof x)throw new Error("projective point not allowed");return r.is0(y)&&r.is0(l)?x.ZERO:new x(y,l,r.ONE)}static fromBytes(b){const y=x.fromAffine(w(C(b,void 0,"point")));return y.assertValidity(),y}static fromHex(b){return x.fromBytes(Ct(b))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(b=8,y=!0){return N.createCache(this,b),y||this.multiply(Wt),this}assertValidity(){Z(this)}hasEvenY(){const{y:b}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(b)}equals(b){k(b);const{X:y,Y:l,Z:E}=this,{X:K,Y:I,Z:O}=b,_=r.eql(r.mul(y,O),r.mul(K,E)),U=r.eql(r.mul(l,O),r.mul(I,E));return _&&U}negate(){return new x(this.X,r.neg(this.Y),this.Z)}double(){const{a:b,b:y}=s,l=r.mul(y,Wt),{X:E,Y:K,Z:I}=this;let O=r.ZERO,_=r.ZERO,U=r.ZERO,H=r.mul(E,E),M=r.mul(K,K),q=r.mul(I,I),D=r.mul(E,K);return D=r.add(D,D),U=r.mul(E,I),U=r.add(U,U),O=r.mul(b,U),_=r.mul(l,q),_=r.add(O,_),O=r.sub(M,_),_=r.add(M,_),_=r.mul(O,_),O=r.mul(D,O),U=r.mul(l,U),q=r.mul(b,q),D=r.sub(H,q),D=r.mul(b,D),D=r.add(D,U),U=r.add(H,H),H=r.add(U,H),H=r.add(H,q),H=r.mul(H,D),_=r.add(_,H),q=r.mul(K,I),q=r.add(q,q),H=r.mul(q,D),O=r.sub(O,H),U=r.mul(q,M),U=r.add(U,U),U=r.add(U,U),new x(O,_,U)}add(b){k(b);const{X:y,Y:l,Z:E}=this,{X:K,Y:I,Z:O}=b;let _=r.ZERO,U=r.ZERO,H=r.ZERO;const M=s.a,q=r.mul(s.b,Wt);let D=r.mul(y,K),V=r.mul(l,I),z=r.mul(E,O),ot=r.add(y,l),Y=r.add(K,I);ot=r.mul(ot,Y),Y=r.add(D,V),ot=r.sub(ot,Y),Y=r.add(y,E);let W=r.add(K,O);return Y=r.mul(Y,W),W=r.add(D,z),Y=r.sub(Y,W),W=r.add(l,E),_=r.add(I,O),W=r.mul(W,_),_=r.add(V,z),W=r.sub(W,_),H=r.mul(M,Y),_=r.mul(q,z),H=r.add(_,H),_=r.sub(V,H),H=r.add(V,H),U=r.mul(_,H),V=r.add(D,D),V=r.add(V,D),z=r.mul(M,z),Y=r.mul(q,Y),V=r.add(V,z),z=r.sub(D,z),z=r.mul(M,z),Y=r.add(Y,z),D=r.mul(V,Y),U=r.add(U,D),D=r.mul(W,Y),_=r.mul(ot,_),_=r.sub(_,D),D=r.mul(ot,V),H=r.mul(W,H),H=r.add(H,D),new x(_,U,H)}subtract(b){return this.add(b.negate())}is0(){return this.equals(x.ZERO)}multiply(b){const{endo:y}=t;if(!o.isValidNot0(b))throw new Error("invalid scalar: out of range");let l,E;const K=I=>N.cached(this,I,O=>Ht(x,O));if(y){const{k1neg:I,k1:O,k2neg:_,k2:U}=T(b),{p:H,f:M}=K(O),{p:q,f:D}=K(U);E=M.add(D),l=B(y.beta,H,q,I,_)}else{const{p:I,f:O}=K(b);l=I,E=O}return Ht(x,[l,E])[0]}multiplyUnsafe(b){const{endo:y}=t,l=this;if(!o.isValid(b))throw new Error("invalid scalar: out of range");if(b===ft||l.is0())return x.ZERO;if(b===At)return l;if(N.hasCache(this))return this.multiply(b);if(y){const{k1neg:E,k1:K,k2neg:I,k2:O}=T(b),{p1:_,p2:U}=go(x,l,K,O);return B(y.beta,_,U,E,I)}else return N.unsafe(l,b)}toAffine(b){return $(this,b)}isTorsionFree(){const{isTorsionFree:b}=t;return i===At?!0:b?b(x,this):N.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:b}=t;return i===At?this:b?b(x,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(b=!0){return xt(b,"isCompressed"),this.assertValidity(),h(x,this,b)}toHex(b=!0){return rt(this.toBytes(b))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const L=o.BITS,N=new Xn(x,t.endo?Math.ceil(L/2):L);return x.BASE.precompute(8),x}function Qn(e){return Uint8Array.of(e?2:3)}function tr(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function Bo(e,t={}){const{Fn:n}=e,r=t.randomBytes||Le,o=Object.assign(tr(e.Fp,n),{seed:Fn(n.ORDER)});function s(h){try{const w=n.fromBytes(h);return n.isValidNot0(w)}catch{return!1}}function i(h,w){const{publicKey:A,publicKeyUncompressed:v}=o;try{const g=h.length;return w===!0&&g!==A||w===!1&&g!==v?!1:!!e.fromBytes(h)}catch{return!1}}function c(h=r(o.seed)){return wo(C(h,o.seed,"seed"),n.ORDER)}function f(h,w=!0){return e.BASE.multiply(n.fromBytes(h)).toBytes(w)}function a(h){const{secretKey:w,publicKey:A,publicKeyUncompressed:v}=o;if(!fe(h)||"_lengths"in n&&n._lengths||w===A)return;const g=C(h,void 0,"key").length;return g===A||g===v}function u(h,w,A=!0){if(a(h)===!0)throw new Error("first arg must be private key");if(a(w)===!1)throw new Error("second arg must be public key");const v=n.fromBytes(h);return e.fromBytes(w).multiply(v).toBytes(A)}const d={isValidSecretKey:s,isValidPublicKey:i,randomSecretKey:c},p=Pn(c,f);return Object.freeze({getPublicKey:f,getSharedSecret:u,keygen:p,Point:e,utils:d,lengths:o})}function Ao(e,t,n={}){Te(t),Yt(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),n=Object.assign({},n);const r=n.randomBytes||Le,o=n.hmac||((y,l)=>Dt(t,y,l)),{Fp:s,Fn:i}=e,{ORDER:c,BITS:f}=i,{keygen:a,getPublicKey:u,getSharedSecret:d,utils:p,lengths:h}=Bo(e,n),w={prehash:!0,lowS:typeof n.lowS=="boolean"?n.lowS:!0,format:"compact",extraEntropy:!1},A=c*Jn<s.ORDER;function v(y){const l=c>>At;return y>l}function g(y,l){if(!i.isValidNot0(l))throw new Error(`invalid signature ${y}: out of range 1..Point.Fn.ORDER`);return l}function S(){if(A)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function m(y,l){_e(l);const E=h.signature,K=l==="compact"?E:l==="recovered"?E+1:void 0;return C(y,K)}class k{r;s;recovery;constructor(l,E,K){if(this.r=g("r",l),this.s=g("s",E),K!=null){if(S(),![0,1,2,3].includes(K))throw new Error("invalid recovery id");this.recovery=K}Object.freeze(this)}static fromBytes(l,E=w.format){m(l,E);let K;if(E==="der"){const{r:U,s:H}=bt.toSig(C(l));return new k(U,H)}E==="recovered"&&(K=l[0],E="compact",l=l.subarray(1));const I=h.signature/2,O=l.subarray(0,I),_=l.subarray(I,I*2);return new k(i.fromBytes(O),i.fromBytes(_),K)}static fromHex(l,E){return this.fromBytes(Ct(l),E)}assertRecovery(){const{recovery:l}=this;if(l==null)throw new Error("invalid recovery id: must be present");return l}addRecoveryBit(l){return new k(this.r,this.s,l)}recoverPublicKey(l){const{r:E,s:K}=this,I=this.assertRecovery(),O=I===2||I===3?E+c:E;if(!s.isValid(O))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const _=s.toBytes(O),U=e.fromBytes(Q(Qn((I&1)===0),_)),H=i.inv(O),M=$(C(l,void 0,"msgHash")),q=i.create(-M*H),D=i.create(K*H),V=e.BASE.multiplyUnsafe(q).add(U.multiplyUnsafe(D));if(V.is0())throw new Error("invalid recovery: point at infinify");return V.assertValidity(),V}hasHighS(){return v(this.s)}toBytes(l=w.format){if(_e(l),l==="der")return Ct(bt.hexFromSig(this));const{r:E,s:K}=this,I=i.toBytes(E),O=i.toBytes(K);return l==="recovered"?(S(),Q(Uint8Array.of(this.assertRecovery()),I,O)):Q(I,O)}toHex(l){return rt(this.toBytes(l))}}const T=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const E=ue(l),K=l.length*8-f;return K>0?E>>BigInt(K):E},$=n.bits2int_modN||function(l){return i.create(T(l))},Z=Ne(f);function B(y){return Ke("num < 2^"+f,y,ft,Z),i.toBytes(y)}function x(y,l){return C(y,void 0,"message"),l?C(t(y),void 0,"prehashed message"):y}function L(y,l,E){const{lowS:K,prehash:I,extraEntropy:O}=pe(E,w);y=x(y,I);const _=$(y),U=i.fromBytes(l);if(!i.isValidNot0(U))throw new Error("invalid private key");const H=[B(U),B(_)];if(O!=null&&O!==!1){const V=O===!0?r(h.secretKey):O;H.push(C(V,void 0,"extraEntropy"))}const M=Q(...H),q=_;function D(V){const z=T(V);if(!i.isValidNot0(z))return;const ot=i.inv(z),Y=e.BASE.multiply(z).toAffine(),W=i.create(Y.x);if(W===ft)return;const jt=i.create(ot*i.create(q+W*U));if(jt===ft)return;let Xe=(Y.x===W?0:2)|Number(Y.y&At),ze=jt;return K&&v(jt)&&(ze=i.neg(jt),Xe^=1),new k(W,ze,A?void 0:Xe)}return{seed:M,k2sig:D}}function N(y,l,E={}){const{seed:K,k2sig:I}=L(y,l,E);return oo(t.outputLen,i.BYTES,o)(K,I).toBytes(E.format)}function R(y,l,E,K={}){const{lowS:I,prehash:O,format:_}=pe(K,w);if(E=C(E,void 0,"publicKey"),l=x(l,O),!fe(y)){const U=y instanceof k?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+U)}m(y,_);try{const U=k.fromBytes(y,_),H=e.fromBytes(E);if(I&&U.hasHighS())return!1;const{r:M,s:q}=U,D=$(l),V=i.inv(q),z=i.create(D*V),ot=i.create(M*V),Y=e.BASE.multiplyUnsafe(z).add(H.multiplyUnsafe(ot));return Y.is0()?!1:i.create(Y.x)===M}catch{return!1}}function b(y,l,E={}){const{prehash:K}=pe(E,w);return l=x(l,K),k.fromBytes(y,"recovered").recoverPublicKey(l).toBytes()}return Object.freeze({keygen:a,getPublicKey:u,getSharedSecret:d,utils:p,lengths:h,Point:e,sign:N,verify:R,recoverPublicKey:b,Signature:k,hash:t})}const De={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},So={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},an=BigInt(2);function Ko(e){const t=De.p,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),c=BigInt(44),f=BigInt(88),a=e*e*e%t,u=a*a*e%t,d=F(u,n,t)*u%t,p=F(d,n,t)*u%t,h=F(p,an,t)*a%t,w=F(h,o,t)*h%t,A=F(w,s,t)*w%t,v=F(A,c,t)*A%t,g=F(v,f,t)*v%t,S=F(g,c,t)*A%t,m=F(S,n,t)*u%t,k=F(m,i,t)*w%t,T=F(k,r,t)*a%t,$=F(T,an,t);if(!Ie.eql(Ie.sqr($),e))throw new Error("Cannot find square root");return $}const Ie=de(De.p,{sqrt:Ko}),_o=vo(De,{Fp:Ie,endo:So}),yt=Ao(_o,j),Io=Uint32Array.from([1732584193,4023233417,2562383102,271733878,3285377520]),Ro=Math.pow(2,32),Oo=Array.from({length:64},(e,t)=>Math.floor(Ro*Math.abs(Math.sin(t+1)))),Jt=Io.slice(0,4),we=new Uint32Array(16);class er extends ae{A=Jt[0]|0;B=Jt[1]|0;C=Jt[2]|0;D=Jt[3]|0;constructor(){super(64,16,8,!0)}get(){const{A:t,B:n,C:r,D:o}=this;return[t,n,r,o]}set(t,n,r,o){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0}process(t,n){for(let c=0;c<16;c++,n+=4)we[c]=t.getUint32(n,!0);let{A:r,B:o,C:s,D:i}=this;for(let c=0;c<64;c++){let f,a,u;c<16?(f=Be(o,s,i),a=c,u=[7,12,17,22]):c<32?(f=Be(i,o,s),a=(5*c+1)%16,u=[5,9,14,20]):c<48?(f=o^s^i,a=(3*c+5)%16,u=[4,11,16,23]):(f=s^(o|~i),a=7*c%16,u=[6,10,15,21]),f=f+r+Oo[c]+we[a],r=i,i=s,s=o,o=o+kt(f,u[c%4])}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,this.set(r,o,s,i)}roundClean(){et(we)}destroy(){this.set(0,0,0,0),et(this.buffer)}}const ko=Vt(()=>new er),Uo=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),nr=Uint8Array.from(new Array(16).fill(0).map((e,t)=>t)),To=nr.map(e=>(9*e+5)%16),rr=(()=>{const n=[[nr],[To]];for(let r=0;r<4;r++)for(let o of n)o.push(o[r].map(s=>Uo[s]));return n})(),or=rr[0],sr=rr[1],ir=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(e=>Uint8Array.from(e)),Lo=or.map((e,t)=>e.map(n=>ir[t][n])),Ho=sr.map((e,t)=>e.map(n=>ir[t][n])),Co=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),No=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function un(e,t,n,r){return e===0?t^n^r:e===1?t&n|~t&r:e===2?(t|~n)^r:e===3?t&r|n&~r:t^(n|~r)}const Qt=new Uint32Array(16);class cr extends ae{h0=1732584193;h1=-271733879;h2=-1732584194;h3=271733878;h4=-1009589776;constructor(){super(64,20,8,!0)}get(){const{h0:t,h1:n,h2:r,h3:o,h4:s}=this;return[t,n,r,o,s]}set(t,n,r,o,s){this.h0=t|0,this.h1=n|0,this.h2=r|0,this.h3=o|0,this.h4=s|0}process(t,n){for(let h=0;h<16;h++,n+=4)Qt[h]=t.getUint32(n,!0);let r=this.h0|0,o=r,s=this.h1|0,i=s,c=this.h2|0,f=c,a=this.h3|0,u=a,d=this.h4|0,p=d;for(let h=0;h<5;h++){const w=4-h,A=Co[h],v=No[h],g=or[h],S=sr[h],m=Lo[h],k=Ho[h];for(let T=0;T<16;T++){const $=kt(r+un(h,s,c,a)+Qt[g[T]]+A,m[T])+d|0;r=d,d=a,a=kt(c,10)|0,c=s,s=$}for(let T=0;T<16;T++){const $=kt(o+un(w,i,f,u)+Qt[S[T]]+v,k[T])+p|0;o=p,p=u,u=kt(f,10)|0,f=i,i=$}}this.set(this.h1+c+u|0,this.h2+a+p|0,this.h3+d+o|0,this.h4+r+i|0,this.h0+s+f|0)}roundClean(){et(Qt)}destroy(){this.destroyed=!0,et(this.buffer),this.set(0,0,0,0,0)}}const Et=Vt(()=>new cr),Gs=Object.freeze(Object.defineProperty({__proto__:null,_MD5:er,_RIPEMD160:cr,md5:ko,ripemd160:Et},Symbol.toStringTag,{value:"Module"}));function Zt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function fr(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(n=>typeof n=="string"):t.every(n=>Number.isSafeInteger(n)):!1}function ar(e){if(typeof e!="function")throw new Error("function expected");return!0}function qt(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function Ft(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function se(e){if(!Array.isArray(e))throw new Error("array expected")}function ur(e,t){if(!fr(!0,t))throw new Error(`${e}: array of strings expected`)}function Ze(e,t){if(!fr(!1,t))throw new Error(`${e}: array of numbers expected`)}function qe(...e){const t=s=>s,n=(s,i)=>c=>s(i(c)),r=e.map(s=>s.encode).reduceRight(n,t),o=e.map(s=>s.decode).reduce(n,t);return{encode:r,decode:o}}function dr(e){const t=typeof e=="string"?e.split(""):e,n=t.length;ur("alphabet",t);const r=new Map(t.map((o,s)=>[o,s]));return{encode:o=>(se(o),o.map(s=>{if(!Number.isSafeInteger(s)||s<0||s>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${e}`);return t[s]})),decode:o=>(se(o),o.map(s=>{qt("alphabet.decode",s);const i=r.get(s);if(i===void 0)throw new Error(`Unknown letter: "${s}". Allowed: ${e}`);return i}))}}function lr(e=""){return qt("join",e),{encode:t=>(ur("join.decode",t),t.join(e)),decode:t=>(qt("join.decode",t),t.split(e))}}function dn(e,t,n){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(se(e),!e.length)return[];let r=0;const o=[],s=Array.from(e,c=>{if(Ft(c),c<0||c>=t)throw new Error(`invalid integer: ${c}`);return c}),i=s.length;for(;;){let c=0,f=!0;for(let a=r;a<i;a++){const u=s[a],d=t*c,p=d+u;if(!Number.isSafeInteger(p)||d/t!==c||p-u!==d)throw new Error("convertRadix: carry overflow");const h=p/n;c=p%n;const w=Math.floor(h);if(s[a]=w,!Number.isSafeInteger(w)||w*n+c!==p)throw new Error("convertRadix: carry overflow");if(f)w?f=!1:r=a;else continue}if(o.push(c),f)break}for(let c=0;c<e.length-1&&e[c]===0;c++)o.push(0);return o.reverse()}const hr=(e,t)=>t===0?e:hr(t,e%t),ie=(e,t)=>e+(t-hr(e,t)),ne=(()=>{let e=[];for(let t=0;t<40;t++)e.push(2**t);return e})();function Re(e,t,n,r){if(se(e),t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(ie(t,n)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${ie(t,n)}`);let o=0,s=0;const i=ne[t],c=ne[n]-1,f=[];for(const a of e){if(Ft(a),a>=i)throw new Error(`convertRadix2: invalid data word=${a} from=${t}`);if(o=o<<t|a,s+t>32)throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);for(s+=t;s>=n;s-=n)f.push((o>>s-n&c)>>>0);const u=ne[s];if(u===void 0)throw new Error("invalid carry");o&=u-1}if(o=o<<n-s&c,!r&&s>=t)throw new Error("Excess padding");if(!r&&o>0)throw new Error(`Non-zero padding: ${o}`);return r&&s>0&&f.push(o>>>0),f}function $o(e){Ft(e);const t=2**8;return{encode:n=>{if(!Zt(n))throw new Error("radix.encode input should be Uint8Array");return dn(Array.from(n),t,e)},decode:n=>(Ze("radix.decode",n),Uint8Array.from(dn(n,e,t)))}}function Do(e,t=!1){if(Ft(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(ie(8,e)>32||ie(e,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!Zt(n))throw new Error("radix2.encode input should be Uint8Array");return Re(Array.from(n),8,e,!t)},decode:n=>(Ze("radix2.decode",n),Uint8Array.from(Re(n,e,8,t)))}}function ln(e){return ar(e),function(...t){try{return e.apply(null,t)}catch{}}}function Zo(e,t){return Ft(e),ar(t),{encode(n){if(!Zt(n))throw new Error("checksum.encode: input should be Uint8Array");const r=t(n).slice(0,e),o=new Uint8Array(n.length+e);return o.set(n),o.set(r,n.length),o},decode(n){if(!Zt(n))throw new Error("checksum.decode: input should be Uint8Array");const r=n.slice(0,-e),o=n.slice(-e),s=t(r).slice(0,e);for(let i=0;i<e;i++)if(s[i]!==o[i])throw new Error("Invalid checksum");return r}}}const qo=e=>qe($o(58),dr(e),lr("")),Mo=qo("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),br=e=>qe(Zo(4,t=>e(e(t))),Mo),Xs=br,Oe=qe(dr("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),lr("")),hn=[996825010,642813549,513874426,1027748829,705979059];function It(e){const t=e>>25;let n=(e&33554431)<<5;for(let r=0;r<hn.length;r++)(t>>r&1)===1&&(n^=hn[r]);return n}function bn(e,t,n=1){const r=e.length;let o=1;for(let s=0;s<r;s++){const i=e.charCodeAt(s);if(i<33||i>126)throw new Error(`Invalid prefix (${e})`);o=It(o)^i>>5}o=It(o);for(let s=0;s<r;s++)o=It(o)^e.charCodeAt(s)&31;for(let s of t)o=It(o)^s;for(let s=0;s<6;s++)o=It(o);return o^=n,Oe.encode(Re([o%ne[30]],30,5,!1))}function yr(e){const t=e==="bech32"?1:734539939,n=Do(5),r=n.decode,o=n.encode,s=ln(r);function i(d,p,h=90){qt("bech32.encode prefix",d),Zt(p)&&(p=Array.from(p)),Ze("bech32.encode",p);const w=d.length;if(w===0)throw new TypeError(`Invalid prefix length ${w}`);const A=w+7+p.length;if(h!==!1&&A>h)throw new TypeError(`Length ${A} exceeds limit ${h}`);const v=d.toLowerCase(),g=bn(v,p,t);return`${v}1${Oe.encode(p)}${g}`}function c(d,p=90){qt("bech32.decode input",d);const h=d.length;if(h<8||p!==!1&&h>p)throw new TypeError(`invalid string length: ${h} (${d}). Expected (8..${p})`);const w=d.toLowerCase();if(d!==w&&d!==d.toUpperCase())throw new Error("String must be lowercase or uppercase");const A=w.lastIndexOf("1");if(A===0||A===-1)throw new Error('Letter "1" must be present between prefix and data only');const v=w.slice(0,A),g=w.slice(A+1);if(g.length<6)throw new Error("Data must be at least 6 characters long");const S=Oe.decode(g).slice(0,-6),m=bn(v,S,t);if(!g.endsWith(m))throw new Error(`Invalid checksum in ${d}: expected "${m}"`);return{prefix:v,words:S}}const f=ln(c);function a(d){const{prefix:p,words:h}=c(d,!1);return{prefix:p,words:h,bytes:r(h)}}function u(d,p){return i(d,o(p))}return{encode:i,decode:c,encodeFromBytes:u,decodeToBytes:a,decodeUnsafe:f,fromWords:r,fromWordsUnsafe:s,toWords:o}}const zs=yr("bech32"),Ps=yr("bech32m");const Ut=yt.Point,{Fn:Rt}=Ut,ge=br(j),Vo=Uint8Array.from("Bitcoin seed".split(""),e=>e.charCodeAt(0)),me={private:76066276,public:76067358},xe=2147483648,Yo=e=>Et(j(e)),Fo=e=>mt(e).getUint32(0,!1),te=e=>{if(!Number.isSafeInteger(e)||e<0||e>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+e);const t=new Uint8Array(4);return mt(t).setUint32(0,e,!1),t};class pt{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Fo(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const t=this._privateKey;if(!t)throw new Error("No private key");return ge.encode(this.serialize(this.versions.private,Q(Uint8Array.of(0),t)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return ge.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(t,n=me){if(C(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const r=Dt(Nt,Vo,t),o=r.slice(0,32),s=r.slice(32);return new pt({versions:n,chainCode:s,privateKey:o})}static fromExtendedKey(t,n=me){const r=ge.decode(t),o=mt(r),s=o.getUint32(0,!1),i={versions:n,depth:r[4],parentFingerprint:o.getUint32(5,!1),index:o.getUint32(9,!1),chainCode:r.slice(13,45)},c=r.slice(45),f=c[0]===0;if(s!==n[f?"private":"public"])throw new Error("Version mismatch");return f?new pt({...i,privateKey:c.slice(1)}):new pt({...i,publicKey:c})}static fromJSON(t){return pt.fromExtendedKey(t.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(t){if(!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||me,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!yt.utils.isValidSecretKey(t.privateKey))throw new Error("Invalid private key");this._privateKey=t.privateKey,this._publicKey=yt.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this._publicKey=Ut.fromBytes(t.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=Yo(this._publicKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const n=t.replace(/^[mM]'?\//,"").split("/");let r=this;for(const o of n){const s=/^(\d+)('?)$/.exec(o),i=s&&s[1];if(!s||s.length!==3||typeof i!="string")throw new Error("invalid child index: "+o);let c=+i;if(!Number.isSafeInteger(c)||c>=xe)throw new Error("Invalid index");s[2]==="'"&&(c+=xe),r=r.deriveChild(c)}return r}deriveChild(t){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let n=te(t);if(t>=xe){const f=this._privateKey;if(!f)throw new Error("Could not derive hardened child key");n=Q(Uint8Array.of(0),f,n)}else n=Q(this._publicKey,n);const r=Dt(Nt,this.chainCode,n),o=r.slice(0,32),s=r.slice(32);if(!yt.utils.isValidSecretKey(o))throw new Error("Tweak bigger than curve order");const i={versions:this.versions,chainCode:s,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t},c=Rt.fromBytes(o);try{if(this._privateKey){const f=Rt.create(Rt.fromBytes(this._privateKey)+c);if(!Rt.isValidNot0(f))throw new Error("The tweak was out of range or the resulted private key is invalid");i.privateKey=Rt.toBytes(f)}else{const f=Ut.fromBytes(this._publicKey).add(Ut.BASE.multiply(c));if(f.equals(Ut.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");i.publicKey=f.toBytes(!0)}return new pt(i)}catch{return this.deriveChild(t+1)}}sign(t){if(!this._privateKey)throw new Error("No privateKey set!");return C(t,32),yt.sign(t,this._privateKey,{prehash:!1})}verify(t,n){if(C(t,32),C(n,64),!this._publicKey)throw new Error("No publicKey set!");return yt.verify(n,t,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,n){if(!this.chainCode)throw new Error("No chainCode set");return C(n,33),Q(te(t),new Uint8Array([this.depth]),te(this.parentFingerprint),te(this.index),this.chainCode,n)}}function jo(e,t,n,r){Te(e);const o=$r({dkLen:32,asyncTick:10},r),{c:s,dkLen:i,asyncTick:c}=o;if(nt(s,"c"),nt(i,"dkLen"),nt(c,"asyncTick"),s<1)throw new Error("iterations (c) must be >= 1");const f=Je(t,"password"),a=Je(n,"salt"),u=new Uint8Array(i),d=Dt.create(e,f),p=d._cloneInto().update(a);return{c:s,dkLen:i,asyncTick:c,DK:u,PRF:d,PRFSalt:p}}function Go(e,t,n,r,o){return e.destroy(),t.destroy(),r&&r.destroy(),et(o),n}function Xo(e,t,n,r){const{c:o,dkLen:s,DK:i,PRF:c,PRFSalt:f}=jo(e,t,n,r);let a;const u=new Uint8Array(4),d=mt(u),p=new Uint8Array(c.outputLen);for(let h=1,w=0;w<s;h++,w+=c.outputLen){const A=i.subarray(w,w+c.outputLen);d.setInt32(0,h,!1),(a=f._cloneInto(a)).update(u).digestInto(p),A.set(p.subarray(0,A.length));for(let v=1;v<o;v++){c._cloneInto(a).update(p).digestInto(p);for(let g=0;g<A.length;g++)A[g]^=p[g]}}return Go(c,f,i,a,p)}function pr(e){if(typeof e!="string")throw new TypeError("invalid mnemonic type: "+typeof e);return e.normalize("NFKD")}function zo(e){const t=pr(e),n=t.split(" ");if(![12,15,18,21,24].includes(n.length))throw new Error("Invalid mnemonic");return{nfkd:t,words:n}}const Po=e=>pr("mnemonic"+e);function Wo(e,t=""){return Xo(Nt,zo(e).nfkd,Po(t),{c:2048,dkLen:64})}const Jo=BigInt(0),Ot=BigInt(1),Qo=BigInt(2),ts=BigInt(7),es=BigInt(256),ns=BigInt(113),wr=[],gr=[],mr=[];for(let e=0,t=Ot,n=1,r=0;e<24;e++){[n,r]=[r,(2*n+3*r)%5],wr.push(2*(5*r+n)),gr.push((e+1)*(e+2)/2%64);let o=Jo;for(let s=0;s<7;s++)t=(t<<Ot^(t>>ts)*ns)%es,t&Qo&&(o^=Ot<<(Ot<<BigInt(s))-Ot);mr.push(o)}const xr=Rn(mr,!0),rs=xr[0],os=xr[1],yn=(e,t,n)=>n>32?Vr(e,t,n):qr(e,t,n),pn=(e,t,n)=>n>32?Yr(e,t,n):Mr(e,t,n);function ss(e,t=24){const n=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let i=0;i<10;i++)n[i]=e[i]^e[i+10]^e[i+20]^e[i+30]^e[i+40];for(let i=0;i<10;i+=2){const c=(i+8)%10,f=(i+2)%10,a=n[f],u=n[f+1],d=yn(a,u,1)^n[c],p=pn(a,u,1)^n[c+1];for(let h=0;h<50;h+=10)e[i+h]^=d,e[i+h+1]^=p}let o=e[2],s=e[3];for(let i=0;i<24;i++){const c=gr[i],f=yn(o,s,c),a=pn(o,s,c),u=wr[i];o=e[u],s=e[u+1],e[u]=f,e[u+1]=a}for(let i=0;i<50;i+=10){for(let c=0;c<10;c++)n[c]=e[i+c];for(let c=0;c<10;c++)e[i+c]^=~n[(c+2)%10]&n[(c+4)%10]}e[0]^=rs[r],e[1]^=os[r]}et(n)}class Me{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(t,n,r,o=!1,s=24){if(this.blockLen=t,this.suffix=n,this.outputLen=r,this.enableXOF=o,this.rounds=s,nt(r,"outputLen"),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=Ur(this.state)}clone(){return this._cloneInto()}keccak(){Pe(this.state32),ss(this.state32,this.rounds),Pe(this.state32),this.posOut=0,this.pos=0}update(t){Kt(this),C(t);const{blockLen:n,state:r}=this,o=t.length;for(let s=0;s<o;){const i=Math.min(n-this.pos,o-s);for(let c=0;c<i;c++)r[this.pos++]^=t[s++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:r,blockLen:o}=this;t[r]^=n,(n&128)!==0&&r===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){Kt(this,!1),C(t),this.finish();const n=this.state,{blockLen:r}=this;for(let o=0,s=t.length;o<s;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,s-o);t.set(n.subarray(this.posOut,this.posOut+i),o),this.posOut+=i,o+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return nt(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Kn(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,et(this.state)}_cloneInto(t){const{blockLen:n,suffix:r,outputLen:o,rounds:s,enableXOF:i}=this;return t||=new Me(n,r,o,i,s),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=r,t.outputLen=o,t.enableXOF=i,t.destroyed=this.destroyed,t}}const is=(e,t,n,r={})=>Vt(()=>new Me(t,e,n),r),Ve=is(1,136,32),Mt=St.t.bind(St),Er={ethereum:60,bitcoin:0,tron:195,bfmeta:9999};function Ye(e,t){const n=Wo(e,t);return pt.fromMasterSeed(n)}function cs(e,t=0,n=0,r=0){return`m/44'/${Er[e]}'/${t}'/${n}/${r}`}function fs(e,t,n=0,r=0,o=0){return`m/${e}'/${t}'/${n}'/${r}/${o}`}function Fe(e,t){return e.derive(t)}function wn(e){const n=yt.getPublicKey(e,!1).slice(1),o=Ve(n).slice(-20);return"0x"+rt(o)}function gn(e){const t=e.toLowerCase().replace("0x",""),n=new TextEncoder,r=rt(Ve(n.encode(t)));let o="0x";for(let s=0;s<t.length;s++)parseInt(r[s],16)>=8?o+=t[s].toUpperCase():o+=t[s];return o}function vr(e,t="mainnet"){const n=j(e),r=Et(n),o=t==="mainnet"?0:111,s=new Uint8Array([o,...r]),i=j(j(s)).slice(0,4),c=new Uint8Array([...s,...i]);return je(c)}function as(e,t="mainnet"){const n=j(e),r=Et(n),o=new Uint8Array([0,20,...r]),s=j(o),i=Et(s),c=t==="mainnet"?5:196,f=new Uint8Array([c,...i]),a=j(j(f)).slice(0,4),u=new Uint8Array([...f,...a]);return je(u)}function us(e,t="mainnet"){const n=j(e),r=Et(n);return ps(t==="mainnet"?"bc":"tb",0,r)}function ds(e,t="mainnet"){const n=e.length===33?e.slice(1):e.slice(1,33);return ws(t==="mainnet"?"bc":"tb",1,n)}function ls(e){const n=yt.getPublicKey(e,!1).slice(1),o=Ve(n).slice(-20),s=new Uint8Array([65,...o]),i=j(j(s)).slice(0,4),c=new Uint8Array([...s,...i]);return je(c)}const mn="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";function je(e){const t=[0];for(const r of e){let o=r;for(let s=0;s<t.length;s++)o+=t[s]<<8,t[s]=o%58,o=o/58|0;for(;o>0;)t.push(o%58),o=o/58|0}let n="";for(const r of e)if(r===0)n+=mn[0];else break;for(let r=t.length-1;r>=0;r--)n+=mn[t[r]];return n}const Br="qpzry9x8gf2tvdw0s3jn54khce6mua7l",hs=[996825010,642813549,513874426,1027748829,705979059];function bs(e){let t=1;for(const n of e){const r=t>>25;t=(t&33554431)<<5^n;for(let o=0;o<5;o++)r>>o&1&&(t^=hs[o])}return t}function ys(e){const t=[];for(const n of e)t.push(n.charCodeAt(0)>>5);t.push(0);for(const n of e)t.push(n.charCodeAt(0)&31);return t}function Ar(e,t,n){const r=[...ys(e),...t],o=n?734539939:1,s=bs([...r,0,0,0,0,0,0])^o,i=[];for(let c=0;c<6;c++)i.push(s>>5*(5-c)&31);return i}function Sr(e,t,n,r){let o=0,s=0;const i=[],c=(1<<n)-1;for(const f of e)for(o=o<<t|f,s+=t;s>=n;)s-=n,i.push(o>>s&c);return s>0&&i.push(o<<n-s&c),i}function ps(e,t,n){const r=Sr(n,8,5),o=[t,...r],s=Ar(e,o,!1),i=[...o,...s].map(c=>Br[c]).join("");return`${e}1${i}`}function ws(e,t,n){const r=Sr(n,8,5),o=[t,...r],s=Ar(e,o,!0),i=[...o,...s].map(c=>Br[c]).join("");return`${e}1${i}`}function Ee(e,t,n=0,r=0){const o=Ye(e),s=cs(t,r,0,n),i=Fe(o,s);if(!i.privateKey||!i.publicKey)throw new Error(Mt("error:crypto.keyDerivationFailed"));const c=rt(i.privateKey),f=rt(i.publicKey);let a;switch(t){case"ethereum":a=gn(wn(i.privateKey));break;case"bitcoin":a=vr(i.publicKey);break;case"tron":a=ls(i.privateKey);break;case"bfmeta":a=gn(wn(i.privateKey));break;default:throw new Error(Mt("error:chain.unsupportedType",{chain:t}))}return{privateKey:c,publicKey:f,address:a,path:s,chain:t}}function gs(e,t=44,n=0,r=0,o="mainnet"){const s=Ye(e),i=fs(t,Er.bitcoin,r,0,n),c=Fe(s,i);if(!c.privateKey||!c.publicKey)throw new Error(Mt("error:crypto.keyDerivationFailed"));const f=rt(c.privateKey),a=rt(c.publicKey);let u;switch(t){case 44:u=vr(c.publicKey,o);break;case 49:u=as(c.publicKey,o);break;case 84:u=us(c.publicKey,o);break;case 86:u=ds(c.publicKey,o);break;default:throw new Error(Mt("error:crypto.unsupportedBitcoinPurpose",{purpose:String(t)}))}return{privateKey:f,publicKey:a,address:u,path:i,chain:"bitcoin",purpose:t}}function ms(e,t=0,n=0,r="mainnet"){return[44,49,84,86].map(s=>gs(e,s,t,n,r))}function Ws(e,t=0,n=0){const r=[];return r.push(Ee(e,"ethereum",t,n)),r.push(Ee(e,"bfmeta",t,n)),r.push(Ee(e,"tron",t,n)),r.push(...ms(e,t,n)),r}function Js(e){const t=Ye(e),r=Fe(t,"m/44'/9999'/0'/1/0");if(!r.privateKey)throw new Error(Mt("error:crypto.keyDerivationFailed"));return r.privateKey}function Qs(e){const n=new TextEncoder().encode(`KeyApp:EncryptionKey:${e}`);return j(n)}function ti(e,t){switch(t){case"ethereum":case"bfmeta":return/^0x[a-fA-F0-9]{40}$/.test(e);case"bitcoin":return/^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(e)||/^bc1q[a-z0-9]{38,}$/.test(e)||/^bc1p[a-z0-9]{58}$/.test(e);case"tron":return/^T[a-zA-Z0-9]{33}$/.test(e);default:return!1}}const ht=BigInt(0),X=BigInt(1),ve=BigInt(2),xs=BigInt(8);function Es(e,t,n,r){const o=e.sqr(n),s=e.sqr(r),i=e.add(e.mul(t.a,o),s),c=e.add(e.ONE,e.mul(t.d,e.mul(o,s)));return e.eql(i,c)}function vs(e,t={}){const n=zn("edwards",e,t,t.FpFnLE),{Fp:r,Fn:o}=n;let s=n.CURVE;const{h:i}=s;Yt(t,{},{uvRatio:"function"});const c=ve<<BigInt(o.BYTES*8)-X,f=v=>r.create(v),a=t.uvRatio||((v,g)=>{try{return{isValid:!0,value:r.sqrt(r.div(v,g))}}catch{return{isValid:!1,value:ht}}});if(!Es(r,s,s.Gx,s.Gy))throw new Error("bad curve params: generator point");function u(v,g,S=!1){const m=S?X:ht;return Ke("coordinate "+v,g,m,c),g}function d(v){if(!(v instanceof w))throw new Error("EdwardsPoint expected")}const p=re((v,g)=>{const{X:S,Y:m,Z:k}=v,T=v.is0();g==null&&(g=T?xs:r.inv(k));const $=f(S*g),Z=f(m*g),B=r.mul(k,g);if(T)return{x:ht,y:X};if(B!==X)throw new Error("invZ was invalid");return{x:$,y:Z}}),h=re(v=>{const{a:g,d:S}=s;if(v.is0())throw new Error("bad point: ZERO");const{X:m,Y:k,Z:T,T:$}=v,Z=f(m*m),B=f(k*k),x=f(T*T),L=f(x*x),N=f(Z*g),R=f(x*f(N+B)),b=f(L+f(S*f(Z*B)));if(R!==b)throw new Error("bad point: equation left != right (1)");const y=f(m*k),l=f(T*$);if(y!==l)throw new Error("bad point: equation left != right (2)");return!0});class w{static BASE=new w(s.Gx,s.Gy,X,f(s.Gx*s.Gy));static ZERO=new w(ht,X,X,ht);static Fp=r;static Fn=o;X;Y;Z;T;constructor(g,S,m,k){this.X=u("x",g),this.Y=u("y",S),this.Z=u("z",m,!0),this.T=u("t",k),Object.freeze(this)}static CURVE(){return s}static fromAffine(g){if(g instanceof w)throw new Error("extended point not allowed");const{x:S,y:m}=g||{};return u("x",S),u("y",m),new w(S,m,X,f(S*m))}static fromBytes(g,S=!1){const m=r.BYTES,{a:k,d:T}=s;g=Se(C(g,m,"point")),xt(S,"zip215");const $=Se(g),Z=g[m-1];$[m-1]=Z&-129;const B=$t($),x=S?c:r.ORDER;Ke("point.y",B,ht,x);const L=f(B*B),N=f(L-X),R=f(T*L-k);let{isValid:b,value:y}=a(N,R);if(!b)throw new Error("bad point: invalid y coordinate");const l=(y&X)===X,E=(Z&128)!==0;if(!S&&y===ht&&E)throw new Error("bad point: x=0 and x_0=1");return E!==l&&(y=f(-y)),w.fromAffine({x:y,y:B})}static fromHex(g,S=!1){return w.fromBytes(Ct(g),S)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(g=8,S=!0){return A.createCache(this,g),S||this.multiply(ve),this}assertValidity(){h(this)}equals(g){d(g);const{X:S,Y:m,Z:k}=this,{X:T,Y:$,Z}=g,B=f(S*Z),x=f(T*k),L=f(m*Z),N=f($*k);return B===x&&L===N}is0(){return this.equals(w.ZERO)}negate(){return new w(f(-this.X),this.Y,this.Z,f(-this.T))}double(){const{a:g}=s,{X:S,Y:m,Z:k}=this,T=f(S*S),$=f(m*m),Z=f(ve*f(k*k)),B=f(g*T),x=S+m,L=f(f(x*x)-T-$),N=B+$,R=N-Z,b=B-$,y=f(L*R),l=f(N*b),E=f(L*b),K=f(R*N);return new w(y,l,K,E)}add(g){d(g);const{a:S,d:m}=s,{X:k,Y:T,Z:$,T:Z}=this,{X:B,Y:x,Z:L,T:N}=g,R=f(k*B),b=f(T*x),y=f(Z*m*N),l=f($*L),E=f((k+T)*(B+x)-R-b),K=l-y,I=l+y,O=f(b-S*R),_=f(E*K),U=f(I*O),H=f(E*O),M=f(K*I);return new w(_,U,M,H)}subtract(g){return this.add(g.negate())}multiply(g){if(!o.isValidNot0(g))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:S,f:m}=A.cached(this,g,k=>Ht(w,k));return Ht(w,[S,m])[0]}multiplyUnsafe(g,S=w.ZERO){if(!o.isValid(g))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return g===ht?w.ZERO:this.is0()||g===X?this:A.unsafe(this,g,m=>Ht(w,m),S)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return A.unsafe(this,s.n).is0()}toAffine(g){return p(this,g)}clearCofactor(){return i===X?this:this.multiplyUnsafe(i)}toBytes(){const{x:g,y:S}=this.toAffine(),m=r.toBytes(S);return m[m.length-1]|=g&X?128:0,m}toHex(){return rt(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const A=new Xn(w,o.BITS);return w.BASE.precompute(8),w}function Bs(e,t,n={}){if(typeof t!="function")throw new Error('"hash" function param is required');Yt(n,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=n,{BASE:o,Fp:s,Fn:i}=e,c=n.randomBytes||Le,f=n.adjustScalarBytes||(B=>B),a=n.domain||((B,x,L)=>{if(xt(L,"phflag"),x.length||L)throw new Error("Contexts/pre-hash are not supported");return B});function u(B){return i.create($t(B))}function d(B){const x=m.secretKey;C(B,m.secretKey,"secretKey");const L=C(t(B),2*x,"hashedSecretKey"),N=f(L.slice(0,x)),R=L.slice(x,2*x),b=u(N);return{head:N,prefix:R,scalar:b}}function p(B){const{head:x,prefix:L,scalar:N}=d(B),R=o.multiply(N),b=R.toBytes();return{head:x,prefix:L,scalar:N,point:R,pointBytes:b}}function h(B){return p(B).pointBytes}function w(B=Uint8Array.of(),...x){const L=Q(...x);return u(t(a(L,C(B,void 0,"context"),!!r)))}function A(B,x,L={}){B=C(B,void 0,"message"),r&&(B=r(B));const{prefix:N,scalar:R,pointBytes:b}=p(x),y=w(L.context,N,B),l=o.multiply(y).toBytes(),E=w(L.context,l,b,B),K=i.create(y+E*R);if(!i.isValid(K))throw new Error("sign failed: invalid s");const I=Q(l,i.toBytes(K));return C(I,m.signature,"result")}const v={zip215:!0};function g(B,x,L,N=v){const{context:R,zip215:b}=N,y=m.signature;B=C(B,y,"signature"),x=C(x,void 0,"message"),L=C(L,m.publicKey,"publicKey"),b!==void 0&&xt(b,"zip215"),r&&(x=r(x));const l=y/2,E=B.subarray(0,l),K=$t(B.subarray(l,y));let I,O,_;try{I=e.fromBytes(L,b),O=e.fromBytes(E,b),_=o.multiplyUnsafe(K)}catch{return!1}if(!b&&I.isSmallOrder())return!1;const U=w(R,O.toBytes(),I.toBytes(),x);return O.add(I.multiplyUnsafe(U)).subtract(_).clearCofactor().is0()}const S=s.BYTES,m={secretKey:S,publicKey:S,signature:2*S,seed:S};function k(B=c(m.seed)){return C(B,m.seed,"seed")}function T(B){return fe(B)&&B.length===i.BYTES}function $(B,x){try{return!!e.fromBytes(B,x)}catch{return!1}}const Z={getExtendedPublicKey:p,randomSecretKey:k,isValidSecretKey:T,isValidPublicKey:$,toMontgomery(B){const{y:x}=e.fromBytes(B),L=m.publicKey,N=L===32;if(!N&&L!==57)throw new Error("only defined for 25519 and 448");const R=N?s.div(X+x,X-x):s.div(x-X,x+X);return s.toBytes(R)},toMontgomerySecret(B){const x=m.secretKey;C(B,x);const L=t(B.subarray(0,x));return f(L).subarray(0,x)}};return Object.freeze({keygen:Pn(k,h),getPublicKey:h,sign:A,verify:g,utils:Z,Point:e,lengths:m})}const As=BigInt(1),xn=BigInt(2),Ss=BigInt(5),Ks=BigInt(8),Ge=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),_s={p:Ge,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Ks,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function Is(e){const t=BigInt(10),n=BigInt(20),r=BigInt(40),o=BigInt(80),s=Ge,c=e*e%s*e%s,f=F(c,xn,s)*c%s,a=F(f,As,s)*e%s,u=F(a,Ss,s)*a%s,d=F(u,t,s)*u%s,p=F(d,n,s)*d%s,h=F(p,r,s)*p%s,w=F(h,o,s)*h%s,A=F(w,o,s)*h%s,v=F(A,t,s)*u%s;return{pow_p_5_8:F(v,xn,s)*e%s,b2:c}}function Rs(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const En=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Os(e,t){const n=Ge,r=G(t*t*t,n),o=G(r*r*t,n),s=Is(e*o).pow_p_5_8;let i=G(e*r*s,n);const c=G(t*i*i,n),f=i,a=G(i*En,n),u=c===e,d=c===G(-e,n),p=c===G(-e*En,n);return u&&(i=f),(d||p)&&(i=a),uo(i,n)&&(i=G(-i,n)),{isValid:u||d,value:i}}const ks=vs(_s,{uvRatio:Os});function Us(e){return Bs(ks,Nt,Object.assign({adjustScalarBytes:Rs},e))}const Kr=Us({});function ke(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}function ei(e){const t=new Uint8Array(e.length/2);for(let n=0;n<t.length;n++)t[n]=parseInt(e.substr(n*2,2),16);return t}const le={bfmeta:{prefix:"b",decimals:8,symbol:"BFM",name:"BFMeta"},ccchain:{prefix:"b",decimals:8,symbol:"CCC",name:"CCChain"},pmchain:{prefix:"b",decimals:8,symbol:"PMC",name:"PMChain"},bfchainv2:{prefix:"b",decimals:8,symbol:"BFT",name:"BFChain V2"},btgmeta:{prefix:"b",decimals:8,symbol:"BTGM",name:"BTGMeta"},biwmeta:{prefix:"b",decimals:8,symbol:"BIW",name:"BIWMeta"},ethmeta:{prefix:"b",decimals:8,symbol:"ETHM",name:"ETHMeta"},malibu:{prefix:"b",decimals:8,symbol:"MLB",name:"Malibu"}};function Ts(e){return e.chainKind==="bioforest"}function Ls(e,t){const n=Ir(e),r=ke(n.publicKey);return t.filter(Ts).map(o=>({chainId:o.id,address:Rr(n.publicKey,o.prefix??"b"),publicKey:r}))}function ni(e,t){return t==null?Ds(e,Zs()).map(n=>({chainId:n.chain,address:n.address})):Ls(e,t).map(({chainId:n,address:r})=>({chainId:n,address:r}))}const ce="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";function Hs(e){const t=[0];for(const r of e){let o=r;for(let s=0;s<t.length;s++)o+=t[s]<<8,t[s]=o%58,o=Math.floor(o/58);for(;o>0;)t.push(o%58),o=Math.floor(o/58)}let n="";for(const r of e)if(r===0)n+=ce[0];else break;for(let r=t.length-1;r>=0;r--)n+=ce[t[r]];return n}function _r(e){const t=[0];for(const n of e){const r=ce.indexOf(n);if(r===-1)throw new Error(`Invalid Base58 character: ${n}`);let o=r;for(let s=0;s<t.length;s++)o+=t[s]*58,t[s]=o&255,o>>=8;for(;o>0;)t.push(o&255),o>>=8}for(const n of e)if(n===ce[0])t.push(0);else break;return new Uint8Array(t.toReversed())}function Cs(e){const t=j(j(e)).slice(0,4),n=new Uint8Array(e.length+t.length);return n.set(e,0),n.set(t,e.length),Hs(n)}function Ns(e){let t;try{t=_r(e)}catch{return}if(t.length<5)return;const n=t.slice(0,-4),r=t.slice(-4),o=j(j(n)).slice(0,4);for(let s=0;s<4;s++)if(r[s]!==o[s])return;return n}function Ir(e){const n=new TextEncoder().encode(e),r=j(n),o=r,s=Kr.getPublicKey(o),i=new Uint8Array(64);return i.set(r,0),i.set(s,32),{secretKey:i,publicKey:s}}function Rr(e,t="b"){const n=Et(j(e));return t+Cs(n)}function ri(e,t){if(typeof e!="string"||e.length<2)return!1;const n=e[0];if(t){const s=le[t];if(n!==s.prefix)return!1}const r=e.slice(1),o=Ns(r);if(o)return o.length===20;if(n!=="c")return!1;try{return _r(r).length===20}catch{return!1}}function oi(e,t){const n=typeof e=="string"?new TextEncoder().encode(e):e,r=j(n),o=t.slice(0,32);return Kr.sign(r,o)}function $s(e,t){const n=le[t];if(!n)throw new Error(`Unsupported BioForest chain: ${t}`);const r=Ir(e),o=Rr(r.publicKey,n.prefix);return{privateKey:ke(r.secretKey),publicKey:ke(r.publicKey),address:o,chain:t}}function Ds(e,t=["bfmeta","pmchain","ccchain"]){return t.map(n=>$s(e,n))}function si(e){return e in le}function Zs(){return Object.keys(le)}export{Vs as A,Wo as B,Ws as C,js as D,Gs as E,ri as a,Js as b,Qs as c,ni as d,Ms as e,Ys as f,kr as g,Fs as h,si as i,Ee as j,Ct as k,Ir as l,ei as m,ke as n,ti as o,Rr as p,Ve as q,yt as r,oi as s,gn as t,rt as u,j as v,gs as w,Xs as x,zs as y,Ps as z};
