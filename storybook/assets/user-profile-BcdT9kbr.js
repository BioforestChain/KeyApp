const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./index-D15qHKTV.js","./index-BgynVEcu.js","./schemas-B18CumQY.js","./iframe-DP2WwkEK.js","./preload-helper-PPVm8Dsz.js","./iframe-DNonhquR.css","./index-C9Fec6lp.js","./amount-BQsqQYGO.js","./index-D0E7N0oa.js","./bioforest-B8KXXzKH.js","./avatar-codec-sXKPhKHq.js"])))=>i.map(i=>d[i]);
import{_ as Hn}from"./preload-helper-PPVm8Dsz.js";import"./index-D0E7N0oa.js";import{b as mt,c as F,e as $e,f as Re,v as on,r as an,g as cn,h as dn,j as zn,k as Vn,l as nt,m as q,n as re,o as ln,p as Yn,q as jn,s as Te,t as Fe,u as Zn,w as qn,x as Gn,y as _t,z as Ot,A as Xn,B as Wt,C as Jn,F as Qn,D as z,E as V,G as He,H as ve,I as rt,J as er,K as ge,L as Dt,M as tr,N as nr,O as Nt,P as rr,Q as sr,R as or,S as ir,T as ar,U as cr}from"./bioforest-B8KXXzKH.js";import{o as de,n as j,e as ue,s as L,a as dr,b as lr}from"./schemas-B18CumQY.js";import{S as bt,u as gt}from"./iframe-DP2WwkEK.js";import{d as Rt,a as ur,e as Ft,g as fr}from"./avatar-codec-sXKPhKHq.js";const un=1e5,hr=16,fn=12,Et=256;async function hn(t,e){const n=new TextEncoder().encode(t),s=await crypto.subtle.importKey("raw",n,"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:un,hash:"SHA-256"},s,{name:"AES-GCM",length:Et},!1,["encrypt","decrypt"])}async function Le(t,e){const n=new TextEncoder().encode(t),s=crypto.getRandomValues(new Uint8Array(hr)),o=crypto.getRandomValues(new Uint8Array(fn)),i=await hn(e,s),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},i,n);return{ciphertext:Ee(a),salt:Ee(s),iv:Ee(o),iterations:un}}async function st(t,e){const r=Ae(t.salt),n=Ae(t.iv),s=Ae(t.ciphertext),o=await hn(e,r);try{const i=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},o,s);return new TextDecoder().decode(i)}catch{throw new Error("解密失败：密码错误或数据损坏")}}async function Ws(t,e){try{return await st(t,e),!0}catch{return!1}}async function Ye(t,e){const n=new TextEncoder().encode(t),s=crypto.getRandomValues(new Uint8Array(fn)),o=await crypto.subtle.importKey("raw",e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength),{name:"AES-GCM",length:Et},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},o,n);return{ciphertext:Ee(i),salt:"",iv:Ee(s),iterations:0}}async function Pt(t,e){const r=Ae(t.iv),n=Ae(t.ciphertext),s=await crypto.subtle.importKey("raw",e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength),{name:"AES-GCM",length:Et},!1,["decrypt"]);try{const o=await crypto.subtle.decrypt({name:"AES-GCM",iv:r},s,n);return new TextDecoder().decode(o)}catch{throw new Error("解密失败：密钥错误或数据损坏")}}function Ee(t){const e=t instanceof Uint8Array?t:new Uint8Array(t);let r="";for(let n=0;n<e.byteLength;n++)r+=String.fromCharCode(e[n]);return btoa(r)}function Ae(t){const e=atob(t),r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r}class yn{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(e,r){if(mt(e),F(r,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?e.create().update(r).digest():r);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=e.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),$e(s)}update(e){return Re(this),this.iHash.update(e),this}digestInto(e){Re(this),F(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||=Object.create(Object.getPrototypeOf(this),{});const{oHash:r,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=r._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ie=(t,e,r)=>new yn(t,e).update(r).digest();Ie.create=(t,e)=>new yn(t,e);const Ut=(t,e)=>(t+(t>=0?e:-e)/pn)/e;function yr(t,e,r){const[[n,s],[o,i]]=e,a=Ut(i*t,r),c=Ut(-s*t,r);let d=t-a*n-c*o,y=-a*s-c*i;const w=d<Q,v=y<Q;w&&(d=-d),v&&(y=-y);const h=dn(Math.ceil(Jn(r)/2))+fe;if(d<Q||d>=h||y<Q||y>=h)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:w,k1:d,k2neg:v,k2:y}}function ot(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function je(t,e){const r={};for(let n of Object.keys(e))r[n]=t[n]===void 0?e[n]:t[n];return Fe(r.lowS,"lowS"),Fe(r.prehash,"prehash"),r.format!==void 0&&ot(r.format),r}class pr extends Error{constructor(e=""){super(e)}}const te={Err:pr,_tlv:{encode:(t,e)=>{const{Err:r}=te;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length&1)throw new r("tlv.encode: unpadded data");const n=e.length/2,s=Te(n);if(s.length/2&128)throw new r("tlv.encode: long form length too big");const o=n>127?Te(s.length/2|128):"";return Te(t)+o+s+e},decode(t,e){const{Err:r}=te;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const s=e[n++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new r("tlv.decode(long): indefinite length not supported");if(c>4)throw new r("tlv.decode(long): byte length is too big");const d=e.subarray(n,n+c);if(d.length!==c)throw new r("tlv.decode: length bytes not complete");if(d[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const y of d)i=i<<8|y;if(n+=c,i<128)throw new r("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+i);if(a.length!==i)throw new r("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+i)}}},_int:{encode(t){const{Err:e}=te;if(t<Q)throw new e("integer: negative integers are not allowed");let r=Te(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=te;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return cn(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=te,s=F(t,void 0,"signature"),{v:o,l:i}=n.decode(48,s);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:d,l:y}=n.decode(2,c);if(y.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(d)}},hexFromSig(t){const{_tlv:e,_int:r}=te,n=e.encode(2,r.encode(t.r)),s=e.encode(2,r.encode(t.s)),o=n+s;return e.encode(48,o)}},Q=BigInt(0),fe=BigInt(1),pn=BigInt(2),Ke=BigInt(3),wr=BigInt(4);function mr(t,e={}){const r=qn("weierstrass",t,e),{Fp:n,Fn:s}=r;let o=r.CURVE;const{h:i,n:a}=o;on(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!n.is0(o.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const d=mn(n,s);function y(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function w(C,f,u){const{x:l,y:p}=f.toAffine(),b=n.toBytes(l);if(Fe(u,"isCompressed"),u){y();const A=!n.isOdd(p);return q(wn(A),b)}else return q(Uint8Array.of(4),b,n.toBytes(p))}function v(C){F(C,void 0,"Point");const{publicKey:f,publicKeyUncompressed:u}=d,l=C.length,p=C[0],b=C.subarray(1);if(l===f&&(p===2||p===3)){const A=n.fromBytes(b);if(!n.isValid(A))throw new Error("bad point: is not on curve, wrong x");const E=k(A);let m;try{m=n.sqrt(E)}catch(P){const O=P instanceof Error?": "+P.message:"";throw new Error("bad point: is not on curve, sqrt error"+O)}y();const I=n.isOdd(m);return(p&1)===1!==I&&(m=n.neg(m)),{x:A,y:m}}else if(l===u&&p===4){const A=n.BYTES,E=n.fromBytes(b.subarray(0,A)),m=n.fromBytes(b.subarray(A,A*2));if(!x(E,m))throw new Error("bad point: is not on curve");return{x:E,y:m}}else throw new Error(`bad point: got length ${l}, expected compressed=${f} or uncompressed=${u}`)}const h=e.toBytes||w,g=e.fromBytes||v;function k(C){const f=n.sqr(C),u=n.mul(f,C);return n.add(n.add(u,n.mul(C,o.a)),o.b)}function x(C,f){const u=n.sqr(f),l=k(C);return n.eql(u,l)}if(!x(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const K=n.mul(n.pow(o.a,Ke),wr),G=n.mul(n.sqr(o.b),BigInt(27));if(n.is0(n.add(K,G)))throw new Error("bad curve params: a or b");function Y(C,f,u=!1){if(!n.isValid(f)||u&&n.is0(f))throw new Error(`bad point coordinate ${C}`);return f}function H(C){if(!(C instanceof T))throw new Error("Weierstrass Point expected")}function se(C){if(!c||!c.basises)throw new Error("no endo");return yr(C,c.basises,s.ORDER)}const ee=_t((C,f)=>{const{X:u,Y:l,Z:p}=C;if(n.eql(p,n.ONE))return{x:u,y:l};const b=C.is0();f==null&&(f=b?n.ONE:n.inv(p));const A=n.mul(u,f),E=n.mul(l,f),m=n.mul(p,f);if(b)return{x:n.ZERO,y:n.ZERO};if(!n.eql(m,n.ONE))throw new Error("invZ was invalid");return{x:A,y:E}}),Ve=_t(C=>{if(C.is0()){if(e.allowInfinityPoint&&!n.is0(C.Y))return;throw new Error("bad point: ZERO")}const{x:f,y:u}=C.toAffine();if(!n.isValid(f)||!n.isValid(u))throw new Error("bad point: x or y not field elements");if(!x(f,u))throw new Error("bad point: equation left != right");if(!C.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function he(C,f,u,l,p){return u=new T(n.mul(u.X,C),u.Y,u.Z),f=Wt(l,f),u=Wt(p,u),f.add(u)}class T{static BASE=new T(o.Gx,o.Gy,n.ONE);static ZERO=new T(n.ZERO,n.ONE,n.ZERO);static Fp=n;static Fn=s;X;Y;Z;constructor(f,u,l){this.X=Y("x",f),this.Y=Y("y",u,!0),this.Z=Y("z",l),Object.freeze(this)}static CURVE(){return o}static fromAffine(f){const{x:u,y:l}=f||{};if(!f||!n.isValid(u)||!n.isValid(l))throw new Error("invalid affine point");if(f instanceof T)throw new Error("projective point not allowed");return n.is0(u)&&n.is0(l)?T.ZERO:new T(u,l,n.ONE)}static fromBytes(f){const u=T.fromAffine(g(F(f,void 0,"point")));return u.assertValidity(),u}static fromHex(f){return T.fromBytes(nt(f))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(f=8,u=!0){return oe.createCache(this,f),u||this.multiply(Ke),this}assertValidity(){Ve(this)}hasEvenY(){const{y:f}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(f)}equals(f){H(f);const{X:u,Y:l,Z:p}=this,{X:b,Y:A,Z:E}=f,m=n.eql(n.mul(u,E),n.mul(b,p)),I=n.eql(n.mul(l,E),n.mul(A,p));return m&&I}negate(){return new T(this.X,n.neg(this.Y),this.Z)}double(){const{a:f,b:u}=o,l=n.mul(u,Ke),{X:p,Y:b,Z:A}=this;let E=n.ZERO,m=n.ZERO,I=n.ZERO,S=n.mul(p,p),P=n.mul(b,b),O=n.mul(A,A),B=n.mul(p,b);return B=n.add(B,B),I=n.mul(p,A),I=n.add(I,I),E=n.mul(f,I),m=n.mul(l,O),m=n.add(E,m),E=n.sub(P,m),m=n.add(P,m),m=n.mul(E,m),E=n.mul(B,E),I=n.mul(l,I),O=n.mul(f,O),B=n.sub(S,O),B=n.mul(f,B),B=n.add(B,I),I=n.add(S,S),S=n.add(I,S),S=n.add(S,O),S=n.mul(S,B),m=n.add(m,S),O=n.mul(b,A),O=n.add(O,O),S=n.mul(O,B),E=n.sub(E,S),I=n.mul(O,P),I=n.add(I,I),I=n.add(I,I),new T(E,m,I)}add(f){H(f);const{X:u,Y:l,Z:p}=this,{X:b,Y:A,Z:E}=f;let m=n.ZERO,I=n.ZERO,S=n.ZERO;const P=o.a,O=n.mul(o.b,Ke);let B=n.mul(u,b),N=n.mul(l,A),M=n.mul(p,E),Z=n.add(u,l),R=n.add(b,A);Z=n.mul(Z,R),R=n.add(B,N),Z=n.sub(Z,R),R=n.add(u,p);let $=n.add(b,E);return R=n.mul(R,$),$=n.add(B,M),R=n.sub(R,$),$=n.add(l,p),m=n.add(A,E),$=n.mul($,m),m=n.add(N,M),$=n.sub($,m),S=n.mul(P,R),m=n.mul(O,M),S=n.add(m,S),m=n.sub(N,S),S=n.add(N,S),I=n.mul(m,S),N=n.add(B,B),N=n.add(N,B),M=n.mul(P,M),R=n.mul(O,R),N=n.add(N,M),M=n.sub(B,M),M=n.mul(P,M),R=n.add(R,M),B=n.mul(N,R),I=n.add(I,B),B=n.mul($,R),m=n.mul(Z,m),m=n.sub(m,B),B=n.mul(Z,N),S=n.mul($,S),S=n.add(S,B),new T(m,I,S)}subtract(f){return this.add(f.negate())}is0(){return this.equals(T.ZERO)}multiply(f){const{endo:u}=e;if(!s.isValidNot0(f))throw new Error("invalid scalar: out of range");let l,p;const b=A=>oe.cached(this,A,E=>Ot(T,E));if(u){const{k1neg:A,k1:E,k2neg:m,k2:I}=se(f),{p:S,f:P}=b(E),{p:O,f:B}=b(I);p=P.add(B),l=he(u.beta,S,O,A,m)}else{const{p:A,f:E}=b(f);l=A,p=E}return Ot(T,[l,p])[0]}multiplyUnsafe(f){const{endo:u}=e,l=this;if(!s.isValid(f))throw new Error("invalid scalar: out of range");if(f===Q||l.is0())return T.ZERO;if(f===fe)return l;if(oe.hasCache(this))return this.multiply(f);if(u){const{k1neg:p,k1:b,k2neg:A,k2:E}=se(f),{p1:m,p2:I}=Xn(T,l,b,E);return he(u.beta,m,I,p,A)}else return oe.unsafe(l,f)}toAffine(f){return ee(this,f)}isTorsionFree(){const{isTorsionFree:f}=e;return i===fe?!0:f?f(T,this):oe.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:f}=e;return i===fe?this:f?f(T,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(f=!0){return Fe(f,"isCompressed"),this.assertValidity(),h(T,this,f)}toHex(f=!0){return re(this.toBytes(f))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const ke=s.BITS,oe=new Gn(T,e.endo?Math.ceil(ke/2):ke);return T.BASE.precompute(8),T}function wn(t){return Uint8Array.of(t?2:3)}function mn(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function br(t,e={}){const{Fn:r}=t,n=e.randomBytes||an,s=Object.assign(mn(t.Fp,r),{seed:zn(r.ORDER)});function o(h){try{const g=r.fromBytes(h);return r.isValidNot0(g)}catch{return!1}}function i(h,g){const{publicKey:k,publicKeyUncompressed:x}=s;try{const K=h.length;return g===!0&&K!==k||g===!1&&K!==x?!1:!!t.fromBytes(h)}catch{return!1}}function a(h=n(s.seed)){return jn(F(h,s.seed,"seed"),r.ORDER)}function c(h,g=!0){return t.BASE.multiply(r.fromBytes(h)).toBytes(g)}function d(h){const{secretKey:g,publicKey:k,publicKeyUncompressed:x}=s;if(!ln(h)||"_lengths"in r&&r._lengths||g===k)return;const K=F(h,void 0,"key").length;return K===k||K===x}function y(h,g,k=!0){if(d(h)===!0)throw new Error("first arg must be private key");if(d(g)===!1)throw new Error("second arg must be public key");const x=r.fromBytes(h);return t.fromBytes(g).multiply(x).toBytes(k)}const w={isValidSecretKey:o,isValidPublicKey:i,randomSecretKey:a},v=Vn(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:y,keygen:v,Point:t,utils:w,lengths:s})}function gr(t,e,r={}){mt(e),on(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),r=Object.assign({},r);const n=r.randomBytes||an,s=r.hmac||((u,l)=>Ie(e,u,l)),{Fp:o,Fn:i}=t,{ORDER:a,BITS:c}=i,{keygen:d,getPublicKey:y,getSharedSecret:w,utils:v,lengths:h}=br(t,r),g={prehash:!0,lowS:typeof r.lowS=="boolean"?r.lowS:!0,format:"compact",extraEntropy:!1},k=a*pn<o.ORDER;function x(u){const l=a>>fe;return u>l}function K(u,l){if(!i.isValidNot0(l))throw new Error(`invalid signature ${u}: out of range 1..Point.Fn.ORDER`);return l}function G(){if(k)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function Y(u,l){ot(l);const p=h.signature,b=l==="compact"?p:l==="recovered"?p+1:void 0;return F(u,b)}class H{r;s;recovery;constructor(l,p,b){if(this.r=K("r",l),this.s=K("s",p),b!=null){if(G(),![0,1,2,3].includes(b))throw new Error("invalid recovery id");this.recovery=b}Object.freeze(this)}static fromBytes(l,p=g.format){Y(l,p);let b;if(p==="der"){const{r:I,s:S}=te.toSig(F(l));return new H(I,S)}p==="recovered"&&(b=l[0],p="compact",l=l.subarray(1));const A=h.signature/2,E=l.subarray(0,A),m=l.subarray(A,A*2);return new H(i.fromBytes(E),i.fromBytes(m),b)}static fromHex(l,p){return this.fromBytes(nt(l),p)}assertRecovery(){const{recovery:l}=this;if(l==null)throw new Error("invalid recovery id: must be present");return l}addRecoveryBit(l){return new H(this.r,this.s,l)}recoverPublicKey(l){const{r:p,s:b}=this,A=this.assertRecovery(),E=A===2||A===3?p+a:p;if(!o.isValid(E))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const m=o.toBytes(E),I=t.fromBytes(q(wn((A&1)===0),m)),S=i.inv(E),P=ee(F(l,void 0,"msgHash")),O=i.create(-P*S),B=i.create(b*S),N=t.BASE.multiplyUnsafe(O).add(I.multiplyUnsafe(B));if(N.is0())throw new Error("invalid recovery: point at infinify");return N.assertValidity(),N}hasHighS(){return x(this.s)}toBytes(l=g.format){if(ot(l),l==="der")return nt(te.hexFromSig(this));const{r:p,s:b}=this,A=i.toBytes(p),E=i.toBytes(b);return l==="recovered"?(G(),q(Uint8Array.of(this.assertRecovery()),A,E)):q(A,E)}toHex(l){return re(this.toBytes(l))}}const se=r.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const p=cn(l),b=l.length*8-c;return b>0?p>>BigInt(b):p},ee=r.bits2int_modN||function(l){return i.create(se(l))},Ve=dn(c);function he(u){return Zn("num < 2^"+c,u,Q,Ve),i.toBytes(u)}function T(u,l){return F(u,void 0,"message"),l?F(e(u),void 0,"prehashed message"):u}function ke(u,l,p){const{lowS:b,prehash:A,extraEntropy:E}=je(p,g);u=T(u,A);const m=ee(u),I=i.fromBytes(l);if(!i.isValidNot0(I))throw new Error("invalid private key");const S=[he(I),he(m)];if(E!=null&&E!==!1){const N=E===!0?n(h.secretKey):E;S.push(F(N,void 0,"extraEntropy"))}const P=q(...S),O=m;function B(N){const M=se(N);if(!i.isValidNot0(M))return;const Z=i.inv(M),R=t.BASE.multiply(M).toAffine(),$=i.create(R.x);if($===Q)return;const Ce=i.create(Z*i.create(O+$*I));if(Ce===Q)return;let Lt=(R.x===$?0:2)|Number(R.y&fe),Kt=Ce;return b&&x(Ce)&&(Kt=i.neg(Ce),Lt^=1),new H($,Kt,k?void 0:Lt)}return{seed:P,k2sig:B}}function oe(u,l,p={}){const{seed:b,k2sig:A}=ke(u,l,p);return Yn(e.outputLen,i.BYTES,s)(b,A).toBytes(p.format)}function C(u,l,p,b={}){const{lowS:A,prehash:E,format:m}=je(b,g);if(p=F(p,void 0,"publicKey"),l=T(l,E),!ln(u)){const I=u instanceof H?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+I)}Y(u,m);try{const I=H.fromBytes(u,m),S=t.fromBytes(p);if(A&&I.hasHighS())return!1;const{r:P,s:O}=I,B=ee(l),N=i.inv(O),M=i.create(B*N),Z=i.create(P*N),R=t.BASE.multiplyUnsafe(M).add(S.multiplyUnsafe(Z));return R.is0()?!1:i.create(R.x)===P}catch{return!1}}function f(u,l,p={}){const{prehash:b}=je(p,g);return l=T(l,b),H.fromBytes(u,"recovered").recoverPublicKey(l).toBytes()}return Object.freeze({keygen:d,getPublicKey:y,getSharedSecret:w,utils:v,lengths:h,Point:t,sign:oe,verify:C,recoverPublicKey:f,Signature:H,hash:e})}const At={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Er={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Mt=BigInt(2);function Ar(t){const e=At.p,r=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),d=t*t*t%e,y=d*d*t%e,w=V(y,r,e)*y%e,v=V(w,r,e)*y%e,h=V(v,Mt,e)*d%e,g=V(h,s,e)*h%e,k=V(g,o,e)*g%e,x=V(k,a,e)*k%e,K=V(x,c,e)*x%e,G=V(K,a,e)*k%e,Y=V(G,r,e)*y%e,H=V(Y,i,e)*g%e,se=V(H,n,e)*d%e,ee=V(se,Mt,e);if(!it.eql(it.sqr(ee),t))throw new Error("Cannot find square root");return ee}const it=Qn(At.p,{sqrt:Ar}),vr=mr(At,{Fp:it,endo:Er}),ne=gr(vr,z);function Se(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function bn(t,e){return Array.isArray(e)?e.length===0?!0:t?e.every(r=>typeof r=="string"):e.every(r=>Number.isSafeInteger(r)):!1}function gn(t){if(typeof t!="function")throw new Error("function expected");return!0}function xe(t,e){if(typeof e!="string")throw new Error(`${t}: string expected`);return!0}function Be(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function Pe(t){if(!Array.isArray(t))throw new Error("array expected")}function En(t,e){if(!bn(!0,e))throw new Error(`${t}: array of strings expected`)}function vt(t,e){if(!bn(!1,e))throw new Error(`${t}: array of numbers expected`)}function It(...t){const e=o=>o,r=(o,i)=>a=>o(i(a)),n=t.map(o=>o.encode).reduceRight(r,e),s=t.map(o=>o.decode).reduce(r,e);return{encode:n,decode:s}}function An(t){const e=typeof t=="string"?t.split(""):t,r=e.length;En("alphabet",e);const n=new Map(e.map((s,o)=>[s,o]));return{encode:s=>(Pe(s),s.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=r)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${t}`);return e[o]})),decode:s=>(Pe(s),s.map(o=>{xe("alphabet.decode",o);const i=n.get(o);if(i===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${t}`);return i}))}}function vn(t=""){return xe("join",t),{encode:e=>(En("join.decode",e),e.join(t)),decode:e=>(xe("join.decode",e),e.split(t))}}function $t(t,e,r){if(e<2)throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);if(Pe(t),!t.length)return[];let n=0;const s=[],o=Array.from(t,a=>{if(Be(a),a<0||a>=e)throw new Error(`invalid integer: ${a}`);return a}),i=o.length;for(;;){let a=0,c=!0;for(let d=n;d<i;d++){const y=o[d],w=e*a,v=w+y;if(!Number.isSafeInteger(v)||w/e!==a||v-y!==w)throw new Error("convertRadix: carry overflow");const h=v/r;a=v%r;const g=Math.floor(h);if(o[d]=g,!Number.isSafeInteger(g)||g*r+a!==v)throw new Error("convertRadix: carry overflow");if(c)g?c=!1:n=d;else continue}if(s.push(a),c)break}for(let a=0;a<t.length-1&&t[a]===0;a++)s.push(0);return s.reverse()}const In=(t,e)=>e===0?t:In(e,t%e),Ue=(t,e)=>t+(e-In(t,e)),Ne=(()=>{let t=[];for(let e=0;e<40;e++)t.push(2**e);return t})();function at(t,e,r,n){if(Pe(t),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(Ue(e,r)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${Ue(e,r)}`);let s=0,o=0;const i=Ne[e],a=Ne[r]-1,c=[];for(const d of t){if(Be(d),d>=i)throw new Error(`convertRadix2: invalid data word=${d} from=${e}`);if(s=s<<e|d,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=r;o-=r)c.push((s>>o-r&a)>>>0);const y=Ne[o];if(y===void 0)throw new Error("invalid carry");s&=y-1}if(s=s<<r-o&a,!n&&o>=e)throw new Error("Excess padding");if(!n&&s>0)throw new Error(`Non-zero padding: ${s}`);return n&&o>0&&c.push(s>>>0),c}function Ir(t){Be(t);const e=2**8;return{encode:r=>{if(!Se(r))throw new Error("radix.encode input should be Uint8Array");return $t(Array.from(r),e,t)},decode:r=>(vt("radix.decode",r),Uint8Array.from($t(r,t,e)))}}function Sr(t,e=!1){if(Be(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(Ue(8,t)>32||Ue(t,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!Se(r))throw new Error("radix2.encode input should be Uint8Array");return at(Array.from(r),8,t,!e)},decode:r=>(vt("radix2.decode",r),Uint8Array.from(at(r,t,8,e)))}}function Ht(t){return gn(t),function(...e){try{return t.apply(null,e)}catch{}}}function xr(t,e){return Be(t),gn(e),{encode(r){if(!Se(r))throw new Error("checksum.encode: input should be Uint8Array");const n=e(r).slice(0,t),s=new Uint8Array(r.length+t);return s.set(r),s.set(n,r.length),s},decode(r){if(!Se(r))throw new Error("checksum.decode: input should be Uint8Array");const n=r.slice(0,-t),s=r.slice(-t),o=e(n).slice(0,t);for(let i=0;i<t;i++)if(o[i]!==s[i])throw new Error("Invalid checksum");return n}}}const Br=t=>It(Ir(58),An(t),vn("")),kr=Br("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),Sn=t=>It(xr(4,e=>t(t(e))),kr),Ds=Sn,ct=It(An("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),vn("")),zt=[996825010,642813549,513874426,1027748829,705979059];function ye(t){const e=t>>25;let r=(t&33554431)<<5;for(let n=0;n<zt.length;n++)(e>>n&1)===1&&(r^=zt[n]);return r}function Vt(t,e,r=1){const n=t.length;let s=1;for(let o=0;o<n;o++){const i=t.charCodeAt(o);if(i<33||i>126)throw new Error(`Invalid prefix (${t})`);s=ye(s)^i>>5}s=ye(s);for(let o=0;o<n;o++)s=ye(s)^t.charCodeAt(o)&31;for(let o of e)s=ye(s)^o;for(let o=0;o<6;o++)s=ye(s);return s^=r,ct.encode(at([s%Ne[30]],30,5,!1))}function xn(t){const e=t==="bech32"?1:734539939,r=Sr(5),n=r.decode,s=r.encode,o=Ht(n);function i(w,v,h=90){xe("bech32.encode prefix",w),Se(v)&&(v=Array.from(v)),vt("bech32.encode",v);const g=w.length;if(g===0)throw new TypeError(`Invalid prefix length ${g}`);const k=g+7+v.length;if(h!==!1&&k>h)throw new TypeError(`Length ${k} exceeds limit ${h}`);const x=w.toLowerCase(),K=Vt(x,v,e);return`${x}1${ct.encode(v)}${K}`}function a(w,v=90){xe("bech32.decode input",w);const h=w.length;if(h<8||v!==!1&&h>v)throw new TypeError(`invalid string length: ${h} (${w}). Expected (8..${v})`);const g=w.toLowerCase();if(w!==g&&w!==w.toUpperCase())throw new Error("String must be lowercase or uppercase");const k=g.lastIndexOf("1");if(k===0||k===-1)throw new Error('Letter "1" must be present between prefix and data only');const x=g.slice(0,k),K=g.slice(k+1);if(K.length<6)throw new Error("Data must be at least 6 characters long");const G=ct.decode(K).slice(0,-6),Y=Vt(x,G,e);if(!K.endsWith(Y))throw new Error(`Invalid checksum in ${w}: expected "${Y}"`);return{prefix:x,words:G}}const c=Ht(a);function d(w){const{prefix:v,words:h}=a(w,!1);return{prefix:v,words:h,bytes:n(h)}}function y(w,v){return i(w,s(v))}return{encode:i,decode:a,encodeFromBytes:y,decodeToBytes:d,decodeUnsafe:c,fromWords:n,fromWordsUnsafe:o,toWords:s}}const Ns=xn("bech32"),Rs=xn("bech32m");const be=ne.Point,{Fn:pe}=be,Ze=Sn(z),Cr=Uint8Array.from("Bitcoin seed".split(""),t=>t.charCodeAt(0)),qe={private:76066276,public:76067358},Ge=2147483648,Tr=t=>ve(z(t)),Lr=t=>He(t).getUint32(0,!1),_e=t=>{if(!Number.isSafeInteger(t)||t<0||t>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+t);const e=new Uint8Array(4);return He(e).setUint32(0,t,!1),e};class ae{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Lr(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const e=this._privateKey;if(!e)throw new Error("No private key");return Ze.encode(this.serialize(this.versions.private,q(Uint8Array.of(0),e)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return Ze.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(e,r=qe){if(F(e),8*e.length<128||8*e.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+e.length);const n=Ie(rt,Cr,e),s=n.slice(0,32),o=n.slice(32);return new ae({versions:r,chainCode:o,privateKey:s})}static fromExtendedKey(e,r=qe){const n=Ze.decode(e),s=He(n),o=s.getUint32(0,!1),i={versions:r,depth:n[4],parentFingerprint:s.getUint32(5,!1),index:s.getUint32(9,!1),chainCode:n.slice(13,45)},a=n.slice(45),c=a[0]===0;if(o!==r[c?"private":"public"])throw new Error("Version mismatch");return c?new ae({...i,privateKey:a.slice(1)}):new ae({...i,publicKey:a})}static fromJSON(e){return ae.fromExtendedKey(e.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(e){if(!e||typeof e!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||qe,this.depth=e.depth||0,this.chainCode=e.chainCode||null,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!ne.utils.isValidSecretKey(e.privateKey))throw new Error("Invalid private key");this._privateKey=e.privateKey,this._publicKey=ne.getPublicKey(e.privateKey,!0)}else if(e.publicKey)this._publicKey=be.fromBytes(e.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=Tr(this._publicKey)}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;const r=e.replace(/^[mM]'?\//,"").split("/");let n=this;for(const s of r){const o=/^(\d+)('?)$/.exec(s),i=o&&o[1];if(!o||o.length!==3||typeof i!="string")throw new Error("invalid child index: "+s);let a=+i;if(!Number.isSafeInteger(a)||a>=Ge)throw new Error("Invalid index");o[2]==="'"&&(a+=Ge),n=n.deriveChild(a)}return n}deriveChild(e){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let r=_e(e);if(e>=Ge){const c=this._privateKey;if(!c)throw new Error("Could not derive hardened child key");r=q(Uint8Array.of(0),c,r)}else r=q(this._publicKey,r);const n=Ie(rt,this.chainCode,r),s=n.slice(0,32),o=n.slice(32);if(!ne.utils.isValidSecretKey(s))throw new Error("Tweak bigger than curve order");const i={versions:this.versions,chainCode:o,depth:this.depth+1,parentFingerprint:this.fingerprint,index:e},a=pe.fromBytes(s);try{if(this._privateKey){const c=pe.create(pe.fromBytes(this._privateKey)+a);if(!pe.isValidNot0(c))throw new Error("The tweak was out of range or the resulted private key is invalid");i.privateKey=pe.toBytes(c)}else{const c=be.fromBytes(this._publicKey).add(be.BASE.multiply(a));if(c.equals(be.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");i.publicKey=c.toBytes(!0)}return new ae(i)}catch{return this.deriveChild(e+1)}}sign(e){if(!this._privateKey)throw new Error("No privateKey set!");return F(e,32),ne.sign(e,this._privateKey,{prehash:!1})}verify(e,r){if(F(e,32),F(r,64),!this._publicKey)throw new Error("No publicKey set!");return ne.verify(r,e,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,r){if(!this.chainCode)throw new Error("No chainCode set");return F(r,33),q(_e(e),new Uint8Array([this.depth]),_e(this.parentFingerprint),_e(this.index),this.chainCode,r)}}function Kr(t,e,r,n){mt(t);const s=er({dkLen:32,asyncTick:10},n),{c:o,dkLen:i,asyncTick:a}=s;if(ge(o,"c"),ge(i,"dkLen"),ge(a,"asyncTick"),o<1)throw new Error("iterations (c) must be >= 1");const c=Dt(e,"password"),d=Dt(r,"salt"),y=new Uint8Array(i),w=Ie.create(t,c),v=w._cloneInto().update(d);return{c:o,dkLen:i,asyncTick:a,DK:y,PRF:w,PRFSalt:v}}function _r(t,e,r,n,s){return t.destroy(),e.destroy(),n&&n.destroy(),$e(s),r}function Or(t,e,r,n){const{c:s,dkLen:o,DK:i,PRF:a,PRFSalt:c}=Kr(t,e,r,n);let d;const y=new Uint8Array(4),w=He(y),v=new Uint8Array(a.outputLen);for(let h=1,g=0;g<o;h++,g+=a.outputLen){const k=i.subarray(g,g+a.outputLen);w.setInt32(0,h,!1),(d=c._cloneInto(d)).update(y).digestInto(v),k.set(v.subarray(0,k.length));for(let x=1;x<s;x++){a._cloneInto(d).update(v).digestInto(v);for(let K=0;K<k.length;K++)k[K]^=v[K]}}return _r(a,c,i,d,v)}function Bn(t){if(typeof t!="string")throw new TypeError("invalid mnemonic type: "+typeof t);return t.normalize("NFKD")}function Wr(t){const e=Bn(t),r=e.split(" ");if(![12,15,18,21,24].includes(r.length))throw new Error("Invalid mnemonic");return{nfkd:e,words:r}}const Dr=t=>Bn("mnemonic"+t);function Nr(t,e=""){return Or(rt,Wr(t).nfkd,Dr(e),{c:2048,dkLen:64})}const Rr=BigInt(0),we=BigInt(1),Fr=BigInt(2),Pr=BigInt(7),Ur=BigInt(256),Mr=BigInt(113),kn=[],Cn=[],Tn=[];for(let t=0,e=we,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],kn.push(2*(5*n+r)),Cn.push((t+1)*(t+2)/2%64);let s=Rr;for(let o=0;o<7;o++)e=(e<<we^(e>>Pr)*Mr)%Ur,e&Fr&&(s^=we<<(we<<BigInt(o))-we);Tn.push(s)}const Ln=cr(Tn,!0),$r=Ln[0],Hr=Ln[1],Yt=(t,e,r)=>r>32?ir(t,e,r):sr(t,e,r),jt=(t,e,r)=>r>32?ar(t,e,r):or(t,e,r);function zr(t,e=24){const r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let i=0;i<10;i++)r[i]=t[i]^t[i+10]^t[i+20]^t[i+30]^t[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,d=r[c],y=r[c+1],w=Yt(d,y,1)^r[a],v=jt(d,y,1)^r[a+1];for(let h=0;h<50;h+=10)t[i+h]^=w,t[i+h+1]^=v}let s=t[2],o=t[3];for(let i=0;i<24;i++){const a=Cn[i],c=Yt(s,o,a),d=jt(s,o,a),y=kn[i];s=t[y],o=t[y+1],t[y]=c,t[y+1]=d}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)r[a]=t[i+a];for(let a=0;a<10;a++)t[i+a]^=~r[(a+2)%10]&r[(a+4)%10]}t[0]^=$r[n],t[1]^=Hr[n]}$e(r)}class St{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(e,r,n,s=!1,o=24){if(this.blockLen=e,this.suffix=r,this.outputLen=n,this.enableXOF=s,this.rounds=o,ge(n,"outputLen"),!(0<e&&e<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=nr(this.state)}clone(){return this._cloneInto()}keccak(){Nt(this.state32),zr(this.state32,this.rounds),Nt(this.state32),this.posOut=0,this.pos=0}update(e){Re(this),F(e);const{blockLen:r,state:n}=this,s=e.length;for(let o=0;o<s;){const i=Math.min(r-this.pos,s-o);for(let a=0;a<i;a++)n[this.pos++]^=e[o++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:r,pos:n,blockLen:s}=this;e[n]^=r,(r&128)!==0&&n===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){Re(this,!1),F(e),this.finish();const r=this.state,{blockLen:n}=this;for(let s=0,o=e.length;s<o;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,o-s);e.set(r.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return ge(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(rr(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,$e(this.state)}_cloneInto(e){const{blockLen:r,suffix:n,outputLen:s,rounds:o,enableXOF:i}=this;return e||=new St(r,n,s,i,o),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=n,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}}const Vr=(t,e,r,n={})=>tr(()=>new St(e,t,r),n),xt=Vr(1,136,32),Kn={ethereum:60,bitcoin:0,tron:195,bfmeta:9999};function Bt(t,e){const r=Nr(t,e);return ae.fromMasterSeed(r)}function Yr(t,e=0,r=0,n=0){return`m/44'/${Kn[t]}'/${e}'/${r}/${n}`}function jr(t,e,r=0,n=0,s=0){return`m/${t}'/${e}'/${r}'/${n}/${s}`}function kt(t,e){return t.derive(e)}function Zt(t){const r=ne.getPublicKey(t,!1).slice(1),s=xt(r).slice(-20);return"0x"+re(s)}function qt(t){const e=t.toLowerCase().replace("0x",""),r=new TextEncoder,n=re(xt(r.encode(e)));let s="0x";for(let o=0;o<e.length;o++)parseInt(n[o],16)>=8?s+=e[o].toUpperCase():s+=e[o];return s}function _n(t,e="mainnet"){const r=z(t),n=ve(r),s=e==="mainnet"?0:111,o=new Uint8Array([s,...n]),i=z(z(o)).slice(0,4),a=new Uint8Array([...o,...i]);return Ct(a)}function Zr(t,e="mainnet"){const r=z(t),n=ve(r),s=new Uint8Array([0,20,...n]),o=z(s),i=ve(o),a=e==="mainnet"?5:196,c=new Uint8Array([a,...i]),d=z(z(c)).slice(0,4),y=new Uint8Array([...c,...d]);return Ct(y)}function qr(t,e="mainnet"){const r=z(t),n=ve(r);return ts(e==="mainnet"?"bc":"tb",0,n)}function Gr(t,e="mainnet"){const r=t.length===33?t.slice(1):t.slice(1,33);return ns(e==="mainnet"?"bc":"tb",1,r)}function Xr(t){const r=ne.getPublicKey(t,!1).slice(1),s=xt(r).slice(-20),o=new Uint8Array([65,...s]),i=z(z(o)).slice(0,4),a=new Uint8Array([...o,...i]);return Ct(a)}const Gt="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";function Ct(t){const e=[0];for(const n of t){let s=n;for(let o=0;o<e.length;o++)s+=e[o]<<8,e[o]=s%58,s=s/58|0;for(;s>0;)e.push(s%58),s=s/58|0}let r="";for(const n of t)if(n===0)r+=Gt[0];else break;for(let n=e.length-1;n>=0;n--)r+=Gt[e[n]];return r}const On="qpzry9x8gf2tvdw0s3jn54khce6mua7l",Jr=[996825010,642813549,513874426,1027748829,705979059];function Qr(t){let e=1;for(const r of t){const n=e>>25;e=(e&33554431)<<5^r;for(let s=0;s<5;s++)n>>s&1&&(e^=Jr[s])}return e}function es(t){const e=[];for(const r of t)e.push(r.charCodeAt(0)>>5);e.push(0);for(const r of t)e.push(r.charCodeAt(0)&31);return e}function Wn(t,e,r){const n=[...es(t),...e],s=r?734539939:1,o=Qr([...n,0,0,0,0,0,0])^s,i=[];for(let a=0;a<6;a++)i.push(o>>5*(5-a)&31);return i}function Dn(t,e,r,n){let s=0,o=0;const i=[],a=(1<<r)-1;for(const c of t)for(s=s<<e|c,o+=e;o>=r;)o-=r,i.push(s>>o&a);return o>0&&i.push(s<<r-o&a),i}function ts(t,e,r){const n=Dn(r,8,5),s=[e,...n],o=Wn(t,s,!1),i=[...s,...o].map(a=>On[a]).join("");return`${t}1${i}`}function ns(t,e,r){const n=Dn(r,8,5),s=[e,...n],o=Wn(t,s,!0),i=[...s,...o].map(a=>On[a]).join("");return`${t}1${i}`}function Xe(t,e,r=0,n=0){const s=Bt(t),o=Yr(e,n,0,r),i=kt(s,o);if(!i.privateKey||!i.publicKey)throw new Error("密钥派生失败");const a=re(i.privateKey),c=re(i.publicKey);let d;switch(e){case"ethereum":d=qt(Zt(i.privateKey));break;case"bitcoin":d=_n(i.publicKey);break;case"tron":d=Xr(i.privateKey);break;case"bfmeta":d=qt(Zt(i.privateKey));break;default:throw new Error(`不支持的链类型: ${e}`)}return{privateKey:a,publicKey:c,address:d,path:o,chain:e}}function rs(t,e=44,r=0,n=0,s="mainnet"){const o=Bt(t),i=jr(e,Kn.bitcoin,n,0,r),a=kt(o,i);if(!a.privateKey||!a.publicKey)throw new Error("密钥派生失败");const c=re(a.privateKey),d=re(a.publicKey);let y;switch(e){case 44:y=_n(a.publicKey,s);break;case 49:y=Zr(a.publicKey,s);break;case 84:y=qr(a.publicKey,s);break;case 86:y=Gr(a.publicKey,s);break;default:throw new Error(`不支持的 Bitcoin purpose: ${e}`)}return{privateKey:c,publicKey:d,address:y,path:i,chain:"bitcoin",purpose:e}}function ss(t,e=0,r=0,n="mainnet"){return[44,49,84,86].map(o=>rs(t,o,e,r,n))}function Fs(t,e=0,r=0){const n=[];return n.push(Xe(t,"ethereum",e,r)),n.push(Xe(t,"bfmeta",e,r)),n.push(Xe(t,"tron",e,r)),n.push(...ss(t,e,r)),n}function Oe(t){const e=Bt(t),n=kt(e,"m/44'/9999'/0'/1/0");if(!n.privateKey)throw new Error("密钥派生失败");return n.privateKey}function We(t){const r=new TextEncoder().encode(`KeyApp:EncryptionKey:${t}`);return z(r)}function Ps(t,e){switch(e){case"ethereum":case"bfmeta":return/^0x[a-fA-F0-9]{40}$/.test(t);case"bitcoin":return/^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(t)||/^bc1q[a-z0-9]{38,}$/.test(t)||/^bc1p[a-z0-9]{58}$/.test(t);case"tron":return/^T[a-zA-Z0-9]{33}$/.test(t);default:return!1}}const dt=(t,e)=>e.some(r=>t instanceof r);let Xt,Jt;function os(){return Xt||(Xt=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function is(){return Jt||(Jt=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const lt=new WeakMap,Je=new WeakMap,ze=new WeakMap;function as(t){const e=new Promise((r,n)=>{const s=()=>{t.removeEventListener("success",o),t.removeEventListener("error",i)},o=()=>{r(ce(t.result)),s()},i=()=>{n(t.error),s()};t.addEventListener("success",o),t.addEventListener("error",i)});return ze.set(e,t),e}function cs(t){if(lt.has(t))return;const e=new Promise((r,n)=>{const s=()=>{t.removeEventListener("complete",o),t.removeEventListener("error",i),t.removeEventListener("abort",i)},o=()=>{r(),s()},i=()=>{n(t.error||new DOMException("AbortError","AbortError")),s()};t.addEventListener("complete",o),t.addEventListener("error",i),t.addEventListener("abort",i)});lt.set(t,e)}let ut={get(t,e,r){if(t instanceof IDBTransaction){if(e==="done")return lt.get(t);if(e==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return ce(t[e])},set(t,e,r){return t[e]=r,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function Nn(t){ut=t(ut)}function ds(t){return is().includes(t)?function(...e){return t.apply(ft(this),e),ce(this.request)}:function(...e){return ce(t.apply(ft(this),e))}}function ls(t){return typeof t=="function"?ds(t):(t instanceof IDBTransaction&&cs(t),dt(t,os())?new Proxy(t,ut):t)}function ce(t){if(t instanceof IDBRequest)return as(t);if(Je.has(t))return Je.get(t);const e=ls(t);return e!==t&&(Je.set(t,e),ze.set(e,t)),e}const ft=t=>ze.get(t);function us(t,e,{blocked:r,upgrade:n,blocking:s,terminated:o}={}){const i=indexedDB.open(t,e),a=ce(i);return n&&i.addEventListener("upgradeneeded",c=>{n(ce(i.result),c.oldVersion,c.newVersion,ce(i.transaction),c)}),r&&i.addEventListener("blocked",c=>r(c.oldVersion,c.newVersion,c)),a.then(c=>{o&&c.addEventListener("close",()=>o()),s&&c.addEventListener("versionchange",d=>s(d.oldVersion,d.newVersion,d))}).catch(()=>{}),a}const fs=["get","getKey","getAll","getAllKeys","count"],hs=["put","add","delete","clear"],Qe=new Map;function Qt(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(Qe.get(e))return Qe.get(e);const r=e.replace(/FromIndex$/,""),n=e!==r,s=hs.includes(r);if(!(r in(n?IDBIndex:IDBObjectStore).prototype)||!(s||fs.includes(r)))return;const o=async function(i,...a){const c=this.transaction(i,s?"readwrite":"readonly");let d=c.store;return n&&(d=d.index(a.shift())),(await Promise.all([d[r](...a),s&&c.done]))[0]};return Qe.set(e,o),o}Nn(t=>({...t,get:(e,r,n)=>Qt(e,r)||t.get(e,r,n),has:(e,r)=>!!Qt(e,r)||t.has(e,r)}));const ys=["continue","continuePrimaryKey","advance"],en={},ht=new WeakMap,Rn=new WeakMap,ps={get(t,e){if(!ys.includes(e))return t[e];let r=en[e];return r||(r=en[e]=function(...n){ht.set(this,Rn.get(this)[e](...n))}),r}};async function*ws(...t){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...t)),!e)return;e=e;const r=new Proxy(e,ps);for(Rn.set(r,e),ze.set(r,ft(e));e;)yield r,e=await(ht.get(r)||e.continue()),ht.delete(r)}function tn(t,e){return e===Symbol.asyncIterator&&dt(t,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&dt(t,[IDBIndex,IDBObjectStore])}Nn(t=>({...t,get(e,r,n){return tn(e,r)?ws:t.get(e,r,n)},has(e,r){return tn(e,r)||t.has(e,r)}}));function me(t,e,r){if(!Array.isArray(e))return[];const n=[];for(let s=0;s<e.length;s++){const o=t.safeParse(e[s]);o.success&&n.push(o.data)}return n}const De=2;var _=(t=>(t.NOT_INITIALIZED="STORAGE_NOT_INITIALIZED",t.WALLET_NOT_FOUND="WALLET_NOT_FOUND",t.ADDRESS_NOT_FOUND="ADDRESS_NOT_FOUND",t.DECRYPTION_FAILED="DECRYPTION_FAILED",t.ENCRYPTION_FAILED="ENCRYPTION_FAILED",t.STORAGE_FULL="STORAGE_FULL",t.MIGRATION_FAILED="MIGRATION_FAILED",t.INVALID_PASSWORD="INVALID_PASSWORD",t))(_||{});class W extends Error{constructor(e,r,n){super(r),this.code=e,this.cause=n,this.name="WalletStorageError"}}class Fn extends Error{code="WALLET_MIGRATION_REQUIRED";storedVersion;requiredVersion;constructor(e,r){super(`Wallet storage migration required: v${e} → v${r}`),this.name="WalletStorageMigrationError",this.storedVersion=e,this.requiredVersion=r}}const yt=de({salt:L(),iv:L(),ciphertext:L()}).passthrough(),ms=de({assetType:L(),symbol:L(),decimals:j(),balance:L().default("0"),contractAddress:L().optional(),logoUrl:L().optional()}).passthrough(),et=de({addressKey:L(),walletId:L(),chain:L(),address:L(),publicKey:L().optional(),encryptedPrivateKey:yt.optional(),derivationPath:L().optional(),assets:lr(ms).default([]),isCustomAssets:ue().default(!1),isFrozen:ue().default(!1)}).passthrough(),nn=de({id:L(),name:L(),keyType:dr(["mnemonic","arbitrary","privateKey"]),primaryChain:L(),primaryAddress:L(),encryptedMnemonic:yt.optional(),encryptedWalletLock:yt.optional(),isBackedUp:ue().default(!1),themeHue:j().optional(),createdAt:j(),updatedAt:j()}).passthrough(),bs=de({name:L(),passwordTips:L().optional(),activeWalletId:L().nullable(),biometricEnabled:ue().default(!1),walletLockEnabled:ue().default(!0),agreementAccepted:ue().default(!1),createdAt:j(),updatedAt:j()}).passthrough();de({version:j(),createdAt:j(),lastMigratedAt:j().optional()}).passthrough();const tt=de({id:L(),chain:L(),address:L(),name:L(),note:L().optional(),createdAt:j(),updatedAt:j()}).passthrough(),gs="bfm-wallet-db",Es=1;class As{db=null;initialized=!1;async initialize(){if(this.initialized)return;this.db=await us(gs,Es,{upgrade(n,s,o,i){let a;if(n.objectStoreNames.contains("metadata")||(a=n.createObjectStore("metadata")),n.objectStoreNames.contains("walleter")||n.createObjectStore("walleter"),n.objectStoreNames.contains("wallets")||n.createObjectStore("wallets",{keyPath:"id"}).createIndex("by-chain","primaryChain"),!n.objectStoreNames.contains("chainAddresses")){const c=n.createObjectStore("chainAddresses",{keyPath:"addressKey"});c.createIndex("by-wallet","walletId"),c.createIndex("by-chain","chain")}n.objectStoreNames.contains("addressBook")||n.createObjectStore("addressBook",{keyPath:"id"}).createIndex("by-chain","chain"),s===0&&a?a.put({version:De,createdAt:Date.now()},"main"):s===0&&i.objectStore("metadata").put({version:De,createdAt:Date.now()},"main")}}),this.initialized=!0;const r=(await this.getMetadata())?.version??0;if(r>0&&r<De)throw new Fn(r,De);await this.runMigrations()}isInitialized(){return this.initialized}ensureInitialized(){if(!this.initialized||!this.db)throw new W(_.NOT_INITIALIZED,"Storage service not initialized. Call initialize() first.")}async getMetadata(){return this.ensureInitialized(),await this.db.get("metadata","main")??null}async saveWalleterInfo(e){this.ensureInitialized(),await this.db.put("walleter",e,"main")}async getWalleterInfo(){this.ensureInitialized();const e=await this.db.get("walleter","main");if(!e)return null;const r=bs.safeParse(e);return r.success?r.data:null}async createWallet(e,r,n){if(this.ensureInitialized(),!r||typeof r!="string")throw new W(_.ENCRYPTION_FAILED,"Invalid mnemonic: mnemonic is required");if(!n||typeof n!="string")throw new W(_.ENCRYPTION_FAILED,"Invalid walletLock: wallet lock password is required");if(typeof crypto>"u"||!crypto.subtle)throw new W(_.ENCRYPTION_FAILED,"Web Crypto API is not available. Please use HTTPS or localhost.");try{const s=await Le(r,n),o=e.keyType==="mnemonic"?Oe(r):We(r),i=await Ye(n,o),a={...e,encryptedMnemonic:s,encryptedWalletLock:i};return await this.db.put("wallets",a),a}catch(s){const o=s instanceof Error?s.message:String(s);throw new W(_.ENCRYPTION_FAILED,`Failed to encrypt wallet data: ${o}`,s instanceof Error?s:void 0)}}async saveWallet(e){this.ensureInitialized(),await this.db.put("wallets",e)}async getWallet(e){this.ensureInitialized();const r=await this.db.get("wallets",e);if(!r)return null;const n=nn.safeParse(r);return n.success?n.data:null}async getAllWallets(){this.ensureInitialized();const e=await this.db.getAll("wallets");return me(nn,e)}async updateWallet(e,r){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new W(_.WALLET_NOT_FOUND,`Wallet not found: ${e}`);await this.db.put("wallets",{...n,...r,updatedAt:Date.now()})}async deleteWallet(e){this.ensureInitialized(),await this.db.delete("wallets",e);const r=await this.getWalletChainAddresses(e),n=this.db.transaction("chainAddresses","readwrite");await Promise.all(r.map(s=>n.store.delete(s.addressKey))),await n.done}async getMnemonic(e,r){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new W(_.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!n.encryptedMnemonic)throw new W(_.DECRYPTION_FAILED,"No encrypted mnemonic found for this wallet");try{return await st(n.encryptedMnemonic,r)}catch(s){throw new W(_.DECRYPTION_FAILED,"Failed to decrypt mnemonic. Wrong password or corrupted data.",s instanceof Error?s:void 0)}}async updateWalletLockEncryption(e,r,n){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new W(_.WALLET_NOT_FOUND,`Wallet not found: ${e}`);const o=await this.getMnemonic(e,r);try{const i=await Le(o,n),a=s.keyType==="mnemonic"?Oe(o):We(o),c=await Ye(n,a);await this.updateWallet(e,{encryptedMnemonic:i,encryptedWalletLock:c})}catch(i){throw new W(_.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",i instanceof Error?i:void 0)}}async verifyMnemonic(e,r){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new W(_.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!n.encryptedWalletLock)throw new W(_.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");try{const s=n.keyType==="mnemonic"?Oe(r):We(r);return await Pt(n.encryptedWalletLock,s),!0}catch{return!1}}async resetWalletLockByMnemonic(e,r,n){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new W(_.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!s.encryptedWalletLock)throw new W(_.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");const o=s.keyType==="mnemonic"?Oe(r):We(r);try{await Pt(s.encryptedWalletLock,o)}catch{throw new W(_.INVALID_PASSWORD,"Invalid mnemonic/secret: failed to decrypt wallet lock")}try{const i=await Le(r,n),a=await Ye(n,o);await this.updateWallet(e,{encryptedMnemonic:i,encryptedWalletLock:a})}catch(i){throw new W(_.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",i instanceof Error?i:void 0)}}async savePrivateKey(e,r,n){this.ensureInitialized();const s=await this.getChainAddress(e);if(!s)throw new W(_.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);try{const o=await Le(r,n);await this.db.put("chainAddresses",{...s,encryptedPrivateKey:o})}catch(o){throw new W(_.ENCRYPTION_FAILED,"Failed to encrypt private key",o instanceof Error?o:void 0)}}async getPrivateKey(e,r){this.ensureInitialized();const n=await this.getChainAddress(e);if(!n)throw new W(_.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);if(!n.encryptedPrivateKey)throw new W(_.DECRYPTION_FAILED,"No encrypted private key found for this address");try{return await st(n.encryptedPrivateKey,r)}catch(s){throw new W(_.DECRYPTION_FAILED,"Failed to decrypt private key. Wrong password or corrupted data.",s instanceof Error?s:void 0)}}async saveChainAddress(e){this.ensureInitialized(),await this.db.put("chainAddresses",e)}async getChainAddress(e){this.ensureInitialized();const r=await this.db.get("chainAddresses",e);if(!r)return null;const n=et.safeParse(r);return n.success?n.data:null}async getWalletChainAddresses(e){this.ensureInitialized();const r=await this.db.getAllFromIndex("chainAddresses","by-wallet",e);return me(et,r)}async getChainAddresses(e){this.ensureInitialized();const r=await this.db.getAllFromIndex("chainAddresses","by-chain",e);return me(et,r)}async updateAssets(e,r){this.ensureInitialized();const n=await this.getChainAddress(e);if(!n)throw new W(_.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);await this.db.put("chainAddresses",{...n,assets:r,isCustomAssets:!0})}async deleteChainAddress(e){this.ensureInitialized(),await this.db.delete("chainAddresses",e)}async saveAddressBookEntry(e){this.ensureInitialized(),await this.db.put("addressBook",e)}async getAddressBookEntry(e){this.ensureInitialized();const r=await this.db.get("addressBook",e);if(!r)return null;const n=tt.safeParse(r);return n.success?n.data:null}async getAllAddressBookEntries(){this.ensureInitialized();const e=await this.db.getAll("addressBook");return me(tt,e)}async getChainAddressBookEntries(e){this.ensureInitialized();const r=await this.db.getAllFromIndex("addressBook","by-chain",e);return me(tt,r)}async deleteAddressBookEntry(e){this.ensureInitialized(),await this.db.delete("addressBook",e)}async clearAll(){this.ensureInitialized();const e=this.db.transaction(["walleter","wallets","chainAddresses","addressBook"],"readwrite");await Promise.all([e.objectStore("walleter").clear(),e.objectStore("wallets").clear(),e.objectStore("chainAddresses").clear(),e.objectStore("addressBook").clear()]),await e.done}close(){this.db&&(this.db.close(),this.db=null,this.initialized=!1)}async runMigrations(){await this.getMetadata()}async migrateFromLocalStorage(){this.ensureInitialized();const e=localStorage.getItem("bfm_wallets");if(!e)return!1;try{const{wallets:r,currentWalletId:n}=JSON.parse(e);for(const o of r){const i={id:o.id,name:o.name,keyType:o.keyType||"mnemonic",primaryChain:o.chain,primaryAddress:o.address,encryptedMnemonic:o.encryptedMnemonic,isBackedUp:!1,createdAt:o.createdAt,updatedAt:Date.now()};if(await this.saveWallet(i),o.chainAddresses)for(const a of o.chainAddresses){const d={addressKey:`${o.id}:${a.chain}`,walletId:o.id,chain:a.chain,address:a.address,assets:[],isCustomAssets:!1,isFrozen:!1};await this.saveChainAddress(d)}}const s=await this.getWalleterInfo();return s?n&&await this.saveWalleterInfo({...s,activeWalletId:n,updatedAt:Date.now()}):await this.saveWalleterInfo({name:"User",activeWalletId:n,biometricEnabled:!1,walletLockEnabled:!1,agreementAccepted:!0,createdAt:Date.now(),updatedAt:Date.now()}),localStorage.removeItem("bfm_wallets"),!0}catch(r){throw new W(_.MIGRATION_FAILED,"Failed to migrate data from localStorage",r instanceof Error?r:void 0)}}}const D=new As;function rn(t){let e=0;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);e=(e<<5)-e+n,e=e&e}return Math.abs(e)%360}const Pn="wallet_chain_preferences";function vs(){try{const t=localStorage.getItem(Pn);if(t)return JSON.parse(t)}catch{}return{}}function sn(t){try{localStorage.setItem(Pn,JSON.stringify(t))}catch{}}const pt={wallets:[],currentWalletId:null,selectedChain:"ethereum",chainPreferences:{},isLoading:!1,isInitialized:!1,migrationRequired:!1},U=new bt(pt);function Is(t,e){const r=t.keyType==="mnemonic"?"mnemonic":"arbitrary",n={id:t.id,name:t.name,keyType:r,address:t.primaryAddress,chain:t.primaryChain,createdAt:t.createdAt,chainAddresses:e.map(s=>({chain:s.chain,address:s.address,publicKey:s.publicKey??""})),themeHue:t.themeHue??0};return t.encryptedMnemonic&&(n.encryptedMnemonic=t.encryptedMnemonic),t.encryptedWalletLock&&(n.encryptedWalletLock=t.encryptedWalletLock),n}const Ss={initialize:async()=>{const t=U.state;if(!(t.isInitialized||t.isLoading)){U.setState(e=>({...e,isLoading:!0}));try{await D.initialize(),await D.migrateFromLocalStorage();const[e,r]=await Promise.all([D.getWalleterInfo(),D.getAllWallets()]),n=await Promise.all(r.map(async c=>{const d=await D.getWalletChainAddresses(c.id);return Is(c,d)})),s=vs(),o=e?.activeWalletId??n[0]?.id??null,i=n.find(c=>c.id===o),a=o?s[o]??i?.chain??"bfmeta":"bfmeta";U.setState(c=>({...c,wallets:n,currentWalletId:o,selectedChain:a,chainPreferences:s,isInitialized:!0,isLoading:!1}))}catch(e){if(e instanceof Fn){U.setState(r=>({...r,isInitialized:!0,isLoading:!1,migrationRequired:!0}));return}U.setState(r=>({...r,isInitialized:!0,isLoading:!1}))}}},createWallet:async(t,e,r,n)=>{const s=crypto.randomUUID(),o=Date.now(),i={id:s,name:t.name,keyType:t.keyType??"mnemonic",primaryChain:t.chain,primaryAddress:t.address,isBackedUp:!1,themeHue:n??rn(e),createdAt:o,updatedAt:o},a=await D.createWallet(i,e,r),c=t.chainAddresses||[{chain:t.chain,address:t.address,publicKey:"",tokens:[]}];for(const w of c)await D.saveChainAddress({addressKey:`${s}:${w.chain}`,walletId:s,chain:w.chain,address:w.address,publicKey:w.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});const d=await D.getWalleterInfo();await D.saveWalleterInfo({name:d?.name??"User",activeWalletId:s,biometricEnabled:d?.biometricEnabled??!1,walletLockEnabled:d?.walletLockEnabled??!1,agreementAccepted:!0,createdAt:d?.createdAt??o,updatedAt:o});const y={id:s,name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:o,chainAddresses:c,themeHue:n??rn(e),...a.encryptedMnemonic?{encryptedMnemonic:a.encryptedMnemonic}:{}};return U.setState(w=>({...w,wallets:[...w.wallets,y],currentWalletId:s})),y},importWallet:async(t,e,r)=>Ss.createWallet(t,e,r),deleteWallet:async t=>{await D.deleteWallet(t),U.setState(e=>{const r=e.wallets.filter(c=>c.id!==t),n=e.currentWalletId===t?r[0]?.id??null:e.currentWalletId,{[t]:s,...o}=e.chainPreferences;sn(o);const i=r.find(c=>c.id===n),a=n?o[n]??i?.chain??"bfmeta":e.selectedChain;return{...e,wallets:r,currentWalletId:n,selectedChain:a,chainPreferences:o}})},setCurrentWallet:async t=>{const e=await D.getWalleterInfo();e&&await D.saveWalleterInfo({...e,activeWalletId:t,updatedAt:Date.now()}),U.setState(r=>{const n=r.wallets.find(o=>o.id===t),s=r.chainPreferences[t]??n?.chain??"bfmeta";return{...r,currentWalletId:t,selectedChain:s}})},setSelectedChain:t=>{U.setState(e=>{const{currentWalletId:r,chainPreferences:n}=e;if(r){const s={...n,[r]:t};return sn(s),{...e,selectedChain:t,chainPreferences:s}}return{...e,selectedChain:t}})},updateWalletName:async(t,e)=>{await D.updateWallet(t,{name:e}),U.setState(r=>({...r,wallets:r.wallets.map(n=>n.id===t?{...n,name:e}:n)}))},updateWalletThemeHue:async(t,e)=>{await D.updateWallet(t,{themeHue:e}),U.setState(r=>({...r,wallets:r.wallets.map(n=>n.id===t?{...n,themeHue:e}:n)}))},updateWalletLock:async(t,e,r)=>{await D.updateWalletLockEncryption(t,e,r);const n=await D.getWallet(t);n?.encryptedMnemonic&&n.encryptedWalletLock&&U.setState(s=>({...s,wallets:s.wallets.map(o=>o.id===t?{...o,encryptedMnemonic:n.encryptedMnemonic,encryptedWalletLock:n.encryptedWalletLock}:o)}))},verifyMnemonic:async(t,e)=>D.verifyMnemonic(t,e),resetWalletLockByMnemonic:async(t,e,r)=>{await D.resetWalletLockByMnemonic(t,e,r);const n=await D.getWallet(t);n?.encryptedMnemonic&&n.encryptedWalletLock&&U.setState(s=>({...s,wallets:s.wallets.map(o=>o.id===t?{...o,encryptedMnemonic:n.encryptedMnemonic,encryptedWalletLock:n.encryptedWalletLock}:o)}))},getMnemonic:async(t,e)=>D.getMnemonic(t,e),updateWalletChainAddresses:async(t,e,r,n)=>{const o=U.state.wallets.find(h=>h.id===t);if(!o)throw new Error("Wallet not found");const i=await D.getMnemonic(t,r),a=new Set(o.chainAddresses.map(h=>h.chain)),c=new Set(e),d=e.filter(h=>!a.has(h)),y=[...a].filter(h=>!c.has(h));if(d.length===0&&y.length===0)return;let w=[];if(d.length>0){const{deriveWalletChainAddresses:h}=await Hn(async()=>{const{deriveWalletChainAddresses:x}=await import("./index-D15qHKTV.js");return{deriveWalletChainAddresses:x}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10]),import.meta.url),g=n.filter(x=>d.includes(x.id));w=(await h({mnemonic:i,chainConfigs:g,selectedChainIds:d})).map(x=>({chain:x.chainId,address:x.address,publicKey:x.publicKey??""}))}for(const h of w)await D.saveChainAddress({addressKey:`${t}:${h.chain}`,walletId:t,chain:h.chain,address:h.address,publicKey:h.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});for(const h of y)await D.deleteChainAddress(`${t}:${h}`);const v=[...o.chainAddresses.filter(h=>!y.includes(h.chain)),...w.map(h=>({chain:h.chain,address:h.address,publicKey:h.publicKey,tokens:[]}))];U.setState(h=>({...h,wallets:h.wallets.map(g=>g.id===t?{...g,chainAddresses:v}:g)}))},clearAll:async()=>{await D.clearAll(),U.setState(()=>pt)},_testAddWallet:t=>{const e={id:t.id??crypto.randomUUID(),name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:t.createdAt??Date.now(),chainAddresses:t.chainAddresses??[{chain:t.chain,address:t.address,publicKey:""}],themeHue:t.themeHue,...t.encryptedMnemonic?{encryptedMnemonic:t.encryptedMnemonic}:{}};return U.setState(r=>({...r,wallets:[...r.wallets,e],currentWalletId:r.currentWalletId??e.id,isInitialized:!0})),e},_testReset:()=>{U.setState(()=>pt)}},xs={getCurrentWallet:t=>t.currentWalletId&&t.wallets.find(e=>e.id===t.currentWalletId)||null,getCurrentChainAddress:t=>{const e=xs.getCurrentWallet(t);return e&&e.chainAddresses.find(r=>r.chain===t.selectedChain)||null},hasWallet:t=>t.wallets.length>0},Un={contacts:[],isInitialized:!1},X=new bt(Un),Tt="bfm_address_book",Mn=3;function ie(t){try{const e={version:Mn,contacts:t};localStorage.setItem(Tt,JSON.stringify(e))}catch{}}function Bs(){try{const t=localStorage.getItem(Tt);if(!t)return[];const e=JSON.parse(t);return e.version===Mn&&Array.isArray(e.contacts)?e.contacts:[]}catch{return[]}}const Us={initialize:()=>{const t=Bs();X.setState(()=>({contacts:t,isInitialized:!0}))},addContact:t=>{if(t.addresses.length>3)throw new Error("Maximum 3 addresses per contact");const e=Date.now(),r={...t,id:crypto.randomUUID(),createdAt:e,updatedAt:e};return X.setState(n=>{const s=[...n.contacts,r];return ie(s),{...n,contacts:s}}),r},updateContact:(t,e)=>{X.setState(r=>{const n=r.contacts.map(s=>s.id===t?{...s,...e,updatedAt:Date.now()}:s);return ie(n),{...r,contacts:n}})},deleteContact:t=>{X.setState(e=>{const r=e.contacts.filter(n=>n.id!==t);return ie(r),{...e,contacts:r}})},addAddressToContact:(t,e)=>{const r={...e,id:crypto.randomUUID()};X.setState(n=>{const s=n.contacts.map(o=>{if(o.id!==t)return o;if(o.addresses.length>=3)throw new Error("Maximum 3 addresses per contact");return{...o,addresses:[...o.addresses,r],updatedAt:Date.now()}});return ie(s),{...n,contacts:s}})},removeAddressFromContact:(t,e)=>{X.setState(r=>{const n=r.contacts.map(s=>s.id!==t?s:{...s,addresses:s.addresses.filter(o=>o.id!==e),updatedAt:Date.now()});return ie(n),{...r,contacts:n}})},setDefaultAddress:(t,e)=>{X.setState(r=>{const n=r.contacts.map(s=>s.id!==t?s:{...s,addresses:s.addresses.map(o=>({...o,isDefault:o.id===e})),updatedAt:Date.now()});return ie(n),{...r,contacts:n}})},importContacts:t=>{if(t.length===0)return 0;let e=0;return X.setState(r=>{const n=r.contacts,s=new Set(n.map(a=>a.name.toLowerCase())),o=t.filter(a=>{const c=a.name.toLowerCase();return s.has(c)?!1:(s.add(c),!0)});if(e=o.length,o.length===0)return r;const i=[...n,...o];return ie(i),{...r,contacts:i}}),e},clearAll:()=>{localStorage.removeItem(Tt),X.setState(()=>Un)}},Ms={getContactByAddress:(t,e)=>{const r=e.toLowerCase();for(const n of t.contacts){const s=n.addresses.find(o=>o.address.toLowerCase()===r);if(s)return{contact:n,matchedAddress:s}}},searchContacts:(t,e)=>{const r=e.toLowerCase();return t.contacts.filter(n=>n.name.toLowerCase().includes(r)||n.addresses.some(s=>s.address.toLowerCase().includes(r)))},suggestContacts:(t,e,r=5)=>{const n=[],s=e&&e.length>0,o=s?e.toLowerCase():"",i=[...t.contacts].toSorted((c,d)=>d.updatedAt-c.updatedAt);for(const c of i){const d=c.addresses;if(d.length!==0){if(!s){const y=d.find(w=>w.isDefault)??d[0];y&&n.push({contact:c,matchedAddress:y,matchType:"name",score:40});continue}for(const y of d){const w=y.address.toLowerCase();w===o?n.push({contact:c,matchedAddress:y,matchType:"exact",score:100}):w.startsWith(o)?n.push({contact:c,matchedAddress:y,matchType:"prefix",score:80}):w.includes(o)&&n.push({contact:c,matchedAddress:y,matchType:"prefix",score:50})}if(c.name.toLowerCase().includes(o)){const y=d.find(w=>w.isDefault)??d[0];y&&n.push({contact:c,matchedAddress:y,matchType:"name",score:60})}}}const a=new Map;for(const c of n){const d=`${c.contact.id}:${c.matchedAddress.id}`,y=a.get(d);(!y||y.score<c.score)&&a.set(d,c)}return Array.from(a.values()).toSorted((c,d)=>d.score!==c.score?d.score-c.score:d.contact.updatedAt-c.contact.updatedAt).slice(0,r)},getContactsByChain:(t,e)=>t.contacts.filter(r=>r.addresses.some(n=>Rt(n.address).chainType===e)),getDefaultAddress:(t,e)=>{const r=e?t.addresses.filter(n=>Rt(n.address).chainType===e):t.addresses;return r.find(n=>n.isDefault)??r[0]}},$n="bfm_user_profile",Me=3,wt={username:"",avatar:"",selectedWalletIds:[]};function ks(){try{const t=localStorage.getItem($n);if(t){const e=JSON.parse(t);return{username:e.username??"",avatar:e.avatar??"",selectedWalletIds:Array.isArray(e.selectedWalletIds)?e.selectedWalletIds.slice(0,Me):[]}}}catch{}return wt}function le(t){try{localStorage.setItem($n,JSON.stringify(t))}catch{}}const J=new bt(ks()),$s={setUsername(t){J.setState(e=>{const r={...e,username:t.trim()};return le(r),r})},randomizeAvatar(){const t=fr(),e=`avatar:${Ft(t)}`;J.setState(r=>{const n={...r,avatar:e};return le(n),n})},initializeDefaultAvatar(t){J.setState(e=>{if(e.avatar)return e;const r=ur(t.toLowerCase()),n=`avatar:${Ft(r)}`,s={...e,avatar:n};return le(s),s})},toggleWalletSelection(t){let e=!1;return J.setState(r=>{const n=r.selectedWalletIds,s=n.includes(t);let o;if(s)o=n.filter(a=>a!==t);else{if(n.length>=Me)return r;o=[...n,t],e=!0}const i={...r,selectedWalletIds:o};return le(i),i}),e},setSelectedWalletIds(t){J.setState(e=>{const r={...e,selectedWalletIds:t.slice(0,Me)};return le(r),r})},clear(){J.setState(()=>(le(wt),wt))}};function Hs(){return gt(J)}function zs(){return gt(J,t=>t.selectedWalletIds)}function Vs(){return gt(J,t=>t.selectedWalletIds.length<Me)}export{$s as A,As as B,De as C,Fn as D,J as E,W,Us as a,D as b,Ms as c,X as d,xs as e,Xe as f,Le as g,st as h,Ps as i,rs as j,xt as k,Ds as l,Ns as m,Rs as n,us as o,Ss as p,_ as q,Nr as r,ne as s,qt as t,Hs as u,Ws as v,U as w,Fs as x,zs as y,Vs as z};
