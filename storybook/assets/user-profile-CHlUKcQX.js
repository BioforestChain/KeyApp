const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./index-BRe906n0.js","./index-DNOIQ5JC.js","./iframe-L7e6CwBi.js","./preload-helper-PPVm8Dsz.js","./iframe-dKmOljRT.css","./service-BkoiQvzo.js","./schemas-CO8_C8zP.js","./index-D0E7N0oa.js","./derivation-ClDV6VJV.js","./amount-BQsqQYGO.js","./bioforest-CcSgL-Rz.js"])))=>i.map(i=>d[i]);
import{_ as Ae}from"./preload-helper-PPVm8Dsz.js";import"./index-D0E7N0oa.js";import{x as _,y as k,z as O,A as R,B as ee,C as te}from"./derivation-ClDV6VJV.js";import{o as D,n as A,c as T,s as f,b as Ie,a as ge}from"./schemas-CO8_C8zP.js";import{S as Q,u as Z}from"./iframe-L7e6CwBi.js";import{i as se,a as Se,e as ae,g as We}from"./avatar-codec-DSrqv8PA.js";const $=(t,e)=>e.some(s=>t instanceof s);let ne,re;function Ee(){return ne||(ne=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function Ce(){return re||(re=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const j=new WeakMap,B=new WeakMap,z=new WeakMap;function De(t){const e=new Promise((s,a)=>{const n=()=>{t.removeEventListener("success",r),t.removeEventListener("error",i)},r=()=>{s(C(t.result)),n()},i=()=>{a(t.error),n()};t.addEventListener("success",r),t.addEventListener("error",i)});return z.set(e,t),e}function be(t){if(j.has(t))return;const e=new Promise((s,a)=>{const n=()=>{t.removeEventListener("complete",r),t.removeEventListener("error",i),t.removeEventListener("abort",i)},r=()=>{s(),n()},i=()=>{a(t.error||new DOMException("AbortError","AbortError")),n()};t.addEventListener("complete",r),t.addEventListener("error",i),t.addEventListener("abort",i)});j.set(t,e)}let Y={get(t,e,s){if(t instanceof IDBTransaction){if(e==="done")return j.get(t);if(e==="store")return s.objectStoreNames[1]?void 0:s.objectStore(s.objectStoreNames[0])}return C(t[e])},set(t,e,s){return t[e]=s,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function ue(t){Y=t(Y)}function ve(t){return Ce().includes(t)?function(...e){return t.apply(V(this),e),C(this.request)}:function(...e){return C(t.apply(V(this),e))}}function Le(t){return typeof t=="function"?ve(t):(t instanceof IDBTransaction&&be(t),$(t,Ee())?new Proxy(t,Y):t)}function C(t){if(t instanceof IDBRequest)return De(t);if(B.has(t))return B.get(t);const e=Le(t);return e!==t&&(B.set(t,e),z.set(e,t)),e}const V=t=>z.get(t);function Te(t,e,{blocked:s,upgrade:a,blocking:n,terminated:r}={}){const i=indexedDB.open(t,e),c=C(i);return a&&i.addEventListener("upgradeneeded",o=>{a(C(i.result),o.oldVersion,o.newVersion,C(i.transaction),o)}),s&&i.addEventListener("blocked",o=>s(o.oldVersion,o.newVersion,o)),c.then(o=>{r&&o.addEventListener("close",()=>r()),n&&o.addEventListener("versionchange",d=>n(d.oldVersion,d.newVersion,d))}).catch(()=>{}),c}const Ne=["get","getKey","getAll","getAllKeys","count"],Pe=["put","add","delete","clear"],K=new Map;function ie(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(K.get(e))return K.get(e);const s=e.replace(/FromIndex$/,""),a=e!==s,n=Pe.includes(s);if(!(s in(a?IDBIndex:IDBObjectStore).prototype)||!(n||Ne.includes(s)))return;const r=async function(i,...c){const o=this.transaction(i,n?"readwrite":"readonly");let d=o.store;return a&&(d=d.index(c.shift())),(await Promise.all([d[s](...c),n&&o.done]))[0]};return K.set(e,r),r}ue(t=>({...t,get:(e,s,a)=>ie(e,s)||t.get(e,s,a),has:(e,s)=>!!ie(e,s)||t.has(e,s)}));const _e=["continue","continuePrimaryKey","advance"],oe={},G=new WeakMap,he=new WeakMap,ke={get(t,e){if(!_e.includes(e))return t[e];let s=oe[e];return s||(s=oe[e]=function(...a){G.set(this,he.get(this)[e](...a))}),s}};async function*Oe(...t){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...t)),!e)return;e=e;const s=new Proxy(e,ke);for(he.set(s,e),z.set(s,V(e));e;)yield s,e=await(G.get(s)||e.continue()),G.delete(s)}function ce(t,e){return e===Symbol.asyncIterator&&$(t,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&$(t,[IDBIndex,IDBObjectStore])}ue(t=>({...t,get(e,s,a){return ce(e,s)?Oe:t.get(e,s,a)},has(e,s){return ce(e,s)||t.has(e,s)}}));function P(t,e,s){if(!Array.isArray(e))return[];const a=[];for(let n=0;n<e.length;n++){const r=t.safeParse(e[n]);r.success&&a.push(r.data)}return a}const M=2;var y=(t=>(t.NOT_INITIALIZED="STORAGE_NOT_INITIALIZED",t.WALLET_NOT_FOUND="WALLET_NOT_FOUND",t.ADDRESS_NOT_FOUND="ADDRESS_NOT_FOUND",t.DECRYPTION_FAILED="DECRYPTION_FAILED",t.ENCRYPTION_FAILED="ENCRYPTION_FAILED",t.STORAGE_FULL="STORAGE_FULL",t.MIGRATION_FAILED="MIGRATION_FAILED",t.INVALID_PASSWORD="INVALID_PASSWORD",t))(y||{});class m extends Error{constructor(e,s,a){super(s),this.code=e,this.cause=a,this.name="WalletStorageError"}}class fe extends Error{code="WALLET_MIGRATION_REQUIRED";storedVersion;requiredVersion;constructor(e,s){super(`Wallet storage migration required: v${e} â†’ v${s}`),this.name="WalletStorageMigrationError",this.storedVersion=e,this.requiredVersion=s}}const H=D({salt:f(),iv:f(),ciphertext:f()}).passthrough(),Me=D({assetType:f(),symbol:f(),decimals:A(),balance:f().default("0"),contractAddress:f().optional(),logoUrl:f().optional()}).passthrough(),x=D({addressKey:f(),walletId:f(),chain:f(),address:f(),publicKey:f().optional(),encryptedPrivateKey:H.optional(),derivationPath:f().optional(),assets:ge(Me).default([]),isCustomAssets:T().default(!1),isFrozen:T().default(!1)}).passthrough(),de=D({id:f(),name:f(),keyType:Ie(["mnemonic","arbitrary","privateKey"]),primaryChain:f(),primaryAddress:f(),encryptedMnemonic:H.optional(),encryptedWalletLock:H.optional(),isBackedUp:T().default(!1),themeHue:A().optional(),createdAt:A(),updatedAt:A()}).passthrough(),Fe=D({name:f(),passwordTips:f().optional(),activeWalletId:f().nullable(),biometricEnabled:T().default(!1),walletLockEnabled:T().default(!0),agreementAccepted:T().default(!1),createdAt:A(),updatedAt:A()}).passthrough();D({version:A(),createdAt:A(),lastMigratedAt:A().optional()}).passthrough();const U=D({id:f(),chain:f(),address:f(),name:f(),note:f().optional(),createdAt:A(),updatedAt:A()}).passthrough(),ze="bfm-wallet-db",Re=1;class Be{db=null;initialized=!1;async initialize(){if(this.initialized)return;this.db=await Te(ze,Re,{upgrade(a,n,r,i){let c;if(a.objectStoreNames.contains("metadata")||(c=a.createObjectStore("metadata")),a.objectStoreNames.contains("walleter")||a.createObjectStore("walleter"),a.objectStoreNames.contains("wallets")||a.createObjectStore("wallets",{keyPath:"id"}).createIndex("by-chain","primaryChain"),!a.objectStoreNames.contains("chainAddresses")){const o=a.createObjectStore("chainAddresses",{keyPath:"addressKey"});o.createIndex("by-wallet","walletId"),o.createIndex("by-chain","chain")}a.objectStoreNames.contains("addressBook")||a.createObjectStore("addressBook",{keyPath:"id"}).createIndex("by-chain","chain"),n===0&&c?c.put({version:M,createdAt:Date.now()},"main"):n===0&&i.objectStore("metadata").put({version:M,createdAt:Date.now()},"main")}}),this.initialized=!0;const s=(await this.getMetadata())?.version??0;if(s>0&&s<M)throw new fe(s,M);await this.runMigrations()}isInitialized(){return this.initialized}ensureInitialized(){if(!this.initialized||!this.db)throw new m(y.NOT_INITIALIZED,"Storage service not initialized. Call initialize() first.")}async getMetadata(){return this.ensureInitialized(),await this.db.get("metadata","main")??null}async saveWalleterInfo(e){this.ensureInitialized(),await this.db.put("walleter",e,"main")}async getWalleterInfo(){this.ensureInitialized();const e=await this.db.get("walleter","main");if(!e)return null;const s=Fe.safeParse(e);return s.success?s.data:null}async createWallet(e,s,a){if(this.ensureInitialized(),!s||typeof s!="string")throw new m(y.ENCRYPTION_FAILED,"Invalid mnemonic: mnemonic is required");if(!a||typeof a!="string")throw new m(y.ENCRYPTION_FAILED,"Invalid walletLock: wallet lock password is required");if(typeof crypto>"u"||!crypto.subtle)throw new m(y.ENCRYPTION_FAILED,"Web Crypto API is not available. Please use HTTPS or localhost.");try{const n=await _(s,a),r=e.keyType==="mnemonic"?k(s):O(s),i=await R(a,r),c={...e,encryptedMnemonic:n,encryptedWalletLock:i};return await this.db.put("wallets",c),c}catch(n){const r=n instanceof Error?n.message:String(n);throw new m(y.ENCRYPTION_FAILED,`Failed to encrypt wallet data: ${r}`,n instanceof Error?n:void 0)}}async saveWallet(e){this.ensureInitialized(),await this.db.put("wallets",e)}async getWallet(e){this.ensureInitialized();const s=await this.db.get("wallets",e);if(!s)return null;const a=de.safeParse(s);return a.success?a.data:null}async getAllWallets(){this.ensureInitialized();const e=await this.db.getAll("wallets");return P(de,e)}async updateWallet(e,s){this.ensureInitialized();const a=await this.getWallet(e);if(!a)throw new m(y.WALLET_NOT_FOUND,`Wallet not found: ${e}`);await this.db.put("wallets",{...a,...s,updatedAt:Date.now()})}async deleteWallet(e){this.ensureInitialized(),await this.db.delete("wallets",e);const s=await this.getWalletChainAddresses(e),a=this.db.transaction("chainAddresses","readwrite");await Promise.all(s.map(n=>a.store.delete(n.addressKey))),await a.done}async getMnemonic(e,s){this.ensureInitialized();const a=await this.getWallet(e);if(!a)throw new m(y.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!a.encryptedMnemonic)throw new m(y.DECRYPTION_FAILED,"No encrypted mnemonic found for this wallet");try{return await ee(a.encryptedMnemonic,s)}catch(n){throw new m(y.DECRYPTION_FAILED,"Failed to decrypt mnemonic. Wrong password or corrupted data.",n instanceof Error?n:void 0)}}async updateWalletLockEncryption(e,s,a){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new m(y.WALLET_NOT_FOUND,`Wallet not found: ${e}`);const r=await this.getMnemonic(e,s);try{const i=await _(r,a),c=n.keyType==="mnemonic"?k(r):O(r),o=await R(a,c);await this.updateWallet(e,{encryptedMnemonic:i,encryptedWalletLock:o})}catch(i){throw new m(y.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",i instanceof Error?i:void 0)}}async verifyMnemonic(e,s){this.ensureInitialized();const a=await this.getWallet(e);if(!a)throw new m(y.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!a.encryptedWalletLock)throw new m(y.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");try{const n=a.keyType==="mnemonic"?k(s):O(s);return await te(a.encryptedWalletLock,n),!0}catch{return!1}}async resetWalletLockByMnemonic(e,s,a){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new m(y.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!n.encryptedWalletLock)throw new m(y.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");const r=n.keyType==="mnemonic"?k(s):O(s);try{await te(n.encryptedWalletLock,r)}catch{throw new m(y.INVALID_PASSWORD,"Invalid mnemonic/secret: failed to decrypt wallet lock")}try{const i=await _(s,a),c=await R(a,r);await this.updateWallet(e,{encryptedMnemonic:i,encryptedWalletLock:c})}catch(i){throw new m(y.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",i instanceof Error?i:void 0)}}async savePrivateKey(e,s,a){this.ensureInitialized();const n=await this.getChainAddress(e);if(!n)throw new m(y.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);try{const r=await _(s,a);await this.db.put("chainAddresses",{...n,encryptedPrivateKey:r})}catch(r){throw new m(y.ENCRYPTION_FAILED,"Failed to encrypt private key",r instanceof Error?r:void 0)}}async getPrivateKey(e,s){this.ensureInitialized();const a=await this.getChainAddress(e);if(!a)throw new m(y.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);if(!a.encryptedPrivateKey)throw new m(y.DECRYPTION_FAILED,"No encrypted private key found for this address");try{return await ee(a.encryptedPrivateKey,s)}catch(n){throw new m(y.DECRYPTION_FAILED,"Failed to decrypt private key. Wrong password or corrupted data.",n instanceof Error?n:void 0)}}async saveChainAddress(e){this.ensureInitialized(),await this.db.put("chainAddresses",e)}async getChainAddress(e){this.ensureInitialized();const s=await this.db.get("chainAddresses",e);if(!s)return null;const a=x.safeParse(s);return a.success?a.data:null}async getWalletChainAddresses(e){this.ensureInitialized();const s=await this.db.getAllFromIndex("chainAddresses","by-wallet",e);return P(x,s)}async getChainAddresses(e){this.ensureInitialized();const s=await this.db.getAllFromIndex("chainAddresses","by-chain",e);return P(x,s)}async updateAssets(e,s){this.ensureInitialized();const a=await this.getChainAddress(e);if(!a)throw new m(y.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);await this.db.put("chainAddresses",{...a,assets:s,isCustomAssets:!0})}async deleteChainAddress(e){this.ensureInitialized(),await this.db.delete("chainAddresses",e)}async saveAddressBookEntry(e){this.ensureInitialized(),await this.db.put("addressBook",e)}async getAddressBookEntry(e){this.ensureInitialized();const s=await this.db.get("addressBook",e);if(!s)return null;const a=U.safeParse(s);return a.success?a.data:null}async getAllAddressBookEntries(){this.ensureInitialized();const e=await this.db.getAll("addressBook");return P(U,e)}async getChainAddressBookEntries(e){this.ensureInitialized();const s=await this.db.getAllFromIndex("addressBook","by-chain",e);return P(U,s)}async deleteAddressBookEntry(e){this.ensureInitialized(),await this.db.delete("addressBook",e)}async clearAll(){this.ensureInitialized();const e=this.db.transaction(["walleter","wallets","chainAddresses","addressBook"],"readwrite");await Promise.all([e.objectStore("walleter").clear(),e.objectStore("wallets").clear(),e.objectStore("chainAddresses").clear(),e.objectStore("addressBook").clear()]),await e.done}close(){this.db&&(this.db.close(),this.db=null,this.initialized=!1)}async runMigrations(){await this.getMetadata()}async migrateFromLocalStorage(){this.ensureInitialized();const e=localStorage.getItem("bfm_wallets");if(!e)return!1;try{const{wallets:s,currentWalletId:a}=JSON.parse(e);for(const r of s){const i={id:r.id,name:r.name,keyType:r.keyType||"mnemonic",primaryChain:r.chain,primaryAddress:r.address,encryptedMnemonic:r.encryptedMnemonic,isBackedUp:!1,createdAt:r.createdAt,updatedAt:Date.now()};if(await this.saveWallet(i),r.chainAddresses)for(const c of r.chainAddresses){const d={addressKey:`${r.id}:${c.chain}`,walletId:r.id,chain:c.chain,address:c.address,assets:[],isCustomAssets:!1,isFrozen:!1};await this.saveChainAddress(d)}}const n=await this.getWalleterInfo();return n?a&&await this.saveWalleterInfo({...n,activeWalletId:a,updatedAt:Date.now()}):await this.saveWalleterInfo({name:"User",activeWalletId:a,biometricEnabled:!1,walletLockEnabled:!1,agreementAccepted:!0,createdAt:Date.now(),updatedAt:Date.now()}),localStorage.removeItem("bfm_wallets"),!0}catch(s){throw new m(y.MIGRATION_FAILED,"Failed to migrate data from localStorage",s instanceof Error?s:void 0)}}}const p=new Be;function le(t){let e=0;for(let s=0;s<t.length;s++){const a=t.charCodeAt(s);e=(e<<5)-e+a,e=e&e}return Math.abs(e)%360}const ye="wallet_chain_preferences";function Ke(){try{const t=localStorage.getItem(ye);if(t)return JSON.parse(t)}catch{}return{}}function b(t){try{localStorage.setItem(ye,JSON.stringify(t))}catch{}}function L(t,e){return!t||t.chainAddresses.some(s=>s.chain===e)?e:t.chainAddresses[0]?.chain??t.chain??e}const J={wallets:[],currentWalletId:null,selectedChain:"ethereum",chainPreferences:{},isLoading:!1,isInitialized:!1,migrationRequired:!1},w=new Q(J);function xe(t,e){const s=t.keyType==="mnemonic"?"mnemonic":"arbitrary",a={id:t.id,name:t.name,keyType:s,address:t.primaryAddress,chain:t.primaryChain,createdAt:t.createdAt,chainAddresses:e.map(n=>({chain:n.chain,address:n.address,publicKey:n.publicKey??""})),themeHue:t.themeHue??0};return t.encryptedMnemonic&&(a.encryptedMnemonic=t.encryptedMnemonic),t.encryptedWalletLock&&(a.encryptedWalletLock=t.encryptedWalletLock),a}const Ue={initialize:async()=>{const t=w.state;if(!(t.isInitialized||t.isLoading)){w.setState(e=>({...e,isLoading:!0}));try{await p.initialize(),await p.migrateFromLocalStorage();const[e,s]=await Promise.all([p.getWalleterInfo(),p.getAllWallets()]),a=await Promise.all(s.map(async l=>{const S=await p.getWalletChainAddresses(l.id);return xe(l,S)})),n=Ke(),r=e?.activeWalletId??a[0]?.id??null,i={...n};let c=!1;for(const l of a){const S=i[l.id]??l.chain??"bfmeta",u=L(l,S);i[l.id]!==u&&(i[l.id]=u,c=!0)}c&&b(i);const o=a.find(l=>l.id===r),d=r?i[r]??o?.chain??"bfmeta":"bfmeta",h=L(o,d);w.setState(l=>({...l,wallets:a,currentWalletId:r,selectedChain:h,chainPreferences:i,isInitialized:!0,isLoading:!1}))}catch(e){if(e instanceof fe){w.setState(s=>({...s,isInitialized:!0,isLoading:!1,migrationRequired:!0}));return}w.setState(s=>({...s,isInitialized:!0,isLoading:!1}))}}},createWallet:async(t,e,s,a)=>{const n=crypto.randomUUID(),r=Date.now(),i={id:n,name:t.name,keyType:t.keyType??"mnemonic",primaryChain:t.chain,primaryAddress:t.address,isBackedUp:!1,themeHue:a??le(e),createdAt:r,updatedAt:r},c=await p.createWallet(i,e,s),o=t.chainAddresses||[{chain:t.chain,address:t.address,publicKey:"",tokens:[]}];for(const l of o)await p.saveChainAddress({addressKey:`${n}:${l.chain}`,walletId:n,chain:l.chain,address:l.address,publicKey:l.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});const d=await p.getWalleterInfo();await p.saveWalleterInfo({name:d?.name??"User",activeWalletId:n,biometricEnabled:d?.biometricEnabled??!1,walletLockEnabled:d?.walletLockEnabled??!1,agreementAccepted:!0,createdAt:d?.createdAt??r,updatedAt:r});const h={id:n,name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:r,chainAddresses:o,themeHue:a??le(e),...c.encryptedMnemonic?{encryptedMnemonic:c.encryptedMnemonic}:{}};return w.setState(l=>{const S=L(h,h.chain),u={...l.chainPreferences,[n]:S};return b(u),{...l,wallets:[...l.wallets,h],currentWalletId:n,selectedChain:S,chainPreferences:u}}),h},importWallet:async(t,e,s)=>Ue.createWallet(t,e,s),deleteWallet:async t=>{await p.deleteWallet(t),w.setState(e=>{const s=e.wallets.filter(h=>h.id!==t),a=e.currentWalletId===t?s[0]?.id??null:e.currentWalletId,{[t]:n,...r}=e.chainPreferences;b(r);const i=s.find(h=>h.id===a),c=a?r[a]??i?.chain??"bfmeta":e.selectedChain,o=L(i,c),d=a&&r[a]!==o?{...r,[a]:o}:r;return d!==r&&b(d),{...e,wallets:s,currentWalletId:a,selectedChain:o,chainPreferences:d}})},setCurrentWallet:async t=>{w.setState(s=>{const a=s.wallets.find(c=>c.id===t);if(!a)return s;const n=s.chainPreferences[t]??a.chain??"bfmeta",r=L(a,n),i=s.chainPreferences[t]!==r?{...s.chainPreferences,[t]:r}:s.chainPreferences;return i!==s.chainPreferences&&b(i),{...s,currentWalletId:t,selectedChain:r,chainPreferences:i}});const e=await p.getWalleterInfo();e&&await p.saveWalleterInfo({...e,activeWalletId:t,updatedAt:Date.now()})},setSelectedChain:t=>{w.setState(e=>{const{currentWalletId:s,chainPreferences:a}=e;if(s){const n={...a,[s]:t};return b(n),{...e,selectedChain:t,chainPreferences:n}}return{...e,selectedChain:t}})},updateWalletName:async(t,e)=>{await p.updateWallet(t,{name:e}),w.setState(s=>({...s,wallets:s.wallets.map(a=>a.id===t?{...a,name:e}:a)}))},updateWalletThemeHue:async(t,e)=>{await p.updateWallet(t,{themeHue:e}),w.setState(s=>({...s,wallets:s.wallets.map(a=>a.id===t?{...a,themeHue:e}:a)}))},updateWalletLock:async(t,e,s)=>{await p.updateWalletLockEncryption(t,e,s);const a=await p.getWallet(t);a?.encryptedMnemonic&&a.encryptedWalletLock&&w.setState(n=>({...n,wallets:n.wallets.map(r=>r.id===t?{...r,encryptedMnemonic:a.encryptedMnemonic,encryptedWalletLock:a.encryptedWalletLock}:r)}))},verifyMnemonic:async(t,e)=>p.verifyMnemonic(t,e),resetWalletLockByMnemonic:async(t,e,s)=>{await p.resetWalletLockByMnemonic(t,e,s);const a=await p.getWallet(t);a?.encryptedMnemonic&&a.encryptedWalletLock&&w.setState(n=>({...n,wallets:n.wallets.map(r=>r.id===t?{...r,encryptedMnemonic:a.encryptedMnemonic,encryptedWalletLock:a.encryptedWalletLock}:r)}))},getMnemonic:async(t,e)=>p.getMnemonic(t,e),updateWalletChainAddresses:async(t,e,s,a)=>{const r=w.state.wallets.find(u=>u.id===t);if(!r)throw new Error("Wallet not found");const i=await p.getMnemonic(t,s),c=new Set(r.chainAddresses.map(u=>u.chain)),o=new Set(e),d=e.filter(u=>!c.has(u)),h=[...c].filter(u=>!o.has(u));if(d.length===0&&h.length===0)return;let l=[];if(d.length>0){const{deriveWalletChainAddresses:u}=await Ae(async()=>{const{deriveWalletChainAddresses:W}=await import("./index-BRe906n0.js");return{deriveWalletChainAddresses:W}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10]),import.meta.url),N=a.filter(W=>d.includes(W.id));l=(await u({mnemonic:i,chainConfigs:N,selectedChainIds:d})).map(W=>({chain:W.chainId,address:W.address,publicKey:W.publicKey??""}))}for(const u of l)await p.saveChainAddress({addressKey:`${t}:${u.chain}`,walletId:t,chain:u.chain,address:u.address,publicKey:u.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});for(const u of h)await p.deleteChainAddress(`${t}:${u}`);const S=[...r.chainAddresses.filter(u=>!h.includes(u.chain)),...l.map(u=>({chain:u.chain,address:u.address,publicKey:u.publicKey,tokens:[]}))];w.setState(u=>({...u,wallets:u.wallets.map(N=>N.id===t?{...N,chainAddresses:S}:N)}))},clearAll:async()=>{await p.clearAll(),w.setState(()=>J)},_testAddWallet:t=>{const e={id:t.id??crypto.randomUUID(),name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:t.createdAt??Date.now(),chainAddresses:t.chainAddresses??[{chain:t.chain,address:t.address,publicKey:""}],themeHue:t.themeHue,...t.encryptedMnemonic?{encryptedMnemonic:t.encryptedMnemonic}:{}};return w.setState(s=>({...s,wallets:[...s.wallets,e],currentWalletId:s.currentWalletId??e.id,isInitialized:!0})),e},_testReset:()=>{w.setState(()=>J)}},$e={getCurrentWallet:t=>t.currentWalletId&&t.wallets.find(e=>e.id===t.currentWalletId)||null,getCurrentChainAddress:t=>{const e=$e.getCurrentWallet(t);if(!e)return null;const s=L(e,t.selectedChain);return e.chainAddresses.find(a=>a.chain===s)||null},hasWallet:t=>t.wallets.length>0},me={contacts:[],isInitialized:!1},I=new Q(me),X="bfm_address_book",pe=3;function E(t){try{const e={version:pe,contacts:t};localStorage.setItem(X,JSON.stringify(e))}catch{}}function je(){try{const t=localStorage.getItem(X);if(!t)return[];const e=JSON.parse(t);return e.version===pe&&Array.isArray(e.contacts)?e.contacts:[]}catch{return[]}}const Xe={initialize:()=>{const t=je();I.setState(()=>({contacts:t,isInitialized:!0}))},addContact:t=>{if(t.addresses.length>3)throw new Error("Maximum 3 addresses per contact");const e=Date.now(),s={...t,id:crypto.randomUUID(),createdAt:e,updatedAt:e};return I.setState(a=>{const n=[...a.contacts,s];return E(n),{...a,contacts:n}}),s},updateContact:(t,e)=>{I.setState(s=>{const a=s.contacts.map(n=>n.id===t?{...n,...e,updatedAt:Date.now()}:n);return E(a),{...s,contacts:a}})},deleteContact:t=>{I.setState(e=>{const s=e.contacts.filter(a=>a.id!==t);return E(s),{...e,contacts:s}})},addAddressToContact:(t,e)=>{const s={...e,id:crypto.randomUUID()};I.setState(a=>{const n=a.contacts.map(r=>{if(r.id!==t)return r;if(r.addresses.length>=3)throw new Error("Maximum 3 addresses per contact");return{...r,addresses:[...r.addresses,s],updatedAt:Date.now()}});return E(n),{...a,contacts:n}})},removeAddressFromContact:(t,e)=>{I.setState(s=>{const a=s.contacts.map(n=>n.id!==t?n:{...n,addresses:n.addresses.filter(r=>r.id!==e),updatedAt:Date.now()});return E(a),{...s,contacts:a}})},setDefaultAddress:(t,e)=>{I.setState(s=>{const a=s.contacts.map(n=>n.id!==t?n:{...n,addresses:n.addresses.map(r=>({...r,isDefault:r.id===e})),updatedAt:Date.now()});return E(a),{...s,contacts:a}})},importContacts:t=>{if(t.length===0)return 0;let e=0;return I.setState(s=>{const a=s.contacts,n=new Set(a.map(c=>c.name.toLowerCase())),r=t.filter(c=>{const o=c.name.toLowerCase();return n.has(o)?!1:(n.add(o),!0)});if(e=r.length,r.length===0)return s;const i=[...a,...r];return E(i),{...s,contacts:i}}),e},clearAll:()=>{localStorage.removeItem(X),I.setState(()=>me)}},et={getContactByAddress:(t,e)=>{const s=e.toLowerCase();for(const a of t.contacts){const n=a.addresses.find(r=>r.address.toLowerCase()===s);if(n)return{contact:a,matchedAddress:n}}},searchContacts:(t,e)=>{const s=e.toLowerCase();return t.contacts.filter(a=>a.name.toLowerCase().includes(s)||a.addresses.some(n=>n.address.toLowerCase().includes(s)))},suggestContacts:(t,e,s=5)=>{const a=[],n=e&&e.length>0,r=n?e.toLowerCase():"",i=[...t.contacts].toSorted((o,d)=>d.updatedAt-o.updatedAt);for(const o of i){const d=o.addresses;if(d.length!==0){if(!n){const h=d.find(l=>l.isDefault)??d[0];h&&a.push({contact:o,matchedAddress:h,matchType:"name",score:40});continue}for(const h of d){const l=h.address.toLowerCase();l===r?a.push({contact:o,matchedAddress:h,matchType:"exact",score:100}):l.startsWith(r)?a.push({contact:o,matchedAddress:h,matchType:"prefix",score:80}):l.includes(r)&&a.push({contact:o,matchedAddress:h,matchType:"prefix",score:50})}if(o.name.toLowerCase().includes(r)){const h=d.find(l=>l.isDefault)??d[0];h&&a.push({contact:o,matchedAddress:h,matchType:"name",score:60})}}}const c=new Map;for(const o of a){const d=`${o.contact.id}:${o.matchedAddress.id}`,h=c.get(d);(!h||h.score<o.score)&&c.set(d,o)}return Array.from(c.values()).toSorted((o,d)=>d.score!==o.score?d.score-o.score:d.contact.updatedAt-o.contact.updatedAt).slice(0,s)},getContactsByChain:(t,e)=>t.contacts.filter(s=>s.addresses.some(a=>se(a.address,e))),getDefaultAddress:(t,e)=>{const s=e?t.addresses.filter(a=>se(a.address,e)):t.addresses;return s.find(a=>a.isDefault)??s[0]}},we="bfm_user_profile",F=3,q={username:"",avatar:"",selectedWalletIds:[]};function Ye(){try{const t=localStorage.getItem(we);if(t){const e=JSON.parse(t);return{username:e.username??"",avatar:e.avatar??"",selectedWalletIds:Array.isArray(e.selectedWalletIds)?e.selectedWalletIds.slice(0,F):[]}}}catch{}return q}function v(t){try{localStorage.setItem(we,JSON.stringify(t))}catch{}}const g=new Q(Ye()),tt={setUsername(t){g.setState(e=>{const s={...e,username:t.trim()};return v(s),s})},randomizeAvatar(){const t=We(),e=`avatar:${ae(t)}`;g.setState(s=>{const a={...s,avatar:e};return v(a),a})},initializeDefaultAvatar(t){g.setState(e=>{if(e.avatar)return e;const s=Se(t.toLowerCase()),a=`avatar:${ae(s)}`,n={...e,avatar:a};return v(n),n})},toggleWalletSelection(t){let e=!1;return g.setState(s=>{const a=s.selectedWalletIds,n=a.includes(t);let r;if(n)r=a.filter(c=>c!==t);else{if(a.length>=F)return s;r=[...a,t],e=!0}const i={...s,selectedWalletIds:r};return v(i),i}),e},setSelectedWalletIds(t){g.setState(e=>{const s={...e,selectedWalletIds:t.slice(0,F)};return v(s),s})},clear(){g.setState(()=>(v(q),q))}};function st(){return Z(g)}function at(){return Z(g,t=>t.selectedWalletIds)}function nt(){return Z(g,t=>t.selectedWalletIds.length<F)}export{m as W,Xe as a,et as b,I as c,p as d,$e as e,Ue as f,y as g,at as h,nt as i,tt as j,Be as k,M as l,fe as m,g as n,Te as o,st as u,w};
