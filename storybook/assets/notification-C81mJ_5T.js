import{d as N}from"./breakpoint-C1BNOfKS.js";import{A as D}from"./amount-BQsqQYGO.js";import{C as J,D as G,A as K,a as V,g as P,I as Y,S as R,d as q,t as L}from"./index-BgynVEcu.js";import{c as Q,a as y,o as c,b as g,s,n as f,d as X,l as Z,_ as A}from"./schemas-B18CumQY.js";import{b as E,o as tt}from"./user-profile-BcdT9kbr.js";import{i as z,g as F,a as et}from"./index-C9Fec6lp.js";import{m as at}from"./transaction-meta-DTHRoAxH.js";import{S as it}from"./iframe-DP2WwkEK.js";const H=Q(e=>e instanceof D),_=y(["send","receive","signature","stake","unstake","destroy","gift","grab","trust","signFor","emigrate","immigrate","exchange","swap","issueAsset","increaseAsset","mint","issueEntity","destroyEntity","locationName","dapp","certificate","approve","interaction","mark","other"]),B=c({id:s(),type:_,status:y(["pending","confirmed","failed"]),amount:H,symbol:s(),decimals:f(),address:s(),timestamp:X(),hash:s().optional(),chain:s(),fee:H.optional(),feeSymbol:s().optional(),feeDecimals:f().optional(),blockNumber:f().optional(),confirmations:f().optional(),from:s().optional(),to:s().optional(),action:K.optional(),direction:G.optional(),assets:g(V).optional(),contract:J.optional()}),nt=c({chain:s().optional(),period:y(["7d","30d","90d","all"]).optional(),type:_.or(Z("all")).optional(),status:y(["pending","confirmed","failed","all"]).optional()}),st=N("transaction",e=>e.description("交易服务").api("getHistory",c({walletId:s(),filter:nt.optional()}),g(B)).api("getTransaction",c({id:s()}),B.nullable()).api("refresh",c({walletId:s()}),A())),T=new Map;function rt(e){const[t,a]=e.split("--");return!t||!a?null:{chainId:t,hash:a}}async function M(e,t){await E.initialize();const a=await z(),i=et(a),n=new Map(i.map(u=>[u.id,u])),r=await E.getWalletChainAddresses(e),d=t?.chain&&t.chain!=="all"?t.chain:null,p=r.flatMap(u=>{if(d&&u.chain!==d)return[];const b=n.get(u.chain)??F(a,u.chain);if(!b||!b.enabled)return[];try{return P(u.chain).transactionHistory.fetch({address:u.address,limit:50}).then(j=>j.map(W=>$(W,b))).catch(()=>[])}catch{return[]}});let o=(await Promise.all(p)).flat();t&&(o=ut(o,t.chain),o=ct(o,t.period),o=dt(o,t.type),o=lt(o,t.status)),o.sort((u,b)=>b.timestamp.getTime()-u.timestamp.getTime()),T.clear();for(const u of o)T.set(u.id,u);return o}function ot(e,t){const a=e.assets.find(i=>i.assetType==="native"||i.assetType==="token");return a?{value:a.value,symbol:a.symbol,decimals:a.decimals}:{value:"0",symbol:t.symbol,decimals:t.decimals}}function $(e,t){const a=at(e.action,e.direction),i=ot(e,{symbol:t.symbol,decimals:t.decimals}),r=e.action==="transfer"?e.direction==="out"?e.to:e.from:e.contract?.address??e.to??e.from;return{id:`${t.id}--${e.hash}`,type:a,status:e.status,amount:D.fromRaw(i.value,i.decimals,i.symbol),symbol:i.symbol,decimals:i.decimals,address:r,timestamp:new Date(e.timestamp),hash:e.hash,chain:t.id,blockNumber:e.blockNumber?Number(e.blockNumber):void 0,confirmations:void 0,fee:e.fee?D.fromRaw(e.fee.value,e.fee.decimals,e.fee.symbol):void 0,feeSymbol:e.fee?.symbol,feeDecimals:e.fee?.decimals,from:e.from,to:e.to,action:e.action,direction:e.direction,assets:e.assets,contract:e.contract}}function ct(e,t){if(!t||t==="all")return e;const a=t==="7d"?7:t==="30d"?30:90,i=Date.now()-a*24*60*60*1e3;return e.filter(n=>n.timestamp.getTime()>=i)}function dt(e,t){return!t||t==="all"?e:e.filter(a=>a.type===t)}function lt(e,t){return!t||t==="all"?e:e.filter(a=>a.status===t)}function ut(e,t){return!t||t==="all"?e:e.filter(a=>a.chain===t)}st.impl({async getHistory({walletId:e,filter:t}){return M(e,t)},async getTransaction({id:e}){const t=T.get(e);if(t)return t;const a=rt(e);if(!a)return null;const i=await z(),n=F(i,a.chainId);if(!n||!n.enabled)return null;try{const r=P(n.id);if(!r.supports("transaction"))return null;const d=await r.transaction.fetch({hash:a.hash});if(!d)return null;const p=$(d,n);return T.set(p.id,p),p}catch(r){if(r instanceof Y)throw r;return null}},async refresh({walletId:e}){await M(e,{chain:"all",period:"all",type:"all",status:"all"})}});const x=y(["created","broadcasting","broadcasted","confirmed","failed"]),mt=y(["send","receive","signature","stake","unstake","destroy","gift","grab","trust","signFor","emigrate","immigrate","exchange","swap","issueAsset","increaseAsset","mint","issueEntity","destroyEntity","locationName","dapp","certificate","mark","approve","interaction","other"]),O=c({type:mt.optional(),displayAmount:s().optional(),displaySymbol:s().optional(),displayToAddress:s().optional()}).passthrough(),m=c({id:s(),walletId:s(),chainId:s(),fromAddress:s(),status:x,txHash:s(),errorCode:s().optional(),errorMessage:s().optional(),retryCount:f().default(0),confirmedBlockHeight:f().optional(),confirmedAt:f().optional(),createdAt:f(),updatedAt:f(),rawTx:R,meta:O.optional()}),ft=c({walletId:s(),chainId:s(),fromAddress:s(),rawTx:R,meta:O.optional()}),pt=c({id:s(),status:x,txHash:s().optional(),errorCode:s().optional(),errorMessage:s().optional(),confirmedBlockHeight:f().optional(),confirmedAt:f().optional()});N("pendingTx",e=>e.description("未上链交易管理服务 - 专注状态管理，不关心交易内容").api("getAll",c({walletId:s()}),g(m)).api("getById",c({id:s()}),m.nullable()).api("getByStatus",c({walletId:s(),status:x}),g(m)).api("getPending",c({walletId:s()}),g(m)).api("create",ft,m).api("updateStatus",pt,m).api("incrementRetry",c({id:s()}),m).api("delete",c({id:s()}),A()).api("deleteConfirmed",c({walletId:s()}),A()).api("deleteAll",c({walletId:s()}),A()));const ht={isExpired(e,t){const a=e;return typeof a?.effectiveBlockHeight=="number"?t>a.effectiveBlockHeight:!1}};function gt(e){if(e.startsWith("bfmeta")||e.startsWith("bfm")||e==="bioforest")return ht}const yt="bfm-pending-tx-db",bt=1,l="pendingTx";class wt{db=null;initialized=!1;subscribers=new Set;subscribe(t){return this.subscribers.add(t),()=>{this.subscribers.delete(t)}}notify(t,a){this.subscribers.forEach(i=>{try{i(t,a)}catch{}})}async ensureDb(){return this.db&&this.initialized?this.db:(this.db=await tt(yt,bt,{upgrade(t){if(!t.objectStoreNames.contains(l)){const a=t.createObjectStore(l,{keyPath:"id"});a.createIndex("by-wallet","walletId"),a.createIndex("by-status","status"),a.createIndex("by-wallet-status",["walletId","status"])}}}),this.initialized=!0,this.db)}async getAll({walletId:t}){return(await(await this.ensureDb()).getAllFromIndex(l,"by-wallet",t)).map(n=>m.safeParse(n)).filter(n=>n.success).map(n=>n.data).sort((n,r)=>r.createdAt-n.createdAt)}async getById({id:t}){const i=await(await this.ensureDb()).get(l,t);if(!i)return null;const n=m.safeParse(i);return n.success?n.data:null}async getByStatus({walletId:t,status:a}){return(await(await this.ensureDb()).getAllFromIndex(l,"by-wallet-status",[t,a])).map(r=>m.safeParse(r)).filter(r=>r.success).map(r=>r.data).sort((r,d)=>d.createdAt-r.createdAt)}async getPending({walletId:t}){return(await this.getAll({walletId:t})).filter(i=>i.status!=="confirmed")}async create(t){const a=await this.ensureDb(),i=Date.now(),n=t.rawTx.signature,r={id:n,walletId:t.walletId,chainId:t.chainId,fromAddress:t.fromAddress,status:"created",txHash:n,retryCount:0,createdAt:i,updatedAt:i,rawTx:t.rawTx,meta:t.meta};return await a.put(l,r),this.notify(r,"created"),r}async updateStatus(t){const a=await this.ensureDb(),i=await a.get(l,t.id);if(!i)throw new Error(`PendingTx not found: ${t.id}`);const n={...i,status:t.status,updatedAt:Date.now(),...t.txHash!==void 0&&{txHash:t.txHash},...t.errorCode!==void 0&&{errorCode:t.errorCode},...t.errorMessage!==void 0&&{errorMessage:t.errorMessage},...t.confirmedBlockHeight!==void 0&&{confirmedBlockHeight:t.confirmedBlockHeight},...t.confirmedAt!==void 0&&{confirmedAt:t.confirmedAt}};return await a.put(l,n),this.notify(n,"updated"),n}async incrementRetry({id:t}){const a=await this.ensureDb(),i=await a.get(l,t);if(!i)throw new Error(`PendingTx not found: ${t}`);const n={...i,retryCount:(i.retryCount??0)+1,updatedAt:Date.now()};return await a.put(l,n),this.notify(n,"updated"),n}async delete({id:t}){const a=await this.ensureDb(),i=await a.get(l,t);await a.delete(l,t),i&&this.notify(i,"deleted")}async deleteConfirmed({walletId:t}){const a=await this.getByStatus({walletId:t,status:"confirmed"}),n=(await this.ensureDb()).transaction(l,"readwrite");await Promise.all(a.map(r=>n.store.delete(r.id))),await n.done}async deleteExpired({walletId:t,maxAge:a,currentBlockHeight:i}){const n=await this.getAll({walletId:t}),r=Date.now(),d=n.filter(o=>o.status==="confirmed"||o.status==="failed"?r-o.updatedAt>a:!!(i!==void 0&&gt(o.chainId)?.isExpired(o.rawTx,i)));if(d.length===0)return 0;const v=(await this.ensureDb()).transaction(l,"readwrite");return await Promise.all(d.map(o=>v.store.delete(o.id))),await v.done,d.length}async deleteAll({walletId:t}){const a=await this.getAll({walletId:t}),n=(await this.ensureDb()).transaction(l,"readwrite");await Promise.all(a.map(r=>n.store.delete(r.id))),await n.done}}const I=new wt,C=new Map;function xt(e,t){const a=`${e}:${t}`;if(!C.has(a)){const i=P(e);if(!i?.supports("blockHeight"))return null;const n=q({name:`pendingTx.${e}.${t}`,source:i.blockHeight,outputSchema:g(m),use:[L({transform:async()=>{const r=await I.getPending({walletId:t});for(const d of r)if(d.status==="broadcasted"&&d.txHash)try{(await i.transaction.fetch({txHash:d.txHash}))?.status==="confirmed"&&await I.delete({id:d.id})}catch(p){console.error("检查pending交易状态失败",p)}return await I.getPending({walletId:t})}})]});C.set(a,n)}return C.get(a)}const U={notifications:[],unreadCount:0,isInitialized:!1},h=new it(U),k="bfm_notifications";function w(e){try{localStorage.setItem(k,JSON.stringify(e))}catch{}}function S(e){return e.filter(t=>!t.read).length}const Et={initialize:()=>{try{const e=localStorage.getItem(k);if(e){const t=JSON.parse(e);h.setState(()=>({notifications:t,unreadCount:S(t),isInitialized:!0}))}else h.setState(t=>({...t,isInitialized:!0}))}catch{h.setState(t=>({...t,isInitialized:!0}))}},add:e=>{const t={...e,id:crypto.randomUUID(),timestamp:Date.now(),read:!1};return h.setState(a=>{const i=[t,...a.notifications];return w(i),{...a,notifications:i,unreadCount:S(i)}}),t},markRead:e=>{h.setState(t=>{const a=t.notifications.map(i=>i.id===e?{...i,read:!0}:i);return w(a),{...t,notifications:a,unreadCount:S(a)}})},markAllRead:()=>{h.setState(e=>{const t=e.notifications.map(a=>({...a,read:!0}));return w(t),{...e,notifications:t,unreadCount:0}})},remove:e=>{h.setState(t=>{const a=t.notifications.filter(i=>i.id!==e);return w(a),{...t,notifications:a,unreadCount:S(a)}})},clearAll:()=>{localStorage.removeItem(k),h.setState(()=>U)}};export{h as a,xt as g,Et as n,I as p};
