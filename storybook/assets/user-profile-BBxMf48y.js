const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./index-Zj5BgaSs.js","./index-C0kkUY8Z.js","./schemas-B18CumQY.js","./iframe-Cr_UN5ps.js","./preload-helper-PPVm8Dsz.js","./iframe-C8gzpSAu.css","./index-COveLHHP.js","./amount-BQsqQYGO.js","./index-D0E7N0oa.js","./bioforest-cU8m0mjs.js"])))=>i.map(i=>d[i]);
import{_ as we}from"./preload-helper-PPVm8Dsz.js";import"./index-D0E7N0oa.js";import{e as v,b as N,c as _,f as M,g as Q,h as Z}from"./bioforest-cU8m0mjs.js";import{o as D,n as A,e as b,s as l,a as Ae,b as Ie}from"./schemas-B18CumQY.js";import{S as H,u as J}from"./iframe-Cr_UN5ps.js";import{d as X,a as ge,e as ee,g as Se}from"./avatar-codec-BFrRl5jW.js";const K=(t,e)=>e.some(a=>t instanceof a);let te,ae;function We(){return te||(te=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function Ee(){return ae||(ae=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const x=new WeakMap,F=new WeakMap,P=new WeakMap;function De(t){const e=new Promise((a,s)=>{const n=()=>{t.removeEventListener("success",r),t.removeEventListener("error",o)},r=()=>{a(E(t.result)),n()},o=()=>{s(t.error),n()};t.addEventListener("success",r),t.addEventListener("error",o)});return P.set(e,t),e}function Ce(t){if(x.has(t))return;const e=new Promise((a,s)=>{const n=()=>{t.removeEventListener("complete",r),t.removeEventListener("error",o),t.removeEventListener("abort",o)},r=()=>{a(),n()},o=()=>{s(t.error||new DOMException("AbortError","AbortError")),n()};t.addEventListener("complete",r),t.addEventListener("error",o),t.addEventListener("abort",o)});x.set(t,e)}let U={get(t,e,a){if(t instanceof IDBTransaction){if(e==="done")return x.get(t);if(e==="store")return a.objectStoreNames[1]?void 0:a.objectStore(a.objectStoreNames[0])}return E(t[e])},set(t,e,a){return t[e]=a,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function de(t){U=t(U)}function be(t){return Ee().includes(t)?function(...e){return t.apply($(this),e),E(this.request)}:function(...e){return E(t.apply($(this),e))}}function Le(t){return typeof t=="function"?be(t):(t instanceof IDBTransaction&&Ce(t),K(t,We())?new Proxy(t,U):t)}function E(t){if(t instanceof IDBRequest)return De(t);if(F.has(t))return F.get(t);const e=Le(t);return e!==t&&(F.set(t,e),P.set(e,t)),e}const $=t=>P.get(t);function Te(t,e,{blocked:a,upgrade:s,blocking:n,terminated:r}={}){const o=indexedDB.open(t,e),c=E(o);return s&&o.addEventListener("upgradeneeded",i=>{s(E(o.result),i.oldVersion,i.newVersion,E(o.transaction),i)}),a&&o.addEventListener("blocked",i=>a(i.oldVersion,i.newVersion,i)),c.then(i=>{r&&i.addEventListener("close",()=>r()),n&&i.addEventListener("versionchange",d=>n(d.oldVersion,d.newVersion,d))}).catch(()=>{}),c}const ve=["get","getKey","getAll","getAllKeys","count"],Ne=["put","add","delete","clear"],z=new Map;function se(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(z.get(e))return z.get(e);const a=e.replace(/FromIndex$/,""),s=e!==a,n=Ne.includes(a);if(!(a in(s?IDBIndex:IDBObjectStore).prototype)||!(n||ve.includes(a)))return;const r=async function(o,...c){const i=this.transaction(o,n?"readwrite":"readonly");let d=i.store;return s&&(d=d.index(c.shift())),(await Promise.all([d[a](...c),n&&i.done]))[0]};return z.set(e,r),r}de(t=>({...t,get:(e,a,s)=>se(e,a)||t.get(e,a,s),has:(e,a)=>!!se(e,a)||t.has(e,a)}));const _e=["continue","continuePrimaryKey","advance"],ne={},j=new WeakMap,le=new WeakMap,ke={get(t,e){if(!_e.includes(e))return t[e];let a=ne[e];return a||(a=ne[e]=function(...s){j.set(this,le.get(this)[e](...s))}),a}};async function*Oe(...t){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...t)),!e)return;e=e;const a=new Proxy(e,ke);for(le.set(a,e),P.set(a,$(e));e;)yield a,e=await(j.get(a)||e.continue()),j.delete(a)}function re(t,e){return e===Symbol.asyncIterator&&K(t,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&K(t,[IDBIndex,IDBObjectStore])}de(t=>({...t,get(e,a,s){return re(e,a)?Oe:t.get(e,a,s)},has(e,a){return re(e,a)||t.has(e,a)}}));function T(t,e,a){if(!Array.isArray(e))return[];const s=[];for(let n=0;n<e.length;n++){const r=t.safeParse(e[n]);r.success&&s.push(r.data)}return s}const k=2;var h=(t=>(t.NOT_INITIALIZED="STORAGE_NOT_INITIALIZED",t.WALLET_NOT_FOUND="WALLET_NOT_FOUND",t.ADDRESS_NOT_FOUND="ADDRESS_NOT_FOUND",t.DECRYPTION_FAILED="DECRYPTION_FAILED",t.ENCRYPTION_FAILED="ENCRYPTION_FAILED",t.STORAGE_FULL="STORAGE_FULL",t.MIGRATION_FAILED="MIGRATION_FAILED",t.INVALID_PASSWORD="INVALID_PASSWORD",t))(h||{});class f extends Error{constructor(e,a,s){super(a),this.code=e,this.cause=s,this.name="WalletStorageError"}}class ue extends Error{code="WALLET_MIGRATION_REQUIRED";storedVersion;requiredVersion;constructor(e,a){super(`Wallet storage migration required: v${e} â†’ v${a}`),this.name="WalletStorageMigrationError",this.storedVersion=e,this.requiredVersion=a}}const Y=D({salt:l(),iv:l(),ciphertext:l()}).passthrough(),Pe=D({assetType:l(),symbol:l(),decimals:A(),balance:l().default("0"),contractAddress:l().optional(),logoUrl:l().optional()}).passthrough(),R=D({addressKey:l(),walletId:l(),chain:l(),address:l(),publicKey:l().optional(),encryptedPrivateKey:Y.optional(),derivationPath:l().optional(),assets:Ie(Pe).default([]),isCustomAssets:b().default(!1),isFrozen:b().default(!1)}).passthrough(),ie=D({id:l(),name:l(),keyType:Ae(["mnemonic","arbitrary","privateKey"]),primaryChain:l(),primaryAddress:l(),encryptedMnemonic:Y.optional(),encryptedWalletLock:Y.optional(),isBackedUp:b().default(!1),themeHue:A().optional(),createdAt:A(),updatedAt:A()}).passthrough(),Me=D({name:l(),passwordTips:l().optional(),activeWalletId:l().nullable(),biometricEnabled:b().default(!1),walletLockEnabled:b().default(!0),agreementAccepted:b().default(!1),createdAt:A(),updatedAt:A()}).passthrough();D({version:A(),createdAt:A(),lastMigratedAt:A().optional()}).passthrough();const B=D({id:l(),chain:l(),address:l(),name:l(),note:l().optional(),createdAt:A(),updatedAt:A()}).passthrough(),Fe="bfm-wallet-db",ze=1;class Re{db=null;initialized=!1;async initialize(){if(this.initialized)return;this.db=await Te(Fe,ze,{upgrade(s,n,r,o){let c;if(s.objectStoreNames.contains("metadata")||(c=s.createObjectStore("metadata")),s.objectStoreNames.contains("walleter")||s.createObjectStore("walleter"),s.objectStoreNames.contains("wallets")||s.createObjectStore("wallets",{keyPath:"id"}).createIndex("by-chain","primaryChain"),!s.objectStoreNames.contains("chainAddresses")){const i=s.createObjectStore("chainAddresses",{keyPath:"addressKey"});i.createIndex("by-wallet","walletId"),i.createIndex("by-chain","chain")}s.objectStoreNames.contains("addressBook")||s.createObjectStore("addressBook",{keyPath:"id"}).createIndex("by-chain","chain"),n===0&&c?c.put({version:k,createdAt:Date.now()},"main"):n===0&&o.objectStore("metadata").put({version:k,createdAt:Date.now()},"main")}}),this.initialized=!0;const a=(await this.getMetadata())?.version??0;if(a>0&&a<k)throw new ue(a,k);await this.runMigrations()}isInitialized(){return this.initialized}ensureInitialized(){if(!this.initialized||!this.db)throw new f(h.NOT_INITIALIZED,"Storage service not initialized. Call initialize() first.")}async getMetadata(){return this.ensureInitialized(),await this.db.get("metadata","main")??null}async saveWalleterInfo(e){this.ensureInitialized(),await this.db.put("walleter",e,"main")}async getWalleterInfo(){this.ensureInitialized();const e=await this.db.get("walleter","main");if(!e)return null;const a=Me.safeParse(e);return a.success?a.data:null}async createWallet(e,a,s){if(this.ensureInitialized(),!a||typeof a!="string")throw new f(h.ENCRYPTION_FAILED,"Invalid mnemonic: mnemonic is required");if(!s||typeof s!="string")throw new f(h.ENCRYPTION_FAILED,"Invalid walletLock: wallet lock password is required");if(typeof crypto>"u"||!crypto.subtle)throw new f(h.ENCRYPTION_FAILED,"Web Crypto API is not available. Please use HTTPS or localhost.");try{const n=await v(a,s),r=e.keyType==="mnemonic"?N(a):_(a),o=await M(s,r),c={...e,encryptedMnemonic:n,encryptedWalletLock:o};return await this.db.put("wallets",c),c}catch(n){const r=n instanceof Error?n.message:String(n);throw new f(h.ENCRYPTION_FAILED,`Failed to encrypt wallet data: ${r}`,n instanceof Error?n:void 0)}}async saveWallet(e){this.ensureInitialized(),await this.db.put("wallets",e)}async getWallet(e){this.ensureInitialized();const a=await this.db.get("wallets",e);if(!a)return null;const s=ie.safeParse(a);return s.success?s.data:null}async getAllWallets(){this.ensureInitialized();const e=await this.db.getAll("wallets");return T(ie,e)}async updateWallet(e,a){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new f(h.WALLET_NOT_FOUND,`Wallet not found: ${e}`);await this.db.put("wallets",{...s,...a,updatedAt:Date.now()})}async deleteWallet(e){this.ensureInitialized(),await this.db.delete("wallets",e);const a=await this.getWalletChainAddresses(e),s=this.db.transaction("chainAddresses","readwrite");await Promise.all(a.map(n=>s.store.delete(n.addressKey))),await s.done}async getMnemonic(e,a){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new f(h.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!s.encryptedMnemonic)throw new f(h.DECRYPTION_FAILED,"No encrypted mnemonic found for this wallet");try{return await Q(s.encryptedMnemonic,a)}catch(n){throw new f(h.DECRYPTION_FAILED,"Failed to decrypt mnemonic. Wrong password or corrupted data.",n instanceof Error?n:void 0)}}async updateWalletLockEncryption(e,a,s){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new f(h.WALLET_NOT_FOUND,`Wallet not found: ${e}`);const r=await this.getMnemonic(e,a);try{const o=await v(r,s),c=n.keyType==="mnemonic"?N(r):_(r),i=await M(s,c);await this.updateWallet(e,{encryptedMnemonic:o,encryptedWalletLock:i})}catch(o){throw new f(h.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",o instanceof Error?o:void 0)}}async verifyMnemonic(e,a){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new f(h.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!s.encryptedWalletLock)throw new f(h.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");try{const n=s.keyType==="mnemonic"?N(a):_(a);return await Z(s.encryptedWalletLock,n),!0}catch{return!1}}async resetWalletLockByMnemonic(e,a,s){this.ensureInitialized();const n=await this.getWallet(e);if(!n)throw new f(h.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!n.encryptedWalletLock)throw new f(h.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");const r=n.keyType==="mnemonic"?N(a):_(a);try{await Z(n.encryptedWalletLock,r)}catch{throw new f(h.INVALID_PASSWORD,"Invalid mnemonic/secret: failed to decrypt wallet lock")}try{const o=await v(a,s),c=await M(s,r);await this.updateWallet(e,{encryptedMnemonic:o,encryptedWalletLock:c})}catch(o){throw new f(h.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",o instanceof Error?o:void 0)}}async savePrivateKey(e,a,s){this.ensureInitialized();const n=await this.getChainAddress(e);if(!n)throw new f(h.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);try{const r=await v(a,s);await this.db.put("chainAddresses",{...n,encryptedPrivateKey:r})}catch(r){throw new f(h.ENCRYPTION_FAILED,"Failed to encrypt private key",r instanceof Error?r:void 0)}}async getPrivateKey(e,a){this.ensureInitialized();const s=await this.getChainAddress(e);if(!s)throw new f(h.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);if(!s.encryptedPrivateKey)throw new f(h.DECRYPTION_FAILED,"No encrypted private key found for this address");try{return await Q(s.encryptedPrivateKey,a)}catch(n){throw new f(h.DECRYPTION_FAILED,"Failed to decrypt private key. Wrong password or corrupted data.",n instanceof Error?n:void 0)}}async saveChainAddress(e){this.ensureInitialized(),await this.db.put("chainAddresses",e)}async getChainAddress(e){this.ensureInitialized();const a=await this.db.get("chainAddresses",e);if(!a)return null;const s=R.safeParse(a);return s.success?s.data:null}async getWalletChainAddresses(e){this.ensureInitialized();const a=await this.db.getAllFromIndex("chainAddresses","by-wallet",e);return T(R,a)}async getChainAddresses(e){this.ensureInitialized();const a=await this.db.getAllFromIndex("chainAddresses","by-chain",e);return T(R,a)}async updateAssets(e,a){this.ensureInitialized();const s=await this.getChainAddress(e);if(!s)throw new f(h.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);await this.db.put("chainAddresses",{...s,assets:a,isCustomAssets:!0})}async deleteChainAddress(e){this.ensureInitialized(),await this.db.delete("chainAddresses",e)}async saveAddressBookEntry(e){this.ensureInitialized(),await this.db.put("addressBook",e)}async getAddressBookEntry(e){this.ensureInitialized();const a=await this.db.get("addressBook",e);if(!a)return null;const s=B.safeParse(a);return s.success?s.data:null}async getAllAddressBookEntries(){this.ensureInitialized();const e=await this.db.getAll("addressBook");return T(B,e)}async getChainAddressBookEntries(e){this.ensureInitialized();const a=await this.db.getAllFromIndex("addressBook","by-chain",e);return T(B,a)}async deleteAddressBookEntry(e){this.ensureInitialized(),await this.db.delete("addressBook",e)}async clearAll(){this.ensureInitialized();const e=this.db.transaction(["walleter","wallets","chainAddresses","addressBook"],"readwrite");await Promise.all([e.objectStore("walleter").clear(),e.objectStore("wallets").clear(),e.objectStore("chainAddresses").clear(),e.objectStore("addressBook").clear()]),await e.done}close(){this.db&&(this.db.close(),this.db=null,this.initialized=!1)}async runMigrations(){await this.getMetadata()}async migrateFromLocalStorage(){this.ensureInitialized();const e=localStorage.getItem("bfm_wallets");if(!e)return!1;try{const{wallets:a,currentWalletId:s}=JSON.parse(e);for(const r of a){const o={id:r.id,name:r.name,keyType:r.keyType||"mnemonic",primaryChain:r.chain,primaryAddress:r.address,encryptedMnemonic:r.encryptedMnemonic,isBackedUp:!1,createdAt:r.createdAt,updatedAt:Date.now()};if(await this.saveWallet(o),r.chainAddresses)for(const c of r.chainAddresses){const d={addressKey:`${r.id}:${c.chain}`,walletId:r.id,chain:c.chain,address:c.address,assets:[],isCustomAssets:!1,isFrozen:!1};await this.saveChainAddress(d)}}const n=await this.getWalleterInfo();return n?s&&await this.saveWalleterInfo({...n,activeWalletId:s,updatedAt:Date.now()}):await this.saveWalleterInfo({name:"User",activeWalletId:s,biometricEnabled:!1,walletLockEnabled:!1,agreementAccepted:!0,createdAt:Date.now(),updatedAt:Date.now()}),localStorage.removeItem("bfm_wallets"),!0}catch(a){throw new f(h.MIGRATION_FAILED,"Failed to migrate data from localStorage",a instanceof Error?a:void 0)}}}const y=new Re;function oe(t){let e=0;for(let a=0;a<t.length;a++){const s=t.charCodeAt(a);e=(e<<5)-e+s,e=e&e}return Math.abs(e)%360}const he="wallet_chain_preferences";function Be(){try{const t=localStorage.getItem(he);if(t)return JSON.parse(t)}catch{}return{}}function ce(t){try{localStorage.setItem(he,JSON.stringify(t))}catch{}}const V={wallets:[],currentWalletId:null,selectedChain:"ethereum",chainPreferences:{},isLoading:!1,isInitialized:!1,migrationRequired:!1},w=new H(V);function Ke(t,e){const a=t.keyType==="mnemonic"?"mnemonic":"arbitrary",s={id:t.id,name:t.name,keyType:a,address:t.primaryAddress,chain:t.primaryChain,createdAt:t.createdAt,chainAddresses:e.map(n=>({chain:n.chain,address:n.address,publicKey:n.publicKey??""})),themeHue:t.themeHue??0};return t.encryptedMnemonic&&(s.encryptedMnemonic=t.encryptedMnemonic),t.encryptedWalletLock&&(s.encryptedWalletLock=t.encryptedWalletLock),s}const xe={initialize:async()=>{const t=w.state;if(!(t.isInitialized||t.isLoading)){w.setState(e=>({...e,isLoading:!0}));try{await y.initialize(),await y.migrateFromLocalStorage();const[e,a]=await Promise.all([y.getWalleterInfo(),y.getAllWallets()]),s=await Promise.all(a.map(async i=>{const d=await y.getWalletChainAddresses(i.id);return Ke(i,d)})),n=Be(),r=e?.activeWalletId??s[0]?.id??null,o=s.find(i=>i.id===r),c=r?n[r]??o?.chain??"bfmeta":"bfmeta";w.setState(i=>({...i,wallets:s,currentWalletId:r,selectedChain:c,chainPreferences:n,isInitialized:!0,isLoading:!1}))}catch(e){if(e instanceof ue){w.setState(a=>({...a,isInitialized:!0,isLoading:!1,migrationRequired:!0}));return}w.setState(a=>({...a,isInitialized:!0,isLoading:!1}))}}},createWallet:async(t,e,a,s)=>{const n=crypto.randomUUID(),r=Date.now(),o={id:n,name:t.name,keyType:t.keyType??"mnemonic",primaryChain:t.chain,primaryAddress:t.address,isBackedUp:!1,themeHue:s??oe(e),createdAt:r,updatedAt:r},c=await y.createWallet(o,e,a),i=t.chainAddresses||[{chain:t.chain,address:t.address,publicKey:"",tokens:[]}];for(const p of i)await y.saveChainAddress({addressKey:`${n}:${p.chain}`,walletId:n,chain:p.chain,address:p.address,publicKey:p.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});const d=await y.getWalleterInfo();await y.saveWalleterInfo({name:d?.name??"User",activeWalletId:n,biometricEnabled:d?.biometricEnabled??!1,walletLockEnabled:d?.walletLockEnabled??!1,agreementAccepted:!0,createdAt:d?.createdAt??r,updatedAt:r});const m={id:n,name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:r,chainAddresses:i,themeHue:s??oe(e),...c.encryptedMnemonic?{encryptedMnemonic:c.encryptedMnemonic}:{}};return w.setState(p=>({...p,wallets:[...p.wallets,m],currentWalletId:n})),m},importWallet:async(t,e,a)=>xe.createWallet(t,e,a),deleteWallet:async t=>{await y.deleteWallet(t),w.setState(e=>{const a=e.wallets.filter(i=>i.id!==t),s=e.currentWalletId===t?a[0]?.id??null:e.currentWalletId,{[t]:n,...r}=e.chainPreferences;ce(r);const o=a.find(i=>i.id===s),c=s?r[s]??o?.chain??"bfmeta":e.selectedChain;return{...e,wallets:a,currentWalletId:s,selectedChain:c,chainPreferences:r}})},setCurrentWallet:async t=>{const e=await y.getWalleterInfo();e&&await y.saveWalleterInfo({...e,activeWalletId:t,updatedAt:Date.now()}),w.setState(a=>{const s=a.wallets.find(r=>r.id===t),n=a.chainPreferences[t]??s?.chain??"bfmeta";return{...a,currentWalletId:t,selectedChain:n}})},setSelectedChain:t=>{w.setState(e=>{const{currentWalletId:a,chainPreferences:s}=e;if(a){const n={...s,[a]:t};return ce(n),{...e,selectedChain:t,chainPreferences:n}}return{...e,selectedChain:t}})},updateWalletName:async(t,e)=>{await y.updateWallet(t,{name:e}),w.setState(a=>({...a,wallets:a.wallets.map(s=>s.id===t?{...s,name:e}:s)}))},updateWalletThemeHue:async(t,e)=>{await y.updateWallet(t,{themeHue:e}),w.setState(a=>({...a,wallets:a.wallets.map(s=>s.id===t?{...s,themeHue:e}:s)}))},updateWalletLock:async(t,e,a)=>{await y.updateWalletLockEncryption(t,e,a);const s=await y.getWallet(t);s?.encryptedMnemonic&&s.encryptedWalletLock&&w.setState(n=>({...n,wallets:n.wallets.map(r=>r.id===t?{...r,encryptedMnemonic:s.encryptedMnemonic,encryptedWalletLock:s.encryptedWalletLock}:r)}))},verifyMnemonic:async(t,e)=>y.verifyMnemonic(t,e),resetWalletLockByMnemonic:async(t,e,a)=>{await y.resetWalletLockByMnemonic(t,e,a);const s=await y.getWallet(t);s?.encryptedMnemonic&&s.encryptedWalletLock&&w.setState(n=>({...n,wallets:n.wallets.map(r=>r.id===t?{...r,encryptedMnemonic:s.encryptedMnemonic,encryptedWalletLock:s.encryptedWalletLock}:r)}))},getMnemonic:async(t,e)=>y.getMnemonic(t,e),updateWalletChainAddresses:async(t,e,a,s)=>{const r=w.state.wallets.find(u=>u.id===t);if(!r)throw new Error("Wallet not found");const o=await y.getMnemonic(t,a),c=new Set(r.chainAddresses.map(u=>u.chain)),i=new Set(e),d=e.filter(u=>!c.has(u)),m=[...c].filter(u=>!i.has(u));if(d.length===0&&m.length===0)return;let p=[];if(d.length>0){const{deriveWalletChainAddresses:u}=await we(async()=>{const{deriveWalletChainAddresses:S}=await import("./index-Zj5BgaSs.js");return{deriveWalletChainAddresses:S}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]),import.meta.url),L=s.filter(S=>d.includes(S.id));p=(await u({mnemonic:o,chainConfigs:L,selectedChainIds:d})).map(S=>({chain:S.chainId,address:S.address,publicKey:S.publicKey??""}))}for(const u of p)await y.saveChainAddress({addressKey:`${t}:${u.chain}`,walletId:t,chain:u.chain,address:u.address,publicKey:u.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});for(const u of m)await y.deleteChainAddress(`${t}:${u}`);const pe=[...r.chainAddresses.filter(u=>!m.includes(u.chain)),...p.map(u=>({chain:u.chain,address:u.address,publicKey:u.publicKey,tokens:[]}))];w.setState(u=>({...u,wallets:u.wallets.map(L=>L.id===t?{...L,chainAddresses:pe}:L)}))},clearAll:async()=>{await y.clearAll(),w.setState(()=>V)},_testAddWallet:t=>{const e={id:t.id??crypto.randomUUID(),name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:t.createdAt??Date.now(),chainAddresses:t.chainAddresses??[{chain:t.chain,address:t.address,publicKey:""}],themeHue:t.themeHue,...t.encryptedMnemonic?{encryptedMnemonic:t.encryptedMnemonic}:{}};return w.setState(a=>({...a,wallets:[...a.wallets,e],currentWalletId:a.currentWalletId??e.id,isInitialized:!0})),e},_testReset:()=>{w.setState(()=>V)}},Ue={getCurrentWallet:t=>t.currentWalletId&&t.wallets.find(e=>e.id===t.currentWalletId)||null,getCurrentChainAddress:t=>{const e=Ue.getCurrentWallet(t);return e&&e.chainAddresses.find(a=>a.chain===t.selectedChain)||null},hasWallet:t=>t.wallets.length>0},fe={contacts:[],isInitialized:!1},I=new H(fe),q="bfm_address_book",ye=3;function W(t){try{const e={version:ye,contacts:t};localStorage.setItem(q,JSON.stringify(e))}catch{}}function $e(){try{const t=localStorage.getItem(q);if(!t)return[];const e=JSON.parse(t);return e.version===ye&&Array.isArray(e.contacts)?e.contacts:[]}catch{return[]}}const Ze={initialize:()=>{const t=$e();I.setState(()=>({contacts:t,isInitialized:!0}))},addContact:t=>{if(t.addresses.length>3)throw new Error("Maximum 3 addresses per contact");const e=Date.now(),a={...t,id:crypto.randomUUID(),createdAt:e,updatedAt:e};return I.setState(s=>{const n=[...s.contacts,a];return W(n),{...s,contacts:n}}),a},updateContact:(t,e)=>{I.setState(a=>{const s=a.contacts.map(n=>n.id===t?{...n,...e,updatedAt:Date.now()}:n);return W(s),{...a,contacts:s}})},deleteContact:t=>{I.setState(e=>{const a=e.contacts.filter(s=>s.id!==t);return W(a),{...e,contacts:a}})},addAddressToContact:(t,e)=>{const a={...e,id:crypto.randomUUID()};I.setState(s=>{const n=s.contacts.map(r=>{if(r.id!==t)return r;if(r.addresses.length>=3)throw new Error("Maximum 3 addresses per contact");return{...r,addresses:[...r.addresses,a],updatedAt:Date.now()}});return W(n),{...s,contacts:n}})},removeAddressFromContact:(t,e)=>{I.setState(a=>{const s=a.contacts.map(n=>n.id!==t?n:{...n,addresses:n.addresses.filter(r=>r.id!==e),updatedAt:Date.now()});return W(s),{...a,contacts:s}})},setDefaultAddress:(t,e)=>{I.setState(a=>{const s=a.contacts.map(n=>n.id!==t?n:{...n,addresses:n.addresses.map(r=>({...r,isDefault:r.id===e})),updatedAt:Date.now()});return W(s),{...a,contacts:s}})},importContacts:t=>{if(t.length===0)return 0;let e=0;return I.setState(a=>{const s=a.contacts,n=new Set(s.map(c=>c.name.toLowerCase())),r=t.filter(c=>{const i=c.name.toLowerCase();return n.has(i)?!1:(n.add(i),!0)});if(e=r.length,r.length===0)return a;const o=[...s,...r];return W(o),{...a,contacts:o}}),e},clearAll:()=>{localStorage.removeItem(q),I.setState(()=>fe)}},Xe={getContactByAddress:(t,e)=>{const a=e.toLowerCase();for(const s of t.contacts){const n=s.addresses.find(r=>r.address.toLowerCase()===a);if(n)return{contact:s,matchedAddress:n}}},searchContacts:(t,e)=>{const a=e.toLowerCase();return t.contacts.filter(s=>s.name.toLowerCase().includes(a)||s.addresses.some(n=>n.address.toLowerCase().includes(a)))},suggestContacts:(t,e,a=5)=>{const s=[],n=e&&e.length>0,r=n?e.toLowerCase():"",o=[...t.contacts].toSorted((i,d)=>d.updatedAt-i.updatedAt);for(const i of o){const d=i.addresses;if(d.length!==0){if(!n){const m=d.find(p=>p.isDefault)??d[0];m&&s.push({contact:i,matchedAddress:m,matchType:"name",score:40});continue}for(const m of d){const p=m.address.toLowerCase();p===r?s.push({contact:i,matchedAddress:m,matchType:"exact",score:100}):p.startsWith(r)?s.push({contact:i,matchedAddress:m,matchType:"prefix",score:80}):p.includes(r)&&s.push({contact:i,matchedAddress:m,matchType:"prefix",score:50})}if(i.name.toLowerCase().includes(r)){const m=d.find(p=>p.isDefault)??d[0];m&&s.push({contact:i,matchedAddress:m,matchType:"name",score:60})}}}const c=new Map;for(const i of s){const d=`${i.contact.id}:${i.matchedAddress.id}`,m=c.get(d);(!m||m.score<i.score)&&c.set(d,i)}return Array.from(c.values()).toSorted((i,d)=>d.score!==i.score?d.score-i.score:d.contact.updatedAt-i.contact.updatedAt).slice(0,a)},getContactsByChain:(t,e)=>t.contacts.filter(a=>a.addresses.some(s=>X(s.address).chainType===e)),getDefaultAddress:(t,e)=>{const a=e?t.addresses.filter(s=>X(s.address).chainType===e):t.addresses;return a.find(s=>s.isDefault)??a[0]}},me="bfm_user_profile",O=3,G={username:"",avatar:"",selectedWalletIds:[]};function je(){try{const t=localStorage.getItem(me);if(t){const e=JSON.parse(t);return{username:e.username??"",avatar:e.avatar??"",selectedWalletIds:Array.isArray(e.selectedWalletIds)?e.selectedWalletIds.slice(0,O):[]}}}catch{}return G}function C(t){try{localStorage.setItem(me,JSON.stringify(t))}catch{}}const g=new H(je()),et={setUsername(t){g.setState(e=>{const a={...e,username:t.trim()};return C(a),a})},randomizeAvatar(){const t=Se(),e=`avatar:${ee(t)}`;g.setState(a=>{const s={...a,avatar:e};return C(s),s})},initializeDefaultAvatar(t){g.setState(e=>{if(e.avatar)return e;const a=ge(t.toLowerCase()),s=`avatar:${ee(a)}`,n={...e,avatar:s};return C(n),n})},toggleWalletSelection(t){let e=!1;return g.setState(a=>{const s=a.selectedWalletIds,n=s.includes(t);let r;if(n)r=s.filter(c=>c!==t);else{if(s.length>=O)return a;r=[...s,t],e=!0}const o={...a,selectedWalletIds:r};return C(o),o}),e},setSelectedWalletIds(t){g.setState(e=>{const a={...e,selectedWalletIds:t.slice(0,O)};return C(a),a})},clear(){g.setState(()=>(C(G),G))}};function tt(){return J(g)}function at(){return J(g,t=>t.selectedWalletIds)}function st(){return J(g,t=>t.selectedWalletIds.length<O)}export{f as W,Ze as a,y as b,Xe as c,I as d,Ue as e,xe as f,h as g,at as h,st as i,et as j,Re as k,k as l,ue as m,g as n,Te as o,tt as u,w};
