import{u as d,S as X}from"./iframe-Bu8aE4Do.js";import{o as w,s as c,n as T,a as B,b as K,c as Z,r as z,u as ee,d as ne}from"./schemas-CO8_C8zP.js";import"./index-D0E7N0oa.js";import{u as te}from"./derivation-CRZn86EQ.js";const re=c().regex(/^\d+\.\d+$/,'version must be "major.minor" (e.g. "1.0")'),oe=K(["bioforest","evm","bitcoin","tron"]),W=K(["default","subscription","manual"]),se=w({type:c().min(1),endpoint:c().url(),config:z(c(),ee()).optional()}).strict(),ae=B(se),ie=w({url:c().url(),queryTx:c().optional(),queryAddress:c().optional(),queryBlock:c().optional()}),P=w({id:c().regex(/^[a-z0-9-]+$/,"id must match /^[a-z0-9-]+$/"),version:re,chainKind:oe,name:c().min(1).max(50),symbol:c().min(1).max(10),icon:c().min(1).optional(),tokenIconBase:B(c().min(1)).optional(),tokenIconContract:B(c().min(1)).optional(),prefix:c().min(1).max(10).optional(),decimals:T().int().min(0).max(18),blockTime:T().positive().optional(),apis:ae.optional(),explorer:ie.optional(),enabled:Z().default(!0),source:W.default("default")}).strict(),_=B(P).min(1),ce=w({version:c().regex(/^\d+\.\d+\.\d+$/,'version must be semver (e.g. "2.0.0")'),chains:_}),O=w({url:c().min(1),refreshIntervalMinutes:T().int().min(1).default(1440),lastUpdated:c().optional(),etag:c().optional()}).strict(),ue="bfm_chain_config",le=1,y="chain_configs",f="chain_preferences";let M=null,S=null;const fe=P.omit({enabled:!0,source:!0}),de=w({key:c(),id:c(),source:W,config:fe}),ge=z(c(),ne());function pe(){if(typeof indexedDB>"u")throw new Error("indexedDB is not available in this environment")}function k(e){return new Promise((n,t)=>{e.onsuccess=()=>n(e.result),e.onerror=()=>t(e.error??new Error("IndexedDB request failed"))})}function p(e){return new Promise((n,t)=>{e.oncomplete=()=>n(),e.onerror=()=>t(e.error??new Error("IndexedDB transaction failed")),e.onabort=()=>t(e.error??new Error("IndexedDB transaction aborted"))})}async function h(){if(pe(),M)return M;if(S)return S;S=new Promise((e,n)=>{const t=indexedDB.open(ue,le);t.onupgradeneeded=()=>{const r=t.result;r.objectStoreNames.contains(y)||r.createObjectStore(y,{keyPath:"key"}).createIndex("source","source",{unique:!1}),r.objectStoreNames.contains(f)||r.createObjectStore(f,{keyPath:"key"})},t.onsuccess=()=>e(t.result),t.onerror=()=>n(t.error??new Error("Failed to open IndexedDB"))});try{return M=await S,M}finally{S=null}}async function he(e,n){const t=e.index("source"),r=[];return new Promise((o,s)=>{const a=t.openCursor(IDBKeyRange.only(n));a.onsuccess=()=>{const u=a.result;if(!u){o(r);return}r.push(u.primaryKey),u.continue()},a.onerror=()=>s(a.error??new Error("Failed to read IndexedDB cursor"))})}async function q(e){const t=(await h()).transaction([y],"readwrite"),r=t.objectStore(y),o=await he(r,e.source);for(const s of o)r.delete(s);for(const s of e.configs){const a={id:s.id,version:s.version,chainKind:s.chainKind,name:s.name,symbol:s.symbol,decimals:s.decimals,...s.icon!==void 0?{icon:s.icon}:{},...s.prefix!==void 0?{prefix:s.prefix}:{},...s.apis!==void 0?{apis:s.apis}:{},...s.explorer!==void 0?{explorer:s.explorer}:{}},u={key:`${e.source}:${s.id}`,id:s.id,source:e.source,config:a};r.put(u)}await p(t)}async function $(){const n=(await h()).transaction([y],"readonly"),t=n.objectStore(y),r=await k(t.getAll());await p(n);const o=[];for(const s of r){const a=de.safeParse(s);a.success&&a.data.id===a.data.config.id&&o.push({...a.data.config,source:a.data.source,enabled:!0})}return o}async function me(e){const t=(await h()).transaction([f],"readwrite"),r=t.objectStore(f),o={key:"enabledMap",value:e};r.put(o),await p(t)}async function G(){const n=(await h()).transaction([f],"readonly"),t=n.objectStore(f),r=await k(t.get("enabledMap"));if(await p(n),!r||typeof r!="object")return{};const o=r.value,s=ge.safeParse(o);if(!s.success)return{};const a={};for(const[u,l]of Object.entries(s.data)){if(typeof l=="boolean"){a[u]=l;continue}if(typeof l=="string"){const g=l.trim().toLowerCase();g==="true"||g==="1"?a[u]=!0:(g==="false"||g==="0")&&(a[u]=!1);continue}l===1?a[u]=!0:l===0&&(a[u]=!1)}return a}async function J(e){const t=(await h()).transaction([f],"readwrite"),r=t.objectStore(f),o={key:"subscriptionMeta",value:e};r.put(o),await p(t)}async function j(){const n=(await h()).transaction([f],"readonly"),t=n.objectStore(f),r=await k(t.get("subscriptionMeta"));if(await p(n),!r||typeof r!="object")return null;const o=r.value,s=O.safeParse(o);return s.success?s.data:null}async function be(e){const t=(await h()).transaction([f],"readwrite"),r=t.objectStore(f),o={key:"defaultVersion",value:e};r.put(o),await p(t)}async function ye(){const n=(await h()).transaction([f],"readonly"),t=n.objectStore(f),r=await k(t.get("defaultVersion"));if(await p(n),!r||typeof r!="object")return null;const o=r.value,s=c().safeParse(o);return s.success?s.data:null}const we=1e4;function Ce(e){const n=Array.isArray(e)?_.safeParse(e):P.safeParse(e);if(!n.success){const r=n.error.issues[0];throw new Error(r?.message??"Invalid subscription chain config")}return(Array.isArray(e)?n.data:[n.data]).map(r=>({...r,source:"subscription",enabled:!0}))}function Se(e,n){if(e.length===0)return n;const t=new Map;for(const r of e)t.set(r.id,{...r,source:"subscription",enabled:!0});return[...t.values()]}function ve(e){return e.filter(n=>n.source==="subscription")}async function Ee(e,n){if(e==="default")return{status:"skipped",reason:"default",configs:[],meta:null};const t=await $(),r=ve(t),o=await j(),s=void 0,a=new AbortController,u=setTimeout(()=>a.abort(),we);try{const l=await fetch(e,{method:"GET",signal:a.signal,headers:{Accept:"application/json",...s!==void 0?{"If-None-Match":s}:{}}});if(clearTimeout(u),l.status===304)return{status:"not_modified",configs:r,meta:o};if(!l.ok)return{status:"error",error:`Subscription fetch failed: ${l.status} ${l.statusText}`,configs:r,meta:o};const g=await l.json(),U=Ce(g),I=Se(U,r),C=l.headers.get("ETag")??void 0,A=O.safeParse({url:e,...C!==void 0?{etag:C}:{},lastUpdated:new Date().toISOString()});if(!A.success)return{status:"error",error:"Invalid subscription meta",configs:r,meta:o??null};const b=A.data;return await q({source:"subscription",configs:I}),await J(b),{status:"updated",configs:I,meta:b}}catch(l){return clearTimeout(u),{status:"error",error:l instanceof Error&&l.name==="AbortError"?"Subscription request timeout":l instanceof Error?l.message:"Failed to fetch subscription",configs:r,meta:o??null}}}class Q extends Error{code="MIGRATION_REQUIRED";storedVersion;requiredVersion;constructor(n,t){super(`Database migration required: stored version ${n??"unknown"} is incompatible with ${t}`),this.name="ChainConfigMigrationError",this.storedVersion=n,this.requiredVersion=t}}const H={bioforest:1,evm:1,bitcoin:1,tron:1},xe="./configs/default-chains.json";let D=null,v=null;function Y(e){const n=e.split(".")[0],t=Number(n);return Number.isInteger(t)?t:null}function Ie(e){const n=Y(e.version);return n===null?!1:n<=H[e.chainKind]}function Ae(){const e=typeof window>"u"?"http://localhost/":window.location.href;return new URL(xe,e).toString()}async function Me(){if(D)return D;if(v)return v;v=(async()=>{if(typeof fetch>"u")throw new Error("fetch is not available in this environment");const e=Ae(),n=await fetch(e,{method:"GET",headers:{Accept:"application/json"}});if(!n.ok)throw new Error(`Failed to load default chain configs: ${n.status} ${n.statusText}`);const t=await n.json(),r=ce.safeParse(t);if(!r.success){const u=r.error.issues[0];throw new Error(u?.message??"Invalid default chain config file")}const o=r.data,s=o.chains.map(u=>{const l=Pe(u,e);return{...u,...l,source:"default",enabled:!0}}),a={version:o.version,configs:s};return D=a,a})();try{return await v}finally{v=null}}function Be(e){try{return JSON.parse(e)}catch{throw new Error("Invalid JSON")}}function R(e,n){return e.startsWith("http://")||e.startsWith("https://")?e:new URL(e,n).toString()}function Pe(e,n){const t={};return e.icon!==void 0&&(t.icon=R(e.icon,n)),e.tokenIconBase!==void 0&&(t.tokenIconBase=e.tokenIconBase.map(r=>R(r,n))),e.tokenIconContract!==void 0&&(t.tokenIconContract=e.tokenIconContract.map(r=>R(r,n))),t}function ke(e,n,t){const r=Array.isArray(e)?_.safeParse(e):P.safeParse(e);if(!r.success){const s=r.error.issues[0];throw new Error(s?.message??"Invalid chain config")}return(Array.isArray(e)?r.data:[r.data]).map(s=>({...s,...{},source:n,enabled:!0}))}function je(e){const n=new Map;for(const t of e.manual)n.set(t.id,{...t,source:"manual"});for(const t of e.subscription)n.has(t.id)||n.set(t.id,{...t,source:"subscription"});for(const t of e.defaults)n.has(t.id)||n.set(t.id,{...t,source:"default"});return[...n.values()]}function Ue(e,n){return e.map(t=>{const r=n[t.id];return{...t,enabled:typeof r=="boolean"?r:!0}})}function De(e){const n=[];for(const t of e){const r=Y(t.version);if(r===null)continue;const o=H[t.chainKind];r>o&&n.push({id:t.id,kind:"incompatible_major",version:t.version,supportedMajor:o,source:t.source})}return n}function Re(e){const n=parseInt(e.split(".")[0]??"0",10);return Number.isNaN(n)?0:n}function Le(e,n){const t=e.split(".").map(Number),r=n.split(".").map(Number);for(let o=0;o<3;o++){const s=t[o]??0,a=r[o]??0;if(s>a)return 1;if(s<a)return-1}return 0}async function x(){const{version:e,configs:n}=await Me(),[t,r,o,s]=await Promise.all([$(),G(),j(),ye()]),a=Re(e),u=t.length>0||Object.keys(r).length>0||o!==null;if(s===null&&a>=2&&u)throw new Q(s,e);Le(e,s??"0.0.0")>0&&await be(e);const g=t.filter(b=>b.source==="manual"),U=o?.url&&o.url!=="default"?t.filter(b=>b.source==="subscription"):[],I=je({manual:g,subscription:U,defaults:n}),C=Ue(I,r),A=De(C);return{configs:C,enabledMap:r,subscription:o,warnings:A}}async function Te(e){const n=typeof e=="string"?Be(e):e,t=ke(n,"manual"),o=(await $()).filter(a=>a.source==="manual"),s=new Map;for(const a of o)s.set(a.id,{...a,source:"manual",enabled:!0});for(const a of t)s.set(a.id,{...a,source:"manual",enabled:!0});return await q({source:"manual",configs:[...s.values()]}),x()}async function L(e,n){const r={...await G(),[e]:n};return await me(r),x()}async function V(){const n=(await j())?.url??"default",t=await Ee(n),r=await x();return{result:t,snapshot:r}}function Ne(e){const n=e.trim();if(n==="")return"default";if(n==="default")return n;let t;try{t=new URL(n)}catch{throw new Error("Invalid subscription URL")}if(t.protocol!=="http:"&&t.protocol!=="https:")throw new Error("Subscription URL must use http(s)");return n}async function _e(e){const n=Ne(e),t=await j(),r=t?.url;r!==n&&await q({source:"subscription",configs:[]});const o=O.parse({url:n,refreshIntervalMinutes:t?.refreshIntervalMinutes??1440,...r===n?{...t?.etag?{etag:t.etag}:{},...t?.lastUpdated?{lastUpdated:t.lastUpdated}:{}}:{}});return await J(o),x()}function F(e){return e.configs.filter(n=>n.enabled&&Ie(n))}function Oe(e,n){const t=n.trim().toLowerCase();return e.configs.find(r=>r.id===n)??e.configs.find(r=>r.id.toLowerCase()===t)??null}const qe={snapshot:null,isLoading:!1,error:null,migrationRequired:!1},i=new X(qe);function N(e){return e instanceof Error?e.message:"Unknown error"}async function E(e){i.setState(n=>({...n,isLoading:!0,error:null,migrationRequired:!1}));try{const n=await e();i.setState(t=>({...t,snapshot:n,isLoading:!1,error:null}))}catch(n){n instanceof Q?i.setState(t=>({...t,isLoading:!1,error:n.message,migrationRequired:!0})):i.setState(t=>({...t,isLoading:!1,error:N(n)}))}}const Ge={initialize:async()=>{const e=i.state;e.isLoading||e.snapshot||await E(async()=>x())},setSubscriptionUrl:async e=>{i.setState(n=>({...n,isLoading:!0,error:null}));try{const n=await _e(e);if((n.subscription?.url??"default")==="default"){i.setState(a=>({...a,snapshot:n,isLoading:!1,error:null}));return}const{result:r,snapshot:o}=await V(),s=r.status==="error"?r.error:null;i.setState(a=>({...a,snapshot:o,isLoading:!1,error:s}))}catch(n){i.setState(t=>({...t,isLoading:!1,error:N(n)}))}},refreshSubscription:async()=>{i.setState(e=>({...e,isLoading:!0,error:null}));try{const{result:e,snapshot:n}=await V(),t=e.status==="error"?e.error:null;i.setState(r=>({...r,snapshot:n,isLoading:!1,error:t}))}catch(e){i.setState(n=>({...n,isLoading:!1,error:N(e)}))}},addManualConfig:async e=>{await E(async()=>Te(e))},setChainEnabled:async(e,n)=>{await E(async()=>L(e,n))},enableChain:async e=>{await E(async()=>L(e,!0))},disableChain:async e=>{await E(async()=>L(e,!1))},clearError:()=>{i.setState(e=>({...e,error:null}))}},m={getSnapshot:e=>e.snapshot,getConfigs:e=>e.snapshot?.configs??[],getSubscription:e=>e.snapshot?.subscription??null,getWarnings:e=>e.snapshot?.warnings??[],getEnabledChains:e=>e.snapshot?F(e.snapshot):[],getEnabledBioforestChainConfigs:e=>e.snapshot?F(e.snapshot).filter(n=>n.chainKind==="bioforest"):[],getChainById:(e,n)=>e.snapshot?Oe(e.snapshot,n):null};function Je(){return d(i)}function Qe(){return d(i,e=>m.getConfigs(e))}function He(){return d(i,e=>m.getEnabledChains(e))}function Ye(){return d(i,e=>m.getEnabledBioforestChainConfigs(e))}function Xe(){return d(i,e=>m.getSubscription(e))}function Ze(){return d(i,e=>m.getWarnings(e))}function en(){return d(i,e=>e.isLoading)}function nn(){return d(i,e=>e.error)}function tn(){return d(i,e=>e.migrationRequired)}function rn(){return d(i,e=>{const n=m.getConfigs(e);return Object.fromEntries(n.map(t=>[t.id,t.name]))})}function on(e){return d(i,n=>e?m.getChainById(n,e)?.name??e:"")}class $e{getConfig(n){return m.getChainById(i.state,n)}getApi(n){return this.getConfig(n)?.apis??[]}getApiByType(n,t){return this.getApi(n).find(o=>o.type===t)??null}getApiByPattern(n,t){const r=this.getApi(n),o=new RegExp("^"+t.replace("*",".*")+"$");return r.find(s=>o.test(s.type))??null}getRpcUrl(n){return this.getApiByPattern(n,"*-rpc")?.endpoint??""}getBiowalletApi(n){return this.getApiByPattern(n,"biowallet-*")?.endpoint??null}getBiowalletGenesisBlock(n){return this.getApiByPattern(n,"biowallet-*")?.config?.genesisBlock??null}getEtherscanApi(n){return(this.getApiByPattern(n,"etherscan-*")??this.getApiByPattern(n,"*scan-*"))?.endpoint??null}getMempoolApi(n){return this.getApiByPattern(n,"mempool-*")?.endpoint??null}getDecimals(n){return this.getConfig(n)?.decimals??18}getSymbol(n){return this.getConfig(n)?.symbol??""}getExplorerUrl(n){return this.getConfig(n)?.explorer?.url??null}getTxQueryUrl(n,t){const o=this.getConfig(n)?.explorer?.queryTx;return o?o.replace(":hash",t).replace(":signature",t):null}getAddressQueryUrl(n,t){const o=this.getConfig(n)?.explorer?.queryAddress;return o?o.replace(":address",t):null}getName(n){return this.getConfig(n)?.name??n}getIcon(n){return this.getConfig(n)?.icon??null}getTokenIconByContract(n,t){const o=this.getConfig(n)?.tokenIconContract;if(!o||o.length===0)return null;try{const s=te(t);return o[0].replace("$address",s)}catch{return null}}}const Ve=new $e,sn=Object.freeze(Object.defineProperty({__proto__:null,chainConfigService:Ve},Symbol.toStringTag,{value:"Module"}));export{F as a,m as b,Ve as c,Qe as d,i as e,Ge as f,Oe as g,tn as h,x as i,rn as j,on as k,Xe as l,Ze as m,en as n,nn as o,He as p,Ye as q,sn as s,Je as u};
