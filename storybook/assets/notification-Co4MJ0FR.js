import{d as X}from"./breakpoint-DQ_qwb34.js";import{A as L}from"./amount-BQsqQYGO.js";import{e as dt,Z as lt,b as w,o as d,n as h,s,l as N,f as ut,a as C,g as ft,h as mt,_ as x}from"./schemas-CO8_C8zP.js";import{d as U,o as pt}from"./user-profile-CFs3-A_r.js";import{i as Y,g as q,a as ht,c as Q}from"./service-BC0gkQFu.js";import{g as F,I as gt,s as yt,p as W,t as bt,r as $,c as wt,S as tt,i as St,a as At,m as j,b as Tt,H as vt,d as It,e as Ct}from"./index-DqfWNcG6.js";import{m as xt}from"./transaction-meta-C0fC4A8j.js";import{S as kt}from"./iframe-Dt8wZwjo.js";function Pt(e){return dt(lt,e)}w(["native","token","nft"]);const et=w(["transfer","swap","exchange","approve","revoke","signature","stake","unstake","claim","mint","burn","gift","grab","trust","signFor","emigrate","immigrate","issueAsset","increaseAsset","destroyAsset","issueEntity","destroyEntity","locationName","dapp","certificate","mark","contract","unknown"]),at=w(["in","out","self"]),Dt=w(["pending","confirmed","failed"]),Et=d({assetType:N("native"),value:s(),symbol:s(),decimals:h()}),Bt=d({assetType:N("token"),value:s(),symbol:s(),decimals:h(),contractAddress:s(),name:s().optional(),logoUrl:s().optional()}),Mt=d({assetType:N("nft"),tokenId:s(),contractAddress:s(),name:s().optional(),imageUrl:s().optional(),collection:s().optional()}),nt=ut("assetType",[Et,Bt,Mt]),Ht=d({value:s(),symbol:s(),decimals:h()}),st=d({address:s(),method:s().optional(),methodId:s().optional()});d({hash:s(),from:s(),to:s(),timestamp:h(),status:Dt,blockNumber:Pt().optional(),action:et,direction:at,assets:C(nt).min(1),fee:Ht.optional(),contract:st.optional(),fromEntity:s().optional(),toEntity:s().optional(),summary:s().optional()});const G=ft(e=>e instanceof L),it=w(["send","receive","signature","stake","unstake","destroy","gift","grab","trust","signFor","emigrate","immigrate","exchange","swap","issueAsset","increaseAsset","mint","issueEntity","destroyEntity","locationName","dapp","certificate","approve","interaction","mark","other"]),J=d({id:s(),type:it,status:w(["pending","confirmed","failed"]),amount:G,symbol:s(),decimals:h(),address:s(),timestamp:mt(),hash:s().optional(),chain:s(),fee:G.optional(),feeSymbol:s().optional(),feeDecimals:h().optional(),blockNumber:h().optional(),confirmations:h().optional(),from:s().optional(),to:s().optional(),action:et.optional(),direction:at.optional(),assets:C(nt).optional(),contract:st.optional()}),Nt=d({chain:s().optional(),period:w(["7d","30d","90d","all"]).optional(),type:it.or(N("all")).optional(),status:w(["pending","confirmed","failed","all"]).optional()}),$t=X("transaction",e=>e.description("交易服务").api("getHistory",d({walletId:s(),filter:Nt.optional()}),C(J)).api("getTransaction",d({id:s()}),J.nullable()).api("refresh",d({walletId:s()}),x())),M=new Map;function zt(e){const[t,a]=e.split("--");return!t||!a?null:{chainId:t,hash:a}}async function Z(e,t){await U.initialize();const a=await Y(),n=ht(a),i=new Map(n.map(m=>[m.id,m])),o=await U.getWalletChainAddresses(e),r=t?.chain&&t.chain!=="all"?t.chain:null,u=o.flatMap(m=>{if(r&&m.chain!==r)return[];const y=i.get(m.chain)??q(a,m.chain);if(!y||!y.enabled)return[];try{return F(m.chain).transactionHistory.fetch({address:m.address,limit:50}).then(P=>P.map(p=>ot(p,y))).catch(()=>[])}catch{return[]}});let c=(await Promise.all(u)).flat();t&&(c=Kt(c,t.chain),c=Lt(c,t.period),c=Rt(c,t.type),c=Ft(c,t.status)),c.sort((m,y)=>y.timestamp.getTime()-m.timestamp.getTime()),M.clear();for(const m of c)M.set(m.id,m);return c}function _t(e,t){const a=e.assets.find(n=>n.assetType==="native"||n.assetType==="token");return a?{value:a.value,symbol:a.symbol,decimals:a.decimals}:{value:"0",symbol:t.symbol,decimals:t.decimals}}function ot(e,t){const a=xt(e.action,e.direction),n=_t(e,{symbol:t.symbol,decimals:t.decimals}),o=e.action==="transfer"?e.direction==="out"?e.to:e.from:e.contract?.address??e.to??e.from;return{id:`${t.id}--${e.hash}`,type:a,status:e.status,amount:L.fromRaw(n.value,n.decimals,n.symbol),symbol:n.symbol,decimals:n.decimals,address:o,timestamp:new Date(e.timestamp),hash:e.hash,chain:t.id,blockNumber:e.blockNumber?Number(e.blockNumber):void 0,confirmations:void 0,fee:e.fee?L.fromRaw(e.fee.value,e.fee.decimals,e.fee.symbol):void 0,feeSymbol:e.fee?.symbol,feeDecimals:e.fee?.decimals,from:e.from,to:e.to,action:e.action,direction:e.direction,assets:e.assets,contract:e.contract}}function Lt(e,t){if(!t||t==="all")return e;const a=t==="7d"?7:t==="30d"?30:90,n=Date.now()-a*24*60*60*1e3;return e.filter(i=>i.timestamp.getTime()>=n)}function Rt(e,t){return!t||t==="all"?e:e.filter(a=>a.type===t)}function Ft(e,t){return!t||t==="all"?e:e.filter(a=>a.status===t)}function Kt(e,t){return!t||t==="all"?e:e.filter(a=>a.chain===t)}$t.impl({async getHistory({walletId:e,filter:t}){return Z(e,t)},async getTransaction({id:e}){const t=M.get(e);if(t)return t;const a=zt(e);if(!a)return null;const n=await Y(),i=q(n,a.chainId);if(!i||!i.enabled)return null;try{const o=F(i.id);if(!o.supports("transaction"))return null;const r=await o.transaction.fetch({txHash:a.hash});if(!r)return null;const u=ot(r,i);return M.set(u.id,u),u}catch(o){if(o instanceof gt)throw o;return null}},async refresh({walletId:e}){await Z(e,{chain:"all",period:"all",type:"all",status:"all"})}});function T(...e){const t=`[chain-effect] pending-tx ${e.join(" ")}`;St(t)&&console.log("[chain-effect]","pending-tx",...e)}const K=w(["created","broadcasting","broadcasted","confirmed","failed"]),Ot=w(["send","receive","signature","stake","unstake","destroy","gift","grab","trust","signFor","emigrate","immigrate","exchange","swap","issueAsset","increaseAsset","mint","issueEntity","destroyEntity","locationName","dapp","certificate","mark","approve","interaction","other"]),rt=d({type:Ot.optional(),displayAmount:s().optional(),displaySymbol:s().optional(),displayToAddress:s().optional()}).passthrough(),b=d({id:s(),walletId:s(),chainId:s(),fromAddress:s(),status:K,txHash:s(),errorCode:s().optional(),errorMessage:s().optional(),retryCount:h().default(0),confirmedBlockHeight:h().optional(),confirmedAt:h().optional(),createdAt:h(),updatedAt:h(),rawTx:tt,meta:rt.optional()});function de(e,t){return`${e}:${t.trim().toLowerCase()}`}const Ut=d({walletId:s(),chainId:s(),fromAddress:s(),rawTx:tt,meta:rt.optional()}),Wt=d({id:s(),status:K,txHash:s().optional(),errorCode:s().optional(),errorMessage:s().optional(),confirmedBlockHeight:h().optional(),confirmedAt:h().optional()});X("pendingTx",e=>e.description("未上链交易管理服务 - 专注状态管理，不关心交易内容").api("getAll",d({walletId:s()}),C(b)).api("getById",d({id:s()}),b.nullable()).api("getByStatus",d({walletId:s(),status:K}),C(b)).api("getPending",d({walletId:s()}),C(b)).api("create",Ut,b).api("updateStatus",Wt,b).api("incrementRetry",d({id:s()}),b).api("delete",d({id:s()}),x()).api("deleteByTxHash",d({walletId:s(),txHashes:C(s())}),x()).api("deleteConfirmed",d({walletId:s()}),x()).api("deleteAll",d({walletId:s()}),x()));const jt={isExpired(e,t){const a=e;return typeof a?.effectiveBlockHeight=="number"?t>a.effectiveBlockHeight:!1}};function Gt(e){if(e.startsWith("bfmeta")||e.startsWith("bfm")||e==="bioforest")return jt}const Jt="bfm-pending-tx-db",Zt=1,f="pendingTx";class Vt{db=null;initialized=!1;subscribers=new Set;subscribe(t){return this.subscribers.add(t),()=>{this.subscribers.delete(t)}}notify(t,a){this.subscribers.forEach(n=>{try{n(t,a)}catch{}})}async ensureDb(){return this.db&&this.initialized?this.db:(this.db=await pt(Jt,Zt,{upgrade(t){if(!t.objectStoreNames.contains(f)){const a=t.createObjectStore(f,{keyPath:"id"});a.createIndex("by-wallet","walletId"),a.createIndex("by-status","status"),a.createIndex("by-wallet-status",["walletId","status"])}}}),this.initialized=!0,this.db)}async getAll({walletId:t}){const i=(await(await this.ensureDb()).getAllFromIndex(f,"by-wallet",t)).map(o=>b.safeParse(o)).filter(o=>o.success).map(o=>o.data).sort((o,r)=>r.createdAt-o.createdAt);return T("getAll",t,`len=${i.length}`),i}async getById({id:t}){const n=await(await this.ensureDb()).get(f,t);if(!n)return null;const i=b.safeParse(n);return i.success?i.data:null}async getByStatus({walletId:t,status:a}){const o=(await(await this.ensureDb()).getAllFromIndex(f,"by-wallet-status",[t,a])).map(r=>b.safeParse(r)).filter(r=>r.success).map(r=>r.data).sort((r,u)=>u.createdAt-r.createdAt);return T("getByStatus",t,a,`len=${o.length}`),o}async getPending({walletId:t}){const n=(await this.getAll({walletId:t})).filter(i=>i.status!=="confirmed");return T("getPending",t,`len=${n.length}`),n}async create(t){const a=await this.ensureDb(),n=Date.now(),i=t.rawTx.signature,o={id:i,walletId:t.walletId,chainId:t.chainId,fromAddress:t.fromAddress,status:"created",txHash:i,retryCount:0,createdAt:n,updatedAt:n,rawTx:t.rawTx,meta:t.meta};return await a.put(f,o),T("create",o.walletId,o.status,o.id),this.notify(o,"created"),o}async updateStatus(t){const a=await this.ensureDb(),n=await a.get(f,t.id);if(!n)throw new Error(`PendingTx not found: ${t.id}`);const i={...n,status:t.status,updatedAt:Date.now(),...t.txHash!==void 0&&{txHash:t.txHash},...t.errorCode!==void 0&&{errorCode:t.errorCode},...t.errorMessage!==void 0&&{errorMessage:t.errorMessage},...t.confirmedBlockHeight!==void 0&&{confirmedBlockHeight:t.confirmedBlockHeight},...t.confirmedAt!==void 0&&{confirmedAt:t.confirmedAt}};return await a.put(f,i),T("updateStatus",i.walletId,`${n.status}->${i.status}`,i.id),this.notify(i,"updated"),i}async incrementRetry({id:t}){const a=await this.ensureDb(),n=await a.get(f,t);if(!n)throw new Error(`PendingTx not found: ${t}`);const i={...n,retryCount:(n.retryCount??0)+1,updatedAt:Date.now()};return await a.put(f,i),this.notify(i,"updated"),i}async delete({id:t}){const a=await this.ensureDb(),n=await a.get(f,t);await a.delete(f,t),n&&(T("delete",n.walletId,n.status,n.id),this.notify(n,"deleted"))}async deleteConfirmed({walletId:t}){const a=await this.getByStatus({walletId:t,status:"confirmed"}),i=(await this.ensureDb()).transaction(f,"readwrite");await Promise.all(a.map(o=>i.store.delete(o.id))),await i.done}async deleteByTxHash({walletId:t,txHashes:a}){if(a.length===0)return;const n=new Set(a.map(l=>l.trim().toLowerCase()).filter(Boolean));if(n.size===0)return;const o=(await this.getAll({walletId:t})).filter(l=>l.txHash?n.has(l.txHash.toLowerCase()):!1);if(o.length===0)return;const u=(await this.ensureDb()).transaction(f,"readwrite");await Promise.all(o.map(l=>u.store.delete(l.id))),await u.done;for(const l of o)T("delete",l.walletId,l.status,l.id),this.notify(l,"deleted")}async deleteExpired({walletId:t,maxAge:a,currentBlockHeight:n}){const i=await this.getAll({walletId:t}),o=Date.now(),r=i.filter(c=>c.status==="confirmed"||c.status==="failed"?o-c.updatedAt>a:!!(n!==void 0&&Gt(c.chainId)?.isExpired(c.rawTx,n)));if(r.length===0)return 0;const l=(await this.ensureDb()).transaction(f,"readwrite");return await Promise.all(r.map(c=>l.store.delete(c.id))),await l.done,r.length}async deleteAll({walletId:t}){const a=await this.getAll({walletId:t}),i=(await this.ensureDb()).transaction(f,"readwrite");await Promise.all(a.map(o=>i.store.delete(o.id))),await i.done}async normalizeWalletKeyByAddress({chainId:t,address:a,walletId:n}){const i=await this.ensureDb(),o=a.trim().toLowerCase(),r=await i.getAll(f);let u=0;for(const l of r){if(l.chainId!==t||l.fromAddress?.toLowerCase()!==o||l.walletId===n)continue;const c={...l,walletId:n,updatedAt:Date.now()};await i.put(f,c),this.notify(c,"updated"),u+=1}return u}}const V=new Vt,k=new Map,z=new Map,_=new Map,H=15e3;function Xt(e){switch(e){case"evm":return 12e3;case"tron":return 3e3;case"bitcoin":return 6e5;case"bioforest":return H;default:return H}}function Yt(e){const t=Q.getConfig(e);if(!t)return H;if(t.chainKind==="bioforest")return Tt(e);const a=t;return typeof a.blockTimeMs=="number"&&a.blockTimeMs>0?a.blockTimeMs:typeof a.blockTimeSeconds=="number"&&a.blockTimeSeconds>0?a.blockTimeSeconds*1e3:typeof a.blockTime=="number"&&a.blockTime>0?a.blockTime*1e3:Xt(t.chainKind)}function qt(e){const t=Q.getConfig(e)?.chainKind,a=Math.max(1,Yt(e));if(t==="bioforest")return j(Math.max(1,Math.floor(a/2)));const n=Math.max(1,Math.ceil(H/a));return j(a*n)}function le(e,t,a){const n=`${e}:${t}`,i=a&&a!==t?a:void 0,o=p=>{const I=new Map;for(const S of p)for(const A of S)I.set(A.id,A);return Array.from(I.values()).sort((S,A)=>A.createdAt-S.createdAt)},r=p=>({...p,stop:Qt(n)}),u=k.get(n);if(u)return i&&u.walletIds.add(i),u.refCount+=1,yt(r(u.source));const l=z.get(n);if(l){const p=_.get(n);return p&&i&&p.add(i),W(async()=>{const I=await l,S=k.get(n);return S&&(i&&S.walletIds.add(i),S.refCount+=1),r(I)})}const c=F(e),m=qt(e),y=new Set([t]);i&&y.add(i),_.set(n,y);const O=bt({try:async()=>{const p=await $(It()),I=Array.from(y),S=await Promise.all(I.map(g=>V.getPending({walletId:g}))),A=o(S);T("poll",`walletIds=${I.join(",")}`,`len=${A.length}`);const D=new Set;for(const g of A)if(g.status==="broadcasted"&&g.txHash)try{(await c.transaction.fetch({txHash:g.txHash,senderId:g.fromAddress}))?.status==="confirmed"&&(await $(p.emit(Ct(e,g.fromAddress,g.txHash))),await V.delete({id:g.id}),D.add(g.id))}catch{}return D.size===0?A:(T("poll","confirmed-removed",`count=${D.size}`),A.filter(g=>!D.has(g.id)))},catch:p=>new vt(p instanceof Error?p.message:"Pending transaction fetch failed")}),P=$(wt({name:`pendingTx.${e}.${t}`,interval:m,fetch:O}));return z.set(n,P),W(async()=>{try{const p=await P;return k.set(n,{source:p,refCount:1,walletIds:y}),r(p)}finally{z.delete(n),_.delete(n)}})}function Qt(e){return At(function*(){const t=k.get(e);t&&(t.refCount-=1,t.refCount<=0&&(yield*t.source.stop,k.delete(e)))})}const ct={notifications:[],unreadCount:0,isInitialized:!1},v=new kt(ct),R="bfm_notifications";function E(e){try{localStorage.setItem(R,JSON.stringify(e))}catch{}}function B(e){return e.filter(t=>!t.read).length}const ue={initialize:()=>{try{const e=localStorage.getItem(R);if(e){const t=JSON.parse(e);v.setState(()=>({notifications:t,unreadCount:B(t),isInitialized:!0}))}else v.setState(t=>({...t,isInitialized:!0}))}catch{v.setState(t=>({...t,isInitialized:!0}))}},add:e=>{const t={...e,id:crypto.randomUUID(),timestamp:Date.now(),read:!1};return v.setState(a=>{const n=[t,...a.notifications];return E(n),{...a,notifications:n,unreadCount:B(n)}}),t},markRead:e=>{v.setState(t=>{const a=t.notifications.map(n=>n.id===e?{...n,read:!0}:n);return E(a),{...t,notifications:a,unreadCount:B(a)}})},markAllRead:()=>{v.setState(e=>{const t=e.notifications.map(a=>({...a,read:!0}));return E(t),{...e,notifications:t,unreadCount:0}})},remove:e=>{v.setState(t=>{const a=t.notifications.filter(n=>n.id!==e);return E(a),{...t,notifications:a,unreadCount:B(a)}})},clearAll:()=>{localStorage.removeItem(R),v.setState(()=>ct)}};export{v as a,le as b,de as g,ue as n,V as p};
