const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./index-DBrPxRsx.js","./amount-BQsqQYGO.js","./index-D0E7N0oa.js","./bioforest-ChHUthdw.js","./schemas-34eCiBJ6.js","./preload-helper-PPVm8Dsz.js","./address-derivation-DIK1T4To.js","./iframe-Cdc63axx.js","./iframe-D2OUpJUL.css","./address-format-BmR8oJgW.js"])))=>i.map(i=>d[i]);
import{_ as Qt}from"./preload-helper-PPVm8Dsz.js";import"./index-D0E7N0oa.js";import{e as Dt,f as P,g as Xe,j as Ye,v as Kn,r as _n,k as Dn,l as Nn,m as gr,n as Er,h as mt,o as J,q as ie,s as On,t as Ar,u as vr,w as Me,x as qe,y as Ir,z as Sr,A as Cr,B as en,C as tn,D as xr,E as nn,F as kr,G as Br,H as j,I as q,J as Je,K as Te,L as bt,M as Tr,N as xe,O as rn,P as Lr,Q as Kr,R as sn,S as _r,T as Dr,U as Nr,V as Or,W as Rr,X as Wr}from"./bioforest-ChHUthdw.js";import{o as Q,n as G,b as he,s as S,a as Nt,c as Ot,r as Rn,u as Mr,t as Ur,d as Pr}from"./schemas-34eCiBJ6.js";import{S as Rt,u as ne}from"./iframe-Cdc63axx.js";import{d as on}from"./address-format-BmR8oJgW.js";const Wn=1e5,Fr=16,Mn=12,Wt=256;async function Un(t,e){const r=new TextEncoder().encode(t),s=await crypto.subtle.importKey("raw",r,"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:Wn,hash:"SHA-256"},s,{name:"AES-GCM",length:Wt},!1,["encrypt","decrypt"])}async function Ue(t,e){const r=new TextEncoder().encode(t),s=crypto.getRandomValues(new Uint8Array(Fr)),o=crypto.getRandomValues(new Uint8Array(Mn)),i=await Un(e,s),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},i,r);return{ciphertext:ke(a),salt:ke(s),iv:ke(o),iterations:Wn}}async function gt(t,e){const n=Be(t.salt),r=Be(t.iv),s=Be(t.ciphertext),o=await Un(e,n);try{const i=await crypto.subtle.decrypt({name:"AES-GCM",iv:r},o,s);return new TextDecoder().decode(i)}catch{throw new Error("解密失败：密码错误或数据损坏")}}async function jo(t,e){try{return await gt(t,e),!0}catch{return!1}}async function st(t,e){const r=new TextEncoder().encode(t),s=crypto.getRandomValues(new Uint8Array(Mn)),o=await crypto.subtle.importKey("raw",e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength),{name:"AES-GCM",length:Wt},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},o,r);return{ciphertext:ke(i),salt:"",iv:ke(s),iterations:0}}async function an(t,e){const n=Be(t.iv),r=Be(t.ciphertext),s=await crypto.subtle.importKey("raw",e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength),{name:"AES-GCM",length:Wt},!1,["decrypt"]);try{const o=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},s,r);return new TextDecoder().decode(o)}catch{throw new Error("解密失败：密钥错误或数据损坏")}}function ke(t){const e=t instanceof Uint8Array?t:new Uint8Array(t);let n="";for(let r=0;r<e.byteLength;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function Be(t){const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;r++)n[r]=e.charCodeAt(r);return n}class Pn{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(e,n){if(Dt(e),P(n,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,s=new Uint8Array(r);s.set(n.length>r?e.create().update(n).digest():n);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=e.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),Xe(s)}update(e){return Ye(this),this.iHash.update(e),this}digestInto(e){Ye(this),P(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||=Object.create(Object.getPrototypeOf(this),{});const{oHash:n,iHash:r,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Le=(t,e,n)=>new Pn(t,e).update(n).digest();Le.create=(t,e)=>new Pn(t,e);const cn=(t,e)=>(t+(t>=0?e:-e)/Fn)/e;function $r(t,e,n){const[[r,s],[o,i]]=e,a=cn(i*t,n),c=cn(-s*t,n);let d=t-a*r-c*o,h=-a*s-c*i;const y=d<te,g=h<te;y&&(d=-d),g&&(h=-h);const f=Nn(Math.ceil(kr(n)/2))+ye;if(d<te||d>=f||h<te||h>=f)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:y,k1:d,k2neg:g,k2:h}}function Et(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function ot(t,e){const n={};for(let r of Object.keys(e))n[r]=t[r]===void 0?e[r]:t[r];return qe(n.lowS,"lowS"),qe(n.prehash,"prehash"),n.format!==void 0&&Et(n.format),n}class Hr extends Error{constructor(e=""){super(e)}}const se={Err:Hr,_tlv:{encode:(t,e)=>{const{Err:n}=se;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length&1)throw new n("tlv.encode: unpadded data");const r=e.length/2,s=Me(r);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const o=r>127?Me(s.length/2|128):"";return Me(t)+o+s+e},decode(t,e){const{Err:n}=se;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const s=e[r++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new n("tlv.decode(long): indefinite length not supported");if(c>4)throw new n("tlv.decode(long): byte length is too big");const d=e.subarray(r,r+c);if(d.length!==c)throw new n("tlv.decode: length bytes not complete");if(d[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const h of d)i=i<<8|h;if(r+=c,i<128)throw new n("tlv.decode(long): not minimal encoding")}const a=e.subarray(r,r+i);if(a.length!==i)throw new n("tlv.decode: wrong value length");return{v:a,l:e.subarray(r+i)}}},_int:{encode(t){const{Err:e}=se;if(t<te)throw new e("integer: negative integers are not allowed");let n=Me(t);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=se;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Dn(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=se,s=P(t,void 0,"signature"),{v:o,l:i}=r.decode(48,s);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,o),{v:d,l:h}=r.decode(2,c);if(h.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(a),s:n.decode(d)}},hexFromSig(t){const{_tlv:e,_int:n}=se,r=e.encode(2,n.encode(t.r)),s=e.encode(2,n.encode(t.s)),o=r+s;return e.encode(48,o)}},te=BigInt(0),ye=BigInt(1),Fn=BigInt(2),Pe=BigInt(3),zr=BigInt(4);function jr(t,e={}){const n=Sr("weierstrass",t,e),{Fp:r,Fn:s}=n;let o=n.CURVE;const{h:i,n:a}=o;Kn(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!r.is0(o.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const d=Hn(r,s);function h(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function y(T,p,u){const{x:l,y:w}=p.toAffine(),E=r.toBytes(l);if(qe(u,"isCompressed"),u){h();const v=!r.isOdd(w);return J($n(v),E)}else return J(Uint8Array.of(4),E,r.toBytes(w))}function g(T){P(T,void 0,"Point");const{publicKey:p,publicKeyUncompressed:u}=d,l=T.length,w=T[0],E=T.subarray(1);if(l===p&&(w===2||w===3)){const v=r.fromBytes(E);if(!r.isValid(v))throw new Error("bad point: is not on curve, wrong x");const A=B(v);let b;try{b=r.sqrt(A)}catch(F){const N=F instanceof Error?": "+F.message:"";throw new Error("bad point: is not on curve, sqrt error"+N)}h();const I=r.isOdd(b);return(w&1)===1!==I&&(b=r.neg(b)),{x:v,y:b}}else if(l===u&&w===4){const v=r.BYTES,A=r.fromBytes(E.subarray(0,v)),b=r.fromBytes(E.subarray(v,v*2));if(!K(A,b))throw new Error("bad point: is not on curve");return{x:A,y:b}}else throw new Error(`bad point: got length ${l}, expected compressed=${p} or uncompressed=${u}`)}const f=e.toBytes||y,m=e.fromBytes||g;function B(T){const p=r.sqr(T),u=r.mul(p,T);return r.add(r.add(u,r.mul(T,o.a)),o.b)}function K(T,p){const u=r.sqr(p),l=B(T);return r.eql(u,l)}if(!K(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const C=r.mul(r.pow(o.a,Pe),zr),Y=r.mul(r.sqr(o.b),BigInt(27));if(r.is0(r.add(C,Y)))throw new Error("bad curve params: a or b");function Z(T,p,u=!1){if(!r.isValid(p)||u&&r.is0(p))throw new Error(`bad point coordinate ${T}`);return p}function z(T){if(!(T instanceof L))throw new Error("Weierstrass Point expected")}function de(T){if(!c||!c.basises)throw new Error("no endo");return $r(T,c.basises,s.ORDER)}const re=en((T,p)=>{const{X:u,Y:l,Z:w}=T;if(r.eql(w,r.ONE))return{x:u,y:l};const E=T.is0();p==null&&(p=E?r.ONE:r.inv(w));const v=r.mul(u,p),A=r.mul(l,p),b=r.mul(w,p);if(E)return{x:r.ZERO,y:r.ZERO};if(!r.eql(b,r.ONE))throw new Error("invZ was invalid");return{x:v,y:A}}),rt=en(T=>{if(T.is0()){if(e.allowInfinityPoint&&!r.is0(T.Y))return;throw new Error("bad point: ZERO")}const{x:p,y:u}=T.toAffine();if(!r.isValid(p)||!r.isValid(u))throw new Error("bad point: x or y not field elements");if(!K(p,u))throw new Error("bad point: equation left != right");if(!T.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function me(T,p,u,l,w){return u=new L(r.mul(u.X,T),u.Y,u.Z),p=nn(l,p),u=nn(w,u),p.add(u)}class L{static BASE=new L(o.Gx,o.Gy,r.ONE);static ZERO=new L(r.ZERO,r.ONE,r.ZERO);static Fp=r;static Fn=s;X;Y;Z;constructor(p,u,l){this.X=Z("x",p),this.Y=Z("y",u,!0),this.Z=Z("z",l),Object.freeze(this)}static CURVE(){return o}static fromAffine(p){const{x:u,y:l}=p||{};if(!p||!r.isValid(u)||!r.isValid(l))throw new Error("invalid affine point");if(p instanceof L)throw new Error("projective point not allowed");return r.is0(u)&&r.is0(l)?L.ZERO:new L(u,l,r.ONE)}static fromBytes(p){const u=L.fromAffine(m(P(p,void 0,"point")));return u.assertValidity(),u}static fromHex(p){return L.fromBytes(mt(p))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(p=8,u=!0){return le.createCache(this,p),u||this.multiply(Pe),this}assertValidity(){rt(this)}hasEvenY(){const{y:p}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(p)}equals(p){z(p);const{X:u,Y:l,Z:w}=this,{X:E,Y:v,Z:A}=p,b=r.eql(r.mul(u,A),r.mul(E,w)),I=r.eql(r.mul(l,A),r.mul(v,w));return b&&I}negate(){return new L(this.X,r.neg(this.Y),this.Z)}double(){const{a:p,b:u}=o,l=r.mul(u,Pe),{X:w,Y:E,Z:v}=this;let A=r.ZERO,b=r.ZERO,I=r.ZERO,x=r.mul(w,w),F=r.mul(E,E),N=r.mul(v,v),k=r.mul(w,E);return k=r.add(k,k),I=r.mul(w,v),I=r.add(I,I),A=r.mul(p,I),b=r.mul(l,N),b=r.add(A,b),A=r.sub(F,b),b=r.add(F,b),b=r.mul(A,b),A=r.mul(k,A),I=r.mul(l,I),N=r.mul(p,N),k=r.sub(x,N),k=r.mul(p,k),k=r.add(k,I),I=r.add(x,x),x=r.add(I,x),x=r.add(x,N),x=r.mul(x,k),b=r.add(b,x),N=r.mul(E,v),N=r.add(N,N),x=r.mul(N,k),A=r.sub(A,x),I=r.mul(N,F),I=r.add(I,I),I=r.add(I,I),new L(A,b,I)}add(p){z(p);const{X:u,Y:l,Z:w}=this,{X:E,Y:v,Z:A}=p;let b=r.ZERO,I=r.ZERO,x=r.ZERO;const F=o.a,N=r.mul(o.b,Pe);let k=r.mul(u,E),R=r.mul(l,v),$=r.mul(w,A),X=r.add(u,l),W=r.add(E,v);X=r.mul(X,W),W=r.add(k,R),X=r.sub(X,W),W=r.add(u,w);let H=r.add(E,A);return W=r.mul(W,H),H=r.add(k,$),W=r.sub(W,H),H=r.add(l,w),b=r.add(v,A),H=r.mul(H,b),b=r.add(R,$),H=r.sub(H,b),x=r.mul(F,W),b=r.mul(N,$),x=r.add(b,x),b=r.sub(R,x),x=r.add(R,x),I=r.mul(b,x),R=r.add(k,k),R=r.add(R,k),$=r.mul(F,$),W=r.mul(N,W),R=r.add(R,$),$=r.sub(k,$),$=r.mul(F,$),W=r.add(W,$),k=r.mul(R,W),I=r.add(I,k),k=r.mul(H,W),b=r.mul(X,b),b=r.sub(b,k),k=r.mul(X,R),x=r.mul(H,x),x=r.add(x,k),new L(b,I,x)}subtract(p){return this.add(p.negate())}is0(){return this.equals(L.ZERO)}multiply(p){const{endo:u}=e;if(!s.isValidNot0(p))throw new Error("invalid scalar: out of range");let l,w;const E=v=>le.cached(this,v,A=>tn(L,A));if(u){const{k1neg:v,k1:A,k2neg:b,k2:I}=de(p),{p:x,f:F}=E(A),{p:N,f:k}=E(I);w=F.add(k),l=me(u.beta,x,N,v,b)}else{const{p:v,f:A}=E(p);l=v,w=A}return tn(L,[l,w])[0]}multiplyUnsafe(p){const{endo:u}=e,l=this;if(!s.isValid(p))throw new Error("invalid scalar: out of range");if(p===te||l.is0())return L.ZERO;if(p===ye)return l;if(le.hasCache(this))return this.multiply(p);if(u){const{k1neg:w,k1:E,k2neg:v,k2:A}=de(p),{p1:b,p2:I}=xr(L,l,E,A);return me(u.beta,b,I,w,v)}else return le.unsafe(l,p)}toAffine(p){return re(this,p)}isTorsionFree(){const{isTorsionFree:p}=e;return i===ye?!0:p?p(L,this):le.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:p}=e;return i===ye?this:p?p(L,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(p=!0){return qe(p,"isCompressed"),this.assertValidity(),f(L,this,p)}toHex(p=!0){return ie(this.toBytes(p))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const Re=s.BITS,le=new Cr(L,e.endo?Math.ceil(Re/2):Re);return L.BASE.precompute(8),L}function $n(t){return Uint8Array.of(t?2:3)}function Hn(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function Vr(t,e={}){const{Fn:n}=t,r=e.randomBytes||_n,s=Object.assign(Hn(t.Fp,n),{seed:gr(n.ORDER)});function o(f){try{const m=n.fromBytes(f);return n.isValidNot0(m)}catch{return!1}}function i(f,m){const{publicKey:B,publicKeyUncompressed:K}=s;try{const C=f.length;return m===!0&&C!==B||m===!1&&C!==K?!1:!!t.fromBytes(f)}catch{return!1}}function a(f=r(s.seed)){return vr(P(f,s.seed,"seed"),n.ORDER)}function c(f,m=!0){return t.BASE.multiply(n.fromBytes(f)).toBytes(m)}function d(f){const{secretKey:m,publicKey:B,publicKeyUncompressed:K}=s;if(!On(f)||"_lengths"in n&&n._lengths||m===B)return;const C=P(f,void 0,"key").length;return C===B||C===K}function h(f,m,B=!0){if(d(f)===!0)throw new Error("first arg must be private key");if(d(m)===!1)throw new Error("second arg must be public key");const K=n.fromBytes(f);return t.fromBytes(m).multiply(K).toBytes(B)}const y={isValidSecretKey:o,isValidPublicKey:i,randomSecretKey:a},g=Er(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:h,keygen:g,Point:t,utils:y,lengths:s})}function Yr(t,e,n={}){Dt(e),Kn(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),n=Object.assign({},n);const r=n.randomBytes||_n,s=n.hmac||((u,l)=>Le(e,u,l)),{Fp:o,Fn:i}=t,{ORDER:a,BITS:c}=i,{keygen:d,getPublicKey:h,getSharedSecret:y,utils:g,lengths:f}=Vr(t,n),m={prehash:!0,lowS:typeof n.lowS=="boolean"?n.lowS:!0,format:"compact",extraEntropy:!1},B=a*Fn<o.ORDER;function K(u){const l=a>>ye;return u>l}function C(u,l){if(!i.isValidNot0(l))throw new Error(`invalid signature ${u}: out of range 1..Point.Fn.ORDER`);return l}function Y(){if(B)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function Z(u,l){Et(l);const w=f.signature,E=l==="compact"?w:l==="recovered"?w+1:void 0;return P(u,E)}class z{r;s;recovery;constructor(l,w,E){if(this.r=C("r",l),this.s=C("s",w),E!=null){if(Y(),![0,1,2,3].includes(E))throw new Error("invalid recovery id");this.recovery=E}Object.freeze(this)}static fromBytes(l,w=m.format){Z(l,w);let E;if(w==="der"){const{r:I,s:x}=se.toSig(P(l));return new z(I,x)}w==="recovered"&&(E=l[0],w="compact",l=l.subarray(1));const v=f.signature/2,A=l.subarray(0,v),b=l.subarray(v,v*2);return new z(i.fromBytes(A),i.fromBytes(b),E)}static fromHex(l,w){return this.fromBytes(mt(l),w)}assertRecovery(){const{recovery:l}=this;if(l==null)throw new Error("invalid recovery id: must be present");return l}addRecoveryBit(l){return new z(this.r,this.s,l)}recoverPublicKey(l){const{r:w,s:E}=this,v=this.assertRecovery(),A=v===2||v===3?w+a:w;if(!o.isValid(A))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const b=o.toBytes(A),I=t.fromBytes(J($n((v&1)===0),b)),x=i.inv(A),F=re(P(l,void 0,"msgHash")),N=i.create(-F*x),k=i.create(E*x),R=t.BASE.multiplyUnsafe(N).add(I.multiplyUnsafe(k));if(R.is0())throw new Error("invalid recovery: point at infinify");return R.assertValidity(),R}hasHighS(){return K(this.s)}toBytes(l=m.format){if(Et(l),l==="der")return mt(se.hexFromSig(this));const{r:w,s:E}=this,v=i.toBytes(w),A=i.toBytes(E);return l==="recovered"?(Y(),J(Uint8Array.of(this.assertRecovery()),v,A)):J(v,A)}toHex(l){return ie(this.toBytes(l))}}const de=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const w=Dn(l),E=l.length*8-c;return E>0?w>>BigInt(E):w},re=n.bits2int_modN||function(l){return i.create(de(l))},rt=Nn(c);function me(u){return Ir("num < 2^"+c,u,te,rt),i.toBytes(u)}function L(u,l){return P(u,void 0,"message"),l?P(e(u),void 0,"prehashed message"):u}function Re(u,l,w){const{lowS:E,prehash:v,extraEntropy:A}=ot(w,m);u=L(u,v);const b=re(u),I=i.fromBytes(l);if(!i.isValidNot0(I))throw new Error("invalid private key");const x=[me(I),me(b)];if(A!=null&&A!==!1){const R=A===!0?r(f.secretKey):A;x.push(P(R,void 0,"extraEntropy"))}const F=J(...x),N=b;function k(R){const $=de(R);if(!i.isValidNot0($))return;const X=i.inv($),W=t.BASE.multiply($).toAffine(),H=i.create(W.x);if(H===te)return;const We=i.create(X*i.create(N+H*I));if(We===te)return;let Xt=(W.x===H?0:2)|Number(W.y&ye),Jt=We;return E&&K(We)&&(Jt=i.neg(We),Xt^=1),new z(H,Jt,B?void 0:Xt)}return{seed:F,k2sig:k}}function le(u,l,w={}){const{seed:E,k2sig:v}=Re(u,l,w);return Ar(e.outputLen,i.BYTES,s)(E,v).toBytes(w.format)}function T(u,l,w,E={}){const{lowS:v,prehash:A,format:b}=ot(E,m);if(w=P(w,void 0,"publicKey"),l=L(l,A),!On(u)){const I=u instanceof z?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+I)}Z(u,b);try{const I=z.fromBytes(u,b),x=t.fromBytes(w);if(v&&I.hasHighS())return!1;const{r:F,s:N}=I,k=re(l),R=i.inv(N),$=i.create(k*R),X=i.create(F*R),W=t.BASE.multiplyUnsafe($).add(x.multiplyUnsafe(X));return W.is0()?!1:i.create(W.x)===F}catch{return!1}}function p(u,l,w={}){const{prehash:E}=ot(w,m);return l=L(l,E),z.fromBytes(u,"recovered").recoverPublicKey(l).toBytes()}return Object.freeze({keygen:d,getPublicKey:h,getSharedSecret:y,utils:g,lengths:f,Point:t,sign:le,verify:T,recoverPublicKey:p,Signature:z,hash:e})}const Mt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},qr={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},dn=BigInt(2);function Zr(t){const e=Mt.p,n=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),d=t*t*t%e,h=d*d*t%e,y=q(h,n,e)*h%e,g=q(y,n,e)*h%e,f=q(g,dn,e)*d%e,m=q(f,s,e)*f%e,B=q(m,o,e)*m%e,K=q(B,a,e)*B%e,C=q(K,c,e)*K%e,Y=q(C,a,e)*B%e,Z=q(Y,n,e)*h%e,z=q(Z,i,e)*m%e,de=q(z,r,e)*d%e,re=q(de,dn,e);if(!At.eql(At.sqr(re),t))throw new Error("Cannot find square root");return re}const At=Br(Mt.p,{sqrt:Zr}),Gr=jr(Mt,{Fp:At,endo:qr}),oe=Yr(Gr,j);function Ke(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function zn(t,e){return Array.isArray(e)?e.length===0?!0:t?e.every(n=>typeof n=="string"):e.every(n=>Number.isSafeInteger(n)):!1}function jn(t){if(typeof t!="function")throw new Error("function expected");return!0}function _e(t,e){if(typeof e!="string")throw new Error(`${t}: string expected`);return!0}function De(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function Ze(t){if(!Array.isArray(t))throw new Error("array expected")}function Vn(t,e){if(!zn(!0,e))throw new Error(`${t}: array of strings expected`)}function Ut(t,e){if(!zn(!1,e))throw new Error(`${t}: array of numbers expected`)}function Pt(...t){const e=o=>o,n=(o,i)=>a=>o(i(a)),r=t.map(o=>o.encode).reduceRight(n,e),s=t.map(o=>o.decode).reduce(n,e);return{encode:r,decode:s}}function Yn(t){const e=typeof t=="string"?t.split(""):t,n=e.length;Vn("alphabet",e);const r=new Map(e.map((s,o)=>[s,o]));return{encode:s=>(Ze(s),s.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${t}`);return e[o]})),decode:s=>(Ze(s),s.map(o=>{_e("alphabet.decode",o);const i=r.get(o);if(i===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${t}`);return i}))}}function qn(t=""){return _e("join",t),{encode:e=>(Vn("join.decode",e),e.join(t)),decode:e=>(_e("join.decode",e),e.split(t))}}function ln(t,e,n){if(e<2)throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(Ze(t),!t.length)return[];let r=0;const s=[],o=Array.from(t,a=>{if(De(a),a<0||a>=e)throw new Error(`invalid integer: ${a}`);return a}),i=o.length;for(;;){let a=0,c=!0;for(let d=r;d<i;d++){const h=o[d],y=e*a,g=y+h;if(!Number.isSafeInteger(g)||y/e!==a||g-h!==y)throw new Error("convertRadix: carry overflow");const f=g/n;a=g%n;const m=Math.floor(f);if(o[d]=m,!Number.isSafeInteger(m)||m*n+a!==g)throw new Error("convertRadix: carry overflow");if(c)m?c=!1:r=d;else continue}if(s.push(a),c)break}for(let a=0;a<t.length-1&&t[a]===0;a++)s.push(0);return s.reverse()}const Zn=(t,e)=>e===0?t:Zn(e,t%e),Ge=(t,e)=>t+(e-Zn(t,e)),Ve=(()=>{let t=[];for(let e=0;e<40;e++)t.push(2**e);return t})();function vt(t,e,n,r){if(Ze(t),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(Ge(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${Ge(e,n)}`);let s=0,o=0;const i=Ve[e],a=Ve[n]-1,c=[];for(const d of t){if(De(d),d>=i)throw new Error(`convertRadix2: invalid data word=${d} from=${e}`);if(s=s<<e|d,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=n;o-=n)c.push((s>>o-n&a)>>>0);const h=Ve[o];if(h===void 0)throw new Error("invalid carry");s&=h-1}if(s=s<<n-o&a,!r&&o>=e)throw new Error("Excess padding");if(!r&&s>0)throw new Error(`Non-zero padding: ${s}`);return r&&o>0&&c.push(s>>>0),c}function Xr(t){De(t);const e=2**8;return{encode:n=>{if(!Ke(n))throw new Error("radix.encode input should be Uint8Array");return ln(Array.from(n),e,t)},decode:n=>(Ut("radix.decode",n),Uint8Array.from(ln(n,t,e)))}}function Jr(t,e=!1){if(De(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(Ge(8,t)>32||Ge(t,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!Ke(n))throw new Error("radix2.encode input should be Uint8Array");return vt(Array.from(n),8,t,!e)},decode:n=>(Ut("radix2.decode",n),Uint8Array.from(vt(n,t,8,e)))}}function un(t){return jn(t),function(...e){try{return t.apply(null,e)}catch{}}}function Qr(t,e){return De(t),jn(e),{encode(n){if(!Ke(n))throw new Error("checksum.encode: input should be Uint8Array");const r=e(n).slice(0,t),s=new Uint8Array(n.length+t);return s.set(n),s.set(r,n.length),s},decode(n){if(!Ke(n))throw new Error("checksum.decode: input should be Uint8Array");const r=n.slice(0,-t),s=n.slice(-t),o=e(r).slice(0,t);for(let i=0;i<t;i++)if(o[i]!==s[i])throw new Error("Invalid checksum");return r}}}const es=t=>Pt(Xr(58),Yn(t),qn("")),ts=es("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),Gn=t=>Pt(Qr(4,e=>t(t(e))),ts),Vo=Gn,It=Pt(Yn("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),qn("")),fn=[996825010,642813549,513874426,1027748829,705979059];function be(t){const e=t>>25;let n=(t&33554431)<<5;for(let r=0;r<fn.length;r++)(e>>r&1)===1&&(n^=fn[r]);return n}function hn(t,e,n=1){const r=t.length;let s=1;for(let o=0;o<r;o++){const i=t.charCodeAt(o);if(i<33||i>126)throw new Error(`Invalid prefix (${t})`);s=be(s)^i>>5}s=be(s);for(let o=0;o<r;o++)s=be(s)^t.charCodeAt(o)&31;for(let o of e)s=be(s)^o;for(let o=0;o<6;o++)s=be(s);return s^=n,It.encode(vt([s%Ve[30]],30,5,!1))}function Xn(t){const e=t==="bech32"?1:734539939,n=Jr(5),r=n.decode,s=n.encode,o=un(r);function i(y,g,f=90){_e("bech32.encode prefix",y),Ke(g)&&(g=Array.from(g)),Ut("bech32.encode",g);const m=y.length;if(m===0)throw new TypeError(`Invalid prefix length ${m}`);const B=m+7+g.length;if(f!==!1&&B>f)throw new TypeError(`Length ${B} exceeds limit ${f}`);const K=y.toLowerCase(),C=hn(K,g,e);return`${K}1${It.encode(g)}${C}`}function a(y,g=90){_e("bech32.decode input",y);const f=y.length;if(f<8||g!==!1&&f>g)throw new TypeError(`invalid string length: ${f} (${y}). Expected (8..${g})`);const m=y.toLowerCase();if(y!==m&&y!==y.toUpperCase())throw new Error("String must be lowercase or uppercase");const B=m.lastIndexOf("1");if(B===0||B===-1)throw new Error('Letter "1" must be present between prefix and data only');const K=m.slice(0,B),C=m.slice(B+1);if(C.length<6)throw new Error("Data must be at least 6 characters long");const Y=It.decode(C).slice(0,-6),Z=hn(K,Y,e);if(!C.endsWith(Z))throw new Error(`Invalid checksum in ${y}: expected "${Z}"`);return{prefix:K,words:Y}}const c=un(a);function d(y){const{prefix:g,words:f}=a(y,!1);return{prefix:g,words:f,bytes:r(f)}}function h(y,g){return i(y,s(g))}return{encode:i,decode:a,encodeFromBytes:h,decodeToBytes:d,decodeUnsafe:c,fromWords:r,fromWordsUnsafe:o,toWords:s}}const Yo=Xn("bech32"),qo=Xn("bech32m");const Se=oe.Point,{Fn:ge}=Se,it=Gn(j),ns=Uint8Array.from("Bitcoin seed".split(""),t=>t.charCodeAt(0)),at={private:76066276,public:76067358},ct=2147483648,rs=t=>Te(j(t)),ss=t=>Je(t).getUint32(0,!1),Fe=t=>{if(!Number.isSafeInteger(t)||t<0||t>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+t);const e=new Uint8Array(4);return Je(e).setUint32(0,t,!1),e};class fe{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return ss(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const e=this._privateKey;if(!e)throw new Error("No private key");return it.encode(this.serialize(this.versions.private,J(Uint8Array.of(0),e)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return it.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(e,n=at){if(P(e),8*e.length<128||8*e.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+e.length);const r=Le(bt,ns,e),s=r.slice(0,32),o=r.slice(32);return new fe({versions:n,chainCode:o,privateKey:s})}static fromExtendedKey(e,n=at){const r=it.decode(e),s=Je(r),o=s.getUint32(0,!1),i={versions:n,depth:r[4],parentFingerprint:s.getUint32(5,!1),index:s.getUint32(9,!1),chainCode:r.slice(13,45)},a=r.slice(45),c=a[0]===0;if(o!==n[c?"private":"public"])throw new Error("Version mismatch");return c?new fe({...i,privateKey:a.slice(1)}):new fe({...i,publicKey:a})}static fromJSON(e){return fe.fromExtendedKey(e.xpriv)}versions;depth=0;index=0;chainCode=null;parentFingerprint=0;_privateKey;_publicKey;pubHash;constructor(e){if(!e||typeof e!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||at,this.depth=e.depth||0,this.chainCode=e.chainCode||null,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!oe.utils.isValidSecretKey(e.privateKey))throw new Error("Invalid private key");this._privateKey=e.privateKey,this._publicKey=oe.getPublicKey(e.privateKey,!0)}else if(e.publicKey)this._publicKey=Se.fromBytes(e.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=rs(this._publicKey)}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;const n=e.replace(/^[mM]'?\//,"").split("/");let r=this;for(const s of n){const o=/^(\d+)('?)$/.exec(s),i=o&&o[1];if(!o||o.length!==3||typeof i!="string")throw new Error("invalid child index: "+s);let a=+i;if(!Number.isSafeInteger(a)||a>=ct)throw new Error("Invalid index");o[2]==="'"&&(a+=ct),r=r.deriveChild(a)}return r}deriveChild(e){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let n=Fe(e);if(e>=ct){const c=this._privateKey;if(!c)throw new Error("Could not derive hardened child key");n=J(Uint8Array.of(0),c,n)}else n=J(this._publicKey,n);const r=Le(bt,this.chainCode,n),s=r.slice(0,32),o=r.slice(32);if(!oe.utils.isValidSecretKey(s))throw new Error("Tweak bigger than curve order");const i={versions:this.versions,chainCode:o,depth:this.depth+1,parentFingerprint:this.fingerprint,index:e},a=ge.fromBytes(s);try{if(this._privateKey){const c=ge.create(ge.fromBytes(this._privateKey)+a);if(!ge.isValidNot0(c))throw new Error("The tweak was out of range or the resulted private key is invalid");i.privateKey=ge.toBytes(c)}else{const c=Se.fromBytes(this._publicKey).add(Se.BASE.multiply(a));if(c.equals(Se.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");i.publicKey=c.toBytes(!0)}return new fe(i)}catch{return this.deriveChild(e+1)}}sign(e){if(!this._privateKey)throw new Error("No privateKey set!");return P(e,32),oe.sign(e,this._privateKey,{prehash:!1})}verify(e,n){if(P(e,32),P(n,64),!this._publicKey)throw new Error("No publicKey set!");return oe.verify(n,e,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,n){if(!this.chainCode)throw new Error("No chainCode set");return P(n,33),J(Fe(e),new Uint8Array([this.depth]),Fe(this.parentFingerprint),Fe(this.index),this.chainCode,n)}}function os(t,e,n,r){Dt(t);const s=Tr({dkLen:32,asyncTick:10},r),{c:o,dkLen:i,asyncTick:a}=s;if(xe(o,"c"),xe(i,"dkLen"),xe(a,"asyncTick"),o<1)throw new Error("iterations (c) must be >= 1");const c=rn(e,"password"),d=rn(n,"salt"),h=new Uint8Array(i),y=Le.create(t,c),g=y._cloneInto().update(d);return{c:o,dkLen:i,asyncTick:a,DK:h,PRF:y,PRFSalt:g}}function is(t,e,n,r,s){return t.destroy(),e.destroy(),r&&r.destroy(),Xe(s),n}function as(t,e,n,r){const{c:s,dkLen:o,DK:i,PRF:a,PRFSalt:c}=os(t,e,n,r);let d;const h=new Uint8Array(4),y=Je(h),g=new Uint8Array(a.outputLen);for(let f=1,m=0;m<o;f++,m+=a.outputLen){const B=i.subarray(m,m+a.outputLen);y.setInt32(0,f,!1),(d=c._cloneInto(d)).update(h).digestInto(g),B.set(g.subarray(0,B.length));for(let K=1;K<s;K++){a._cloneInto(d).update(g).digestInto(g);for(let C=0;C<B.length;C++)B[C]^=g[C]}}return is(a,c,i,d,g)}function Jn(t){if(typeof t!="string")throw new TypeError("invalid mnemonic type: "+typeof t);return t.normalize("NFKD")}function cs(t){const e=Jn(t),n=e.split(" ");if(![12,15,18,21,24].includes(n.length))throw new Error("Invalid mnemonic");return{nfkd:e,words:n}}const ds=t=>Jn("mnemonic"+t);function ls(t,e=""){return as(bt,cs(t).nfkd,ds(e),{c:2048,dkLen:64})}const us=BigInt(0),Ee=BigInt(1),fs=BigInt(2),hs=BigInt(7),ps=BigInt(256),ys=BigInt(113),Qn=[],er=[],tr=[];for(let t=0,e=Ee,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],Qn.push(2*(5*r+n)),er.push((t+1)*(t+2)/2%64);let s=us;for(let o=0;o<7;o++)e=(e<<Ee^(e>>hs)*ys)%ps,e&fs&&(s^=Ee<<(Ee<<BigInt(o))-Ee);tr.push(s)}const nr=Wr(tr,!0),ws=nr[0],ms=nr[1],pn=(t,e,n)=>n>32?Or(t,e,n):Dr(t,e,n),yn=(t,e,n)=>n>32?Rr(t,e,n):Nr(t,e,n);function bs(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let i=0;i<10;i++)n[i]=t[i]^t[i+10]^t[i+20]^t[i+30]^t[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,d=n[c],h=n[c+1],y=pn(d,h,1)^n[a],g=yn(d,h,1)^n[a+1];for(let f=0;f<50;f+=10)t[i+f]^=y,t[i+f+1]^=g}let s=t[2],o=t[3];for(let i=0;i<24;i++){const a=er[i],c=pn(s,o,a),d=yn(s,o,a),h=Qn[i];s=t[h],o=t[h+1],t[h]=c,t[h+1]=d}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)n[a]=t[i+a];for(let a=0;a<10;a++)t[i+a]^=~n[(a+2)%10]&n[(a+4)%10]}t[0]^=ws[r],t[1]^=ms[r]}Xe(n)}class Ft{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(e,n,r,s=!1,o=24){if(this.blockLen=e,this.suffix=n,this.outputLen=r,this.enableXOF=s,this.rounds=o,xe(r,"outputLen"),!(0<e&&e<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=Kr(this.state)}clone(){return this._cloneInto()}keccak(){sn(this.state32),bs(this.state32,this.rounds),sn(this.state32),this.posOut=0,this.pos=0}update(e){Ye(this),P(e);const{blockLen:n,state:r}=this,s=e.length;for(let o=0;o<s;){const i=Math.min(n-this.pos,s-o);for(let a=0;a<i;a++)r[this.pos++]^=e[o++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:n,pos:r,blockLen:s}=this;e[r]^=n,(n&128)!==0&&r===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){Ye(this,!1),P(e),this.finish();const n=this.state,{blockLen:r}=this;for(let s=0,o=e.length;s<o;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,o-s);e.set(n.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return xe(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(_r(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,Xe(this.state)}_cloneInto(e){const{blockLen:n,suffix:r,outputLen:s,rounds:o,enableXOF:i}=this;return e||=new Ft(n,r,s,i,o),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=r,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}}const gs=(t,e,n,r={})=>Lr(()=>new Ft(e,t,n),r),$t=gs(1,136,32),rr={ethereum:60,bitcoin:0,tron:195,bfmeta:9999};function Ht(t,e){const n=ls(t,e);return fe.fromMasterSeed(n)}function Es(t,e=0,n=0,r=0){return`m/44'/${rr[t]}'/${e}'/${n}/${r}`}function As(t,e,n=0,r=0,s=0){return`m/${t}'/${e}'/${n}'/${r}/${s}`}function zt(t,e){return t.derive(e)}function wn(t){const n=oe.getPublicKey(t,!1).slice(1),s=$t(n).slice(-20);return"0x"+ie(s)}function mn(t){const e=t.toLowerCase().replace("0x",""),n=new TextEncoder,r=ie($t(n.encode(e)));let s="0x";for(let o=0;o<e.length;o++)parseInt(r[o],16)>=8?s+=e[o].toUpperCase():s+=e[o];return s}function sr(t,e="mainnet"){const n=j(t),r=Te(n),s=e==="mainnet"?0:111,o=new Uint8Array([s,...r]),i=j(j(o)).slice(0,4),a=new Uint8Array([...o,...i]);return jt(a)}function vs(t,e="mainnet"){const n=j(t),r=Te(n),s=new Uint8Array([0,20,...r]),o=j(s),i=Te(o),a=e==="mainnet"?5:196,c=new Uint8Array([a,...i]),d=j(j(c)).slice(0,4),h=new Uint8Array([...c,...d]);return jt(h)}function Is(t,e="mainnet"){const n=j(t),r=Te(n);return Ts(e==="mainnet"?"bc":"tb",0,r)}function Ss(t,e="mainnet"){const n=t.length===33?t.slice(1):t.slice(1,33);return Ls(e==="mainnet"?"bc":"tb",1,n)}function Cs(t){const n=oe.getPublicKey(t,!1).slice(1),s=$t(n).slice(-20),o=new Uint8Array([65,...s]),i=j(j(o)).slice(0,4),a=new Uint8Array([...o,...i]);return jt(a)}const bn="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";function jt(t){const e=[0];for(const r of t){let s=r;for(let o=0;o<e.length;o++)s+=e[o]<<8,e[o]=s%58,s=s/58|0;for(;s>0;)e.push(s%58),s=s/58|0}let n="";for(const r of t)if(r===0)n+=bn[0];else break;for(let r=e.length-1;r>=0;r--)n+=bn[e[r]];return n}const or="qpzry9x8gf2tvdw0s3jn54khce6mua7l",xs=[996825010,642813549,513874426,1027748829,705979059];function ks(t){let e=1;for(const n of t){const r=e>>25;e=(e&33554431)<<5^n;for(let s=0;s<5;s++)r>>s&1&&(e^=xs[s])}return e}function Bs(t){const e=[];for(const n of t)e.push(n.charCodeAt(0)>>5);e.push(0);for(const n of t)e.push(n.charCodeAt(0)&31);return e}function ir(t,e,n){const r=[...Bs(t),...e],s=n?734539939:1,o=ks([...r,0,0,0,0,0,0])^s,i=[];for(let a=0;a<6;a++)i.push(o>>5*(5-a)&31);return i}function ar(t,e,n,r){let s=0,o=0;const i=[],a=(1<<n)-1;for(const c of t)for(s=s<<e|c,o+=e;o>=n;)o-=n,i.push(s>>o&a);return o>0&&i.push(s<<n-o&a),i}function Ts(t,e,n){const r=ar(n,8,5),s=[e,...r],o=ir(t,s,!1),i=[...s,...o].map(a=>or[a]).join("");return`${t}1${i}`}function Ls(t,e,n){const r=ar(n,8,5),s=[e,...r],o=ir(t,s,!0),i=[...s,...o].map(a=>or[a]).join("");return`${t}1${i}`}function dt(t,e,n=0,r=0){const s=Ht(t),o=Es(e,r,0,n),i=zt(s,o);if(!i.privateKey||!i.publicKey)throw new Error("密钥派生失败");const a=ie(i.privateKey),c=ie(i.publicKey);let d;switch(e){case"ethereum":d=mn(wn(i.privateKey));break;case"bitcoin":d=sr(i.publicKey);break;case"tron":d=Cs(i.privateKey);break;case"bfmeta":d=mn(wn(i.privateKey));break;default:throw new Error(`不支持的链类型: ${e}`)}return{privateKey:a,publicKey:c,address:d,path:o,chain:e}}function Ks(t,e=44,n=0,r=0,s="mainnet"){const o=Ht(t),i=As(e,rr.bitcoin,r,0,n),a=zt(o,i);if(!a.privateKey||!a.publicKey)throw new Error("密钥派生失败");const c=ie(a.privateKey),d=ie(a.publicKey);let h;switch(e){case 44:h=sr(a.publicKey,s);break;case 49:h=vs(a.publicKey,s);break;case 84:h=Is(a.publicKey,s);break;case 86:h=Ss(a.publicKey,s);break;default:throw new Error(`不支持的 Bitcoin purpose: ${e}`)}return{privateKey:c,publicKey:d,address:h,path:i,chain:"bitcoin",purpose:e}}function _s(t,e=0,n=0,r="mainnet"){return[44,49,84,86].map(o=>Ks(t,o,e,n,r))}function Zo(t,e=0,n=0){const r=[];return r.push(dt(t,"ethereum",e,n)),r.push(dt(t,"bfmeta",e,n)),r.push(dt(t,"tron",e,n)),r.push(..._s(t,e,n)),r}function $e(t){const e=Ht(t),r=zt(e,"m/44'/9999'/0'/1/0");if(!r.privateKey)throw new Error("密钥派生失败");return r.privateKey}function He(t){const n=new TextEncoder().encode(`KeyApp:EncryptionKey:${t}`);return j(n)}function Go(t,e){switch(e){case"ethereum":case"bfmeta":return/^0x[a-fA-F0-9]{40}$/.test(t);case"bitcoin":return/^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(t)||/^bc1q[a-z0-9]{38,}$/.test(t)||/^bc1p[a-z0-9]{58}$/.test(t);case"tron":return/^T[a-zA-Z0-9]{33}$/.test(t);default:return!1}}const St=(t,e)=>e.some(n=>t instanceof n);let gn,En;function Ds(){return gn||(gn=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function Ns(){return En||(En=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const Ct=new WeakMap,lt=new WeakMap,Qe=new WeakMap;function Os(t){const e=new Promise((n,r)=>{const s=()=>{t.removeEventListener("success",o),t.removeEventListener("error",i)},o=()=>{n(pe(t.result)),s()},i=()=>{r(t.error),s()};t.addEventListener("success",o),t.addEventListener("error",i)});return Qe.set(e,t),e}function Rs(t){if(Ct.has(t))return;const e=new Promise((n,r)=>{const s=()=>{t.removeEventListener("complete",o),t.removeEventListener("error",i),t.removeEventListener("abort",i)},o=()=>{n(),s()},i=()=>{r(t.error||new DOMException("AbortError","AbortError")),s()};t.addEventListener("complete",o),t.addEventListener("error",i),t.addEventListener("abort",i)});Ct.set(t,e)}let xt={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return Ct.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return pe(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function cr(t){xt=t(xt)}function Ws(t){return Ns().includes(t)?function(...e){return t.apply(kt(this),e),pe(this.request)}:function(...e){return pe(t.apply(kt(this),e))}}function Ms(t){return typeof t=="function"?Ws(t):(t instanceof IDBTransaction&&Rs(t),St(t,Ds())?new Proxy(t,xt):t)}function pe(t){if(t instanceof IDBRequest)return Os(t);if(lt.has(t))return lt.get(t);const e=Ms(t);return e!==t&&(lt.set(t,e),Qe.set(e,t)),e}const kt=t=>Qe.get(t);function Us(t,e,{blocked:n,upgrade:r,blocking:s,terminated:o}={}){const i=indexedDB.open(t,e),a=pe(i);return r&&i.addEventListener("upgradeneeded",c=>{r(pe(i.result),c.oldVersion,c.newVersion,pe(i.transaction),c)}),n&&i.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),a.then(c=>{o&&c.addEventListener("close",()=>o()),s&&c.addEventListener("versionchange",d=>s(d.oldVersion,d.newVersion,d))}).catch(()=>{}),a}const Ps=["get","getKey","getAll","getAllKeys","count"],Fs=["put","add","delete","clear"],ut=new Map;function An(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(ut.get(e))return ut.get(e);const n=e.replace(/FromIndex$/,""),r=e!==n,s=Fs.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(s||Ps.includes(n)))return;const o=async function(i,...a){const c=this.transaction(i,s?"readwrite":"readonly");let d=c.store;return r&&(d=d.index(a.shift())),(await Promise.all([d[n](...a),s&&c.done]))[0]};return ut.set(e,o),o}cr(t=>({...t,get:(e,n,r)=>An(e,n)||t.get(e,n,r),has:(e,n)=>!!An(e,n)||t.has(e,n)}));const $s=["continue","continuePrimaryKey","advance"],vn={},Bt=new WeakMap,dr=new WeakMap,Hs={get(t,e){if(!$s.includes(e))return t[e];let n=vn[e];return n||(n=vn[e]=function(...r){Bt.set(this,dr.get(this)[e](...r))}),n}};async function*zs(...t){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...t)),!e)return;e=e;const n=new Proxy(e,Hs);for(dr.set(n,e),Qe.set(n,kt(e));e;)yield n,e=await(Bt.get(n)||e.continue()),Bt.delete(n)}function In(t,e){return e===Symbol.asyncIterator&&St(t,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&St(t,[IDBIndex,IDBObjectStore])}cr(t=>({...t,get(e,n,r){return In(e,n)?zs:t.get(e,n,r)},has(e,n){return In(e,n)||t.has(e,n)}}));function ft(t,e,n){if(!Array.isArray(e))return console.warn(`[safeParse] Expected array from ${n}, got ${typeof e}`),[];const r=[];for(let s=0;s<e.length;s++){const o=t.safeParse(e[s]);o.success?r.push(o.data):console.warn(`[safeParse] Invalid item at index ${s} from ${n}:`,o.error.issues[0])}return r}const ze=2;var D=(t=>(t.NOT_INITIALIZED="STORAGE_NOT_INITIALIZED",t.WALLET_NOT_FOUND="WALLET_NOT_FOUND",t.ADDRESS_NOT_FOUND="ADDRESS_NOT_FOUND",t.DECRYPTION_FAILED="DECRYPTION_FAILED",t.ENCRYPTION_FAILED="ENCRYPTION_FAILED",t.STORAGE_FULL="STORAGE_FULL",t.MIGRATION_FAILED="MIGRATION_FAILED",t.INVALID_PASSWORD="INVALID_PASSWORD",t))(D||{});class O extends Error{constructor(e,n,r){super(n),this.code=e,this.cause=r,this.name="WalletStorageError"}}class lr extends Error{code="WALLET_MIGRATION_REQUIRED";storedVersion;requiredVersion;constructor(e,n){super(`Wallet storage migration required: v${e} → v${n}`),this.name="WalletStorageMigrationError",this.storedVersion=e,this.requiredVersion=n}}const Tt=Q({salt:S(),iv:S(),ciphertext:S()}).passthrough(),js=Q({assetType:S(),symbol:S(),decimals:G(),balance:S().default("0"),contractAddress:S().optional(),logoUrl:S().optional()}).passthrough(),ht=Q({addressKey:S(),walletId:S(),chain:S(),address:S(),publicKey:S().optional(),encryptedPrivateKey:Tt.optional(),derivationPath:S().optional(),assets:Ot(js).default([]),isCustomAssets:he().default(!1),isFrozen:he().default(!1)}).passthrough(),Sn=Q({id:S(),name:S(),keyType:Nt(["mnemonic","arbitrary","privateKey"]),primaryChain:S(),primaryAddress:S(),encryptedMnemonic:Tt.optional(),encryptedWalletLock:Tt.optional(),isBackedUp:he().default(!1),themeHue:G().optional(),createdAt:G(),updatedAt:G()}).passthrough(),Vs=Q({name:S(),passwordTips:S().optional(),activeWalletId:S().nullable(),biometricEnabled:he().default(!1),walletLockEnabled:he().default(!0),agreementAccepted:he().default(!1),createdAt:G(),updatedAt:G()}).passthrough();Q({version:G(),createdAt:G(),lastMigratedAt:G().optional()}).passthrough();const Ys="bfm-wallet-db",qs=1;class Zs{db=null;initialized=!1;async initialize(){if(this.initialized)return;this.db=await Us(Ys,qs,{upgrade(r,s,o,i){let a;if(r.objectStoreNames.contains("metadata")||(a=r.createObjectStore("metadata")),r.objectStoreNames.contains("walleter")||r.createObjectStore("walleter"),r.objectStoreNames.contains("wallets")||r.createObjectStore("wallets",{keyPath:"id"}).createIndex("by-chain","primaryChain"),!r.objectStoreNames.contains("chainAddresses")){const c=r.createObjectStore("chainAddresses",{keyPath:"addressKey"});c.createIndex("by-wallet","walletId"),c.createIndex("by-chain","chain")}r.objectStoreNames.contains("addressBook")||r.createObjectStore("addressBook",{keyPath:"id"}).createIndex("by-chain","chain"),s===0&&a?a.put({version:ze,createdAt:Date.now()},"main"):s===0&&i.objectStore("metadata").put({version:ze,createdAt:Date.now()},"main")}}),this.initialized=!0;const n=(await this.getMetadata())?.version??0;if(n>0&&n<ze)throw new lr(n,ze);await this.runMigrations()}isInitialized(){return this.initialized}ensureInitialized(){if(!this.initialized||!this.db)throw new O(D.NOT_INITIALIZED,"Storage service not initialized. Call initialize() first.")}async getMetadata(){return this.ensureInitialized(),await this.db.get("metadata","main")??null}async saveWalleterInfo(e){this.ensureInitialized(),await this.db.put("walleter",e,"main")}async getWalleterInfo(){this.ensureInitialized();const e=await this.db.get("walleter","main");if(!e)return null;const n=Vs.safeParse(e);return n.success?n.data:(console.warn("[WalletStorage] Invalid walleter info:",n.error.issues[0]),null)}async createWallet(e,n,r){if(this.ensureInitialized(),!n||typeof n!="string")throw new O(D.ENCRYPTION_FAILED,"Invalid mnemonic: mnemonic is required");if(!r||typeof r!="string")throw new O(D.ENCRYPTION_FAILED,"Invalid walletLock: wallet lock password is required");if(typeof crypto>"u"||!crypto.subtle)throw new O(D.ENCRYPTION_FAILED,"Web Crypto API is not available. Please use HTTPS or localhost.");try{const s=await Ue(n,r),o=e.keyType==="mnemonic"?$e(n):He(n),i=await st(r,o),a={...e,encryptedMnemonic:s,encryptedWalletLock:i};return await this.db.put("wallets",a),a}catch(s){const o=s instanceof Error?s.message:String(s);throw new O(D.ENCRYPTION_FAILED,`Failed to encrypt wallet data: ${o}`,s instanceof Error?s:void 0)}}async saveWallet(e){this.ensureInitialized(),await this.db.put("wallets",e)}async getWallet(e){this.ensureInitialized();const n=await this.db.get("wallets",e);if(!n)return null;const r=Sn.safeParse(n);return r.success?r.data:(console.warn("[WalletStorage] Invalid wallet info:",r.error.issues[0]),null)}async getAllWallets(){this.ensureInitialized();const e=await this.db.getAll("wallets");return ft(Sn,e,"indexeddb:wallets")}async updateWallet(e,n){this.ensureInitialized();const r=await this.getWallet(e);if(!r)throw new O(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);await this.db.put("wallets",{...r,...n,updatedAt:Date.now()})}async deleteWallet(e){this.ensureInitialized(),await this.db.delete("wallets",e);const n=await this.getWalletChainAddresses(e),r=this.db.transaction("chainAddresses","readwrite");await Promise.all(n.map(s=>r.store.delete(s.addressKey))),await r.done}async getMnemonic(e,n){this.ensureInitialized();const r=await this.getWallet(e);if(!r)throw new O(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!r.encryptedMnemonic)throw new O(D.DECRYPTION_FAILED,"No encrypted mnemonic found for this wallet");try{return await gt(r.encryptedMnemonic,n)}catch(s){throw new O(D.DECRYPTION_FAILED,"Failed to decrypt mnemonic. Wrong password or corrupted data.",s instanceof Error?s:void 0)}}async updateWalletLockEncryption(e,n,r){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new O(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);const o=await this.getMnemonic(e,n);try{const i=await Ue(o,r),a=s.keyType==="mnemonic"?$e(o):He(o),c=await st(r,a);await this.updateWallet(e,{encryptedMnemonic:i,encryptedWalletLock:c})}catch(i){throw new O(D.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",i instanceof Error?i:void 0)}}async verifyMnemonic(e,n){this.ensureInitialized();const r=await this.getWallet(e);if(!r)throw new O(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!r.encryptedWalletLock)throw new O(D.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");try{const s=r.keyType==="mnemonic"?$e(n):He(n);return await an(r.encryptedWalletLock,s),!0}catch{return!1}}async resetWalletLockByMnemonic(e,n,r){this.ensureInitialized();const s=await this.getWallet(e);if(!s)throw new O(D.WALLET_NOT_FOUND,`Wallet not found: ${e}`);if(!s.encryptedWalletLock)throw new O(D.DECRYPTION_FAILED,"No encrypted wallet lock found for this wallet");const o=s.keyType==="mnemonic"?$e(n):He(n);try{await an(s.encryptedWalletLock,o)}catch{throw new O(D.INVALID_PASSWORD,"Invalid mnemonic/secret: failed to decrypt wallet lock")}try{const i=await Ue(n,r),a=await st(r,o);await this.updateWallet(e,{encryptedMnemonic:i,encryptedWalletLock:a})}catch(i){throw new O(D.ENCRYPTION_FAILED,"Failed to re-encrypt wallet data",i instanceof Error?i:void 0)}}async savePrivateKey(e,n,r){this.ensureInitialized();const s=await this.getChainAddress(e);if(!s)throw new O(D.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);try{const o=await Ue(n,r);await this.db.put("chainAddresses",{...s,encryptedPrivateKey:o})}catch(o){throw new O(D.ENCRYPTION_FAILED,"Failed to encrypt private key",o instanceof Error?o:void 0)}}async getPrivateKey(e,n){this.ensureInitialized();const r=await this.getChainAddress(e);if(!r)throw new O(D.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);if(!r.encryptedPrivateKey)throw new O(D.DECRYPTION_FAILED,"No encrypted private key found for this address");try{return await gt(r.encryptedPrivateKey,n)}catch(s){throw new O(D.DECRYPTION_FAILED,"Failed to decrypt private key. Wrong password or corrupted data.",s instanceof Error?s:void 0)}}async saveChainAddress(e){this.ensureInitialized(),await this.db.put("chainAddresses",e)}async getChainAddress(e){this.ensureInitialized();const n=await this.db.get("chainAddresses",e);if(!n)return null;const r=ht.safeParse(n);return r.success?r.data:(console.warn("[WalletStorage] Invalid chain address:",r.error.issues[0]),null)}async getWalletChainAddresses(e){this.ensureInitialized();const n=await this.db.getAllFromIndex("chainAddresses","by-wallet",e);return ft(ht,n,"indexeddb:chainAddresses")}async getChainAddresses(e){this.ensureInitialized();const n=await this.db.getAllFromIndex("chainAddresses","by-chain",e);return ft(ht,n,"indexeddb:chainAddresses")}async updateAssets(e,n){this.ensureInitialized();const r=await this.getChainAddress(e);if(!r)throw new O(D.ADDRESS_NOT_FOUND,`Chain address not found: ${e}`);await this.db.put("chainAddresses",{...r,assets:n,isCustomAssets:!0})}async deleteChainAddress(e){this.ensureInitialized(),await this.db.delete("chainAddresses",e)}async saveAddressBookEntry(e){this.ensureInitialized(),await this.db.put("addressBook",e)}async getAddressBookEntry(e){return this.ensureInitialized(),await this.db.get("addressBook",e)??null}async getAllAddressBookEntries(){return this.ensureInitialized(),this.db.getAll("addressBook")}async getChainAddressBookEntries(e){return this.ensureInitialized(),this.db.getAllFromIndex("addressBook","by-chain",e)}async deleteAddressBookEntry(e){this.ensureInitialized(),await this.db.delete("addressBook",e)}async clearAll(){this.ensureInitialized();const e=this.db.transaction(["walleter","wallets","chainAddresses","addressBook"],"readwrite");await Promise.all([e.objectStore("walleter").clear(),e.objectStore("wallets").clear(),e.objectStore("chainAddresses").clear(),e.objectStore("addressBook").clear()]),await e.done}close(){this.db&&(this.db.close(),this.db=null,this.initialized=!1)}async runMigrations(){await this.getMetadata()}async migrateFromLocalStorage(){this.ensureInitialized();const e=localStorage.getItem("bfm_wallets");if(!e)return!1;try{const{wallets:n,currentWalletId:r}=JSON.parse(e);for(const o of n){const i={id:o.id,name:o.name,keyType:o.keyType||"mnemonic",primaryChain:o.chain,primaryAddress:o.address,encryptedMnemonic:o.encryptedMnemonic,isBackedUp:!1,createdAt:o.createdAt,updatedAt:Date.now()};if(await this.saveWallet(i),o.chainAddresses)for(const a of o.chainAddresses){const d={addressKey:`${o.id}:${a.chain}`,walletId:o.id,chain:a.chain,address:a.address,assets:[],isCustomAssets:!1,isFrozen:!1};await this.saveChainAddress(d)}}const s=await this.getWalleterInfo();return s?r&&await this.saveWalleterInfo({...s,activeWalletId:r,updatedAt:Date.now()}):await this.saveWalleterInfo({name:"User",activeWalletId:r,biometricEnabled:!1,walletLockEnabled:!1,agreementAccepted:!0,createdAt:Date.now(),updatedAt:Date.now()}),localStorage.removeItem("bfm_wallets"),!0}catch(n){throw console.error("Failed to migrate from localStorage:",n),new O(D.MIGRATION_FAILED,"Failed to migrate data from localStorage",n instanceof Error?n:void 0)}}}const _=new Zs;function Cn(t){let e=0;for(let n=0;n<t.length;n++){const r=t.charCodeAt(n);e=(e<<5)-e+r,e=e&e}return Math.abs(e)%360}const ur="wallet_chain_preferences";function Gs(){try{const t=localStorage.getItem(ur);if(t)return JSON.parse(t)}catch{}return{}}function xn(t){try{localStorage.setItem(ur,JSON.stringify(t))}catch{}}const Lt={wallets:[],currentWalletId:null,selectedChain:"ethereum",chainPreferences:{},isLoading:!1,isInitialized:!1,migrationRequired:!1},U=new Rt(Lt);function Xs(t,e){const n=t.keyType==="mnemonic"?"mnemonic":"arbitrary",r={id:t.id,name:t.name,keyType:n,address:t.primaryAddress,chain:t.primaryChain,createdAt:t.createdAt,chainAddresses:e.map(s=>({chain:s.chain,address:s.address,publicKey:s.publicKey??"",tokens:s.assets.map(o=>{const i={id:`${s.chain}:${o.assetType}`,symbol:o.symbol,name:o.symbol,balance:o.balance,fiatValue:0,change24h:0,decimals:o.decimals,chain:s.chain};return o.contractAddress&&(i.contractAddress=o.contractAddress),o.logoUrl&&(i.icon=o.logoUrl),i})})),themeHue:t.themeHue??0,tokens:[]};return t.encryptedMnemonic&&(r.encryptedMnemonic=t.encryptedMnemonic),t.encryptedWalletLock&&(r.encryptedWalletLock=t.encryptedWalletLock),r}const pt={initialize:async()=>{const t=U.state;if(!(t.isInitialized||t.isLoading)){U.setState(e=>({...e,isLoading:!0}));try{await _.initialize(),await _.migrateFromLocalStorage();const[e,n]=await Promise.all([_.getWalleterInfo(),_.getAllWallets()]),r=await Promise.all(n.map(async c=>{const d=await _.getWalletChainAddresses(c.id);return Xs(c,d)})),s=Gs(),o=e?.activeWalletId??r[0]?.id??null,i=r.find(c=>c.id===o),a=o?s[o]??i?.chain??"bfmeta":"bfmeta";U.setState(c=>({...c,wallets:r,currentWalletId:o,selectedChain:a,chainPreferences:s,isInitialized:!0,isLoading:!1}))}catch(e){if(e instanceof lr){U.setState(n=>({...n,isInitialized:!0,isLoading:!1,migrationRequired:!0}));return}console.error("Failed to initialize wallets:",e),U.setState(n=>({...n,isInitialized:!0,isLoading:!1}))}}},createWallet:async(t,e,n,r)=>{const s=crypto.randomUUID(),o=Date.now(),i={id:s,name:t.name,keyType:t.keyType??"mnemonic",primaryChain:t.chain,primaryAddress:t.address,isBackedUp:!1,themeHue:r??Cn(e),createdAt:o,updatedAt:o},a=await _.createWallet(i,e,n),c=t.chainAddresses||[{chain:t.chain,address:t.address,publicKey:"",tokens:[]}];for(const y of c)await _.saveChainAddress({addressKey:`${s}:${y.chain}`,walletId:s,chain:y.chain,address:y.address,publicKey:y.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});const d=await _.getWalleterInfo();await _.saveWalleterInfo({name:d?.name??"User",activeWalletId:s,biometricEnabled:d?.biometricEnabled??!1,walletLockEnabled:d?.walletLockEnabled??!1,agreementAccepted:!0,createdAt:d?.createdAt??o,updatedAt:o});const h={id:s,name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:o,chainAddresses:c,themeHue:r??Cn(e),tokens:[],...a.encryptedMnemonic?{encryptedMnemonic:a.encryptedMnemonic}:{}};return U.setState(y=>({...y,wallets:[...y.wallets,h],currentWalletId:s})),h},importWallet:async(t,e,n)=>pt.createWallet(t,e,n),deleteWallet:async t=>{await _.deleteWallet(t),U.setState(e=>{const n=e.wallets.filter(c=>c.id!==t),r=e.currentWalletId===t?n[0]?.id??null:e.currentWalletId,{[t]:s,...o}=e.chainPreferences;xn(o);const i=n.find(c=>c.id===r),a=r?o[r]??i?.chain??"bfmeta":e.selectedChain;return{...e,wallets:n,currentWalletId:r,selectedChain:a,chainPreferences:o}})},setCurrentWallet:async t=>{const e=await _.getWalleterInfo();e&&await _.saveWalleterInfo({...e,activeWalletId:t,updatedAt:Date.now()}),U.setState(n=>{const r=n.wallets.find(o=>o.id===t),s=n.chainPreferences[t]??r?.chain??"bfmeta";return{...n,currentWalletId:t,selectedChain:s}})},setSelectedChain:t=>{U.setState(e=>{const{currentWalletId:n,chainPreferences:r}=e;if(n){const s={...r,[n]:t};return xn(s),{...e,selectedChain:t,chainPreferences:s}}return{...e,selectedChain:t}})},updateWalletName:async(t,e)=>{await _.updateWallet(t,{name:e}),U.setState(n=>({...n,wallets:n.wallets.map(r=>r.id===t?{...r,name:e}:r)}))},updateWalletThemeHue:async(t,e)=>{await _.updateWallet(t,{themeHue:e}),U.setState(n=>({...n,wallets:n.wallets.map(r=>r.id===t?{...r,themeHue:e}:r)}))},updateChainAssets:async(t,e,n)=>{const r=`${t}:${e}`;await _.updateAssets(r,n.map(s=>({assetType:s.symbol,symbol:s.symbol,decimals:s.decimals,balance:s.balance,contractAddress:s.contractAddress,logoUrl:s.icon}))),U.setState(s=>({...s,wallets:s.wallets.map(o=>o.id!==t?o:{...o,chainAddresses:o.chainAddresses.map(i=>i.chain===e?{...i,tokens:n}:i)})}))},refreshBalance:async(t,e)=>{const r=U.state.wallets.find(o=>o.id===t);if(!r)return;const s=r.chainAddresses.find(o=>o.chain===e);if(s)try{const{getChainProvider:o}=await Qt(async()=>{const{getChainProvider:d}=await import("./index-DBrPxRsx.js").then(h=>h.k);return{getChainProvider:d}},__vite__mapDeps([0,1,2,3,4,5]),import.meta.url),i=o(e);if(!i.supportsNativeBalance)return;const a=await i.getNativeBalance(s.address),c=[{id:`${e}:${a.symbol}`,symbol:a.symbol,name:a.symbol,balance:a.amount.toFormatted(),fiatValue:0,change24h:0,decimals:a.amount.decimals,chain:e}];await pt.updateChainAssets(t,e,c)}catch(o){console.error(`[refreshBalance] Failed to refresh balance for ${e}:`,o)}},refreshAllBalances:async()=>{const t=U.state,e=Ce.getCurrentWallet(t);e&&await Promise.all(e.chainAddresses.map(n=>pt.refreshBalance(e.id,n.chain)))},updateWalletLock:async(t,e,n)=>{await _.updateWalletLockEncryption(t,e,n);const r=await _.getWallet(t);r?.encryptedMnemonic&&r.encryptedWalletLock&&U.setState(s=>({...s,wallets:s.wallets.map(o=>o.id===t?{...o,encryptedMnemonic:r.encryptedMnemonic,encryptedWalletLock:r.encryptedWalletLock}:o)}))},verifyMnemonic:async(t,e)=>_.verifyMnemonic(t,e),resetWalletLockByMnemonic:async(t,e,n)=>{await _.resetWalletLockByMnemonic(t,e,n);const r=await _.getWallet(t);r?.encryptedMnemonic&&r.encryptedWalletLock&&U.setState(s=>({...s,wallets:s.wallets.map(o=>o.id===t?{...o,encryptedMnemonic:r.encryptedMnemonic,encryptedWalletLock:r.encryptedWalletLock}:o)}))},getMnemonic:async(t,e)=>_.getMnemonic(t,e),updateWalletChainAddresses:async(t,e,n,r)=>{const o=U.state.wallets.find(f=>f.id===t);if(!o)throw new Error("Wallet not found");const i=await _.getMnemonic(t,n),a=new Set(o.chainAddresses.map(f=>f.chain)),c=new Set(e),d=e.filter(f=>!a.has(f)),h=[...a].filter(f=>!c.has(f));if(d.length===0&&h.length===0)return;let y=[];if(d.length>0){const{deriveAddressesForChains:f}=await Qt(async()=>{const{deriveAddressesForChains:C}=await import("./address-derivation-DIK1T4To.js");return{deriveAddressesForChains:C}},__vite__mapDeps([6,3,5,2,4,7,8,9]),import.meta.url),m=r.filter(C=>d.includes(C.id)),B=f(i,m),K=new Map(B.map(C=>[C.chainId,{address:C.address,publicKey:C.publicKey}]));y=d.map(C=>{const Y=K.get(C);return Y?{chain:C,address:Y.address,publicKey:Y.publicKey}:null}).filter(C=>C!==null)}for(const f of y)await _.saveChainAddress({addressKey:`${t}:${f.chain}`,walletId:t,chain:f.chain,address:f.address,publicKey:f.publicKey,assets:[],isCustomAssets:!1,isFrozen:!1});for(const f of h)await _.deleteChainAddress(`${t}:${f}`);const g=[...o.chainAddresses.filter(f=>!h.includes(f.chain)),...y.map(f=>({chain:f.chain,address:f.address,publicKey:f.publicKey,tokens:[]}))];U.setState(f=>({...f,wallets:f.wallets.map(m=>m.id===t?{...m,chainAddresses:g}:m)}))},clearAll:async()=>{await _.clearAll(),U.setState(()=>Lt)},_testAddWallet:t=>{const e={id:t.id??crypto.randomUUID(),name:t.name,keyType:t.keyType??"mnemonic",address:t.address,chain:t.chain,createdAt:t.createdAt??Date.now(),chainAddresses:t.chainAddresses??[{chain:t.chain,address:t.address,publicKey:"",tokens:[]}],themeHue:t.themeHue,tokens:[],...t.encryptedMnemonic?{encryptedMnemonic:t.encryptedMnemonic}:{}};return U.setState(n=>({...n,wallets:[...n.wallets,e],currentWalletId:n.currentWalletId??e.id,isInitialized:!0})),e},_testReset:()=>{U.setState(()=>Lt)}},Ce={getCurrentWallet:t=>t.currentWalletId&&t.wallets.find(e=>e.id===t.currentWalletId)||null,getCurrentChainAddress:t=>{const e=Ce.getCurrentWallet(t);return e&&e.chainAddresses.find(n=>n.chain===t.selectedChain)||null},getCurrentChainTokens:t=>Ce.getCurrentChainAddress(t)?.tokens||[],getAvailableChains:t=>{const e=Ce.getCurrentWallet(t);return e?e.chainAddresses.map(n=>n.chain):[]},getTotalFiatValue:t=>{const e=Ce.getCurrentWallet(t);return e?e.chainAddresses.reduce((n,r)=>n+r.tokens.reduce((s,o)=>s+o.fiatValue,0),0):0},hasWallet:t=>t.wallets.length>0},fr={contacts:[],isInitialized:!1},ee=new Rt(fr),Vt="bfm_address_book",hr=3;function ue(t){try{const e={version:hr,contacts:t};localStorage.setItem(Vt,JSON.stringify(e))}catch(e){console.error("Failed to persist address book:",e)}}function Js(){try{const t=localStorage.getItem(Vt);if(!t)return[];const e=JSON.parse(t);return e.version===hr&&Array.isArray(e.contacts)?e.contacts:[]}catch(t){return console.error("Failed to load address book:",t),[]}}const Xo={initialize:()=>{const t=Js();ee.setState(()=>({contacts:t,isInitialized:!0}))},addContact:t=>{if(t.addresses.length>3)throw new Error("Maximum 3 addresses per contact");const e=Date.now(),n={...t,id:crypto.randomUUID(),createdAt:e,updatedAt:e};return ee.setState(r=>{const s=[...r.contacts,n];return ue(s),{...r,contacts:s}}),n},updateContact:(t,e)=>{ee.setState(n=>{const r=n.contacts.map(s=>s.id===t?{...s,...e,updatedAt:Date.now()}:s);return ue(r),{...n,contacts:r}})},deleteContact:t=>{ee.setState(e=>{const n=e.contacts.filter(r=>r.id!==t);return ue(n),{...e,contacts:n}})},addAddressToContact:(t,e)=>{const n={...e,id:crypto.randomUUID()};ee.setState(r=>{const s=r.contacts.map(o=>{if(o.id!==t)return o;if(o.addresses.length>=3)throw new Error("Maximum 3 addresses per contact");return{...o,addresses:[...o.addresses,n],updatedAt:Date.now()}});return ue(s),{...r,contacts:s}})},removeAddressFromContact:(t,e)=>{ee.setState(n=>{const r=n.contacts.map(s=>s.id!==t?s:{...s,addresses:s.addresses.filter(o=>o.id!==e),updatedAt:Date.now()});return ue(r),{...n,contacts:r}})},setDefaultAddress:(t,e)=>{ee.setState(n=>{const r=n.contacts.map(s=>s.id!==t?s:{...s,addresses:s.addresses.map(o=>({...o,isDefault:o.id===e})),updatedAt:Date.now()});return ue(r),{...n,contacts:r}})},importContacts:t=>{if(t.length===0)return 0;let e=0;return ee.setState(n=>{const r=n.contacts,s=new Set(r.map(a=>a.name.toLowerCase())),o=t.filter(a=>{const c=a.name.toLowerCase();return s.has(c)?!1:(s.add(c),!0)});if(e=o.length,o.length===0)return n;const i=[...r,...o];return ue(i),{...n,contacts:i}}),e},clearAll:()=>{localStorage.removeItem(Vt),ee.setState(()=>fr)}},Jo={getContactByAddress:(t,e)=>{const n=e.toLowerCase();for(const r of t.contacts){const s=r.addresses.find(o=>o.address.toLowerCase()===n);if(s)return{contact:r,matchedAddress:s}}},searchContacts:(t,e)=>{const n=e.toLowerCase();return t.contacts.filter(r=>r.name.toLowerCase().includes(n)||r.addresses.some(s=>s.address.toLowerCase().includes(n)))},suggestContacts:(t,e,n=5)=>{const r=[],s=e&&e.length>0,o=s?e.toLowerCase():"",i=[...t.contacts].sort((c,d)=>d.updatedAt-c.updatedAt);for(const c of i){const d=c.addresses;if(d.length!==0){if(!s){const h=d.find(y=>y.isDefault)??d[0];h&&r.push({contact:c,matchedAddress:h,matchType:"name",score:40});continue}for(const h of d){const y=h.address.toLowerCase();y===o?r.push({contact:c,matchedAddress:h,matchType:"exact",score:100}):y.startsWith(o)?r.push({contact:c,matchedAddress:h,matchType:"prefix",score:80}):y.includes(o)&&r.push({contact:c,matchedAddress:h,matchType:"prefix",score:50})}if(c.name.toLowerCase().includes(o)){const h=d.find(y=>y.isDefault)??d[0];h&&r.push({contact:c,matchedAddress:h,matchType:"name",score:60})}}}const a=new Map;for(const c of r){const d=`${c.contact.id}:${c.matchedAddress.id}`,h=a.get(d);(!h||h.score<c.score)&&a.set(d,c)}return Array.from(a.values()).sort((c,d)=>d.score!==c.score?d.score-c.score:d.contact.updatedAt-c.contact.updatedAt).slice(0,n)},getContactsByChain:(t,e)=>t.contacts.filter(n=>n.addresses.some(r=>on(r.address).chainType===e)),getDefaultAddress:(t,e)=>{const n=e?t.addresses.filter(r=>on(r.address).chainType===e):t.addresses;return n.find(r=>r.isDefault)??n[0]}},Qs=S().regex(/^\d+\.\d+$/,'version must be "major.minor" (e.g. "1.0")'),eo=Nt(["bioforest","evm","bitcoin","tron","custom"]),to=Nt(["default","subscription","manual"]),no=Mr([S().url(),Ur([S().url(),Rn(S(),Pr())])]),ro=Rn(S(),no),so=Q({url:S().url(),queryTx:S().optional(),queryAddress:S().optional(),queryBlock:S().optional()}),et=Q({id:S().regex(/^[a-z0-9-]+$/,"id must match /^[a-z0-9-]+$/"),version:Qs,chainKind:eo,name:S().min(1).max(50),symbol:S().min(1).max(10),icon:S().min(1).optional(),tokenIconBase:Ot(S().min(1)).optional(),prefix:S().min(1).max(10).optional(),decimals:G().int().min(0).max(18),api:ro.optional(),explorer:so.optional(),enabled:he().default(!0),source:to.default("default")}).strict(),Yt=Ot(et).min(1),oo=Q({version:S().regex(/^\d+\.\d+\.\d+$/,'version must be semver (e.g. "2.0.0")'),chains:Yt}),qt=Q({url:S().min(1),refreshIntervalMinutes:G().int().min(1).default(1440),lastUpdated:S().optional(),etag:S().optional()}).strict(),io="bfm_chain_config",ao=1,we="chain_configs",V="chain_preferences";let je=null,Ae=null;function co(){if(typeof indexedDB>"u")throw new Error("indexedDB is not available in this environment")}function tt(t){return new Promise((e,n)=>{t.onsuccess=()=>e(t.result),t.onerror=()=>n(t.error??new Error("IndexedDB request failed"))})}function ae(t){return new Promise((e,n)=>{t.oncomplete=()=>e(),t.onerror=()=>n(t.error??new Error("IndexedDB transaction failed")),t.onabort=()=>n(t.error??new Error("IndexedDB transaction aborted"))})}async function ce(){if(co(),je)return je;if(Ae)return Ae;Ae=new Promise((t,e)=>{const n=indexedDB.open(io,ao);n.onupgradeneeded=()=>{const r=n.result;r.objectStoreNames.contains(we)||r.createObjectStore(we,{keyPath:"key"}).createIndex("source","source",{unique:!1}),r.objectStoreNames.contains(V)||r.createObjectStore(V,{keyPath:"key"})},n.onsuccess=()=>t(n.result),n.onerror=()=>e(n.error??new Error("Failed to open IndexedDB"))});try{return je=await Ae,je}finally{Ae=null}}async function lo(t,e){const n=t.index("source"),r=[];return new Promise((s,o)=>{const i=n.openCursor(IDBKeyRange.only(e));i.onsuccess=()=>{const a=i.result;if(!a){s(r);return}r.push(a.primaryKey),a.continue()},i.onerror=()=>o(i.error??new Error("Failed to read IndexedDB cursor"))})}async function Zt(t){const n=(await ce()).transaction([we],"readwrite"),r=n.objectStore(we),s=await lo(r,t.source);for(const o of s)r.delete(o);for(const o of t.configs){const i={id:o.id,version:o.version,chainKind:o.chainKind,name:o.name,symbol:o.symbol,decimals:o.decimals,...o.icon!==void 0?{icon:o.icon}:{},...o.prefix!==void 0?{prefix:o.prefix}:{},...o.api!==void 0?{api:o.api}:{},...o.explorer!==void 0?{explorer:o.explorer}:{}},a={key:`${t.source}:${o.id}`,id:o.id,source:t.source,config:i};r.put(a)}await ae(n)}async function Gt(){const e=(await ce()).transaction([we],"readonly"),n=e.objectStore(we),r=await tt(n.getAll());return await ae(e),r.filter(s=>typeof s=="object"&&s!==null&&"source"in s&&"config"in s&&"id"in s).map(s=>({...s.config,source:s.source,enabled:!0}))}function uo(t){if(typeof t!="object"||t===null||Array.isArray(t))return!1;for(const e of Object.values(t))if(typeof e!="boolean")return!1;return!0}async function fo(t){const n=(await ce()).transaction([V],"readwrite"),r=n.objectStore(V),s={key:"enabledMap",value:t};r.put(s),await ae(n)}async function pr(){const e=(await ce()).transaction([V],"readonly"),n=e.objectStore(V),r=await tt(n.get("enabledMap"));if(await ae(e),!r||typeof r!="object")return{};const s=r.value;return uo(s)?s:{}}async function yr(t){const n=(await ce()).transaction([V],"readwrite"),r=n.objectStore(V),s={key:"subscriptionMeta",value:t};r.put(s),await ae(n)}async function nt(){const e=(await ce()).transaction([V],"readonly"),n=e.objectStore(V),r=await tt(n.get("subscriptionMeta"));if(await ae(e),!r||typeof r!="object")return null;const s=r.value,o=qt.safeParse(s);return o.success?o.data:null}async function ho(t){const n=(await ce()).transaction([V],"readwrite"),r=n.objectStore(V),s={key:"defaultVersion",value:t};r.put(s),await ae(n)}async function po(){const e=(await ce()).transaction([V],"readonly"),n=e.objectStore(V),r=await tt(n.get("defaultVersion"));if(await ae(e),!r||typeof r!="object")return null;const s=r.value;return typeof s=="string"?s:null}const yo=1e4,wo=new Set(["bioforest","evm","bip39","custom"]);function kn(t){if(typeof t!="object"||t===null||Array.isArray(t))return t;const e=t,n=e.type;return typeof n=="string"&&!wo.has(n)?{...e,chainKind:"custom"}:t}function mo(t){const e=Array.isArray(t)?t.map(kn):kn(t);return(Array.isArray(e)?Yt.parse(e):[et.parse(e)]).map(r=>({...r,source:"subscription",enabled:!0}))}function bo(t,e){if(t.length===0)return e;const n=new Map;for(const r of t)n.set(r.id,{...r,source:"subscription",enabled:!0});return[...n.values()]}function go(t){return t.filter(e=>e.source==="subscription")}async function Eo(t,e){if(t==="default")return{status:"skipped",reason:"default",configs:[],meta:null};const n=await Gt(),r=go(n),s=await nt(),o=void 0,i=new AbortController,a=setTimeout(()=>i.abort(),yo);try{const c=await fetch(t,{method:"GET",signal:i.signal,headers:{Accept:"application/json",...o!==void 0?{"If-None-Match":o}:{}}});if(clearTimeout(a),c.status===304)return{status:"not_modified",configs:r,meta:s};if(!c.ok)return{status:"error",error:`Subscription fetch failed: ${c.status} ${c.statusText}`,configs:r,meta:s};const d=await c.json(),h=mo(d),y=bo(h,r),g=c.headers.get("ETag")??void 0,f=qt.parse({url:t,...g!==void 0?{etag:g}:{},lastUpdated:new Date().toISOString()});return await Zt({source:"subscription",configs:y}),await yr(f),{status:"updated",configs:y,meta:f}}catch(c){return clearTimeout(a),{status:"error",error:c instanceof Error&&c.name==="AbortError"?"Subscription request timeout":c instanceof Error?c.message:"Failed to fetch subscription",configs:r,meta:s??null}}}class wr extends Error{code="MIGRATION_REQUIRED";storedVersion;requiredVersion;constructor(e,n){super(`Database migration required: stored version ${e??"unknown"} is incompatible with ${n}`),this.name="ChainConfigMigrationError",this.storedVersion=e,this.requiredVersion=n}}const Ao=new Set(["bioforest","evm","bitcoin","tron","custom"]),mr={bioforest:1,evm:1,bitcoin:1,tron:1,custom:1},vo="./configs/default-chains.json";let yt=null,ve=null;function Kt(t){if(typeof t!="object"||t===null||Array.isArray(t))return t;const e=t,n=e.chainKind;return typeof n=="string"&&!Ao.has(n)?{...e,chainKind:"custom"}:t}function br(t){const e=t.split(".")[0],n=Number(e);return Number.isInteger(n)?n:null}function Io(t){const e=br(t.version);return e===null?!1:e<=mr[t.chainKind]}function So(){const t=typeof window>"u"?"http://localhost/":window.location.href;return new URL(vo,t).toString()}async function Co(){if(yt)return yt;if(ve)return ve;ve=(async()=>{if(typeof fetch>"u")throw new Error("fetch is not available in this environment");const t=So(),e=await fetch(t,{method:"GET",headers:{Accept:"application/json"}});if(!e.ok)throw new Error(`Failed to load default chain configs: ${e.status} ${e.statusText}`);const n=await e.json(),r=oo.parse(n),s=r.chains.map(i=>Kt(i)).map(i=>{const a=et.parse(i),c=ko(a,t);return{...a,...c,source:"default",enabled:!0}}),o={version:r.version,configs:s};return yt=o,o})();try{return await ve}finally{ve=null}}function xo(t){try{return JSON.parse(t)}catch{throw new Error("Invalid JSON")}}function Bn(t,e){return t.startsWith("http://")||t.startsWith("https://")?t:new URL(t,e).toString()}function ko(t,e){const n={};return t.icon!==void 0&&(n.icon=Bn(t.icon,e)),t.tokenIconBase!==void 0&&(n.tokenIconBase=t.tokenIconBase.map(r=>Bn(r,e))),n}function Bo(t,e,n){const r=Array.isArray(t)?t.map(Kt):Kt(t);return(Array.isArray(r)?Yt.parse(r):[et.parse(r)]).map(o=>({...o,...{},source:e,enabled:!0}))}function To(t){const e=new Map;for(const n of t.manual)e.set(n.id,{...n,source:"manual"});for(const n of t.subscription)e.has(n.id)||e.set(n.id,{...n,source:"subscription"});for(const n of t.defaults)e.has(n.id)||e.set(n.id,{...n,source:"default"});return[...e.values()]}function Lo(t,e){return t.map(n=>{const r=e[n.id];return{...n,enabled:typeof r=="boolean"?r:!0}})}function Ko(t){const e=[];for(const n of t){const r=br(n.version);if(r===null)continue;const s=mr[n.chainKind];r>s&&e.push({id:n.id,kind:"incompatible_major",version:n.version,supportedMajor:s,source:n.source})}return e}function _o(t){const e=parseInt(t.split(".")[0]??"0",10);return Number.isNaN(e)?0:e}function Do(t,e){const n=t.split(".").map(Number),r=e.split(".").map(Number);for(let s=0;s<3;s++){const o=n[s]??0,i=r[s]??0;if(o>i)return 1;if(o<i)return-1}return 0}async function Ne(){const{version:t,configs:e}=await Co(),[n,r,s,o]=await Promise.all([Gt(),pr(),nt(),po()]),i=_o(t),a=n.length>0||Object.keys(r).length>0||s!==null;if(o===null&&i>=2&&a)throw new wr(o,t);Do(t,o??"0.0.0")>0&&await ho(t);const d=n.filter(m=>m.source==="manual"),h=s?.url&&s.url!=="default"?n.filter(m=>m.source==="subscription"):[],y=To({manual:d,subscription:h,defaults:e}),g=Lo(y,r),f=Ko(g);return{configs:g,enabledMap:r,subscription:s,warnings:f}}async function No(t){const e=typeof t=="string"?xo(t):t,n=Bo(e,"manual"),s=(await Gt()).filter(i=>i.source==="manual"),o=new Map;for(const i of s)o.set(i.id,{...i,source:"manual",enabled:!0});for(const i of n)o.set(i.id,{...i,source:"manual",enabled:!0});return await Zt({source:"manual",configs:[...o.values()]}),Ne()}async function wt(t,e){const r={...await pr(),[t]:e};return await fo(r),Ne()}async function Tn(){const e=(await nt())?.url??"default",n=await Eo(e),r=await Ne();return{result:n,snapshot:r}}function Oo(t){const e=t.trim();if(e==="")return"default";if(e==="default")return e;let n;try{n=new URL(e)}catch{throw new Error("Invalid subscription URL")}if(n.protocol!=="http:"&&n.protocol!=="https:")throw new Error("Subscription URL must use http(s)");return e}async function Ro(t){const e=Oo(t),n=await nt(),r=n?.url;r!==e&&await Zt({source:"subscription",configs:[]});const s=qt.parse({url:e,refreshIntervalMinutes:n?.refreshIntervalMinutes??1440,...r===e?{...n?.etag?{etag:n.etag}:{},...n?.lastUpdated?{lastUpdated:n.lastUpdated}:{}}:{}});return await yr(s),Ne()}function Ln(t){return t.configs.filter(e=>e.enabled&&Io(e))}function Wo(t,e){return t.configs.find(n=>n.id===e)??null}const Mo={snapshot:null,isLoading:!1,error:null,migrationRequired:!1},M=new Rt(Mo);function _t(t){return t instanceof Error?t.message:"Unknown error"}async function Ie(t){M.setState(e=>({...e,isLoading:!0,error:null,migrationRequired:!1}));try{const e=await t();M.setState(n=>({...n,snapshot:e,isLoading:!1,error:null}))}catch(e){e instanceof wr?M.setState(n=>({...n,isLoading:!1,error:e.message,migrationRequired:!0})):M.setState(n=>({...n,isLoading:!1,error:_t(e)}))}}const Qo={initialize:async()=>{const t=M.state;t.isLoading||t.snapshot||await Ie(async()=>Ne())},setSubscriptionUrl:async t=>{M.setState(e=>({...e,isLoading:!0,error:null}));try{const e=await Ro(t);if((e.subscription?.url??"default")==="default"){M.setState(i=>({...i,snapshot:e,isLoading:!1,error:null}));return}const{result:r,snapshot:s}=await Tn(),o=r.status==="error"?r.error:null;M.setState(i=>({...i,snapshot:s,isLoading:!1,error:o}))}catch(e){M.setState(n=>({...n,isLoading:!1,error:_t(e)}))}},refreshSubscription:async()=>{M.setState(t=>({...t,isLoading:!0,error:null}));try{const{result:t,snapshot:e}=await Tn(),n=t.status==="error"?t.error:null;M.setState(r=>({...r,snapshot:e,isLoading:!1,error:n}))}catch(t){M.setState(e=>({...e,isLoading:!1,error:_t(t)}))}},addManualConfig:async t=>{await Ie(async()=>No(t))},setChainEnabled:async(t,e)=>{await Ie(async()=>wt(t,e))},enableChain:async t=>{await Ie(async()=>wt(t,!0))},disableChain:async t=>{await Ie(async()=>wt(t,!1))},clearError:()=>{M.setState(t=>({...t,error:null}))}},Oe={getSnapshot:t=>t.snapshot,getConfigs:t=>t.snapshot?.configs??[],getSubscription:t=>t.snapshot?.subscription??null,getWarnings:t=>t.snapshot?.warnings??[],getEnabledChains:t=>t.snapshot?Ln(t.snapshot):[],getEnabledBioforestChainConfigs:t=>t.snapshot?Ln(t.snapshot).filter(e=>e.chainKind==="bioforest"):[],getChainById:(t,e)=>t.snapshot?Wo(t.snapshot,e):null};function ei(){return ne(M)}function ti(){return ne(M,t=>Oe.getConfigs(t))}function ni(){return ne(M,t=>Oe.getEnabledChains(t))}function ri(){return ne(M,t=>Oe.getEnabledBioforestChainConfigs(t))}function si(){return ne(M,t=>Oe.getSubscription(t))}function oi(){return ne(M,t=>Oe.getWarnings(t))}function ii(){return ne(M,t=>t.isLoading)}function ai(){return ne(M,t=>t.error)}function ci(){return ne(M,t=>t.migrationRequired)}export{gt as A,jo as B,pt as C,ei as D,ni as E,ri as F,si as G,fe as H,oi as I,ii as J,ai as K,ci as L,ls as M,Zo as N,Zs as W,Xo as a,Ks as b,Jo as c,dt as d,ee as e,M as f,Qo as g,Oe as h,_ as i,Ne as j,Ln as k,Wo as l,Go as m,$t as n,Yo as o,Vo as p,qo as q,ze as r,oe as s,mn as t,ti as u,O as v,U as w,D as x,lr as y,Ce as z};
