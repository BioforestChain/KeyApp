const o={INTERNAL_ERROR:-32603};function a(r,e,t){const n=new Error(e);return n.code=r,n.data=t,n}class c{handlers=new Map;on(e,t){let n=this.handlers.get(e);n||(n=new Set,this.handlers.set(e,n)),n.add(t)}off(e,t){const n=this.handlers.get(e);n&&(n.delete(t),n.size===0&&this.handlers.delete(e))}emit(e,...t){const n=this.handlers.get(e);n&&n.forEach(i=>{try{i(...t)}catch(s){console.error(`[BioSDK] Error in event handler for "${e}":`,s)}})}removeAllListeners(e){e?this.handlers.delete(e):this.handlers.clear()}}class u{events=new c;pendingRequests=new Map;requestIdCounter=0;connected=!1;targetOrigin;constructor(e="*"){this.targetOrigin=e,this.setupMessageListener(),this.connect()}setupMessageListener(){window.addEventListener("message",this.handleMessage.bind(this))}handleMessage(e){const t=e.data;!t||typeof t!="object"||(t.type==="bio_response"?this.handleResponse(t):t.type==="bio_event"&&this.handleEvent(t))}handleResponse(e){const t=this.pendingRequests.get(e.id);if(t)if(this.pendingRequests.delete(e.id),e.success)t.resolve(e.result);else{const n=e.error??{code:o.INTERNAL_ERROR,message:"Unknown error"};t.reject(a(n.code,n.message,n.data))}}handleEvent(e){this.events.emit(e.event,...e.args),e.event==="connect"?this.connected=!0:e.event==="disconnect"&&(this.connected=!1)}connect(){this.postMessage({type:"bio_request",id:this.generateId(),method:"bio_connect",params:[]})}generateId(){return`bio_${Date.now()}_${++this.requestIdCounter}`}postMessage(e){if(window.parent===window){console.warn("[BioSDK] Not running in iframe, cannot communicate with host");return}window.parent.postMessage(e,this.targetOrigin)}async request(e){const t=this.generateId();return new Promise((n,i)=>{this.pendingRequests.set(t,{resolve:n,reject:i}),this.postMessage({type:"bio_request",id:t,method:e.method,params:e.params}),setTimeout(()=>{this.pendingRequests.has(t)&&(this.pendingRequests.delete(t),i(a(o.INTERNAL_ERROR,"Request timeout")))},300*1e3)})}on(e,t){this.events.on(e,t)}off(e,t){this.events.off(e,t)}isConnected(){return this.connected}}class l{events=new c;pendingRequests=new Map;requestIdCounter=0;connected=!1;currentChainId=null;accounts=[];targetOrigin;isMetaMask=!1;isKeyApp=!0;constructor(e="*"){this.targetOrigin=e,this.setupMessageListener()}setupMessageListener(){window.addEventListener("message",this.handleMessage.bind(this))}handleMessage(e){const t=e.data;!t||typeof t!="object"||(t.type==="eth_response"?this.handleResponse(t):t.type==="eth_event"&&this.handleEvent(t))}handleResponse(e){const t=this.pendingRequests.get(e.id);if(t)if(this.pendingRequests.delete(e.id),e.success)t.resolve(e.result);else{const n=e.error??{code:o.INTERNAL_ERROR,message:"Unknown error"};t.reject(a(n.code,n.message,n.data))}}handleEvent(e){if(this.events.emit(e.event,...e.args),e.event==="connect"){this.connected=!0;const t=e.args[0];this.currentChainId=t?.chainId??null}else e.event==="disconnect"?(this.connected=!1,this.accounts=[]):e.event==="chainChanged"?this.currentChainId=e.args[0]:e.event==="accountsChanged"&&(this.accounts=e.args[0])}generateId(){return`eth_${Date.now()}_${++this.requestIdCounter}`}postMessage(e){if(window.parent===window){console.warn("[EthereumProvider] Not running in iframe, cannot communicate with host");return}window.parent.postMessage(e,this.targetOrigin)}async request(e){const{method:t,params:n}=e,i=Array.isArray(n)?n:n?[n]:[],s=this.generateId();return new Promise((h,d)=>{this.pendingRequests.set(s,{resolve:h,reject:d}),this.postMessage({type:"eth_request",id:s,method:t,params:i}),setTimeout(()=>{this.pendingRequests.has(s)&&(this.pendingRequests.delete(s),d(a(o.INTERNAL_ERROR,"Request timeout")))},300*1e3)})}on(e,t){return this.events.on(e,t),this}off(e,t){return this.events.off(e,t),this}removeListener(e,t){return this.off(e,t)}once(e,t){const n=(...i)=>{this.off(e,n),t(...i)};return this.on(e,n),this}isConnected(){return this.connected}get chainId(){return this.currentChainId}get selectedAddress(){return this.accounts[0]??null}async enable(){return this.request({method:"eth_requestAccounts"})}send(e,t){return this.request({method:e,params:t})}sendAsync(e,t){this.request({method:e.method,params:e.params}).then(n=>t(null,{result:n})).catch(n=>t(n))}}function f(r="*"){if(typeof window>"u")throw new Error("[EthereumProvider] Cannot initialize: window is not defined");if(window.ethereum)return console.warn("[EthereumProvider] Provider already exists, returning existing instance"),window.ethereum;const e=new l(r);return window.ethereum=e,console.log("[EthereumProvider] Provider initialized"),e}class w{events=new c;pendingRequests=new Map;requestIdCounter=0;targetOrigin;constructor(e="*"){this.targetOrigin=e,this.setupMessageListener()}setupMessageListener(){window.addEventListener("message",this.handleMessage.bind(this))}handleMessage(e){const t=e.data;!t||typeof t!="object"||(t.type==="tron_response"?this.handleResponse(t):t.type==="tron_event"&&this.handleEvent(t))}handleResponse(e){const t=this.pendingRequests.get(e.id);if(t)if(this.pendingRequests.delete(e.id),e.success)t.resolve(e.result);else{const n=e.error??{code:o.INTERNAL_ERROR,message:"Unknown error"};t.reject(a(n.code,n.message,n.data))}}handleEvent(e){this.events.emit(e.event,...e.args)}generateId(){return`tron_${Date.now()}_${++this.requestIdCounter}`}postMessage(e){if(window.parent===window){console.warn("[TronLinkProvider] Not running in iframe, cannot communicate with host");return}window.parent.postMessage(e,this.targetOrigin)}async request(e){const{method:t,params:n}=e,i=Array.isArray(n)?n:n!==void 0?[n]:[],s=this.generateId();return new Promise((h,d)=>{this.pendingRequests.set(s,{resolve:h,reject:d}),this.postMessage({type:"tron_request",id:s,method:t,params:i}),setTimeout(()=>{this.pendingRequests.has(s)&&(this.pendingRequests.delete(s),d(a(o.INTERNAL_ERROR,"Request timeout")))},300*1e3)})}on(e,t){return this.events.on(e,t),this}off(e,t){return this.events.off(e,t),this}}class p{tronLink;_ready=!1;_defaultAddress={base58:"",hex:""};trx;constructor(e){this.tronLink=e,this.trx=new g(e),e.on("accountsChanged",t=>{if(Array.isArray(t)&&t.length>0){const n=t[0];this._defaultAddress=n,this._ready=!0}else this._defaultAddress={base58:"",hex:""},this._ready=!1})}get ready(){return this._ready}get defaultAddress(){return this._defaultAddress}setAddress(e){this._defaultAddress=e,this._ready=!0}isAddress(e){return e.startsWith("T")?e.length===34:e.startsWith("41")?e.length===42:!1}address={toHex:e=>e,fromHex:e=>e}}class g{tronLink;constructor(e){this.tronLink=e}async sign(e){return this.tronLink.request({method:"tron_signTransaction",params:e})}async sendRawTransaction(e){return this.tronLink.request({method:"tron_sendRawTransaction",params:e})}async getBalance(e){return this.tronLink.request({method:"tron_getBalance",params:e})}async getAccount(e){return this.tronLink.request({method:"tron_getAccount",params:e})}}function m(r="*"){if(typeof window>"u")throw new Error("[TronProvider] Cannot initialize: window is not defined");if(window.tronLink&&window.tronWeb)return console.warn("[TronProvider] Providers already exist, returning existing instances"),{tronLink:window.tronLink,tronWeb:window.tronWeb};const e=new w(r),t=new p(e);return window.tronLink=e,window.tronWeb=t,console.log("[TronProvider] Providers initialized"),{tronLink:e,tronWeb:t}}const v={ethereum:1,binance:56},R=Object.fromEntries(Object.entries(v).map(([r,e])=>[e,r])),E={ETH:"ethereum",BSC:"binance",TRON:"tron",BFMCHAIN:"bfmeta",BFCHAIN:"bfchain",eth:"ethereum",bsc:"binance",tron:"tron",bfmchain:"bfmeta",bfchain:"bfchain"},q={ethereum:"Ethereum",binance:"BNB Smart Chain",tron:"Tron",bfmeta:"BFMeta",bfchain:"BFChain"};function A(r){return`0x${r.toString(16)}`}function _(r){if(!r.startsWith("0x"))throw new Error(`Invalid hex chain ID: ${r}`);return parseInt(r,16)}function I(r){const e=_(r);return R[e]??null}function b(r){return E[r]??r.toLowerCase()}function y(r="*"){if(typeof window>"u")throw new Error("[BioSDK] Cannot initialize: window is not defined");if(window.bio)return console.warn("[BioSDK] Provider already exists, returning existing instance"),window.bio;const e=new u(r);return window.bio=e,console.log("[BioSDK] Provider initialized"),e}if(typeof window<"u"){const r=()=>{y(),f(),m()};document.readyState==="loading"?document.addEventListener("DOMContentLoaded",r):r()}export{q as C,v as E,I as g,b as n,_ as p,A as t};
