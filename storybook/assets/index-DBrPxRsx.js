import{h as pt,f as gt,m as yt,t as wt,n as B,s as _,H as X,o as P,p as bt,q as K}from"./chain-config-CVvvJPxJ.js";import{A as u}from"./amount-BQsqQYGO.js";import"./index-D0E7N0oa.js";import{h as R,q as A,H as b,K as Tt,c as vt,p as St,a as _t,Y,Z as L}from"./bioforest-ChHUthdw.js";import{o as F,b as At,s as y,n as It,r as q}from"./schemas-34eCiBJ6.js";import{_ as D}from"./preload-helper-PPVm8Dsz.js";class Et{getConfig(t){return pt.getChainById(gt.state,t)}getApi(t){const e=this.getConfig(t);if(!e?.api)return[];const s=[];for(const[n,r]of Object.entries(e.api))s.push(this.parseApiEntry(n,r));return s}getApiByType(t,e){return this.getApi(t).find(n=>n.type===e)??null}getApiByPattern(t,e){const s=this.getApi(t),n=new RegExp("^"+e.replace("*",".*")+"$");return s.find(r=>n.test(r.type))??null}parseApiEntry(t,e){if(typeof e=="string")return{type:t,endpoint:e};const[s,n]=e;return{type:t,endpoint:s,config:n}}getRpcUrl(t){return this.getApiByPattern(t,"*-rpc")?.endpoint??""}getBiowalletApi(t){const e=this.getApiByPattern(t,"biowallet-*");if(!e)return null;const s=e.config?.path??t;return{endpoint:e.endpoint,path:s}}getEtherscanApi(t){return(this.getApiByPattern(t,"etherscan-*")??this.getApiByPattern(t,"*scan-*"))?.endpoint??null}getMempoolApi(t){return this.getApiByPattern(t,"mempool-*")?.endpoint??null}getDecimals(t){return this.getConfig(t)?.decimals??18}getSymbol(t){return this.getConfig(t)?.symbol??""}getExplorerUrl(t){return this.getConfig(t)?.explorer?.url??null}getTxQueryUrl(t,e){const n=this.getConfig(t)?.explorer?.queryTx;return n?n.replace(":hash",e).replace(":signature",e):null}getAddressQueryUrl(t,e){const n=this.getConfig(t)?.explorer?.queryAddress;return n?n.replace(":address",e):null}}const h=new Et;class Q{chainId;providers;constructor(t,e){this.chainId=t,this.providers=e}supports(t){return this.providers.some(e=>typeof e[t]=="function")}getMethod(t){const e=this.providers.find(n=>typeof n[t]=="function");if(!e)return;const s=e[t];if(typeof s=="function")return s.bind(e)}get supportsNativeBalance(){return this.supports("getNativeBalance")}get supportsTransactionHistory(){return this.supports("getTransactionHistory")}get supportsTransaction(){return this.supports("getTransaction")}get supportsBlockHeight(){return this.supports("getBlockHeight")}get supportsFeeEstimate(){return this.supports("estimateFee")}get supportsBuildTransaction(){return this.supports("buildTransaction")}get supportsSignTransaction(){return this.supports("signTransaction")}get supportsBroadcast(){return this.supports("broadcastTransaction")}get supportsFullTransaction(){return this.supportsBuildTransaction&&this.supportsSignTransaction&&this.supportsBroadcast}get supportsDeriveAddress(){return this.supports("deriveAddress")}get supportsAddressValidation(){return this.supports("isValidAddress")}get getNativeBalance(){return this.getMethod("getNativeBalance")}get getTransactionHistory(){return this.getMethod("getTransactionHistory")}get getTransaction(){return this.getMethod("getTransaction")}get getTransactionStatus(){return this.getMethod("getTransactionStatus")}get getBlockHeight(){return this.getMethod("getBlockHeight")}get estimateFee(){return this.getMethod("estimateFee")}get buildTransaction(){return this.getMethod("buildTransaction")}get signTransaction(){return this.getMethod("signTransaction")}get broadcastTransaction(){return this.getMethod("broadcastTransaction")}get deriveAddress(){return this.getMethod("deriveAddress")}get deriveAddresses(){return this.getMethod("deriveAddresses")}get isValidAddress(){return this.getMethod("isValidAddress")}get normalizeAddress(){return this.getMethod("normalizeAddress")}getProviders(){return this.providers}getProviderByType(t){return this.providers.find(e=>e.type===t)}}const Bt={ethereum:1,binance:56,"ethereum-sepolia":11155111,"bsc-testnet":97};class Z{type;endpoint;config;chainId;evmChainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.evmChainId=Bt[e]??1,this.symbol=h.getSymbol(e),this.decimals=h.getDecimals(e)}async getTransactionHistory(t,e=20){try{const s=this.config?.apiKey??"",n=new URLSearchParams({chainid:this.evmChainId.toString(),module:"account",action:"txlist",address:t,startblock:"0",endblock:"99999999",page:"1",offset:e.toString(),sort:"desc"});s&&n.set("apikey",s);const r=`${this.endpoint}?${n.toString()}`,o=await fetch(r);if(!o.ok)return console.warn(`[EtherscanProvider] HTTP ${o.status}`),[];const a=await o.json();return a.status!=="1"||!Array.isArray(a.result)?[]:a.result.map(c=>({hash:c.hash,from:c.from,to:c.to,value:c.value,symbol:this.symbol,timestamp:parseInt(c.timeStamp,10)*1e3,status:c.isError==="0"?"confirmed":"failed",blockNumber:BigInt(c.blockNumber)}))}catch(s){return console.warn("[EtherscanProvider] Error fetching transactions:",s),[]}}}function tt(i,t){return i.type.includes("etherscan")||i.type.includes("blockscout")||i.type.includes("scan")?new Z(i,t):null}class et{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=h.getSymbol(e),this.decimals=h.getDecimals(e)}async rpc(t,e=[]){const s=await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:Date.now(),method:t,params:e})});if(!s.ok)throw new Error(`HTTP ${s.status}: ${s.statusText}`);const n=await s.json();if(n.error)throw new Error(n.error.message);return n.result}async getNativeBalance(t){try{const e=await this.rpc("eth_getBalance",[t,"latest"]),s=BigInt(e);return{amount:u.fromRaw(s.toString(),this.decimals,this.symbol),symbol:this.symbol}}catch(e){return console.warn("[EvmRpcProvider] Error fetching balance:",e),{amount:u.zero(this.decimals,this.symbol),symbol:this.symbol}}}async getBlockHeight(){try{const t=await this.rpc("eth_blockNumber");return BigInt(t)}catch{return 0n}}}function st(i,t){return i.type.endsWith("-rpc")&&(i.type.includes("ethereum")||i.type.includes("bsc"))?new et(i,t):null}class nt{type;endpoint;config;chainId;path;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.path=t.config?.path??e,this.symbol=h.getSymbol(e),this.decimals=h.getDecimals(e)}get baseUrl(){return`${this.endpoint}/wallet/${this.path}`}async getNativeBalance(t){try{const e=await fetch(`${this.baseUrl}/address/asset`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({address:t})});if(!e.ok)throw new Error(`HTTP ${e.status}`);const s=await e.json();if(!s.success||!s.result)return{amount:u.zero(this.decimals,this.symbol),symbol:this.symbol};for(const n of Object.values(s.result.assets))for(const r of Object.values(n))if(r.assetType===this.symbol)return{amount:u.fromRaw(r.assetNumber,this.decimals,this.symbol),symbol:this.symbol};return{amount:u.zero(this.decimals,this.symbol),symbol:this.symbol}}catch(e){return console.warn("[BiowalletProvider] Error fetching balance:",e),{amount:u.zero(this.decimals,this.symbol),symbol:this.symbol}}}async getTransactionHistory(t,e=20){try{const s=await fetch(`${this.baseUrl}/lastblock`);if(!s.ok)return[];const n=await s.json();if(!n.success||!n.result)return[];const r=n.result.height,o=await fetch(`${this.baseUrl}/transactions/query`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({maxHeight:r,address:t,limit:e})});if(!o.ok)return[];const a=await o.json();return!a.success||!a.result?.transactions?[]:a.result.transactions.map(c=>({hash:c.signature,from:c.senderAddress,to:c.receiverAddress,value:c.amount,symbol:c.assetType,timestamp:c.timestamp,status:"confirmed",blockNumber:BigInt(c.applyBlockHeight)}))}catch(s){return console.warn("[BiowalletProvider] Error fetching transactions:",s),[]}}async getBlockHeight(){try{const t=await fetch(`${this.baseUrl}/lastblock`);if(!t.ok)return 0n;const e=await t.json();return!e.success||!e.result?0n:BigInt(e.result.height)}catch{return 0n}}}function rt(i,t){return i.type.startsWith("biowallet-")?new nt(i,t):null}class it{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=h.getSymbol(e),this.decimals=h.getDecimals(e)}async api(t,e){const s=`${this.endpoint}${t}`,n=e?{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)}:{method:"GET"},r=await fetch(s,n);if(!r.ok)throw new Error(`HTTP ${r.status}`);return r.json()}async getNativeBalance(t){try{const s=(await this.api("/wallet/getaccount",{address:t,visible:!0})).balance??0;return{amount:u.fromRaw(s.toString(),this.decimals,this.symbol),symbol:this.symbol}}catch(e){return console.warn("[TronRpcProvider] Error fetching balance:",e),{amount:u.zero(this.decimals,this.symbol),symbol:this.symbol}}}async getBlockHeight(){try{const e=(await this.api("/wallet/getnowblock")).block_header?.raw_data?.number??0;return BigInt(e)}catch{return 0n}}}function ot(i,t){return i.type==="tron-rpc"||i.type.startsWith("tron-")?new it(i,t):null}class at{type;endpoint;config;chainId;symbol;decimals;constructor(t,e){this.type=t.type,this.endpoint=t.endpoint,this.config=t.config,this.chainId=e,this.symbol=h.getSymbol(e),this.decimals=h.getDecimals(e)}async api(t){const e=await fetch(`${this.endpoint}${t}`);if(!e.ok)throw new Error(`HTTP ${e.status}`);return e.json()}async getNativeBalance(t){try{const e=await this.api(`/address/${t}`),s=e.chain_stats.funded_txo_sum-e.chain_stats.spent_txo_sum,n=e.mempool_stats.funded_txo_sum-e.mempool_stats.spent_txo_sum,r=s+n;return{amount:u.fromRaw(r.toString(),this.decimals,this.symbol),symbol:this.symbol}}catch(e){return console.warn("[MempoolProvider] Error fetching balance:",e),{amount:u.zero(this.decimals,this.symbol),symbol:this.symbol}}}async getTransactionHistory(t,e=20){try{return(await this.api(`/address/${t}/txs`)).slice(0,e).map(n=>{const r=n.vin.some(c=>c.prevout?.scriptpubkey_address===t);let o=0n;if(r)for(const c of n.vout)c.scriptpubkey_address&&c.scriptpubkey_address!==t&&(o+=BigInt(c.value));else for(const c of n.vout)c.scriptpubkey_address===t&&(o+=BigInt(c.value));const a=r?n.vout.find(c=>c.scriptpubkey_address!==t)?.scriptpubkey_address??"":n.vin[0]?.prevout?.scriptpubkey_address??"";return{hash:n.txid,from:r?t:a,to:r?a:t,value:o.toString(),symbol:this.symbol,timestamp:(n.status.block_time??Math.floor(Date.now()/1e3))*1e3,status:n.status.confirmed?"confirmed":"pending",blockNumber:n.status.block_height?BigInt(n.status.block_height):void 0}})}catch(s){return console.warn("[MempoolProvider] Error fetching transactions:",s),[]}}async getBlockHeight(){try{const t=await this.api("/blocks/tip/height");return BigInt(t)}catch{return 0n}}}function ct(i,t){return i.type.startsWith("mempool-")?new at(i,t):null}class N{constructor(t,e,s){this.transactionService=e,this.assetService=s,this.type=t}type;endpoint="";async getNativeBalance(t){return this.assetService.getNativeBalance(t)}async getTransactionHistory(t,e){return(await this.transactionService.getTransactionHistory(t,e)).map(n=>this.convertTransaction(n))}async getTransaction(t){const e=await this.transactionService.getTransaction(t);return e?this.convertTransaction(e):null}async getTransactionStatus(t){const e=await this.transactionService.getTransactionStatus(t);return this.convertTransactionStatus(e)}async estimateFee(t){const e=await this.transactionService.estimateFee(t);return this.convertFeeEstimate(e)}async buildTransaction(t){return this.transactionService.buildTransaction(t)}async signTransaction(t,e){const s=await this.transactionService.signTransaction(t,e);return{chainId:s.chainId,data:s.data,signature:typeof s.signature=="string"?s.signature:""}}async broadcastTransaction(t){return this.transactionService.broadcastTransaction(t)}convertTransaction(t){return{hash:t.hash,from:t.from,to:t.to??"",value:t.value,symbol:t.symbol,timestamp:t.timestamp,status:t.status,blockNumber:t.blockNumber}}convertTransactionStatus(t){let e;switch(t.status){case"pending":e="pending";break;case"confirmed":e="confirmed";break;case"failed":e="failed";break;default:e="pending"}return{status:e,confirmations:t.confirmations,requiredConfirmations:t.requiredConfirmations}}convertFeeEstimate(t){const e=(s,n)=>({amount:s.amount,estimatedTime:n});return{slow:e(t.slow,600),standard:e(t.standard,180),fast:e(t.fast,30)}}}class k{constructor(t,e){this.identityService=e,this.type=t}type;endpoint="";async deriveAddress(t,e=0){return this.identityService.deriveAddress(t,e)}async deriveAddresses(t,e,s){return this.identityService.deriveAddresses(t,e,s)}isValidAddress(t){return this.identityService.isValidAddress(t)}normalizeAddress(t){return this.identityService.normalizeAddress(t)}}class Nt{chainId;constructor(t){this.chainId=t}async deriveAddress(t,e=0){throw new Error("Use deriveAddressesForChains from @/lib/crypto instead")}async deriveAddresses(t,e,s){throw new Error("Use deriveAddressesForChains from @/lib/crypto instead")}isValidAddress(t){return yt(t,"ethereum")}normalizeAddress(t){return wt(t)}async signMessage(t,e){throw new Error("Not implemented")}async verifyMessage(t,e,s){throw new Error("Not implemented")}}class m extends Error{code;details;constructor(t,e,s,n){super(e,{cause:n}),this.name="ChainServiceError",this.code=t,this.details=s}}const f={CHAIN_NOT_SUPPORTED:"CHAIN_NOT_SUPPORTED",NETWORK_ERROR:"NETWORK_ERROR",INSUFFICIENT_BALANCE:"INSUFFICIENT_BALANCE",INSUFFICIENT_FEE:"INSUFFICIENT_FEE",INVALID_ADDRESS:"INVALID_ADDRESS",TRANSACTION_REJECTED:"TRANSACTION_REJECTED",TRANSACTION_TIMEOUT:"TRANSACTION_TIMEOUT",TX_BUILD_FAILED:"TX_BUILD_FAILED",TX_BROADCAST_FAILED:"TX_BROADCAST_FAILED",SIGNATURE_FAILED:"SIGNATURE_FAILED",ADDRESS_FROZEN:"ADDRESS_FROZEN",PAYSECRET_REQUIRED:"PAYSECRET_REQUIRED",ADDRESS_NOT_ACTIVATED:"ADDRESS_NOT_ACTIVATED",ENERGY_INSUFFICIENT:"ENERGY_INSUFFICIENT",NONCE_TOO_LOW:"NONCE_TOO_LOW",GAS_TOO_LOW:"GAS_TOO_LOW",UTXO_INSUFFICIENT:"UTXO_INSUFFICIENT"};class kt{chainId;constructor(t){this.chainId=t}get rpcUrl(){return h.getRpcUrl(this.chainId)}get decimals(){return h.getDecimals(this.chainId)}get symbol(){return h.getSymbol(this.chainId)}async rpc(t,e){const s=await fetch(this.rpcUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:1})});if(!s.ok)throw new m(f.NETWORK_ERROR,`HTTP ${s.status}: ${s.statusText}`);const n=await s.json();if(n.error)throw new m(f.NETWORK_ERROR,n.error.message);return n.result}async getNativeBalance(t){try{const e=await this.rpc("eth_getBalance",[t,"latest"]),s=BigInt(e).toString();return{amount:u.fromRaw(s,this.decimals,this.symbol),symbol:this.symbol}}catch{return{amount:u.fromRaw("0",this.decimals,this.symbol),symbol:this.symbol}}}async getTokenBalance(t,e){try{const s=`0x70a08231000000000000000000000000${t.slice(2).toLowerCase()}`,n=await this.rpc("eth_call",[{to:e,data:s},"latest"]),r=BigInt(n).toString();return{amount:u.fromRaw(r,18,"TOKEN"),symbol:"TOKEN"}}catch{return{amount:u.fromRaw("0",18,"UNKNOWN"),symbol:"UNKNOWN"}}}async getTokenBalances(t){return[await this.getNativeBalance(t)]}async getTokenMetadata(t){return{address:t,name:"Unknown Token",symbol:"UNKNOWN",decimals:18}}}const Rt={ethereum:1,"ethereum-sepolia":11155111,binance:56,"bsc-testnet":97};class Ct{chainId;evmChainId;constructor(t){this.chainId=t,this.evmChainId=Rt[t]??1}get rpcUrl(){return h.getRpcUrl(this.chainId)}get decimals(){return h.getDecimals(this.chainId)}get symbol(){return h.getSymbol(this.chainId)}async rpc(t,e=[]){const s=await fetch(this.rpcUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:Date.now(),method:t,params:e})});if(!s.ok)throw new m(f.NETWORK_ERROR,`HTTP ${s.status}: ${s.statusText}`);const n=await s.json();if(n.error)throw new m(f.NETWORK_ERROR,n.error.message,{code:n.error.code});return n.result}async estimateFee(t){const e=await this.rpc("eth_gasPrice"),r=21000n*BigInt(e),o=u.fromRaw((r*80n/100n).toString(),this.decimals,this.symbol),a=u.fromRaw(r.toString(),this.decimals,this.symbol),c=u.fromRaw((r*120n/100n).toString(),this.decimals,this.symbol);return{slow:{amount:o,estimatedTime:60},standard:{amount:a,estimatedTime:15},fast:{amount:c,estimatedTime:5}}}async buildTransaction(t){const e=await this.rpc("eth_getTransactionCount",[t.from,"pending"]),s=parseInt(e,16),n=await this.rpc("eth_gasPrice");return{chainId:this.chainId,data:{nonce:s,gasPrice:n,gasLimit:"0x5208",to:t.to,value:"0x"+t.amount.raw.toString(16),data:"0x",chainId:this.evmChainId}}}async signTransaction(t,e){const s=t.data,n=this.rlpEncode([this.toRlpHex(s.nonce),s.gasPrice,s.gasLimit,s.to.toLowerCase(),s.value,s.data,this.toRlpHex(s.chainId),"0x","0x"]),r=B(R(n.slice(2))),o=_.sign(r,e,{prehash:!1,format:"recovered"}),a=BigInt("0x"+A(o.slice(0,32))),c=BigInt("0x"+A(o.slice(32,64))),l=o[64],d=s.chainId*2+35+l,p=a.toString(16).padStart(64,"0"),g=c.toString(16).padStart(64,"0"),v=this.rlpEncode([this.toRlpHex(s.nonce),s.gasPrice,s.gasLimit,s.to.toLowerCase(),s.value,s.data,this.toRlpHex(d),"0x"+p,"0x"+g]);return{chainId:this.chainId,data:v,signature:"0x"+p+g}}async broadcastTransaction(t){const e=t.data;return await this.rpc("eth_sendRawTransaction",[e])}toRlpHex(t){return t===0?"0x":"0x"+t.toString(16)}rlpEncode(t){const e=t.map(a=>{if(a==="0x"||a==="")return new Uint8Array([128]);const c=R(a.startsWith("0x")?a.slice(2):a);if(c.length===1&&c[0]<128)return c;if(c.length<=55)return new Uint8Array([128+c.length,...c]);const l=this.numberToBytes(c.length);return new Uint8Array([183+l.length,...l,...c])}),s=e.reduce((a,c)=>a+c.length,0);let n;if(s<=55)n=new Uint8Array([192+s]);else{const a=this.numberToBytes(s);n=new Uint8Array([247+a.length,...a])}const r=new Uint8Array(n.length+s);r.set(n);let o=n.length;for(const a of e)r.set(a,o),o+=a.length;return"0x"+A(r)}numberToBytes(t){const e=t.toString(16),s=e.length%2?"0"+e:e;return R(s)}async getTransactionStatus(t){try{const e=await this.rpc("eth_getTransactionReceipt",[t]);if(!e)return{status:"pending",confirmations:0,requiredConfirmations:12};const s=await this.rpc("eth_blockNumber"),n=parseInt(s,16)-parseInt(e.blockNumber,16);return{status:n>=12?"confirmed":"confirming",confirmations:Math.max(0,n),requiredConfirmations:12}}catch{return{status:"pending",confirmations:0,requiredConfirmations:12}}}async getTransaction(t){try{const[e,s]=await Promise.all([this.rpc("eth_getTransactionByHash",[t]),this.rpc("eth_getTransactionReceipt",[t])]);if(!e)return null;const n=e.blockNumber?await this.rpc("eth_getBlockByNumber",[e.blockNumber,!1]):null;return{hash:e.hash,from:e.from,to:e.to??"",amount:u.fromRaw(BigInt(e.value).toString(),this.decimals,this.symbol),fee:s?u.fromRaw((BigInt(s.gasUsed)*BigInt(e.gasPrice)).toString(),this.decimals,this.symbol):u.fromRaw("0",this.decimals,this.symbol),status:{status:s?.status==="0x1"?"confirmed":s?"failed":"pending",confirmations:s?12:0,requiredConfirmations:12},timestamp:n?parseInt(n.timestamp,16)*1e3:Date.now(),blockNumber:e.blockNumber?BigInt(e.blockNumber):void 0,type:"transfer"}}catch{return null}}async getTransactionHistory(t,e=20){return[]}}const x="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";class Ot{constructor(t){}async deriveAddress(t,e=0){const n=X.fromMasterSeed(t).derive(`m/44'/195'/0'/0/${e}`);if(!n.privateKey)throw new Error("Failed to derive private key");const r=_.getPublicKey(n.privateKey,!1),a=B(r.slice(1)).slice(-20),c=new Uint8Array([65,...a]),l=b(b(c)).slice(0,4),d=new Uint8Array([...c,...l]);return this.encodeBase58(d)}async deriveAddresses(t,e,s){const n=[];for(let r=0;r<s;r++)n.push(await this.deriveAddress(t,e+r));return n}isValidAddress(t){if(!t.startsWith("T")||t.length!==34)return!1;for(const e of t)if(!x.includes(e))return!1;try{const e=this.decodeBase58(t);if(e.length!==25)return!1;const s=e.slice(0,21),n=e.slice(21),r=b(b(s));return n.every((o,a)=>o===r[a])}catch{return!1}}decodeBase58(t){let e=BigInt(0);for(const r of t){const o=x.indexOf(r);if(o===-1)throw new Error(`Invalid base58 character: ${r}`);e=e*58n+BigInt(o)}const s=e.toString(16).padStart(50,"0"),n=new Uint8Array(25);for(let r=0;r<25;r++)n[r]=parseInt(s.slice(r*2,r*2+2),16);return n}normalizeAddress(t){return t}async signMessage(t,e){const s=typeof t=="string"?new TextEncoder().encode(t):t,n=new TextEncoder().encode(`TRON Signed Message:
`+s.length),r=B(new Uint8Array([...n,...s])),o=_.sign(r,e,{prehash:!1,format:"recovered"});return A(o)}async verifyMessage(t,e,s){try{const n=typeof t=="string"?new TextEncoder().encode(t):t,r=new TextEncoder().encode(`TRON Signed Message:
`+n.length),o=B(new Uint8Array([...r,...n])),a=R(e),c=_.recoverPublicKey(o,a);if(!c)return!1;const d=B(c.slice(1)).slice(-20),p=new Uint8Array([65,...d]),g=b(b(p)).slice(0,4),v=new Uint8Array([...p,...g]);return this.encodeBase58(v)===s}catch{return!1}}encodeBase58(t){let e=BigInt(0);for(const n of t)e=e*256n+BigInt(n);let s="";for(;e>0n;){const n=Number(e%58n);e=e/58n,s=x[n]+s}for(const n of t)if(n===0)s=x[0]+s;else break;return s}}class Pt{chainId;constructor(t){this.chainId=t}get rpcUrl(){return h.getRpcUrl(this.chainId)}get decimals(){return h.getDecimals(this.chainId)}get symbol(){return h.getSymbol(this.chainId)}async api(t,e){const s=`${this.rpcUrl}${t}`,n=e?{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)}:{method:"GET"},r=await fetch(s,n);if(!r.ok)throw new m(f.NETWORK_ERROR,`Tron API error: ${r.status}`);return r.json()}async getNativeBalance(t){try{const e=await this.api("/wallet/getaccount",{address:t,visible:!0});return!e||!("balance"in e)?{amount:u.fromRaw("0",this.decimals,this.symbol),symbol:this.symbol}:{amount:u.fromRaw(e.balance.toString(),this.decimals,this.symbol),symbol:this.symbol}}catch{return{amount:u.fromRaw("0",this.decimals,this.symbol),symbol:this.symbol}}}async getTokenBalance(t,e){try{const s=await this.api("/wallet/getaccount",{address:t,visible:!0});if(s?.trc20){for(const n of s.trc20)if(n[e])return{amount:u.fromRaw(n[e],18,"TOKEN"),symbol:"TOKEN"}}return{amount:u.fromRaw("0",18,"TOKEN"),symbol:"TOKEN"}}catch{return{amount:u.fromRaw("0",18,"TOKEN"),symbol:"TOKEN"}}}async getTokenBalances(t){return[await this.getNativeBalance(t)]}async getTokenMetadata(t){return{address:t,name:"TRC20 Token",symbol:"TOKEN",decimals:18}}}const xt="https://api.trongrid.io";class Ut{chainId;config=null;rpcUrl="";constructor(t){this.chainId=t}getConfig(){if(!this.config){const t=h.getConfig(this.chainId);if(!t)throw new m(f.CHAIN_NOT_FOUND,`Chain config not found: ${this.chainId}`);this.config=t,this.rpcUrl=h.getRpcUrl(t.id)||xt}return this.config}async api(t,e){const s=`${this.rpcUrl}${t}`,n=e?{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)}:{method:"GET"},r=await fetch(s,n);if(!r.ok)throw new m(f.NETWORK_ERROR,`Tron API error: ${r.status} ${r.statusText}`);return r.json()}base58ToHex(t){const e="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";let s=BigInt(0);for(const r of t){const o=e.indexOf(r);if(o===-1)throw new Error(`Invalid base58 character: ${r}`);s=s*58n+BigInt(o)}return s.toString(16).padStart(50,"0").slice(0,42)}async estimateFee(t){const e=this.getConfig(),n={amount:u.fromRaw("0",e.decimals,e.symbol),estimatedTime:3};return{slow:n,standard:n,fast:n}}async buildTransaction(t){const e=this.getConfig(),s=this.base58ToHex(t.from),n=this.base58ToHex(t.to),r=await this.api("/wallet/createtransaction",{owner_address:s,to_address:n,amount:Number(t.amount.raw),visible:!1});if(!r.txID)throw new m(f.TX_BUILD_FAILED,"Failed to create Tron transaction");return{chainId:e.id,data:r}}async signTransaction(t,e){const s=t.data,n=R(s.txID),r=_.sign(n,e,{prehash:!1,format:"recovered"}),o=A(r),a={...s,signature:[o]};return{chainId:t.chainId,data:a,signature:o}}async broadcastTransaction(t){const e=t.data,s=await this.api("/wallet/broadcasttransaction",e);if(!s.result){const n=s.message?Buffer.from(s.message,"hex").toString("utf8"):s.code??"Unknown error";throw new m(f.TX_BROADCAST_FAILED,`Broadcast failed: ${n}`)}return e.txID}async getTransactionStatus(t){try{const e=await this.api("/wallet/gettransactioninfobyid",{value:t});if(!e||!("blockNumber"in e))return{status:"pending",confirmations:0,requiredConfirmations:19};const r=(await this.api("/wallet/getnowblock")).block_header.raw_data.number-e.blockNumber;return{status:r>=19?"confirmed":"confirming",confirmations:Math.max(0,r),requiredConfirmations:19}}catch{return{status:"pending",confirmations:0,requiredConfirmations:19}}}async getTransaction(t){try{const[e,s]=await Promise.all([this.api("/wallet/gettransactionbyid",{value:t}),this.api("/wallet/gettransactioninfobyid",{value:t})]);if(!e||!("txID"in e))return null;const n=e.raw_data.contract[0];if(!n||n.type!=="TransferContract")return null;const{amount:r,owner_address:o,to_address:a}=n.parameter.value,c="blockNumber"in s,l=this.getConfig();return{hash:e.txID,from:o,to:a,amount:u.fromRaw(r.toString(),l.decimals,l.symbol),fee:u.fromRaw((s.receipt?.net_usage??0).toString(),l.decimals,l.symbol),status:{status:c?"confirmed":"pending",confirmations:c?19:0,requiredConfirmations:19},timestamp:e.raw_data.timestamp,blockNumber:c?BigInt(s.blockNumber):void 0,type:"transfer"}}catch{return null}}async getTransactionHistory(t,e=20){return[]}}class Ht{constructor(t){}async deriveAddress(t,e=0){const n=X.fromMasterSeed(t).derive(`m/84'/0'/0'/0/${e}`);if(!n.publicKey)throw new Error("Failed to derive public key");const r=Tt(b(n.publicKey)),o=P.toWords(r);return P.encode("bc",[0,...o])}async deriveAddresses(t,e,s){const n=[];for(let r=0;r<s;r++)n.push(await this.deriveAddress(t,e+r));return n}isValidAddress(t){try{if(t.startsWith("1")||t.startsWith("3"))return bt(b).decode(t).length===21;if(t.toLowerCase().startsWith("bc1q")){const e=t.toLowerCase(),s=P.decode(e),n=P.fromWords(s.words.slice(1));return s.prefix==="bc"&&s.words[0]===0&&n.length===20}if(t.toLowerCase().startsWith("bc1p")){const e=t.toLowerCase(),s=K.decode(e),n=K.fromWords(s.words.slice(1));return s.prefix==="bc"&&s.words[0]===1&&n.length===32}return!1}catch{return!1}}normalizeAddress(t){return t.startsWith("bc1")||t.startsWith("BC1")?t.toLowerCase():t}async signMessage(t,e){const s=typeof t=="string"?new TextEncoder().encode(t):t,n=new TextEncoder().encode(`Bitcoin Signed Message:
`),r=new Uint8Array([s.length]),o=new Uint8Array([...n,...r,...s]),a=b(b(o)),c=_.sign(a,e,{prehash:!1,format:"recovered"});return A(c)}async verifyMessage(t,e,s){return!1}}const W={bitcoin:"https://mempool.space/api","bitcoin-testnet":"https://mempool.space/testnet/api","bitcoin-signet":"https://mempool.space/signet/api"};class Ft{config;apiUrl;constructor(t){this.config=t,this.apiUrl=W[t.id]??W.bitcoin}async api(t){const e=`${this.apiUrl}${t}`,s=await fetch(e);if(!s.ok)throw new m(f.NETWORK_ERROR,`Bitcoin API error: ${s.status}`);return s.json()}async getNativeBalance(t){try{const e=await this.api(`/address/${t}`),s=e.chain_stats.funded_txo_sum-e.chain_stats.spent_txo_sum,n=e.mempool_stats.funded_txo_sum-e.mempool_stats.spent_txo_sum,r=s+n;return{amount:u.fromRaw(r.toString(),this.config.decimals,this.config.symbol),symbol:this.config.symbol}}catch{return{amount:u.fromRaw("0",this.config.decimals,this.config.symbol),symbol:this.config.symbol}}}async getTokenBalance(t,e){return{amount:u.fromRaw("0",8,"TOKEN"),symbol:"TOKEN"}}async getTokenBalances(t){return[]}async getTokenMetadata(t){return{address:t,name:"Unknown",symbol:"UNKNOWN",decimals:8}}async getUtxos(t){return this.api(`/address/${t}/utxo`)}}const $t="https://mempool.space/api";class Dt{config;apiUrl;constructor(t){this.config=t,this.apiUrl=h.getMempoolApi(t.id)??$t}async api(t,e){const s=`${this.apiUrl}${t}`,n=await fetch(s,e);if(!n.ok)throw new m(f.NETWORK_ERROR,`Bitcoin API error: ${n.status}`);const r=await n.text();try{return JSON.parse(r)}catch{return r}}async estimateFee(t){try{const e=await this.api("/v1/fees/recommended"),s=140,n={amount:u.fromRaw((e.hourFee*s).toString(),this.config.decimals,this.config.symbol),estimatedTime:3600},r={amount:u.fromRaw((e.halfHourFee*s).toString(),this.config.decimals,this.config.symbol),estimatedTime:1800},o={amount:u.fromRaw((e.fastestFee*s).toString(),this.config.decimals,this.config.symbol),estimatedTime:600};return{slow:n,standard:r,fast:o}}catch{const e={amount:u.fromRaw("2000",this.config.decimals,this.config.symbol),estimatedTime:1800};return{slow:e,standard:e,fast:e}}}async buildTransaction(t){const e=await this.api(`/address/${t.from}/utxo`);if(e.length===0)throw new m(f.INSUFFICIENT_BALANCE,"No UTXOs available");const n=(await this.api("/v1/fees/recommended")).halfHourFee,r=e.reduce((p,g)=>p+g.value,0),o=Number(t.amount.raw),a=10+e.length*68+62,c=n*a;if(r<o+c)throw new m(f.INSUFFICIENT_BALANCE,`Insufficient balance: need ${o+c}, have ${r}`);const l=r-o-c,d={inputs:e.map(p=>({txid:p.txid,vout:p.vout,value:p.value,scriptPubKey:""})),outputs:[{address:t.to,value:o}],fee:c,changeAddress:t.from};return l>546&&d.outputs.push({address:t.from,value:l}),{chainId:this.config.id,data:d}}async signTransaction(t,e){throw new m(f.CHAIN_NOT_SUPPORTED,"Bitcoin transaction signing requires specialized library (bitcoinjs-lib or similar)")}async broadcastTransaction(t){const e=t.data;return await this.api("/tx",{method:"POST",body:e})}async getTransactionStatus(t){try{const e=await this.api(`/tx/${t}`);if(!e.status.confirmed)return{status:"pending",confirmations:0,requiredConfirmations:6};const s=await this.api("/blocks/tip/height"),n=s-(e.status.block_height??s)+1;return{status:n>=6?"confirmed":"confirming",confirmations:Math.max(0,n),requiredConfirmations:6}}catch{return{status:"pending",confirmations:0,requiredConfirmations:6}}}async getTransaction(t){try{const e=await this.api(`/tx/${t}`),s=e.vin[0]?.prevout?.scriptpubkey_address??"",n=e.vout[0]?.scriptpubkey_address??"",r=e.vout[0]?.value??0;return{hash:e.txid,from:s,to:n,amount:u.fromRaw(r.toString(),this.config.decimals,this.config.symbol),fee:u.fromRaw(e.fee.toString(),this.config.decimals,this.config.symbol),status:{status:e.status.confirmed?"confirmed":"pending",confirmations:e.status.confirmed?6:0,requiredConfirmations:6},timestamp:(e.status.block_time??Math.floor(Date.now()/1e3))*1e3,blockNumber:e.status.block_height?BigInt(e.status.block_height):void 0,type:"transfer"}}catch{return null}}async getTransactionHistory(t,e=20){try{return(await this.api(`/address/${t}/txs`)).slice(0,e).map(n=>{const r=n.vin.some(l=>l.prevout?.scriptpubkey_address===t),o=r?t:n.vin[0]?.prevout?.scriptpubkey_address??"",a=r?n.vout.find(l=>l.scriptpubkey_address!==t)?.scriptpubkey_address??"":t,c=r?n.vout.filter(l=>l.scriptpubkey_address!==t).reduce((l,d)=>l+d.value,0):n.vout.filter(l=>l.scriptpubkey_address===t).reduce((l,d)=>l+d.value,0);return{hash:n.txid,from:o,to:a,amount:u.fromRaw(c.toString(),this.config.decimals,this.config.symbol),fee:u.fromRaw(n.fee.toString(),this.config.decimals,this.config.symbol),status:{status:n.status.confirmed?"confirmed":"pending",confirmations:n.status.confirmed?6:0,requiredConfirmations:6},timestamp:(n.status.block_time??Math.floor(Date.now()/1e3))*1e3,blockNumber:n.status.block_height?BigInt(n.status.block_height):void 0,type:"transfer"}})}catch{return[]}}}function Mt(i){return Array.from(i).map(t=>t.toString(16).padStart(2,"0")).join("")}class jt{chainId;prefix=null;constructor(t){this.chainId=t}getPrefix(){if(!this.prefix){const t=h.getConfig(this.chainId);this.prefix=t?.prefix??"b"}return this.prefix}async deriveAddress(t,e=0){const s=new TextDecoder().decode(t),n=vt(s);return St(n.publicKey,this.getPrefix())}async deriveAddresses(t,e,s){const n=await this.deriveAddress(t,e);return Array(s).fill(n)}isValidAddress(t){return _t(t)}normalizeAddress(t){return t}async signMessage(t,e){const s=Y(t,e);return Mt(s)}async verifyMessage(t,e,s){return!1}}const Kt=F({assetNumber:y(),assetType:y().min(1),sourceChainMagic:y(),sourceChainName:y(),iconUrl:y().optional()}),Lt=F({success:At(),result:F({address:y(),assets:q(y(),q(y(),Kt)),forgingRewards:y().optional()}).nullish(),error:F({code:It(),message:y(),info:y().optional()}).nullish()});class qt{chainId;config=null;constructor(t){this.chainId=t}getConfig(){if(!this.config){const t=h.getConfig(this.chainId);if(!t)throw new m(f.CHAIN_NOT_FOUND,`Chain config not found: ${this.chainId}`);this.config=t}return this.config}getEmptyNativeBalance(){const t=this.getConfig();return{amount:u.zero(t.decimals,t.symbol),symbol:t.symbol}}async getNativeBalance(t){const e=await this.getTokenBalances(t),s=this.getConfig();return e.find(r=>r.symbol===s.symbol)??this.getEmptyNativeBalance()}async getTokenBalance(t,e){const s=e,r=(await this.getTokenBalances(t)).find(a=>a.symbol===s);if(r)return r;const o=this.getConfig();return{amount:u.zero(o.decimals,s),symbol:s}}async getTokenBalances(t){const e=this.getConfig(),s=h.getBiowalletApi(e.id);if(!s)return[this.getEmptyNativeBalance()];const{endpoint:n,path:r}=s;try{const o=await fetch(`${n}/wallet/${r}/address/asset`,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({address:t})});if(!o.ok)throw new m(f.NETWORK_ERROR,`Failed to fetch balances: ${o.status}`);const a=await o.json(),c=Lt.safeParse(a);if(!c.success)return console.warn("[BioforestAssetService] Invalid API response:",c.error.message),[this.getEmptyNativeBalance()];const{success:l,result:d}=c.data;if(!l||!d)return[this.getEmptyNativeBalance()];const p=[],{assets:g}=d;for(const v of Object.keys(g)){const T=g[v];if(T)for(const w of Object.keys(T)){const S=T[w];if(!S)continue;const O=e.decimals,$=u.fromRaw(S.assetNumber,O,S.assetType);p.push({amount:$,symbol:S.assetType})}}return p.length>0?p:[this.getEmptyNativeBalance()]}catch(o){throw o instanceof m?o:new m(f.NETWORK_ERROR,"Failed to fetch balances",void 0,o instanceof Error?o:void 0)}}async getTokenMetadata(t){const e=this.getConfig();return{address:null,name:t,symbol:t,decimals:e.decimals}}}class E extends Error{constructor(t,e,s){super(t),this.status=e,this.response=s,this.name="ApiError"}}class Wt{baseUrl;timeout;fetchFn;constructor(t){this.baseUrl=t.baseUrl.replace(/\/$/,""),this.timeout=t.timeout??3e4,this.fetchFn=t.fetch??((e,s)=>fetch(e,s))}async request(t,e,s){const n=`${this.baseUrl}${e}`,r=new AbortController,o=setTimeout(()=>r.abort(),this.timeout);try{const a={method:t,signal:r.signal};s&&(a.headers={"Content-Type":"application/json"},a.body=JSON.stringify(s));const c=await this.fetchFn(n,a),l=await c.json();if(!c.ok)throw new E(l.message??`Request failed: ${c.status}`,c.status,l);if(!l.success)throw new E(l.message??"Request failed",c.status,l);return l.result}catch(a){throw a instanceof E?a:a instanceof Error&&a.name==="AbortError"?new E("Request timeout",void 0,void 0):new E(a instanceof Error?a.message:"Unknown error",void 0,void 0)}finally{clearTimeout(o)}}async get(t){return this.request("GET",t)}async post(t,e){return this.request("POST",t,e)}}const Vt="https://walletapi.bfmeta.info";class Jt{client;chainPath;constructor(t){this.chainPath=t.chainPath;const e={baseUrl:t.baseUrl??Vt};t.timeout!==void 0&&(e.timeout=t.timeout),t.fetch!==void 0&&(e.fetch=t.fetch),this.client=new Wt(e)}path(t){return`/wallet/${this.chainPath}${t}`}async getLastBlock(){return this.client.get(this.path("/lastblock"))}async getBlockByHeight(t){return this.client.post(this.path("/block/query"),{height:t})}async getBalance(t){return this.client.post(this.path("/address/balance"),t)}async getAddressInfo(t){return this.client.post(this.path("/address/info"),{address:t})}async getAddressAssets(t){return this.client.post(this.path("/address/asset"),{address:t})}async getBlockAverageFee(){return this.client.get(this.path("/blockAveFee"))}async broadcastTransaction(t){return this.client.post(this.path("/transactions/broadcast"),t)}async queryTransactions(t){return this.client.post(this.path("/transactions/query"),t)}async queryPendingTransactions(t){return this.client.post(this.path("/pendingTr"),t)}async queryTokenList(t){return this.client.post(this.path("/assets"),t)}async queryTokenDetail(t){return this.client.post(this.path("/asset/details"),t)}}const V=new Map;function M(i,t){const e=`${i}|${t}`;let s=V.get(e);return s||(s=new Jt({baseUrl:i,chainPath:t}),V.set(e,s)),s}const J=new Map,z=new Map;let U=null,H=null;function j(i,t){return t||(i==="bfmeta"?"bfm":i)}function zt(){return typeof document<"u"?new URL("/configs/genesis",document.baseURI).href:"/configs/genesis"}async function Gt(i){const t=J.get(i);if(t)return t;const e=`${zt()}/${i}.json`;let s;if(e.startsWith("http://")||e.startsWith("https://")){const n=await fetch(e);if(!n.ok)throw new Error(`Failed to fetch genesis block: ${n.status}`);s=await n.json()}else s=(await import(e)).default;return J.set(i,s),s}async function Xt(){const{sha256:i}=await D(async()=>{const{sha256:r}=await import("./bioforest-ChHUthdw.js").then(o=>o.$);return{sha256:r}},[],import.meta.url),{md5:t,ripemd160:e}=await D(async()=>{const{md5:r,ripemd160:o}=await import("./bioforest-ChHUthdw.js").then(a=>a.a0);return{md5:r,ripemd160:o}},[],import.meta.url),s=r=>{const o=[];return{update(a){const c=typeof a=="string"?new TextEncoder().encode(a):a;return o.push(c),this},async digest(){const a=o.reduce((d,p)=>d+p.length,0),c=new Uint8Array(a);let l=0;for(const d of o)c.set(d,l),l+=d.length;return Buffer.from(r(c))}}};return{sha256(r){if(!r)return s(a=>i(a));const o=typeof r=="string"?new TextEncoder().encode(r):r;return Promise.resolve(Buffer.from(i(o)))},md5(r){if(!r)return s(a=>t(a));const o=typeof r=="string"?new TextEncoder().encode(r):r;return Promise.resolve(Buffer.from(t(o)))},ripemd160(r){if(!r)return s(a=>e(a));const o=typeof r=="string"?new TextEncoder().encode(r):r;return Promise.resolve(Buffer.from(e(o)))}}}async function Yt(){return U||H||(H=(async()=>(U={setup:(await D(()=>import("./bioforest-chain-bundle-CsZkxsox.js"),[],import.meta.url)).setup},U))(),H)}async function I(i){const t=await Gt(i),e=t.magic,s=z.get(e);if(s)return s;const n=await Yt(),r=await Xt(),o=await n.setup(t,r,{n:"KeyApp",m:"true",a:"web"});return z.set(e,o),o}async function C(i,t){const s=await M(i,t).getLastBlock();return{height:s.height,timestamp:s.timestamp}}async function lt(i,t,e){const s=M(i,t);try{return await s.getAddressInfo(e)??{address:e}}catch{return{address:e}}}async function Qt(i){const t=await I(i.chainId),e=j(i.chainId,i.apiPath),s=await C(i.rpcUrl,e),n=s.height,r=s.timestamp;let o=i.fee;o||(o=await t.transactionController.getTransferTransactionMinFee({transaction:{applyBlockHeight:n,timestamp:r,remark:i.remark??{}},assetInfo:{sourceChainName:await t.getChainName(),sourceChainMagic:await t.getMagic(),assetType:i.assetType,amount:i.amount}}));let a=!1;if(i.paySecret){const d=await lt(i.rpcUrl,e,i.from);d.secondPublicKey&&(a=await ht(i.chainId,i.mainSecret,i.paySecret,d.secondPublicKey)==="v1")}const c={mainSecret:i.mainSecret,...i.paySecret?{paySecret:i.paySecret,usePaySecretV1:a}:{}},l={sourceChainName:await t.getChainName(),sourceChainMagic:await t.getMagic(),assetType:i.assetType,amount:i.amount};return t.transactionController.createTransferTransactionJSON({secrets:c,transaction:{fee:o,recipientId:i.to,applyBlockHeight:n,timestamp:r,remark:i.remark??{},effectiveBlockHeight:n+100},assetInfo:l})}async function ut(i,t,e){const{nonce:s,...n}=e,o=await M(i,t).broadcastTransaction(n);if(!o.success){const a=o.message??"Transaction rejected",c=o.minFee;throw new Error(c?`${a} (minFee: ${c})`:a)}return e.signature}async function ht(i,t,e,s){const r=(await I(i)).accountBaseHelper();try{if((await r.createSecondSecretKeypairV2(t,e)).publicKey.toString("hex")===s)return"v2"}catch{}try{if((await r.createSecondSecretKeypair(t,e)).publicKey.toString("hex")===s)return"v1"}catch{}return!1}async function Zt(i,t,e){const s=await I(e),n=await C(i,t),r=n.height,o=n.timestamp;return s.transactionController.getSignatureTransactionMinFee({newPaySecret:`${Date.now()}getSignatureTransactionMinFee`,applyBlockHeight:r,timestamp:o})}async function dt(i){const t=await I(i.chainId),e=j(i.chainId,i.apiPath),s=await C(i.rpcUrl,e),n=s.height,r=s.timestamp;let o=i.fee;return o||(o=await t.transactionController.getSignatureTransactionMinFee({newPaySecret:i.newPaySecret,applyBlockHeight:n,timestamp:r})),t.transactionController.createSignatureTransactionJSON({mainSecret:i.mainSecret},{newPaySecret:i.newPaySecret,fee:o,applyBlockHeight:n,timestamp:r,effectiveBlockHeight:n+100})}async function te(i){const t=j(i.chainId,i.apiPath),e=await dt({rpcUrl:i.rpcUrl,chainId:i.chainId,apiPath:t,mainSecret:i.mainSecret,newPaySecret:i.newPaySecret});return await ut(i.rpcUrl,t,e).catch(()=>{}),{txHash:e.signature,success:!0}}const me=Object.freeze(Object.defineProperty({__proto__:null,broadcastTransaction:ut,createSignatureTransaction:dt,createTransferTransaction:Qt,getAddressInfo:lt,getBioforestCore:I,getLastBlock:C,getSignatureTransactionMinFee:Zt,setTwoStepSecret:te,verifyTwoStepSecret:ht},Symbol.toStringTag,{value:"Module"}));class ee{chainId;config=null;apiUrl="";apiPath="";constructor(t){this.chainId=t}getConfig(){if(!this.config){const t=h.getConfig(this.chainId);if(!t)throw new m(f.CHAIN_NOT_FOUND,`Chain config not found: ${this.chainId}`);this.config=t;const e=h.getBiowalletApi(t.id);this.apiUrl=e?.endpoint??"",this.apiPath=e?.path??t.id}return this.config}async estimateFee(t){const e=this.getConfig(),{decimals:s,symbol:n}=e,r=(o,a)=>({amount:o,estimatedTime:a});try{if(!this.apiUrl)throw new Error("No RPC URL configured");const o=await I(e.id),a=await C(this.apiUrl,this.apiPath),c=await o.transactionController.getTransferTransactionMinFee({transaction:{applyBlockHeight:a.height,timestamp:a.timestamp,remark:{}},assetInfo:{sourceChainName:await o.getChainName(),sourceChainMagic:await o.getMagic(),assetType:t.amount?.symbol??n,amount:t.amount?.toRawString()??"0"}}),l=u.fromRaw(c,s,n);return{slow:r(l,30),standard:r(l,15),fast:r(l.mul(2),5)}}catch(o){console.warn("[TransactionService] Failed to get min fee from SDK, using default:",o);const a=u.fromRaw("1000",s,n);return{slow:r(a,30),standard:r(a,15),fast:r(a.mul(2),5)}}}async buildTransaction(t){const e=this.getConfig();if(!t.from||!t.to)throw new m(f.INVALID_ADDRESS,"Invalid address");const s=await this.estimateFee(t);return{chainId:e.id,data:{type:"transfer",from:t.from,to:t.to,amount:t.amount.toRawString(),assetType:e.symbol,fee:s.standard.amount.toRawString(),memo:t.memo,timestamp:Date.now()}}}async signTransaction(t,e){const s=t.data,n=JSON.stringify({type:s.type,from:s.from,to:s.to,amount:s.amount,assetType:s.assetType,fee:s.fee,timestamp:s.timestamp,memo:s.memo??""}),r=Y(n,e),o=L(r);return{chainId:t.chainId,data:{...s,signature:o,publicKey:L(e.slice(32,64))},signature:o}}async broadcastTransaction(t){if(this.getConfig(),!this.apiUrl)throw new m(f.NETWORK_ERROR,"RPC URL not configured");try{const e=await fetch(`${this.apiUrl}/wallet/${this.apiPath}/transactions/broadcast`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({transaction:t.data})});if(!e.ok){const n=await e.json().catch(()=>({}));throw new m(f.TRANSACTION_REJECTED,n.message??`Broadcast failed: ${e.status}`)}const s=await e.json();if(!s.success)throw new m(f.TRANSACTION_REJECTED,s.error?.message??"Broadcast failed");return t.signature}catch(e){throw e instanceof m?e:new m(f.NETWORK_ERROR,"Failed to broadcast transaction",void 0,e instanceof Error?e:void 0)}}async getTransactionStatus(t){if(this.getConfig(),!this.apiUrl)return{status:"pending",confirmations:0,requiredConfirmations:1};try{const e=await fetch(`${this.apiUrl}/wallet/${this.apiPath}/transactions/query`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({signature:t})});if(!e.ok)return{status:"pending",confirmations:0,requiredConfirmations:1};const s=await e.json();return s.success&&s.result?.trs?.[0]?.height?{status:"confirmed",confirmations:1,requiredConfirmations:1}:{status:"pending",confirmations:0,requiredConfirmations:1}}catch{return{status:"pending",confirmations:0,requiredConfirmations:1}}}async getTransaction(t){if(this.getConfig(),!this.apiUrl)return null;try{const e=await fetch(`${this.apiUrl}/wallet/${this.apiPath}/transactions/query`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({signature:t})});if(!e.ok)return null;const s=await e.json();if(!s.success||!s.result?.trs?.[0])return null;const n=s.result.trs[0],r=n.transaction,{decimals:o,symbol:a}=this.config,c=r.asset?.transferAsset?.amount??"0";return{hash:r.signature,from:r.senderId,to:r.recipientId??"",amount:u.fromRaw(c,o,a),fee:u.fromRaw(r.fee,o,a),status:{status:"confirmed",confirmations:1,requiredConfirmations:1},timestamp:r.timestamp*1e3,blockNumber:BigInt(n.height),type:"transfer"}}catch{return null}}async getTransactionHistory(t,e=20){const s=this.getConfig();if(!this.apiUrl)return console.warn("[TransactionService] No baseUrl configured for chain:",s.id),[];try{const n=`${this.apiUrl}/wallet/${this.apiPath}/lastblock`,r=await fetch(n);if(!r.ok)return console.warn("[TransactionService] Failed to get lastblock:",r.status),[];const o=await r.json();if(!o.success)return console.warn("[TransactionService] lastblock API returned success=false"),[];const a=o.result.height,c=`${this.apiUrl}/wallet/${this.apiPath}/transactions/query`,l=await fetch(c,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({maxHeight:a,address:t,page:1,pageSize:e,sort:-1})});if(!l.ok)return console.warn("[TransactionService] API error:",l.status,l.statusText,"for",c),[];const d=await l.json();if(!d.success)return console.warn("[TransactionService] API returned success=false"),[];const p=d.result?.trs??[];if(p.length===0)return console.debug("[TransactionService] No transactions found for",t,"on",s.id),[];const{decimals:g,symbol:v}=s;return p.map(T=>{const w=T.transaction,S=w.type,O=w.asset?.transferAsset,$=O?.amount??w.fee??"0",ft=O?.assetType??v;return{hash:w.signature||`${T.signature}:${T.tIndex}`,from:w.senderId,to:w.recipientId??"",amount:u.fromRaw($,g,ft),fee:u.fromRaw(w.fee,g,v),status:{status:"confirmed",confirmations:1,requiredConfirmations:1},timestamp:w.timestamp*1e3,blockNumber:BigInt(T.height),type:"transfer",rawType:S}})}catch(n){return console.error("[TransactionService] Failed to fetch history:",n),[]}}}const se=[rt,tt,st,ot,ct];function ne(i,t){for(const e of se){const s=e(i,t);if(s)return s}return null}function re(i){const t=[];switch(i.chainKind){case"evm":{const e=new Nt(i.id),s=new kt(i.id),n=new Ct(i.id);t.push(new N("wrapped-evm-tx",n,s),new k("wrapped-evm-identity",e));break}case"tron":{const e=new Ot(i.id),s=new Pt(i.id),n=new Ut(i.id);t.push(new N("wrapped-tron-tx",n,s),new k("wrapped-tron-identity",e));break}case"bitcoin":{const e=new Ht(i.id),s=new Ft(i.id),n=new Dt(i.id);t.push(new N("wrapped-bitcoin-tx",n,s),new k("wrapped-bitcoin-identity",e));break}case"bioforest":{const e=new jt(i.id),s=new qt(i.id),n=new ee(i.id);t.push(new N("wrapped-bioforest-tx",n,s),new k("wrapped-bioforest-identity",e));break}}return t}function mt(i){const t=h.getApi(i),e=h.getConfig(i),s=[];for(const n of t){const r=ne(n,i);r&&s.push(r)}if(e){const n=re(e);s.push(...n)}return new Q(i,s)}const G=new Map;function ie(i){let t=G.get(i);return t||(t=mt(i),G.set(i,t)),t}const fe=Object.freeze(Object.defineProperty({__proto__:null,BiowalletProvider:nt,ChainProvider:Q,EtherscanProvider:Z,EvmRpcProvider:et,MempoolProvider:at,TronRpcProvider:it,WrappedIdentityProvider:k,WrappedTransactionProvider:N,createBiowalletProvider:rt,createChainProvider:mt,createEtherscanProvider:tt,createEvmRpcProvider:st,createMempoolProvider:ct,createTronRpcProvider:ot,getChainProvider:ie},Symbol.toStringTag,{value:"Module"}));export{jt as B,m as C,f as a,qt as b,h as c,ee as d,lt as e,Zt as f,ie as g,Qt as h,ut as i,me as j,fe as k,te as s,ht as v};
