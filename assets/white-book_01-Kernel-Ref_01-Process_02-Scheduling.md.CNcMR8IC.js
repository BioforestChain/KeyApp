import{_ as o,c as a,o as t,ag as r}from"./chunks/framework.B0we9iV-.js";const u=JSON.parse('{"title":"02. 调度与保活 (Scheduling)","description":"","frontmatter":{},"headers":[],"relativePath":"white-book/01-Kernel-Ref/01-Process/02-Scheduling.md","filePath":"white-book/01-Kernel-Ref/01-Process/02-Scheduling.md"}'),i={name:"white-book/01-Kernel-Ref/01-Process/02-Scheduling.md"};function n(l,e,c,s,d,g){return t(),a("div",null,[...e[0]||(e[0]=[r('<h1 id="_02-调度与保活-scheduling" tabindex="-1">02. 调度与保活 (Scheduling) <a class="header-anchor" href="#_02-调度与保活-scheduling" aria-label="Permalink to &quot;02. 调度与保活 (Scheduling)&quot;">​</a></h1><p>Code: <code>src/services/miniapp-runtime/iframe-manager.ts</code></p><p>为了防止浏览器内存溢出，KeyApp 实现了一套简单的调度策略来管理后台应用。</p><h2 id="后台限制-background-limit" tabindex="-1">后台限制 (Background Limit) <a class="header-anchor" href="#后台限制-background-limit" aria-label="Permalink to &quot;后台限制 (Background Limit)&quot;">​</a></h2><ul><li><strong>最大后台数</strong>: 默认为 <strong>4</strong> 个 (<code>MAX_BACKGROUND_IFRAMES</code>)。</li><li><strong>淘汰策略</strong>: <strong>LRU (Least Recently Used)</strong>。当后台应用数量超过限制时，最久未使用的应用会被强行销毁。</li></ul><h2 id="watchdog-机制" tabindex="-1">Watchdog 机制 <a class="header-anchor" href="#watchdog-机制" aria-label="Permalink to &quot;Watchdog 机制&quot;">​</a></h2><p>为了防止应用在关闭过程中卡死（例如动画回调未触发），内核启动了一个 <strong>Watchdog Timer</strong>。</p><ul><li><strong>超时时间</strong>: 30秒 (<code>DISMISS_WATCHDOG_DELAY</code>)。</li><li><strong>行为</strong>: 如果在超时后应用仍未完成关闭流程，Watchdog 会强制执行 <code>finalizeCloseApp</code> 进行资源清理。</li></ul><h2 id="准备阶段超时" tabindex="-1">准备阶段超时 <a class="header-anchor" href="#准备阶段超时" aria-label="Permalink to &quot;准备阶段超时&quot;">​</a></h2><p>在 <code>preparing</code> 阶段，内核会等待 DOM 元素（图标、插槽）就绪。为了防止无限等待：</p><ul><li><strong>超时时间</strong>: 2.5秒 (<code>PREPARING_TIMEOUT</code>)。</li><li><strong>行为</strong>: 超时后自动取消启动，并提示用户错误信息。</li></ul>',11)])])}const _=o(i,[["render",n]]);export{u as __pageData,_ as default};
